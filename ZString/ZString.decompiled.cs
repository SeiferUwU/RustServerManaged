using System;
using System.Buffers;
using System.Buffers.Text;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableAttribute : Attribute
	{
		public readonly byte[] NullableFlags;

		public NullableAttribute(byte P_0)
		{
			NullableFlags = new byte[1] { P_0 };
		}

		public NullableAttribute(byte[] P_0)
		{
			NullableFlags = P_0;
		}
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Interface | AttributeTargets.Delegate, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableContextAttribute : Attribute
	{
		public readonly byte Flag;

		public NullableContextAttribute(byte P_0)
		{
			Flag = P_0;
		}
	}
}
[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		return new MonoScriptData
		{
			FilePathsData = new byte[2582]
			{
				0, 0, 0, 1, 0, 0, 0, 35, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 90, 83, 116, 114, 105, 110,
				103, 92, 69, 110, 117, 109, 85, 116, 105, 108,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				40, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 90, 83, 116,
				114, 105, 110, 103, 92, 69, 120, 99, 101, 112,
				116, 105, 111, 110, 85, 116, 105, 108, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 43, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 90, 83, 116, 114, 105,
				110, 103, 92, 70, 97, 115, 116, 78, 117, 109,
				98, 101, 114, 87, 114, 105, 116, 101, 114, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 39,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 90, 83, 116, 114,
				105, 110, 103, 92, 70, 111, 114, 109, 97, 116,
				72, 101, 108, 112, 101, 114, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 39, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 90, 83, 116, 114, 105, 110, 103,
				92, 70, 111, 114, 109, 97, 116, 80, 97, 114,
				115, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 50, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				90, 83, 116, 114, 105, 110, 103, 92, 73, 82,
				101, 115, 101, 116, 116, 97, 98, 108, 101, 66,
				117, 102, 102, 101, 114, 87, 114, 105, 116, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 63, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 90, 83,
				116, 114, 105, 110, 103, 92, 78, 101, 115, 116,
				101, 100, 83, 116, 114, 105, 110, 103, 66, 117,
				105, 108, 100, 101, 114, 67, 114, 101, 97, 116,
				105, 111, 110, 69, 120, 99, 101, 112, 116, 105,
				111, 110, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 47, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 90,
				83, 116, 114, 105, 110, 103, 92, 78, 117, 109,
				98, 101, 114, 92, 66, 105, 116, 79, 112, 101,
				114, 97, 116, 105, 111, 110, 115, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 42, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 90, 83, 116, 114, 105, 110,
				103, 92, 78, 117, 109, 98, 101, 114, 92, 66,
				117, 102, 102, 101, 114, 69, 120, 46, 99, 115,
				0, 0, 0, 3, 0, 0, 0, 43, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 90, 83, 116, 114, 105, 110,
				103, 92, 78, 117, 109, 98, 101, 114, 92, 68,
				101, 99, 105, 109, 97, 108, 69, 120, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 41, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 90, 83, 116, 114, 105,
				110, 103, 92, 78, 117, 109, 98, 101, 114, 92,
				70, 108, 111, 97, 116, 69, 120, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 51, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 90, 83, 116, 114, 105, 110,
				103, 92, 78, 117, 109, 98, 101, 114, 92, 70,
				111, 114, 109, 97, 116, 116, 105, 110, 103, 72,
				101, 108, 112, 101, 114, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 40, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 90, 83, 116, 114, 105, 110, 103,
				92, 78, 117, 109, 98, 101, 114, 92, 71, 117,
				105, 100, 69, 120, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 46, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 90, 83, 116, 114, 105, 110, 103, 92, 78,
				117, 109, 98, 101, 114, 92, 72, 101, 120, 67,
				111, 110, 118, 101, 114, 116, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 48, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 90, 83, 116, 114, 105,
				110, 103, 92, 78, 117, 109, 98, 101, 114, 92,
				73, 110, 116, 101, 114, 110, 97, 108, 83, 112,
				97, 110, 69, 120, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 40, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 90, 83, 116, 114, 105, 110, 103, 92, 78,
				117, 109, 98, 101, 114, 92, 77, 97, 116, 104,
				69, 120, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 51, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 90,
				83, 116, 114, 105, 110, 103, 92, 78, 117, 109,
				98, 101, 114, 92, 78, 117, 109, 98, 101, 114,
				46, 66, 105, 103, 73, 110, 116, 101, 103, 101,
				114, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 46, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 90, 83,
				116, 114, 105, 110, 103, 92, 78, 117, 109, 98,
				101, 114, 92, 78, 117, 109, 98, 101, 114, 46,
				68, 105, 121, 70, 112, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 48, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 90, 83, 116, 114, 105, 110, 103, 92,
				78, 117, 109, 98, 101, 114, 92, 78, 117, 109,
				98, 101, 114, 46, 68, 114, 97, 103, 111, 110,
				52, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 51, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 90, 83,
				116, 114, 105, 110, 103, 92, 78, 117, 109, 98,
				101, 114, 92, 78, 117, 109, 98, 101, 114, 46,
				70, 111, 114, 109, 97, 116, 116, 105, 110, 103,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				47, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 90, 83, 116,
				114, 105, 110, 103, 92, 78, 117, 109, 98, 101,
				114, 92, 78, 117, 109, 98, 101, 114, 46, 71,
				114, 105, 115, 117, 51, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 53, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 90, 83, 116, 114, 105, 110, 103, 92,
				78, 117, 109, 98, 101, 114, 92, 78, 117, 109,
				98, 101, 114, 46, 78, 117, 109, 98, 101, 114,
				66, 117, 102, 102, 101, 114, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 66, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 90, 83, 116, 114, 105, 110, 103,
				92, 78, 117, 109, 98, 101, 114, 92, 78, 117,
				109, 98, 101, 114, 46, 78, 117, 109, 98, 101,
				114, 84, 111, 70, 108, 111, 97, 116, 105, 110,
				103, 80, 111, 105, 110, 116, 66, 105, 116, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				48, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 90, 83, 116,
				114, 105, 110, 103, 92, 78, 117, 109, 98, 101,
				114, 92, 78, 117, 109, 98, 101, 114, 46, 80,
				97, 114, 115, 105, 110, 103, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 52, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 90, 83, 116, 114, 105, 110, 103,
				92, 78, 117, 109, 98, 101, 114, 92, 78, 117,
				109, 98, 101, 114, 70, 111, 114, 109, 97, 116,
				73, 110, 102, 111, 69, 120, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 52, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 90, 83, 116, 114, 105, 110, 103,
				92, 78, 117, 109, 98, 101, 114, 92, 86, 97,
				108, 117, 101, 83, 116, 114, 105, 110, 103, 66,
				117, 105, 108, 100, 101, 114, 46, 99, 115, 0,
				0, 0, 32, 0, 0, 0, 41, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 90, 83, 116, 114, 105, 110, 103,
				92, 80, 114, 101, 112, 97, 114, 101, 100, 70,
				111, 114, 109, 97, 116, 46, 99, 115, 0, 0,
				0, 3, 0, 0, 0, 47, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 90, 83, 116, 114, 105, 110, 103, 92,
				80, 114, 101, 112, 97, 114, 101, 100, 70, 111,
				114, 109, 97, 116, 72, 101, 108, 112, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				46, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 90, 83, 116,
				114, 105, 110, 103, 92, 82, 101, 97, 100, 79,
				110, 108, 121, 76, 105, 115, 116, 65, 100, 97,
				112, 116, 111, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 42, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 90, 83, 116, 114, 105, 110, 103, 92, 83,
				116, 97, 110, 100, 97, 114, 100, 70, 111, 114,
				109, 97, 116, 115, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 51, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 90, 83, 116, 114, 105, 110, 103, 92, 83,
				116, 114, 105, 110, 103, 66, 117, 105, 108, 100,
				101, 114, 46, 65, 112, 112, 101, 110, 100, 74,
				111, 105, 110, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 69, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				90, 83, 116, 114, 105, 110, 103, 92, 85, 116,
				102, 49, 54, 92, 85, 116, 102, 49, 54, 86,
				97, 108, 117, 101, 83, 116, 114, 105, 110, 103,
				66, 117, 105, 108, 100, 101, 114, 46, 65, 112,
				112, 101, 110, 100, 70, 111, 114, 109, 97, 116,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				72, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 90, 83, 116,
				114, 105, 110, 103, 92, 85, 116, 102, 49, 54,
				92, 85, 116, 102, 49, 54, 86, 97, 108, 117,
				101, 83, 116, 114, 105, 110, 103, 66, 117, 105,
				108, 100, 101, 114, 46, 67, 114, 101, 97, 116,
				101, 70, 111, 114, 109, 97, 116, 116, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				78, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 90, 83, 116,
				114, 105, 110, 103, 92, 85, 116, 102, 49, 54,
				92, 85, 116, 102, 49, 54, 86, 97, 108, 117,
				101, 83, 116, 114, 105, 110, 103, 66, 117, 105,
				108, 100, 101, 114, 46, 83, 112, 97, 110, 70,
				111, 114, 109, 97, 116, 116, 97, 98, 108, 101,
				65, 112, 112, 101, 110, 100, 46, 99, 115, 0,
				0, 0, 3, 0, 0, 0, 50, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 90, 83, 116, 114, 105, 110, 103,
				92, 85, 116, 102, 49, 54, 86, 97, 108, 117,
				101, 83, 116, 114, 105, 110, 103, 66, 117, 105,
				108, 100, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 67, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 90, 83, 116, 114, 105, 110, 103, 92, 85,
				116, 102, 56, 92, 85, 116, 102, 56, 86, 97,
				108, 117, 101, 83, 116, 114, 105, 110, 103, 66,
				117, 105, 108, 100, 101, 114, 46, 65, 112, 112,
				101, 110, 100, 70, 111, 114, 109, 97, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 70,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 90, 83, 116, 114,
				105, 110, 103, 92, 85, 116, 102, 56, 92, 85,
				116, 102, 56, 86, 97, 108, 117, 101, 83, 116,
				114, 105, 110, 103, 66, 117, 105, 108, 100, 101,
				114, 46, 67, 114, 101, 97, 116, 101, 70, 111,
				114, 109, 97, 116, 116, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 76, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 90, 83, 116, 114, 105, 110,
				103, 92, 85, 116, 102, 56, 92, 85, 116, 102,
				56, 86, 97, 108, 117, 101, 83, 116, 114, 105,
				110, 103, 66, 117, 105, 108, 100, 101, 114, 46,
				83, 112, 97, 110, 70, 111, 114, 109, 97, 116,
				116, 97, 98, 108, 101, 65, 112, 112, 101, 110,
				100, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 49, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 90, 83,
				116, 114, 105, 110, 103, 92, 85, 116, 102, 56,
				86, 97, 108, 117, 101, 83, 116, 114, 105, 110,
				103, 66, 117, 105, 108, 100, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 41, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 90, 83, 116, 114, 105,
				110, 103, 92, 90, 83, 116, 114, 105, 110, 103,
				46, 67, 111, 110, 99, 97, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 34, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 90, 83, 116, 114, 105, 110,
				103, 92, 90, 83, 116, 114, 105, 110, 103, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 41,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 90, 83, 116, 114,
				105, 110, 103, 92, 90, 83, 116, 114, 105, 110,
				103, 46, 70, 111, 114, 109, 97, 116, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 42, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 90, 83, 116, 114, 105,
				110, 103, 92, 90, 83, 116, 114, 105, 110, 103,
				46, 80, 114, 101, 112, 97, 114, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 45, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 90, 83, 116, 114, 105,
				110, 103, 92, 90, 83, 116, 114, 105, 110, 103,
				46, 85, 116, 102, 56, 70, 111, 114, 109, 97,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 40, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 90, 83,
				116, 114, 105, 110, 103, 92, 90, 83, 116, 114,
				105, 110, 103, 87, 114, 105, 116, 101, 114, 46,
				99, 115
			},
			TypesData = new byte[2971]
			{
				0, 0, 0, 0, 21, 67, 121, 115, 104, 97,
				114, 112, 46, 84, 101, 120, 116, 124, 69, 110,
				117, 109, 85, 116, 105, 108, 0, 0, 0, 0,
				26, 67, 121, 115, 104, 97, 114, 112, 46, 84,
				101, 120, 116, 124, 69, 120, 99, 101, 112, 116,
				105, 111, 110, 85, 116, 105, 108, 0, 0, 0,
				0, 29, 67, 121, 115, 104, 97, 114, 112, 46,
				84, 101, 120, 116, 124, 70, 97, 115, 116, 78,
				117, 109, 98, 101, 114, 87, 114, 105, 116, 101,
				114, 0, 0, 0, 0, 30, 67, 121, 115, 104,
				97, 114, 112, 46, 84, 101, 120, 116, 124, 85,
				116, 102, 49, 54, 70, 111, 114, 109, 97, 116,
				72, 101, 108, 112, 101, 114, 0, 0, 0, 0,
				29, 67, 121, 115, 104, 97, 114, 112, 46, 84,
				101, 120, 116, 124, 85, 116, 102, 56, 70, 111,
				114, 109, 97, 116, 72, 101, 108, 112, 101, 114,
				0, 0, 0, 0, 25, 67, 121, 115, 104, 97,
				114, 112, 46, 84, 101, 120, 116, 124, 70, 111,
				114, 109, 97, 116, 80, 97, 114, 115, 101, 114,
				0, 0, 0, 0, 37, 67, 121, 115, 104, 97,
				114, 112, 46, 84, 101, 120, 116, 46, 70, 111,
				114, 109, 97, 116, 80, 97, 114, 115, 101, 114,
				124, 80, 97, 114, 115, 101, 82, 101, 115, 117,
				108, 116, 0, 0, 0, 0, 36, 67, 121, 115,
				104, 97, 114, 112, 46, 84, 101, 120, 116, 124,
				73, 82, 101, 115, 101, 116, 116, 97, 98, 108,
				101, 66, 117, 102, 102, 101, 114, 87, 114, 105,
				116, 101, 114, 0, 0, 0, 0, 49, 67, 121,
				115, 104, 97, 114, 112, 46, 84, 101, 120, 116,
				124, 78, 101, 115, 116, 101, 100, 83, 116, 114,
				105, 110, 103, 66, 117, 105, 108, 100, 101, 114,
				67, 114, 101, 97, 116, 105, 111, 110, 69, 120,
				99, 101, 112, 116, 105, 111, 110, 0, 0, 0,
				0, 29, 83, 121, 115, 116, 101, 109, 46, 78,
				117, 109, 101, 114, 105, 99, 115, 124, 66, 105,
				116, 79, 112, 101, 114, 97, 116, 105, 111, 110,
				115, 0, 0, 0, 0, 15, 83, 121, 115, 116,
				101, 109, 124, 66, 117, 102, 102, 101, 114, 69,
				120, 0, 0, 0, 0, 16, 83, 121, 115, 116,
				101, 109, 124, 68, 101, 99, 105, 109, 97, 108,
				69, 120, 0, 0, 0, 0, 28, 83, 121, 115,
				116, 101, 109, 46, 68, 101, 99, 105, 109, 97,
				108, 69, 120, 124, 68, 101, 99, 105, 109, 97,
				108, 66, 105, 116, 115, 0, 0, 0, 0, 24,
				83, 121, 115, 116, 101, 109, 46, 68, 101, 99,
				105, 109, 97, 108, 69, 120, 124, 68, 101, 99,
				67, 97, 108, 99, 0, 0, 0, 0, 14, 83,
				121, 115, 116, 101, 109, 124, 70, 108, 111, 97,
				116, 69, 120, 0, 0, 0, 0, 37, 83, 121,
				115, 116, 101, 109, 46, 66, 117, 102, 102, 101,
				114, 115, 46, 84, 101, 120, 116, 124, 70, 111,
				114, 109, 97, 116, 116, 105, 110, 103, 72, 101,
				108, 112, 101, 114, 115, 0, 0, 0, 0, 13,
				83, 121, 115, 116, 101, 109, 124, 71, 117, 105,
				100, 69, 120, 0, 0, 0, 0, 19, 83, 121,
				115, 116, 101, 109, 124, 72, 101, 120, 67, 111,
				110, 118, 101, 114, 116, 101, 114, 0, 0, 0,
				0, 21, 83, 121, 115, 116, 101, 109, 124, 73,
				110, 116, 101, 114, 110, 97, 108, 83, 112, 97,
				110, 69, 120, 0, 0, 0, 0, 13, 83, 121,
				115, 116, 101, 109, 124, 77, 97, 116, 104, 69,
				120, 1, 0, 0, 0, 13, 83, 121, 115, 116,
				101, 109, 124, 78, 117, 109, 98, 101, 114, 0,
				0, 0, 0, 24, 83, 121, 115, 116, 101, 109,
				46, 78, 117, 109, 98, 101, 114, 124, 66, 105,
				103, 73, 110, 116, 101, 103, 101, 114, 1, 0,
				0, 0, 13, 83, 121, 115, 116, 101, 109, 124,
				78, 117, 109, 98, 101, 114, 0, 0, 0, 0,
				19, 83, 121, 115, 116, 101, 109, 46, 78, 117,
				109, 98, 101, 114, 124, 68, 105, 121, 70, 112,
				1, 0, 0, 0, 13, 83, 121, 115, 116, 101,
				109, 124, 78, 117, 109, 98, 101, 114, 1, 0,
				0, 0, 13, 83, 121, 115, 116, 101, 109, 124,
				78, 117, 109, 98, 101, 114, 1, 0, 0, 0,
				13, 83, 121, 115, 116, 101, 109, 124, 78, 117,
				109, 98, 101, 114, 0, 0, 0, 0, 20, 83,
				121, 115, 116, 101, 109, 46, 78, 117, 109, 98,
				101, 114, 124, 71, 114, 105, 115, 117, 51, 1,
				0, 0, 0, 13, 83, 121, 115, 116, 101, 109,
				124, 78, 117, 109, 98, 101, 114, 0, 0, 0,
				0, 26, 83, 121, 115, 116, 101, 109, 46, 78,
				117, 109, 98, 101, 114, 124, 78, 117, 109, 98,
				101, 114, 66, 117, 102, 102, 101, 114, 1, 0,
				0, 0, 13, 83, 121, 115, 116, 101, 109, 124,
				78, 117, 109, 98, 101, 114, 0, 0, 0, 0,
				31, 83, 121, 115, 116, 101, 109, 46, 78, 117,
				109, 98, 101, 114, 124, 70, 108, 111, 97, 116,
				105, 110, 103, 80, 111, 105, 110, 116, 73, 110,
				102, 111, 1, 0, 0, 0, 13, 83, 121, 115,
				116, 101, 109, 124, 78, 117, 109, 98, 101, 114,
				0, 0, 0, 0, 25, 83, 121, 115, 116, 101,
				109, 124, 78, 117, 109, 98, 101, 114, 70, 111,
				114, 109, 97, 116, 73, 110, 102, 111, 69, 120,
				0, 0, 0, 0, 30, 83, 121, 115, 116, 101,
				109, 46, 84, 101, 120, 116, 124, 86, 97, 108,
				117, 101, 83, 116, 114, 105, 110, 103, 66, 117,
				105, 108, 100, 101, 114, 1, 0, 0, 0, 32,
				67, 121, 115, 104, 97, 114, 112, 46, 84, 101,
				120, 116, 124, 85, 116, 102, 49, 54, 80, 114,
				101, 112, 97, 114, 101, 100, 70, 111, 114, 109,
				97, 116, 1, 0, 0, 0, 32, 67, 121, 115,
				104, 97, 114, 112, 46, 84, 101, 120, 116, 124,
				85, 116, 102, 49, 54, 80, 114, 101, 112, 97,
				114, 101, 100, 70, 111, 114, 109, 97, 116, 1,
				0, 0, 0, 32, 67, 121, 115, 104, 97, 114,
				112, 46, 84, 101, 120, 116, 124, 85, 116, 102,
				49, 54, 80, 114, 101, 112, 97, 114, 101, 100,
				70, 111, 114, 109, 97, 116, 1, 0, 0, 0,
				32, 67, 121, 115, 104, 97, 114, 112, 46, 84,
				101, 120, 116, 124, 85, 116, 102, 49, 54, 80,
				114, 101, 112, 97, 114, 101, 100, 70, 111, 114,
				109, 97, 116, 1, 0, 0, 0, 32, 67, 121,
				115, 104, 97, 114, 112, 46, 84, 101, 120, 116,
				124, 85, 116, 102, 49, 54, 80, 114, 101, 112,
				97, 114, 101, 100, 70, 111, 114, 109, 97, 116,
				1, 0, 0, 0, 32, 67, 121, 115, 104, 97,
				114, 112, 46, 84, 101, 120, 116, 124, 85, 116,
				102, 49, 54, 80, 114, 101, 112, 97, 114, 101,
				100, 70, 111, 114, 109, 97, 116, 1, 0, 0,
				0, 32, 67, 121, 115, 104, 97, 114, 112, 46,
				84, 101, 120, 116, 124, 85, 116, 102, 49, 54,
				80, 114, 101, 112, 97, 114, 101, 100, 70, 111,
				114, 109, 97, 116, 1, 0, 0, 0, 32, 67,
				121, 115, 104, 97, 114, 112, 46, 84, 101, 120,
				116, 124, 85, 116, 102, 49, 54, 80, 114, 101,
				112, 97, 114, 101, 100, 70, 111, 114, 109, 97,
				116, 1, 0, 0, 0, 32, 67, 121, 115, 104,
				97, 114, 112, 46, 84, 101, 120, 116, 124, 85,
				116, 102, 49, 54, 80, 114, 101, 112, 97, 114,
				101, 100, 70, 111, 114, 109, 97, 116, 1, 0,
				0, 0, 32, 67, 121, 115, 104, 97, 114, 112,
				46, 84, 101, 120, 116, 124, 85, 116, 102, 49,
				54, 80, 114, 101, 112, 97, 114, 101, 100, 70,
				111, 114, 109, 97, 116, 1, 0, 0, 0, 32,
				67, 121, 115, 104, 97, 114, 112, 46, 84, 101,
				120, 116, 124, 85, 116, 102, 49, 54, 80, 114,
				101, 112, 97, 114, 101, 100, 70, 111, 114, 109,
				97, 116, 1, 0, 0, 0, 32, 67, 121, 115,
				104, 97, 114, 112, 46, 84, 101, 120, 116, 124,
				85, 116, 102, 49, 54, 80, 114, 101, 112, 97,
				114, 101, 100, 70, 111, 114, 109, 97, 116, 1,
				0, 0, 0, 32, 67, 121, 115, 104, 97, 114,
				112, 46, 84, 101, 120, 116, 124, 85, 116, 102,
				49, 54, 80, 114, 101, 112, 97, 114, 101, 100,
				70, 111, 114, 109, 97, 116, 1, 0, 0, 0,
				32, 67, 121, 115, 104, 97, 114, 112, 46, 84,
				101, 120, 116, 124, 85, 116, 102, 49, 54, 80,
				114, 101, 112, 97, 114, 101, 100, 70, 111, 114,
				109, 97, 116, 1, 0, 0, 0, 32, 67, 121,
				115, 104, 97, 114, 112, 46, 84, 101, 120, 116,
				124, 85, 116, 102, 49, 54, 80, 114, 101, 112,
				97, 114, 101, 100, 70, 111, 114, 109, 97, 116,
				1, 0, 0, 0, 32, 67, 121, 115, 104, 97,
				114, 112, 46, 84, 101, 120, 116, 124, 85, 116,
				102, 49, 54, 80, 114, 101, 112, 97, 114, 101,
				100, 70, 111, 114, 109, 97, 116, 1, 0, 0,
				0, 31, 67, 121, 115, 104, 97, 114, 112, 46,
				84, 101, 120, 116, 124, 85, 116, 102, 56, 80,
				114, 101, 112, 97, 114, 101, 100, 70, 111, 114,
				109, 97, 116, 1, 0, 0, 0, 31, 67, 121,
				115, 104, 97, 114, 112, 46, 84, 101, 120, 116,
				124, 85, 116, 102, 56, 80, 114, 101, 112, 97,
				114, 101, 100, 70, 111, 114, 109, 97, 116, 1,
				0, 0, 0, 31, 67, 121, 115, 104, 97, 114,
				112, 46, 84, 101, 120, 116, 124, 85, 116, 102,
				56, 80, 114, 101, 112, 97, 114, 101, 100, 70,
				111, 114, 109, 97, 116, 1, 0, 0, 0, 31,
				67, 121, 115, 104, 97, 114, 112, 46, 84, 101,
				120, 116, 124, 85, 116, 102, 56, 80, 114, 101,
				112, 97, 114, 101, 100, 70, 111, 114, 109, 97,
				116, 1, 0, 0, 0, 31, 67, 121, 115, 104,
				97, 114, 112, 46, 84, 101, 120, 116, 124, 85,
				116, 102, 56, 80, 114, 101, 112, 97, 114, 101,
				100, 70, 111, 114, 109, 97, 116, 1, 0, 0,
				0, 31, 67, 121, 115, 104, 97, 114, 112, 46,
				84, 101, 120, 116, 124, 85, 116, 102, 56, 80,
				114, 101, 112, 97, 114, 101, 100, 70, 111, 114,
				109, 97, 116, 1, 0, 0, 0, 31, 67, 121,
				115, 104, 97, 114, 112, 46, 84, 101, 120, 116,
				124, 85, 116, 102, 56, 80, 114, 101, 112, 97,
				114, 101, 100, 70, 111, 114, 109, 97, 116, 1,
				0, 0, 0, 31, 67, 121, 115, 104, 97, 114,
				112, 46, 84, 101, 120, 116, 124, 85, 116, 102,
				56, 80, 114, 101, 112, 97, 114, 101, 100, 70,
				111, 114, 109, 97, 116, 1, 0, 0, 0, 31,
				67, 121, 115, 104, 97, 114, 112, 46, 84, 101,
				120, 116, 124, 85, 116, 102, 56, 80, 114, 101,
				112, 97, 114, 101, 100, 70, 111, 114, 109, 97,
				116, 1, 0, 0, 0, 31, 67, 121, 115, 104,
				97, 114, 112, 46, 84, 101, 120, 116, 124, 85,
				116, 102, 56, 80, 114, 101, 112, 97, 114, 101,
				100, 70, 111, 114, 109, 97, 116, 1, 0, 0,
				0, 31, 67, 121, 115, 104, 97, 114, 112, 46,
				84, 101, 120, 116, 124, 85, 116, 102, 56, 80,
				114, 101, 112, 97, 114, 101, 100, 70, 111, 114,
				109, 97, 116, 1, 0, 0, 0, 31, 67, 121,
				115, 104, 97, 114, 112, 46, 84, 101, 120, 116,
				124, 85, 116, 102, 56, 80, 114, 101, 112, 97,
				114, 101, 100, 70, 111, 114, 109, 97, 116, 1,
				0, 0, 0, 31, 67, 121, 115, 104, 97, 114,
				112, 46, 84, 101, 120, 116, 124, 85, 116, 102,
				56, 80, 114, 101, 112, 97, 114, 101, 100, 70,
				111, 114, 109, 97, 116, 1, 0, 0, 0, 31,
				67, 121, 115, 104, 97, 114, 112, 46, 84, 101,
				120, 116, 124, 85, 116, 102, 56, 80, 114, 101,
				112, 97, 114, 101, 100, 70, 111, 114, 109, 97,
				116, 1, 0, 0, 0, 31, 67, 121, 115, 104,
				97, 114, 112, 46, 84, 101, 120, 116, 124, 85,
				116, 102, 56, 80, 114, 101, 112, 97, 114, 101,
				100, 70, 111, 114, 109, 97, 116, 1, 0, 0,
				0, 31, 67, 121, 115, 104, 97, 114, 112, 46,
				84, 101, 120, 116, 124, 85, 116, 102, 56, 80,
				114, 101, 112, 97, 114, 101, 100, 70, 111, 114,
				109, 97, 116, 0, 0, 0, 0, 33, 67, 121,
				115, 104, 97, 114, 112, 46, 84, 101, 120, 116,
				124, 80, 114, 101, 112, 97, 114, 101, 100, 70,
				111, 114, 109, 97, 116, 72, 101, 108, 112, 101,
				114, 0, 0, 0, 0, 30, 67, 121, 115, 104,
				97, 114, 112, 46, 84, 101, 120, 116, 124, 85,
				116, 102, 56, 70, 111, 114, 109, 97, 116, 83,
				101, 103, 109, 101, 110, 116, 0, 0, 0, 0,
				31, 67, 121, 115, 104, 97, 114, 112, 46, 84,
				101, 120, 116, 124, 85, 116, 102, 49, 54, 70,
				111, 114, 109, 97, 116, 83, 101, 103, 109, 101,
				110, 116, 0, 0, 0, 0, 32, 67, 121, 115,
				104, 97, 114, 112, 46, 84, 101, 120, 116, 124,
				82, 101, 97, 100, 79, 110, 108, 121, 76, 105,
				115, 116, 65, 100, 97, 112, 116, 111, 114, 0,
				0, 0, 0, 28, 67, 121, 115, 104, 97, 114,
				112, 46, 84, 101, 120, 116, 124, 83, 116, 97,
				110, 100, 97, 114, 100, 70, 111, 114, 109, 97,
				116, 115, 1, 0, 0, 0, 36, 67, 121, 115,
				104, 97, 114, 112, 46, 84, 101, 120, 116, 124,
				85, 116, 102, 49, 54, 86, 97, 108, 117, 101,
				83, 116, 114, 105, 110, 103, 66, 117, 105, 108,
				100, 101, 114, 1, 0, 0, 0, 35, 67, 121,
				115, 104, 97, 114, 112, 46, 84, 101, 120, 116,
				124, 85, 116, 102, 56, 86, 97, 108, 117, 101,
				83, 116, 114, 105, 110, 103, 66, 117, 105, 108,
				100, 101, 114, 1, 0, 0, 0, 36, 67, 121,
				115, 104, 97, 114, 112, 46, 84, 101, 120, 116,
				124, 85, 116, 102, 49, 54, 86, 97, 108, 117,
				101, 83, 116, 114, 105, 110, 103, 66, 117, 105,
				108, 100, 101, 114, 1, 0, 0, 0, 36, 67,
				121, 115, 104, 97, 114, 112, 46, 84, 101, 120,
				116, 124, 85, 116, 102, 49, 54, 86, 97, 108,
				117, 101, 83, 116, 114, 105, 110, 103, 66, 117,
				105, 108, 100, 101, 114, 1, 0, 0, 0, 36,
				67, 121, 115, 104, 97, 114, 112, 46, 84, 101,
				120, 116, 124, 85, 116, 102, 49, 54, 86, 97,
				108, 117, 101, 83, 116, 114, 105, 110, 103, 66,
				117, 105, 108, 100, 101, 114, 1, 0, 0, 0,
				36, 67, 121, 115, 104, 97, 114, 112, 46, 84,
				101, 120, 116, 124, 85, 116, 102, 49, 54, 86,
				97, 108, 117, 101, 83, 116, 114, 105, 110, 103,
				66, 117, 105, 108, 100, 101, 114, 0, 0, 0,
				0, 27, 67, 121, 115, 104, 97, 114, 112, 46,
				84, 101, 120, 116, 46, 124, 69, 120, 99, 101,
				112, 116, 105, 111, 110, 85, 116, 105, 108, 1,
				0, 0, 0, 28, 67, 121, 115, 104, 97, 114,
				112, 46, 84, 101, 120, 116, 46, 124, 70, 111,
				114, 109, 97, 116, 116, 101, 114, 67, 97, 99,
				104, 101, 1, 0, 0, 0, 35, 67, 121, 115,
				104, 97, 114, 112, 46, 84, 101, 120, 116, 124,
				85, 116, 102, 56, 86, 97, 108, 117, 101, 83,
				116, 114, 105, 110, 103, 66, 117, 105, 108, 100,
				101, 114, 1, 0, 0, 0, 35, 67, 121, 115,
				104, 97, 114, 112, 46, 84, 101, 120, 116, 124,
				85, 116, 102, 56, 86, 97, 108, 117, 101, 83,
				116, 114, 105, 110, 103, 66, 117, 105, 108, 100,
				101, 114, 1, 0, 0, 0, 35, 67, 121, 115,
				104, 97, 114, 112, 46, 84, 101, 120, 116, 124,
				85, 116, 102, 56, 86, 97, 108, 117, 101, 83,
				116, 114, 105, 110, 103, 66, 117, 105, 108, 100,
				101, 114, 1, 0, 0, 0, 35, 67, 121, 115,
				104, 97, 114, 112, 46, 84, 101, 120, 116, 124,
				85, 116, 102, 56, 86, 97, 108, 117, 101, 83,
				116, 114, 105, 110, 103, 66, 117, 105, 108, 100,
				101, 114, 1, 0, 0, 0, 28, 67, 121, 115,
				104, 97, 114, 112, 46, 84, 101, 120, 116, 46,
				124, 70, 111, 114, 109, 97, 116, 116, 101, 114,
				67, 97, 99, 104, 101, 1, 0, 0, 0, 20,
				67, 121, 115, 104, 97, 114, 112, 46, 84, 101,
				120, 116, 124, 90, 83, 116, 114, 105, 110, 103,
				1, 0, 0, 0, 20, 67, 121, 115, 104, 97,
				114, 112, 46, 84, 101, 120, 116, 124, 90, 83,
				116, 114, 105, 110, 103, 1, 0, 0, 0, 20,
				67, 121, 115, 104, 97, 114, 112, 46, 84, 101,
				120, 116, 124, 90, 83, 116, 114, 105, 110, 103,
				1, 0, 0, 0, 20, 67, 121, 115, 104, 97,
				114, 112, 46, 84, 101, 120, 116, 124, 90, 83,
				116, 114, 105, 110, 103, 1, 0, 0, 0, 20,
				67, 121, 115, 104, 97, 114, 112, 46, 84, 101,
				120, 116, 124, 90, 83, 116, 114, 105, 110, 103,
				0, 0, 0, 0, 26, 67, 121, 115, 104, 97,
				114, 112, 46, 84, 101, 120, 116, 124, 90, 83,
				116, 114, 105, 110, 103, 87, 114, 105, 116, 101,
				114
			},
			TotalFiles = 45,
			TotalTypes = 91,
			IsEditorOnly = false
		};
	}
}
namespace System
{
	internal static class BufferEx
	{
		internal unsafe static void ZeroMemory(byte* dest, uint len)
		{
			if (len != 0)
			{
				for (int i = 0; i < len; i++)
				{
					dest[i] = 0;
				}
			}
		}

		internal unsafe static void Memcpy(byte* dest, byte* src, int len)
		{
			if (len != 0)
			{
				for (int i = 0; i < len; i++)
				{
					dest[i] = src[i];
				}
			}
		}
	}
	internal static class DecimalEx
	{
		[StructLayout(LayoutKind.Explicit)]
		private struct DecimalBits
		{
			[FieldOffset(0)]
			public int flags;

			[FieldOffset(4)]
			public int hi;

			[FieldOffset(8)]
			public int lo;

			[FieldOffset(12)]
			public int mid;
		}

		[StructLayout(LayoutKind.Explicit)]
		private struct DecCalc
		{
			private const uint TenToPowerNine = 1000000000u;

			[FieldOffset(0)]
			public uint uflags;

			[FieldOffset(4)]
			public uint uhi;

			[FieldOffset(8)]
			public uint ulo;

			[FieldOffset(12)]
			public uint umid;

			[FieldOffset(8)]
			private ulong ulomidLE;

			internal static uint DecDivMod1E9(ref DecCalc value)
			{
				ulong num = ((ulong)value.uhi << 32) + value.umid;
				ulong num2 = num / 1000000000;
				value.uhi = (uint)(num2 >> 32);
				value.umid = (uint)num2;
				ulong num3 = (num - (uint)((int)num2 * 1000000000) << 32) + value.ulo;
				return (uint)(int)num3 - (value.ulo = (uint)(num3 / 1000000000)) * 1000000000;
			}
		}

		private const int ScaleShift = 16;

		private static ref DecCalc AsMutable(ref decimal d)
		{
			return ref Unsafe.As<decimal, DecCalc>(ref d);
		}

		internal static uint High(this decimal value)
		{
			return Unsafe.As<decimal, DecCalc>(ref value).uhi;
		}

		internal static uint Low(this decimal value)
		{
			return Unsafe.As<decimal, DecCalc>(ref value).ulo;
		}

		internal static uint Mid(this decimal value)
		{
			return Unsafe.As<decimal, DecCalc>(ref value).umid;
		}

		internal static bool IsNegative(this decimal value)
		{
			return Unsafe.As<decimal, DecimalBits>(ref value).flags < 0;
		}

		internal static int Scale(this decimal value)
		{
			return (byte)(Unsafe.As<decimal, DecimalBits>(ref value).flags >> 16);
		}

		internal static uint DecDivMod1E9(ref decimal value)
		{
			return DecCalc.DecDivMod1E9(ref AsMutable(ref value));
		}
	}
	internal static class FloatEx
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsFinite(double d)
		{
			return (BitConverter.DoubleToInt64Bits(d) & 0x7FFFFFFFFFFFFFFFL) < 9218868437227405312L;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsNegative(double d)
		{
			return BitConverter.DoubleToInt64Bits(d) < 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsFinite(float f)
		{
			return (SingleToInt32Bits(f) & 0x7FFFFFFF) < 2139095040;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsNegative(float f)
		{
			return SingleToInt32Bits(f) < 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe static int SingleToInt32Bits(float value)
		{
			return *(int*)(&value);
		}
	}
	internal struct GuidEx
	{
		private int _a;

		private short _b;

		private short _c;

		private byte _d;

		private byte _e;

		private byte _f;

		private byte _g;

		private byte _h;

		private byte _i;

		private byte _j;

		private byte _k;

		private unsafe static int HexsToChars(char* guidChars, int a, int b)
		{
			*guidChars = HexConverter.ToCharLower(a >> 4);
			guidChars[1] = HexConverter.ToCharLower(a);
			guidChars[2] = HexConverter.ToCharLower(b >> 4);
			guidChars[3] = HexConverter.ToCharLower(b);
			return 4;
		}

		private unsafe static int HexsToCharsHexOutput(char* guidChars, int a, int b)
		{
			*guidChars = '0';
			guidChars[1] = 'x';
			guidChars[2] = HexConverter.ToCharLower(a >> 4);
			guidChars[3] = HexConverter.ToCharLower(a);
			guidChars[4] = ',';
			guidChars[5] = '0';
			guidChars[6] = 'x';
			guidChars[7] = HexConverter.ToCharLower(b >> 4);
			guidChars[8] = HexConverter.ToCharLower(b);
			return 9;
		}

		public unsafe bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>))
		{
			if (format.Length == 0)
			{
				format = "D".AsSpan();
			}
			if (format.Length != 1)
			{
				throw new FormatException("InvalidGuidFormatSpecification");
			}
			bool flag = true;
			bool flag2 = false;
			int num = 0;
			int num2;
			switch (format[0])
			{
			case 'D':
			case 'd':
				num2 = 36;
				break;
			case 'N':
			case 'n':
				flag = false;
				num2 = 32;
				break;
			case 'B':
			case 'b':
				num = 8192123;
				num2 = 38;
				break;
			case 'P':
			case 'p':
				num = 2687016;
				num2 = 38;
				break;
			case 'X':
			case 'x':
				num = 8192123;
				flag = false;
				flag2 = true;
				num2 = 68;
				break;
			default:
				throw new FormatException("InvalidGuidFormatSpecification");
			}
			if (destination.Length < num2)
			{
				charsWritten = 0;
				return false;
			}
			fixed (char* reference = &MemoryMarshal.GetReference(destination))
			{
				char* ptr = reference;
				if (num != 0)
				{
					*(ptr++) = (char)num;
				}
				if (flag2)
				{
					*(ptr++) = '0';
					*(ptr++) = 'x';
					ptr += HexsToChars(ptr, _a >> 24, _a >> 16);
					ptr += HexsToChars(ptr, _a >> 8, _a);
					*(ptr++) = ',';
					*(ptr++) = '0';
					*(ptr++) = 'x';
					ptr += HexsToChars(ptr, _b >> 8, _b);
					*(ptr++) = ',';
					*(ptr++) = '0';
					*(ptr++) = 'x';
					ptr += HexsToChars(ptr, _c >> 8, _c);
					*(ptr++) = ',';
					*(ptr++) = '{';
					ptr += HexsToCharsHexOutput(ptr, _d, _e);
					*(ptr++) = ',';
					ptr += HexsToCharsHexOutput(ptr, _f, _g);
					*(ptr++) = ',';
					ptr += HexsToCharsHexOutput(ptr, _h, _i);
					*(ptr++) = ',';
					ptr += HexsToCharsHexOutput(ptr, _j, _k);
					*(ptr++) = '}';
				}
				else
				{
					ptr += HexsToChars(ptr, _a >> 24, _a >> 16);
					ptr += HexsToChars(ptr, _a >> 8, _a);
					if (flag)
					{
						*(ptr++) = '-';
					}
					ptr += HexsToChars(ptr, _b >> 8, _b);
					if (flag)
					{
						*(ptr++) = '-';
					}
					ptr += HexsToChars(ptr, _c >> 8, _c);
					if (flag)
					{
						*(ptr++) = '-';
					}
					ptr += HexsToChars(ptr, _d, _e);
					if (flag)
					{
						*(ptr++) = '-';
					}
					ptr += HexsToChars(ptr, _f, _g);
					ptr += HexsToChars(ptr, _h, _i);
					ptr += HexsToChars(ptr, _j, _k);
				}
				if (num != 0)
				{
					*(ptr++) = (char)(num >> 16);
				}
			}
			charsWritten = num2;
			return true;
		}
	}
	internal static class HexConverter
	{
		public enum Casing : uint
		{
			Upper = 0u,
			Lower = 8224u
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ToBytesBuffer(byte value, Span<byte> buffer, int startingIndex = 0, Casing casing = Casing.Upper)
		{
			uint num = (uint)(((value & 0xF0) << 4) + (value & 0xF) - 35209);
			uint num2 = ((((0 - num) & 0x7070) >> 4) + num + 47545) | (uint)casing;
			buffer[startingIndex + 1] = (byte)num2;
			buffer[startingIndex] = (byte)(num2 >> 8);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ToCharsBuffer(byte value, Span<char> buffer, int startingIndex = 0, Casing casing = Casing.Upper)
		{
			uint num = (uint)(((value & 0xF0) << 4) + (value & 0xF) - 35209);
			uint num2 = ((((0 - num) & 0x7070) >> 4) + num + 47545) | (uint)casing;
			buffer[startingIndex + 1] = (char)(num2 & 0xFF);
			buffer[startingIndex] = (char)(num2 >> 8);
		}

		public static string ToString(ReadOnlySpan<byte> bytes, Casing casing = Casing.Upper)
		{
			Span<char> span = default(Span<char>);
			span = ((bytes.Length <= 16) ? stackalloc char[bytes.Length * 2] : new char[bytes.Length * 2].AsSpan());
			int num = 0;
			ReadOnlySpan<byte> readOnlySpan = bytes;
			for (int i = 0; i < readOnlySpan.Length; i++)
			{
				ToCharsBuffer(readOnlySpan[i], span, num, casing);
				num += 2;
			}
			return span.ToString();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static char ToCharUpper(int value)
		{
			value &= 0xF;
			value += 48;
			if (value > 57)
			{
				value += 7;
			}
			return (char)value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static char ToCharLower(int value)
		{
			value &= 0xF;
			value += 48;
			if (value > 57)
			{
				value += 39;
			}
			return (char)value;
		}
	}
	internal static class InternalSpanEx
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool EqualsOrdinalIgnoreCase(this ReadOnlySpan<char> span, ReadOnlySpan<char> value)
		{
			if (span.Length != value.Length)
			{
				return false;
			}
			if (value.Length == 0)
			{
				return true;
			}
			return EqualsOrdinalIgnoreCase(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(value), span.Length);
		}

		private static bool EqualsOrdinalIgnoreCase(ref char charA, ref char charB, int length)
		{
			IntPtr zero = IntPtr.Zero;
			if (IntPtr.Size == 8)
			{
				while ((uint)length >= 4u)
				{
					ulong num = Unsafe.ReadUnaligned<ulong>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charA, zero)));
					ulong num2 = Unsafe.ReadUnaligned<ulong>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charB, zero)));
					ulong num3 = num | num2;
					if (AllCharsInUInt32AreAscii((uint)((int)num3 | (int)(num3 >> 32))))
					{
						if (!UInt64OrdinalIgnoreCaseAscii(num, num2))
						{
							return false;
						}
						zero += 8;
						length -= 4;
						continue;
					}
					goto IL_0104;
				}
			}
			while (true)
			{
				switch (length)
				{
				default:
				{
					uint num6 = Unsafe.ReadUnaligned<uint>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charA, zero)));
					uint num7 = Unsafe.ReadUnaligned<uint>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charB, zero)));
					if (AllCharsInUInt32AreAscii(num6 | num7))
					{
						if (UInt32OrdinalIgnoreCaseAscii(num6, num7))
						{
							goto IL_00aa;
						}
						return false;
					}
					break;
				}
				case 1:
				{
					uint num4 = Unsafe.AddByteOffset(ref charA, zero);
					uint num5 = Unsafe.AddByteOffset(ref charB, zero);
					if ((num4 | num5) <= 127)
					{
						if (num4 == num5)
						{
							return true;
						}
						num4 |= 0x20;
						if (num4 - 97 > 25)
						{
							return false;
						}
						if (num4 != (num5 | 0x20))
						{
							return false;
						}
						return true;
					}
					break;
				}
				case 0:
					return true;
				}
				break;
				IL_00aa:
				zero += 4;
				length -= 2;
			}
			goto IL_0104;
			IL_0104:
			return EqualsOrdinalIgnoreCaseNonAscii(ref Unsafe.AddByteOffset(ref charA, zero), ref Unsafe.AddByteOffset(ref charB, zero), length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool AllCharsInUInt32AreAscii(uint value)
		{
			return (value & 0xFF80FF80u) == 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool AllCharsInUInt64AreAscii(ulong value)
		{
			return (value & 0xFF80FF80FF80FF80uL) == 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool UInt32OrdinalIgnoreCaseAscii(uint valueA, uint valueB)
		{
			uint num = valueA ^ valueB;
			uint num2 = valueA + 16777472 - 4259905;
			uint num3 = (valueA | 0x200020) + 8388736 - 8061051;
			return ((((num2 | num3) >> 2) | 0xFFDFFFDFu) & num) == 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool UInt64OrdinalIgnoreCaseAscii(ulong valueA, ulong valueB)
		{
			ulong num = valueA + 36029346783166592L - 18296152663326785L;
			ulong num2 = (valueA | 0x20002000200020L) + 72058693566333184L - 34621950424449147L;
			ulong num3 = (0x80008000800080L & num & num2) >> 2;
			return (valueA | num3) == (valueB | num3);
		}

		private static bool EqualsOrdinalIgnoreCaseNonAscii(ref char charA, ref char charB, int length)
		{
			IntPtr zero = IntPtr.Zero;
			while (length != 0)
			{
				uint num = Unsafe.AddByteOffset(ref charA, zero);
				uint num2 = Unsafe.AddByteOffset(ref charB, zero);
				if (num == num2 || ((num | 0x20) == (num2 | 0x20) && (num | 0x20) - 97 <= 25))
				{
					zero += 2;
					length--;
					continue;
				}
				return false;
			}
			return true;
		}
	}
	internal static class MathEx
	{
		public static uint DivRem(uint a, uint b, out uint result)
		{
			uint num = a / b;
			result = a - num * b;
			return num;
		}

		public static ulong DivRem(ulong a, ulong b, out ulong result)
		{
			ulong num = a / b;
			result = a - num * b;
			return num;
		}

		public static int DivRem(int a, int b, out int result)
		{
			int num = a / b;
			result = a - num * b;
			return num;
		}

		public static long DivRem(long a, long b, out long result)
		{
			long num = a / b;
			result = a - num * b;
			return num;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static byte Clamp(byte value, byte min, byte max)
		{
			if (min > max)
			{
				ThrowMinMaxException(min, max);
			}
			if (value < min)
			{
				return min;
			}
			if (value > max)
			{
				return max;
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static decimal Clamp(decimal value, decimal min, decimal max)
		{
			if (min > max)
			{
				ThrowMinMaxException(min, max);
			}
			if (value < min)
			{
				return min;
			}
			if (value > max)
			{
				return max;
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static double Clamp(double value, double min, double max)
		{
			if (min > max)
			{
				ThrowMinMaxException(min, max);
			}
			if (value < min)
			{
				return min;
			}
			if (value > max)
			{
				return max;
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static short Clamp(short value, short min, short max)
		{
			if (min > max)
			{
				ThrowMinMaxException(min, max);
			}
			if (value < min)
			{
				return min;
			}
			if (value > max)
			{
				return max;
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int Clamp(int value, int min, int max)
		{
			if (min > max)
			{
				ThrowMinMaxException(min, max);
			}
			if (value < min)
			{
				return min;
			}
			if (value > max)
			{
				return max;
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static long Clamp(long value, long min, long max)
		{
			if (min > max)
			{
				ThrowMinMaxException(min, max);
			}
			if (value < min)
			{
				return min;
			}
			if (value > max)
			{
				return max;
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static sbyte Clamp(sbyte value, sbyte min, sbyte max)
		{
			if (min > max)
			{
				ThrowMinMaxException(min, max);
			}
			if (value < min)
			{
				return min;
			}
			if (value > max)
			{
				return max;
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static float Clamp(float value, float min, float max)
		{
			if (min > max)
			{
				ThrowMinMaxException(min, max);
			}
			if (value < min)
			{
				return min;
			}
			if (value > max)
			{
				return max;
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ushort Clamp(ushort value, ushort min, ushort max)
		{
			if (min > max)
			{
				ThrowMinMaxException(min, max);
			}
			if (value < min)
			{
				return min;
			}
			if (value > max)
			{
				return max;
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static uint Clamp(uint value, uint min, uint max)
		{
			if (min > max)
			{
				ThrowMinMaxException(min, max);
			}
			if (value < min)
			{
				return min;
			}
			if (value > max)
			{
				return max;
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ulong Clamp(ulong value, ulong min, ulong max)
		{
			if (min > max)
			{
				ThrowMinMaxException(min, max);
			}
			if (value < min)
			{
				return min;
			}
			if (value > max)
			{
				return max;
			}
			return value;
		}

		private static void ThrowMinMaxException<T>(T min, T max)
		{
			throw new ArgumentException($"Argument_MinMaxValue, min:{min} max:{max}");
		}
	}
	internal static class Number
	{
		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		internal ref struct BigInteger
		{
			private const int BitsForLongestBinaryMantissa = 1074;

			private const int BitsForLongestDigitSequence = 2552;

			private const int MaxBits = 3658;

			private const int BitsPerBlock = 32;

			private const int MaxBlockCount = 115;

			private static readonly uint[] s_Pow10UInt32Table = new uint[8] { 1u, 10u, 100u, 1000u, 10000u, 100000u, 1000000u, 10000000u };

			private static readonly int[] s_Pow10BigNumTableIndices = new int[8] { 0, 2, 5, 10, 18, 33, 61, 116 };

			private static readonly uint[] s_Pow10BigNumTable = new uint[233]
			{
				1u, 100000000u, 2u, 1874919424u, 2328306u, 4u, 0u, 2242703233u, 762134875u, 1262u,
				7u, 0u, 0u, 3211403009u, 1849224548u, 3668416493u, 3913284084u, 1593091u, 14u, 0u,
				0u, 0u, 0u, 781532673u, 64985353u, 253049085u, 594863151u, 3553621484u, 3288652808u, 3167596762u,
				2788392729u, 3911132675u, 590u, 27u, 0u, 0u, 0u, 0u, 0u, 0u,
				0u, 0u, 2553183233u, 3201533787u, 3638140786u, 303378311u, 1809731782u, 3477761648u, 3583367183u, 649228654u,
				2915460784u, 487929380u, 1011012442u, 1677677582u, 3428152256u, 1710878487u, 1438394610u, 2161952759u, 4100910556u, 1608314830u,
				349175u, 54u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
				0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 4234999809u, 2012377703u,
				2408924892u, 1570150255u, 3090844311u, 3273530073u, 1187251475u, 2498123591u, 3364452033u, 1148564857u, 687371067u, 2854068671u,
				1883165473u, 505794538u, 2988060450u, 3159489326u, 2531348317u, 3215191468u, 849106862u, 3892080979u, 3288073877u, 2242451748u,
				4183778142u, 2995818208u, 2477501924u, 325481258u, 2487842652u, 1774082830u, 1933815724u, 2962865281u, 1168579910u, 2724829000u,
				2360374019u, 2315984659u, 2360052375u, 3251779801u, 1664357844u, 28u, 107u, 0u, 0u, 0u,
				0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
				0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
				0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 689565697u,
				4116392818u, 1853628763u, 516071302u, 2568769159u, 365238920u, 336250165u, 1283268122u, 3425490969u, 248595470u, 2305176814u,
				2111925499u, 507770399u, 2681111421u, 589114268u, 591287751u, 1708941527u, 4098957707u, 475844916u, 3378731398u, 2452339615u,
				2817037361u, 2678008327u, 1656645978u, 2383430340u, 73103988u, 448667107u, 2329420453u, 3124020241u, 3625235717u, 3208634035u,
				2412059158u, 2981664444u, 4117622508u, 838560765u, 3069470027u, 270153238u, 1802868219u, 3692709886u, 2161737865u, 2159912357u,
				2585798786u, 837488486u, 4237238160u, 2540319504u, 3798629246u, 3748148874u, 1021550776u, 2386715342u, 1973637538u, 1823520457u,
				1146713475u, 833971519u, 3277251466u, 905620390u, 26278816u, 2680483154u, 2294040859u, 373297482u, 5996609u, 4109575006u,
				512575049u, 917036550u, 1942311753u, 2816916778u, 3248920332u, 1192784020u, 3537586671u, 2456567643u, 2925660628u, 759380297u,
				888447942u, 3559939476u, 3654687237u, 805u, 0u, 0u, 0u, 0u, 0u, 0u,
				0u, 0u, 0u
			};

			private int _length;

			private unsafe fixed uint _blocks[115];

			public unsafe static void Add(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
			{
				ref BigInteger reference = ref lhs._length < rhs._length ? ref rhs : ref lhs;
				ref BigInteger reference2 = ref lhs._length < rhs._length ? ref lhs : ref rhs;
				int length = reference._length;
				int length2 = reference2._length;
				result._length = length;
				ulong num = 0uL;
				int num2 = 0;
				int num3 = 0;
				int num4 = 0;
				while (num3 < length2)
				{
					ulong num5 = num + reference._blocks[num2] + reference2._blocks[num3];
					num = num5 >> 32;
					result._blocks[num4] = (uint)num5;
					num2++;
					num3++;
					num4++;
				}
				while (num2 < length)
				{
					ulong num6 = num + reference._blocks[num2];
					num = num6 >> 32;
					result._blocks[num4] = (uint)num6;
					num2++;
					num4++;
				}
				if (num != 0L)
				{
					result._blocks[num4] = 1u;
					result._length++;
				}
			}

			public unsafe static int Compare(ref BigInteger lhs, ref BigInteger rhs)
			{
				int length = lhs._length;
				int length2 = rhs._length;
				int num = length - length2;
				if (num != 0)
				{
					return num;
				}
				if (length == 0)
				{
					return 0;
				}
				for (int num2 = length - 1; num2 >= 0; num2--)
				{
					long num3 = (long)lhs._blocks[num2] - (long)rhs._blocks[num2];
					if (num3 != 0L)
					{
						if (num3 <= 0)
						{
							return -1;
						}
						return 1;
					}
				}
				return 0;
			}

			public static uint CountSignificantBits(uint value)
			{
				return (uint)(32 - BitOperations.LeadingZeroCount(value));
			}

			public static uint CountSignificantBits(ulong value)
			{
				return (uint)(64 - BitOperations.LeadingZeroCount(value));
			}

			public unsafe static uint CountSignificantBits(ref BigInteger value)
			{
				if (value.IsZero())
				{
					return 0u;
				}
				uint num = (uint)(value._length - 1);
				return num * 32 + CountSignificantBits(value._blocks[num]);
			}

			public unsafe static void DivRem(ref BigInteger lhs, ref BigInteger rhs, out BigInteger quo, out BigInteger rem)
			{
				if (lhs.IsZero())
				{
					SetZero(out quo);
					SetZero(out rem);
					return;
				}
				int length = lhs._length;
				int length2 = rhs._length;
				if (length == 1 && length2 == 1)
				{
					uint result;
					uint value = MathEx.DivRem(lhs._blocks[0], rhs._blocks[0], out result);
					SetUInt32(out quo, value);
					SetUInt32(out rem, result);
					return;
				}
				if (length2 == 1)
				{
					int num = length;
					ulong b = rhs._blocks[0];
					ulong result2 = 0uL;
					for (int num2 = num - 1; num2 >= 0; num2--)
					{
						ulong num3 = MathEx.DivRem((result2 << 32) | lhs._blocks[num2], b, out result2);
						if (num3 == 0L && num2 == num - 1)
						{
							num--;
						}
						else
						{
							quo._blocks[num2] = (uint)num3;
						}
					}
					quo._length = num;
					SetUInt32(out rem, (uint)result2);
					return;
				}
				if (length2 > length)
				{
					SetZero(out quo);
					SetValue(out rem, ref lhs);
					return;
				}
				int num4 = length - length2 + 1;
				SetValue(out rem, ref lhs);
				int num5 = length;
				uint num6 = rhs._blocks[length2 - 1];
				uint num7 = rhs._blocks[length2 - 2];
				int num8 = BitOperations.LeadingZeroCount(num6);
				int num9 = 32 - num8;
				if (num8 > 0)
				{
					num6 = (num6 << num8) | (num7 >> num9);
					num7 <<= num8;
					if (length2 > 2)
					{
						num7 |= rhs._blocks[length2 - 3] >> num9;
					}
				}
				for (int num10 = length; num10 >= length2; num10--)
				{
					int num11 = num10 - length2;
					uint num12 = ((num10 < length) ? rem._blocks[num10] : 0u);
					ulong num13 = ((ulong)num12 << 32) | rem._blocks[num10 - 1];
					uint num14 = ((num10 > 1) ? rem._blocks[num10 - 2] : 0u);
					if (num8 > 0)
					{
						num13 = (num13 << num8) | (num14 >> num9);
						num14 <<= num8;
						if (num10 > 2)
						{
							num14 |= rem._blocks[num10 - 3] >> num9;
						}
					}
					ulong num15 = num13 / num6;
					if (num15 > uint.MaxValue)
					{
						num15 = 4294967295uL;
					}
					while (DivideGuessTooBig(num15, num13, num14, num6, num7))
					{
						num15--;
					}
					if (num15 != 0 && SubtractDivisor(ref rem, num11, ref rhs, num15) != num12)
					{
						AddDivisor(ref rem, num11, ref rhs);
						num15--;
					}
					if (num4 != 0)
					{
						if (num15 == 0L && num11 == num4 - 1)
						{
							num4--;
						}
						else
						{
							quo._blocks[num11] = (uint)num15;
						}
					}
					if (num10 < num5)
					{
						num5--;
					}
				}
				quo._length = num4;
				for (int num16 = num5 - 1; num16 >= 0; num16--)
				{
					if (rem._blocks[num16] == 0)
					{
						num5--;
					}
				}
				rem._length = num5;
			}

			public unsafe static uint HeuristicDivide(ref BigInteger dividend, ref BigInteger divisor)
			{
				int num = divisor._length;
				if (dividend._length < num)
				{
					return 0u;
				}
				int num2 = num - 1;
				uint num3 = dividend._blocks[num2] / (divisor._blocks[num2] + 1);
				if (num3 != 0)
				{
					int num4 = 0;
					ulong num5 = 0uL;
					ulong num6 = 0uL;
					do
					{
						ulong num7 = (ulong)((long)divisor._blocks[num4] * (long)num3) + num6;
						num6 = num7 >> 32;
						ulong num8 = (ulong)((long)dividend._blocks[num4] - (long)(uint)num7) - num5;
						num5 = (num8 >> 32) & 1;
						dividend._blocks[num4] = (uint)num8;
						num4++;
					}
					while (num4 < num);
					while (num > 0 && dividend._blocks[num - 1] == 0)
					{
						num--;
					}
					dividend._length = num;
				}
				if (Compare(ref dividend, ref divisor) >= 0)
				{
					num3++;
					int num9 = 0;
					ulong num10 = 0uL;
					do
					{
						ulong num11 = (ulong)((long)dividend._blocks[num9] - (long)divisor._blocks[num9]) - num10;
						num10 = (num11 >> 32) & 1;
						dividend._blocks[num9] = (uint)num11;
						num9++;
					}
					while (num9 < num);
					while (num > 0 && dividend._blocks[num - 1] == 0)
					{
						num--;
					}
					dividend._length = num;
				}
				return num3;
			}

			public unsafe static void Multiply(ref BigInteger lhs, uint value, out BigInteger result)
			{
				if (!lhs.IsZero())
				{
					switch (value)
					{
					case 1u:
						break;
					case 0u:
						SetZero(out result);
						return;
					default:
					{
						int length = lhs._length;
						int i = 0;
						uint num = 0u;
						for (; i < length; i++)
						{
							ulong num2 = (ulong)((long)lhs._blocks[i] * (long)value + num);
							result._blocks[i] = (uint)num2;
							num = (uint)(num2 >> 32);
						}
						if (num != 0)
						{
							result._blocks[i] = num;
							result._length = length + 1;
						}
						else
						{
							result._length = length;
						}
						return;
					}
					}
				}
				SetValue(out result, ref lhs);
			}

			public unsafe static void Multiply(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
			{
				if (lhs.IsZero() || rhs.IsOne())
				{
					SetValue(out result, ref lhs);
					return;
				}
				if (rhs.IsZero())
				{
					SetZero(out result);
					return;
				}
				ref BigInteger reference = ref lhs;
				int length = lhs._length;
				ref BigInteger reference2 = ref rhs;
				int length2 = rhs._length;
				if (length < length2)
				{
					reference = ref rhs;
					length = rhs._length;
					reference2 = ref lhs;
					length2 = lhs._length;
				}
				int num = (result._length = length2 + length);
				BufferEx.ZeroMemory((byte*)result.GetBlocksPointer(), (uint)(num * 4));
				int num2 = 0;
				int num3 = 0;
				while (num2 < length2)
				{
					if (reference2._blocks[num2] != 0)
					{
						int num4 = 0;
						int num5 = num3;
						ulong num6 = 0uL;
						do
						{
							ulong num7 = (ulong)(result._blocks[num5] + (long)reference2._blocks[num2] * (long)reference._blocks[num4]) + num6;
							num6 = num7 >> 32;
							result._blocks[num5] = (uint)num7;
							num5++;
							num4++;
						}
						while (num4 < length);
						result._blocks[num5] = (uint)num6;
					}
					num2++;
					num3++;
				}
				if (num > 0 && result._blocks[num - 1] == 0)
				{
					result._length--;
				}
			}

			public unsafe static void Pow2(uint exponent, out BigInteger result)
			{
				uint remainder;
				uint num = DivRem32(exponent, out remainder);
				result._length = (int)(num + 1);
				if (num != 0)
				{
					BufferEx.ZeroMemory((byte*)result.GetBlocksPointer(), num * 4);
				}
				result._blocks[num] = (uint)(1 << (int)remainder);
			}

			public unsafe static void Pow10(uint exponent, out BigInteger result)
			{
				SetUInt32(out var result2, s_Pow10UInt32Table[exponent & 7]);
				ref BigInteger reference = ref result2;
				SetZero(out var result3);
				ref BigInteger reference2 = ref result3;
				exponent >>= 3;
				uint num = 0u;
				while (exponent != 0)
				{
					if ((exponent & 1) != 0)
					{
						fixed (uint* ptr = &s_Pow10BigNumTable[s_Pow10BigNumTableIndices[num]])
						{
							Multiply(ref reference, ref *(BigInteger*)ptr, out reference2);
						}
						ref BigInteger reference3 = ref reference2;
						reference2 = ref reference;
						reference = ref reference3;
					}
					num++;
					exponent >>= 1;
				}
				SetValue(out result, ref reference);
			}

			private unsafe static uint AddDivisor(ref BigInteger lhs, int lhsStartIndex, ref BigInteger rhs)
			{
				int length = rhs._length;
				ulong num = 0uL;
				for (int i = 0; i < length; i++)
				{
					ref uint reference = ref lhs._blocks[lhsStartIndex + i];
					ulong num2 = reference + num + rhs._blocks[i];
					reference = (uint)num2;
					num = num2 >> 32;
				}
				return (uint)num;
			}

			private static bool DivideGuessTooBig(ulong q, ulong valHi, uint valLo, uint divHi, uint divLo)
			{
				ulong num = divHi * q;
				ulong num2 = divLo * q;
				num += num2 >> 32;
				num2 &= 0xFFFFFFFFu;
				if (num < valHi)
				{
					return false;
				}
				if (num > valHi)
				{
					return true;
				}
				if (num2 < valLo)
				{
					return false;
				}
				if (num2 > valLo)
				{
					return true;
				}
				return false;
			}

			private unsafe static uint SubtractDivisor(ref BigInteger lhs, int lhsStartIndex, ref BigInteger rhs, ulong q)
			{
				int length = rhs._length;
				ulong num = 0uL;
				for (int i = 0; i < length; i++)
				{
					num += rhs._blocks[i] * q;
					uint num2 = (uint)num;
					num >>= 32;
					ref uint reference = ref lhs._blocks[lhsStartIndex + i];
					if (reference < num2)
					{
						num++;
					}
					reference -= num2;
				}
				return (uint)num;
			}

			public unsafe void Add(uint value)
			{
				int length = _length;
				if (length == 0)
				{
					SetUInt32(out this, value);
					return;
				}
				_blocks[0] += value;
				if (_blocks[0] >= value)
				{
					return;
				}
				for (int i = 1; i < length; i++)
				{
					ref uint reference = ref _blocks[i];
					reference++;
					if (_blocks[i] != 0)
					{
						return;
					}
				}
				_blocks[length] = 1u;
				_length = length + 1;
			}

			public unsafe uint GetBlock(uint index)
			{
				return _blocks[index];
			}

			public int GetLength()
			{
				return _length;
			}

			public unsafe bool IsOne()
			{
				if (_length == 1)
				{
					return _blocks[0] == 1;
				}
				return false;
			}

			public bool IsZero()
			{
				return _length == 0;
			}

			public void Multiply(uint value)
			{
				Multiply(ref this, value, out this);
			}

			public void Multiply(ref BigInteger value)
			{
				SetValue(out var result, ref this);
				Multiply(ref result, ref value, out this);
			}

			public unsafe void Multiply10()
			{
				if (!IsZero())
				{
					int i = 0;
					int length = _length;
					ulong num = 0uL;
					for (; i < length; i++)
					{
						ulong num2 = _blocks[i];
						ulong num3 = (num2 << 3) + (num2 << 1) + num;
						num = num3 >> 32;
						_blocks[i] = (uint)num3;
					}
					if (num != 0L)
					{
						_blocks[i] = (uint)num;
						_length++;
					}
				}
			}

			public unsafe void MultiplyPow10(uint exponent)
			{
				if (!IsZero())
				{
					Pow10(exponent, out var result);
					if (result._length == 1)
					{
						Multiply(result._blocks[0]);
					}
					else
					{
						Multiply(ref result);
					}
				}
			}

			public unsafe static void SetUInt32(out BigInteger result, uint value)
			{
				if (value == 0)
				{
					SetZero(out result);
					return;
				}
				result._blocks[0] = value;
				result._length = 1;
			}

			public unsafe static void SetUInt64(out BigInteger result, ulong value)
			{
				if (value <= uint.MaxValue)
				{
					SetUInt32(out result, (uint)value);
					return;
				}
				result._blocks[0] = (uint)value;
				result._blocks[1] = (uint)(value >> 32);
				result._length = 2;
			}

			public unsafe static void SetValue(out BigInteger result, ref BigInteger value)
			{
				BufferEx.Memcpy(len: (result._length = value._length) * 4, dest: (byte*)result.GetBlocksPointer(), src: (byte*)value.GetBlocksPointer());
			}

			public static void SetZero(out BigInteger result)
			{
				result._length = 0;
			}

			public unsafe void ShiftLeft(uint shift)
			{
				int length = _length;
				if (length == 0 || shift == 0)
				{
					return;
				}
				uint remainder;
				uint num = DivRem32(shift, out remainder);
				int num2 = length - 1;
				int num3 = num2 + (int)num;
				if (remainder == 0)
				{
					while (num2 >= 0)
					{
						_blocks[num3] = _blocks[num2];
						num2--;
						num3--;
					}
					_length += (int)num;
					BufferEx.ZeroMemory((byte*)GetBlocksPointer(), num * 4);
					return;
				}
				num3++;
				_length = num3 + 1;
				uint num4 = 32 - remainder;
				uint num5 = 0u;
				uint num6 = _blocks[num2];
				uint num7 = num6 >> (int)num4;
				while (num2 > 0)
				{
					_blocks[num3] = num5 | num7;
					num5 = num6 << (int)remainder;
					num2--;
					num3--;
					num6 = _blocks[num2];
					num7 = num6 >> (int)num4;
				}
				_blocks[num3] = num5 | num7;
				_blocks[num3 - 1] = num6 << (int)remainder;
				BufferEx.ZeroMemory((byte*)GetBlocksPointer(), num * 4);
				if (_blocks[_length - 1] == 0)
				{
					_length--;
				}
			}

			public unsafe ulong ToUInt64()
			{
				if (_length > 1)
				{
					return ((ulong)_blocks[1] << 32) + _blocks[0];
				}
				if (_length > 0)
				{
					return _blocks[0];
				}
				return 0uL;
			}

			private unsafe uint* GetBlocksPointer()
			{
				return (uint*)Unsafe.AsPointer(ref _blocks[0]);
			}

			private static uint DivRem32(uint value, out uint remainder)
			{
				remainder = value & 0x1F;
				return value >> 5;
			}
		}

		internal readonly ref struct DiyFp
		{
			public const int DoubleImplicitBitIndex = 52;

			public const int SingleImplicitBitIndex = 23;

			public const int SignificandSize = 64;

			public readonly ulong f;

			public readonly int e;

			public static DiyFp CreateAndGetBoundaries(double value, out DiyFp mMinus, out DiyFp mPlus)
			{
				DiyFp result = new DiyFp(value);
				result.GetBoundaries(52, out mMinus, out mPlus);
				return result;
			}

			public static DiyFp CreateAndGetBoundaries(float value, out DiyFp mMinus, out DiyFp mPlus)
			{
				DiyFp result = new DiyFp(value);
				result.GetBoundaries(23, out mMinus, out mPlus);
				return result;
			}

			public DiyFp(double value)
			{
				f = ExtractFractionAndBiasedExponent(value, out e);
			}

			public DiyFp(float value)
			{
				f = ExtractFractionAndBiasedExponent(value, out e);
			}

			public DiyFp(ulong f, int e)
			{
				this.f = f;
				this.e = e;
			}

			public DiyFp Multiply(in DiyFp other)
			{
				int num = (int)(f >> 32);
				uint num2 = (uint)f;
				uint num3 = (uint)(other.f >> 32);
				uint num4 = (uint)other.f;
				ulong num5 = (ulong)(uint)num * (ulong)num3;
				ulong num6 = (ulong)num2 * (ulong)num3;
				ulong num7 = (ulong)(uint)num * (ulong)num4;
				ulong num8 = (ulong)(((long)num2 * (long)num4 >>> 32) + (uint)num7 + (uint)num6);
				num8 += 2147483648u;
				return new DiyFp(num5 + (num7 >> 32) + (num6 >> 32) + (num8 >> 32), e + other.e + 64);
			}

			public DiyFp Normalize()
			{
				int num = BitOperations.LeadingZeroCount(f);
				return new DiyFp(f << num, e - num);
			}

			public DiyFp Subtract(in DiyFp other)
			{
				return new DiyFp(f - other.f, e);
			}

			private void GetBoundaries(int implicitBitIndex, out DiyFp mMinus, out DiyFp mPlus)
			{
				mPlus = new DiyFp((f << 1) + 1, e - 1).Normalize();
				if (f == (ulong)(1L << implicitBitIndex))
				{
					mMinus = new DiyFp((f << 2) - 1, e - 2);
				}
				else
				{
					mMinus = new DiyFp((f << 1) - 1, e - 1);
				}
				mMinus = new DiyFp(mMinus.f << mMinus.e - mPlus.e, mPlus.e);
			}
		}

		internal static class Grisu3
		{
			private const int CachedPowersDecimalExponentDistance = 8;

			private const int CachedPowersMinDecimalExponent = -348;

			private const int CachedPowersPowerMaxDecimalExponent = 340;

			private const int CachedPowersOffset = 348;

			private const double D1Log210 = 0.3010299956639812;

			private const int MaximalTargetExponent = -32;

			private const int MinimalTargetExponent = -60;

			private static readonly short[] s_CachedPowersBinaryExponent = new short[87]
			{
				-1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980,
				-954, -927, -901, -874, -847, -821, -794, -768, -741, -715,
				-688, -661, -635, -608, -582, -555, -529, -502, -475, -449,
				-422, -396, -369, -343, -316, -289, -263, -236, -210, -183,
				-157, -130, -103, -77, -50, -24, 3, 30, 56, 83,
				109, 136, 162, 189, 216, 242, 269, 295, 322, 348,
				375, 402, 428, 455, 481, 508, 534, 561, 588, 614,
				641, 667, 694, 720, 747, 774, 800, 827, 853, 880,
				907, 933, 960, 986, 1013, 1039, 1066
			};

			private static readonly short[] s_CachedPowersDecimalExponent = new short[87]
			{
				-348, -340, -332, -324, -316, -308, -300, -292, -284, -276,
				-268, -260, -252, -244, -236, -228, -220, -212, -204, -196,
				-188, -180, -172, -164, -156, -148, -140, -132, -124, -116,
				-108, -100, -92, -84, -76, -68, -60, -52, -44, -36,
				-28, -20, -12, -4, 4, 12, 20, 28, 36, 44,
				52, 60, 68, 76, 84, 92, 100, 108, 116, 124,
				132, 140, 148, 156, 164, 172, 180, 188, 196, 204,
				212, 220, 228, 236, 244, 252, 260, 268, 276, 284,
				292, 300, 308, 316, 324, 332, 340
			};

			private static readonly ulong[] s_CachedPowersSignificand = new ulong[87]
			{
				18054884314459144840uL, 13451937075301367670uL, 10022474136428063862uL, 14934650266808366570uL, 11127181549972568877uL, 16580792590934885855uL, 12353653155963782858uL, 18408377700990114895uL, 13715310171984221708uL, 10218702384817765436uL,
				15227053142812498563uL, 11345038669416679861uL, 16905424996341287883uL, 12595523146049147757uL, 9384396036005875287uL, 13983839803942852151uL, 10418772551374772303uL, 15525180923007089351uL, 11567161174868858868uL, 17236413322193710309uL,
				12842128665889583758uL, 9568131466127621947uL, 14257626930069360058uL, 10622759856335341974uL, 15829145694278690180uL, 11793632577567316726uL, 17573882009934360870uL, 13093562431584567480uL, 9755464219737475723uL, 14536774485912137811uL,
				10830740992659433045uL, 16139061738043178685uL, 12024538023802026127uL, 17917957937422433684uL, 13349918974505688015uL, 9946464728195732843uL, 14821387422376473014uL, 11042794154864902060uL, 16455045573212060422uL, 12259964326927110867uL,
				18268770466636286478uL, 13611294676837538539uL, 10141204801825835212uL, 15111572745182864684uL, 11258999068426240000uL, 16777216000000000000uL, 12500000000000000000uL, 9313225746154785156uL, 13877787807814456755uL, 10339757656912845936uL,
				15407439555097886824uL, 11479437019748901445uL, 17105694144590052135uL, 12744735289059618216uL, 9495567745759798747uL, 14149498560666738074uL, 10542197943230523224uL, 15709099088952724970uL, 11704190886730495818uL, 17440603504673385349uL,
				12994262207056124023uL, 9681479787123295682uL, 14426529090290212157uL, 10748601772107342003uL, 16016664761464807395uL, 11933345169920330789uL, 17782069995880619868uL, 13248674568444952270uL, 9871031767461413346uL, 14708983551653345445uL,
				10959046745042015199uL, 16330252207878254650uL, 12166986024289022870uL, 18130221999122236476uL, 13508068024458167312uL, 10064294952495520794uL, 14996968138956309548uL, 11173611982879273257uL, 16649979327439178909uL, 12405201291620119593uL,
				9242595204427927429uL, 13772540099066387757uL, 10261342003245940623uL, 15290591125556738113uL, 11392378155556871081uL, 16975966327722178521uL, 12648080533535911531uL
			};

			private static readonly uint[] s_SmallPowersOfTen = new uint[10] { 1u, 10u, 100u, 1000u, 10000u, 100000u, 1000000u, 10000000u, 100000000u, 1000000000u };

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private static bool IsNegative(double d)
			{
				return BitConverter.DoubleToInt64Bits(d) < 0;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private static bool IsNegativeInfinity(float f)
			{
				return f == float.NegativeInfinity;
			}

			public static bool TryRunDouble(double value, int requestedDigits, ref NumberBuffer number)
			{
				double value2 = (IsNegative(value) ? (0.0 - value) : value);
				DiyFp diyFp;
				bool flag;
				int length;
				int decimalExponent;
				if (requestedDigits == -1)
				{
					diyFp = DiyFp.CreateAndGetBoundaries(value2, out var mMinus, out var mPlus);
					flag = TryRunShortest(in mMinus, diyFp.Normalize(), in mPlus, number.Digits, out length, out decimalExponent);
				}
				else
				{
					diyFp = new DiyFp(value2);
					flag = TryRunCounted(diyFp.Normalize(), requestedDigits, number.Digits, out length, out decimalExponent);
				}
				if (flag)
				{
					number.Scale = length + decimalExponent;
					number.Digits[length] = 0;
					number.DigitsCount = length;
				}
				return flag;
			}

			public static bool TryRunSingle(float value, int requestedDigits, ref NumberBuffer number)
			{
				float value2 = (IsNegative(value) ? (0f - value) : value);
				DiyFp diyFp;
				bool flag;
				int length;
				int decimalExponent;
				if (requestedDigits == -1)
				{
					diyFp = DiyFp.CreateAndGetBoundaries(value2, out var mMinus, out var mPlus);
					flag = TryRunShortest(in mMinus, diyFp.Normalize(), in mPlus, number.Digits, out length, out decimalExponent);
				}
				else
				{
					diyFp = new DiyFp(value2);
					flag = TryRunCounted(diyFp.Normalize(), requestedDigits, number.Digits, out length, out decimalExponent);
				}
				if (flag)
				{
					number.Scale = length + decimalExponent;
					number.Digits[length] = 0;
					number.DigitsCount = length;
				}
				return flag;
			}

			private static bool TryRunCounted(in DiyFp w, int requestedDigits, Span<byte> buffer, out int length, out int decimalExponent)
			{
				int minExponent = -60 - (w.e + 64);
				int maxExponent = -32 - (w.e + 64);
				int decimalExponent2;
				int kappa;
				bool result = TryDigitGenCounted(w.Multiply(GetCachedPowerForBinaryExponentRange(minExponent, maxExponent, out decimalExponent2)), requestedDigits, buffer, out length, out kappa);
				decimalExponent = -decimalExponent2 + kappa;
				return result;
			}

			private static bool TryRunShortest(in DiyFp boundaryMinus, in DiyFp w, in DiyFp boundaryPlus, Span<byte> buffer, out int length, out int decimalExponent)
			{
				int minExponent = -60 - (w.e + 64);
				int maxExponent = -32 - (w.e + 64);
				int decimalExponent2;
				DiyFp other = GetCachedPowerForBinaryExponentRange(minExponent, maxExponent, out decimalExponent2);
				DiyFp w2 = w.Multiply(in other);
				int kappa;
				bool result = TryDigitGenShortest(boundaryMinus.Multiply(in other), in w2, boundaryPlus.Multiply(in other), buffer, out length, out kappa);
				decimalExponent = -decimalExponent2 + kappa;
				return result;
			}

			private static uint BiggestPowerTen(uint number, int numberBits, out int exponentPlusOne)
			{
				int num = (numberBits + 1) * 1233 >> 12;
				uint num2 = s_SmallPowersOfTen[num];
				if (number < num2)
				{
					num--;
					num2 = s_SmallPowersOfTen[num];
				}
				exponentPlusOne = num + 1;
				return num2;
			}

			private static bool TryDigitGenCounted(in DiyFp w, int requestedDigits, Span<byte> buffer, out int length, out int kappa)
			{
				ulong num = 1uL;
				DiyFp diyFp = new DiyFp((ulong)(1L << -w.e), w.e);
				uint result = (uint)(w.f >> -diyFp.e);
				ulong num2 = w.f & (diyFp.f - 1);
				if (num2 == 0L && (requestedDigits >= 11 || result < s_SmallPowersOfTen[requestedDigits - 1]))
				{
					length = 0;
					kappa = 0;
					return false;
				}
				uint num3 = BiggestPowerTen(result, 64 - -diyFp.e, out kappa);
				length = 0;
				while (kappa > 0)
				{
					uint num4 = MathEx.DivRem(result, num3, out result);
					buffer[length] = (byte)(48 + num4);
					length++;
					requestedDigits--;
					kappa--;
					if (requestedDigits == 0)
					{
						break;
					}
					num3 /= 10;
				}
				if (requestedDigits == 0)
				{
					ulong rest = ((ulong)result << -diyFp.e) + num2;
					return TryRoundWeedCounted(buffer, length, rest, (ulong)num3 << -diyFp.e, num, ref kappa);
				}
				while (requestedDigits > 0 && num2 > num)
				{
					num2 *= 10;
					num *= 10;
					uint num5 = (uint)(num2 >> -diyFp.e);
					buffer[length] = (byte)(48 + num5);
					length++;
					requestedDigits--;
					kappa--;
					num2 &= diyFp.f - 1;
				}
				if (requestedDigits != 0)
				{
					buffer[0] = 0;
					length = 0;
					kappa = 0;
					return false;
				}
				return TryRoundWeedCounted(buffer, length, num2, diyFp.f, num, ref kappa);
			}

			private static bool TryDigitGenShortest(in DiyFp low, in DiyFp w, in DiyFp high, Span<byte> buffer, out int length, out int kappa)
			{
				ulong num = 1uL;
				DiyFp other = new DiyFp(low.f - num, low.e);
				DiyFp diyFp = new DiyFp(high.f + num, high.e);
				DiyFp diyFp2 = diyFp.Subtract(in other);
				DiyFp diyFp3 = new DiyFp((ulong)(1L << -w.e), w.e);
				uint result = (uint)(diyFp.f >> -diyFp3.e);
				ulong num2 = diyFp.f & (diyFp3.f - 1);
				uint num3 = BiggestPowerTen(result, 64 - -diyFp3.e, out kappa);
				length = 0;
				while (kappa > 0)
				{
					uint num4 = MathEx.DivRem(result, num3, out result);
					buffer[length] = (byte)(48 + num4);
					length++;
					kappa--;
					ulong num5 = ((ulong)result << -diyFp3.e) + num2;
					if (num5 < diyFp2.f)
					{
						return TryRoundWeedShortest(buffer, length, diyFp.Subtract(in w).f, diyFp2.f, num5, (ulong)num3 << -diyFp3.e, num);
					}
					num3 /= 10;
				}
				do
				{
					num2 *= 10;
					num *= 10;
					diyFp2 = new DiyFp(diyFp2.f * 10, diyFp2.e);
					uint num6 = (uint)(num2 >> -diyFp3.e);
					buffer[length] = (byte)(48 + num6);
					length++;
					kappa--;
					num2 &= diyFp3.f - 1;
				}
				while (num2 >= diyFp2.f);
				return TryRoundWeedShortest(buffer, length, diyFp.Subtract(in w).f * num, diyFp2.f, num2, diyFp3.f, num);
			}

			private static DiyFp GetCachedPowerForBinaryExponentRange(int minExponent, int maxExponent, out int decimalExponent)
			{
				double num = Math.Ceiling((double)(minExponent + 64 - 1) * 0.3010299956639812);
				int num2 = (348 + (int)num - 1) / 8 + 1;
				decimalExponent = s_CachedPowersDecimalExponent[num2];
				return new DiyFp(s_CachedPowersSignificand[num2], s_CachedPowersBinaryExponent[num2]);
			}

			private static bool TryRoundWeedCounted(Span<byte> buffer, int length, ulong rest, ulong tenKappa, ulong unit, ref int kappa)
			{
				if (unit >= tenKappa || tenKappa - unit <= unit)
				{
					return false;
				}
				if (tenKappa - rest > rest && tenKappa - 2 * rest >= 2 * unit)
				{
					return true;
				}
				if (rest > unit && (tenKappa <= rest - unit || tenKappa - (rest - unit) <= rest - unit))
				{
					buffer[length - 1]++;
					int num = length - 1;
					while (num > 0 && buffer[num] == 58)
					{
						buffer[num] = 48;
						buffer[num - 1]++;
						num--;
					}
					if (buffer[0] == 58)
					{
						buffer[0] = 49;
						kappa++;
					}
					return true;
				}
				return false;
			}

			private static bool TryRoundWeedShortest(Span<byte> buffer, int length, ulong distanceTooHighW, ulong unsafeInterval, ulong rest, ulong tenKappa, ulong unit)
			{
				ulong num = distanceTooHighW - unit;
				ulong num2 = distanceTooHighW + unit;
				while (rest < num && unsafeInterval - rest >= tenKappa && (rest + tenKappa < num || num - rest >= rest + tenKappa - num))
				{
					buffer[length - 1]--;
					rest += tenKappa;
				}
				if (rest < num2 && unsafeInterval - rest >= tenKappa && (rest + tenKappa < num2 || num2 - rest > rest + tenKappa - num2))
				{
					return false;
				}
				if (2 * unit <= rest)
				{
					return rest <= unsafeInterval - 4 * unit;
				}
				return false;
			}
		}

		internal ref struct NumberBuffer
		{
			public int DigitsCount;

			public int Scale;

			public bool IsNegative;

			public bool HasNonZeroTail;

			public NumberBufferKind Kind;

			public Span<byte> Digits;

			public unsafe NumberBuffer(NumberBufferKind kind, byte* digits, int digitsLength)
			{
				DigitsCount = 0;
				Scale = 0;
				IsNegative = false;
				HasNonZeroTail = false;
				Kind = kind;
				Digits = new Span<byte>(digits, digitsLength);
				Digits[0] = 0;
			}

			[Conditional("DEBUG")]
			public void CheckConsistency()
			{
			}

			public unsafe byte* GetDigitsPointer()
			{
				return (byte*)Unsafe.AsPointer(ref Digits[0]);
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append('[');
				stringBuilder.Append('"');
				for (int i = 0; i < Digits.Length; i++)
				{
					byte b = Digits[i];
					if (b == 0)
					{
						break;
					}
					stringBuilder.Append((char)b);
				}
				stringBuilder.Append('"');
				stringBuilder.Append(", Length = ").Append(DigitsCount);
				stringBuilder.Append(", Scale = ").Append(Scale);
				stringBuilder.Append(", IsNegative = ").Append(IsNegative);
				stringBuilder.Append(", HasNonZeroTail = ").Append(HasNonZeroTail);
				stringBuilder.Append(", Kind = ").Append(Kind);
				stringBuilder.Append(']');
				return stringBuilder.ToString();
			}
		}

		internal enum NumberBufferKind : byte
		{
			Unknown,
			Integer,
			Decimal,
			FloatingPoint
		}

		public readonly struct FloatingPointInfo
		{
			public static readonly FloatingPointInfo Double = new FloatingPointInfo(52, 11, 1023, 1023, 9218868437227405312uL);

			public static readonly FloatingPointInfo Single = new FloatingPointInfo(23, 8, 127, 127, 2139095040uL);

			public ulong ZeroBits { get; }

			public ulong InfinityBits { get; }

			public ulong NormalMantissaMask { get; }

			public ulong DenormalMantissaMask { get; }

			public int MinBinaryExponent { get; }

			public int MaxBinaryExponent { get; }

			public int ExponentBias { get; }

			public int OverflowDecimalExponent { get; }

			public ushort NormalMantissaBits { get; }

			public ushort DenormalMantissaBits { get; }

			public ushort ExponentBits { get; }

			public FloatingPointInfo(ushort denormalMantissaBits, ushort exponentBits, int maxBinaryExponent, int exponentBias, ulong infinityBits)
			{
				ExponentBits = exponentBits;
				DenormalMantissaBits = denormalMantissaBits;
				NormalMantissaBits = (ushort)(denormalMantissaBits + 1);
				OverflowDecimalExponent = (maxBinaryExponent + 2 * NormalMantissaBits) / 3;
				ExponentBias = exponentBias;
				MaxBinaryExponent = maxBinaryExponent;
				MinBinaryExponent = 1 - maxBinaryExponent;
				DenormalMantissaMask = (ulong)((1L << (int)denormalMantissaBits) - 1);
				NormalMantissaMask = (ulong)((1L << (int)NormalMantissaBits) - 1);
				InfinityBits = infinityBits;
				ZeroBits = 0uL;
			}
		}

		internal enum ParsingStatus
		{
			OK,
			Failed,
			Overflow
		}

		internal const int DecimalPrecision = 29;

		private const int SinglePrecision = 9;

		private const int DoublePrecision = 17;

		private const int SinglePrecisionCustomFormat = 7;

		private const int DoublePrecisionCustomFormat = 15;

		private const int DefaultPrecisionExponentialFormat = 6;

		private const int MaxUInt32DecDigits = 10;

		private const int CharStackBufferSize = 32;

		private const string PosNumberFormat = "#";

		private static readonly string[] s_singleDigitStringCache = new string[10] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" };

		private static readonly string[] s_posCurrencyFormats = new string[4] { "$#", "#$", "$ #", "# $" };

		private static readonly string[] s_negCurrencyFormats = new string[16]
		{
			"($#)", "-$#", "$-#", "$#-", "(#$)", "-#$", "#-$", "#$-", "-# $", "-$ #",
			"# $-", "$ #-", "$ -#", "#- $", "($ #)", "(# $)"
		};

		private static readonly string[] s_posPercentFormats = new string[4] { "# %", "#%", "%#", "% #" };

		private static readonly string[] s_negPercentFormats = new string[12]
		{
			"-# %", "-#%", "-%#", "%-#", "%#-", "#-%", "#%-", "-% #", "# %-", "% #-",
			"% -#", "#- %"
		};

		private static readonly string[] s_negNumberFormats = new string[5] { "(#)", "-#", "- #", "#-", "# -" };

		internal const int DecimalNumberBufferLength = 31;

		internal const int DoubleNumberBufferLength = 769;

		internal const int Int32NumberBufferLength = 11;

		internal const int Int64NumberBufferLength = 20;

		internal const int SingleNumberBufferLength = 114;

		internal const int UInt32NumberBufferLength = 11;

		internal const int UInt64NumberBufferLength = 21;

		private static readonly float[] s_Pow10SingleTable = new float[11]
		{
			1f, 10f, 100f, 1000f, 10000f, 100000f, 1000000f, 10000000f, 100000000f, 1E+09f,
			1E+10f
		};

		private static readonly double[] s_Pow10DoubleTable = new double[23]
		{
			1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 10000000.0, 100000000.0, 1000000000.0,
			10000000000.0, 100000000000.0, 1000000000000.0, 10000000000000.0, 100000000000000.0, 1000000000000000.0, 10000000000000000.0, 1E+17, 1E+18, 1E+19,
			1E+20, 1E+21, 1E+22
		};

		private const int Int32Precision = 10;

		private const int UInt32Precision = 10;

		private const int Int64Precision = 19;

		private const int UInt64Precision = 20;

		private const int DoubleMaxExponent = 309;

		private const int DoubleMinExponent = -324;

		private const int FloatingPointMaxExponent = 309;

		private const int FloatingPointMinExponent = -324;

		private const int SingleMaxExponent = 39;

		private const int SingleMinExponent = -45;

		internal static ReadOnlySpan<byte> CharToHexLookup => new byte[103]
		{
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 0, 1,
			2, 3, 4, 5, 6, 7, 8, 9, 255, 255,
			255, 255, 255, 255, 255, 10, 11, 12, 13, 14,
			15, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 10, 11, 12,
			13, 14, 15
		};

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static bool IsNegative(double d)
		{
			return BitConverter.DoubleToInt64Bits(d) < 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsNegativeInfinity(float f)
		{
			return f == float.NegativeInfinity;
		}

		public static void Dragon4Double(double value, int cutoffNumber, bool isSignificantDigits, ref NumberBuffer number)
		{
			IsNegative(value);
			int exponent;
			ulong num = ExtractFractionAndBiasedExponent(value, out exponent);
			bool hasUnequalMargins = false;
			uint mantissaHighBitIdx;
			if (num >> 52 != 0L)
			{
				mantissaHighBitIdx = 52u;
				hasUnequalMargins = num == 4503599627370496L;
			}
			else
			{
				mantissaHighBitIdx = (uint)BitOperations.Log2(num);
			}
			int decimalExponent;
			int num2 = (int)Dragon4(num, exponent, mantissaHighBitIdx, hasUnequalMargins, cutoffNumber, isSignificantDigits, number.Digits, out decimalExponent);
			number.Scale = decimalExponent + 1;
			number.Digits[num2] = 0;
			number.DigitsCount = num2;
		}

		public static void Dragon4Single(float value, int cutoffNumber, bool isSignificantDigits, ref NumberBuffer number)
		{
			IsNegative(value);
			int exponent;
			uint num = ExtractFractionAndBiasedExponent(value, out exponent);
			bool hasUnequalMargins = false;
			uint mantissaHighBitIdx;
			if (num >> 23 != 0)
			{
				mantissaHighBitIdx = 23u;
				hasUnequalMargins = num == 8388608;
			}
			else
			{
				mantissaHighBitIdx = (uint)BitOperations.Log2(num);
			}
			int decimalExponent;
			int num2 = (int)Dragon4(num, exponent, mantissaHighBitIdx, hasUnequalMargins, cutoffNumber, isSignificantDigits, number.Digits, out decimalExponent);
			number.Scale = decimalExponent + 1;
			number.Digits[num2] = 0;
			number.DigitsCount = num2;
		}

		private unsafe static uint Dragon4(ulong mantissa, int exponent, uint mantissaHighBitIdx, bool hasUnequalMargins, int cutoffNumber, bool isSignificantDigits, Span<byte> buffer, out int decimalExponent)
		{
			int num = 0;
			BigInteger lhs;
			BigInteger rhs;
			BigInteger result;
			BigInteger* ptr;
			if (hasUnequalMargins)
			{
				BigInteger result2;
				if (exponent > 0)
				{
					BigInteger.SetUInt64(out lhs, 4 * mantissa);
					lhs.ShiftLeft((uint)exponent);
					BigInteger.SetUInt32(out rhs, 4u);
					BigInteger.Pow2((uint)exponent, out result);
					BigInteger.Pow2((uint)(exponent + 1), out result2);
				}
				else
				{
					BigInteger.SetUInt64(out lhs, 4 * mantissa);
					BigInteger.Pow2((uint)(-exponent + 2), out rhs);
					BigInteger.SetUInt32(out result, 1u);
					BigInteger.SetUInt32(out result2, 2u);
				}
				ptr = &result2;
			}
			else
			{
				if (exponent > 0)
				{
					BigInteger.SetUInt64(out lhs, 2 * mantissa);
					lhs.ShiftLeft((uint)exponent);
					BigInteger.SetUInt32(out rhs, 2u);
					BigInteger.Pow2((uint)exponent, out result);
				}
				else
				{
					BigInteger.SetUInt64(out lhs, 2 * mantissa);
					BigInteger.Pow2((uint)(-exponent + 1), out rhs);
					BigInteger.SetUInt32(out result, 1u);
				}
				ptr = &result;
			}
			int num2 = (int)Math.Ceiling((double)((int)mantissaHighBitIdx + exponent) * 0.3010299956639812 - 0.69);
			if (num2 > 0)
			{
				rhs.MultiplyPow10((uint)num2);
			}
			else if (num2 < 0)
			{
				BigInteger.Pow10((uint)(-num2), out var result3);
				lhs.Multiply(ref result3);
				result.Multiply(ref result3);
				if (ptr != &result)
				{
					BigInteger.Multiply(ref result, 2u, out *ptr);
				}
			}
			bool flag = mantissa % 2 == 0;
			bool flag2 = false;
			if (cutoffNumber == -1)
			{
				BigInteger.Add(ref lhs, ref *ptr, out var result4);
				int num3 = BigInteger.Compare(ref result4, ref rhs);
				flag2 = (flag ? (num3 >= 0) : (num3 > 0));
			}
			else
			{
				flag2 = BigInteger.Compare(ref lhs, ref rhs) >= 0;
			}
			if (flag2)
			{
				num2++;
			}
			else
			{
				lhs.Multiply10();
				result.Multiply10();
				if (ptr != &result)
				{
					BigInteger.Multiply(ref result, 2u, out *ptr);
				}
			}
			int num4 = num2 - buffer.Length;
			if (cutoffNumber != -1)
			{
				int num5 = 0;
				num5 = ((!isSignificantDigits) ? (-cutoffNumber) : (num2 - cutoffNumber));
				if (num5 > num4)
				{
					num4 = num5;
				}
			}
			num2 = (decimalExponent = num2 - 1);
			uint block = rhs.GetBlock((uint)(rhs.GetLength() - 1));
			if (block < 8 || block > 429496729)
			{
				uint num6 = (uint)BitOperations.Log2(block);
				uint shift = (59 - num6) % 32;
				rhs.ShiftLeft(shift);
				lhs.ShiftLeft(shift);
				result.ShiftLeft(shift);
				if (ptr != &result)
				{
					BigInteger.Multiply(ref result, 2u, out *ptr);
				}
			}
			bool flag3;
			bool flag4;
			uint num7;
			if (cutoffNumber == -1)
			{
				while (true)
				{
					num7 = BigInteger.HeuristicDivide(ref lhs, ref rhs);
					BigInteger.Add(ref lhs, ref *ptr, out var result5);
					int num8 = BigInteger.Compare(ref lhs, ref result);
					int num9 = BigInteger.Compare(ref result5, ref rhs);
					if (flag)
					{
						flag3 = num8 <= 0;
						flag4 = num9 >= 0;
					}
					else
					{
						flag3 = num8 < 0;
						flag4 = num9 > 0;
					}
					if (flag3 || flag4 || num2 == num4)
					{
						break;
					}
					buffer[num] = (byte)(48 + num7);
					num++;
					lhs.Multiply10();
					result.Multiply10();
					if (ptr != &result)
					{
						BigInteger.Multiply(ref result, 2u, out *ptr);
					}
					num2--;
				}
			}
			else
			{
				if (num2 < num4)
				{
					num7 = BigInteger.HeuristicDivide(ref lhs, ref rhs);
					if (num7 > 5 || (num7 == 5 && !lhs.IsZero()))
					{
						decimalExponent++;
						num7 = 1u;
					}
					buffer[num] = (byte)(48 + num7);
					return (uint)(num + 1);
				}
				flag3 = false;
				flag4 = false;
				while (true)
				{
					num7 = BigInteger.HeuristicDivide(ref lhs, ref rhs);
					if (lhs.IsZero() || num2 <= num4)
					{
						break;
					}
					buffer[num] = (byte)(48 + num7);
					num++;
					lhs.Multiply10();
					num2--;
				}
			}
			bool flag5 = flag3;
			if (flag3 == flag4)
			{
				lhs.ShiftLeft(1u);
				int num10 = BigInteger.Compare(ref lhs, ref rhs);
				flag5 = num10 < 0;
				if (num10 == 0)
				{
					flag5 = (num7 & 1) == 0;
				}
			}
			if (flag5)
			{
				buffer[num] = (byte)(48 + num7);
				num++;
			}
			else if (num7 == 9)
			{
				while (true)
				{
					if (num == 0)
					{
						buffer[num] = 49;
						num++;
						decimalExponent++;
						break;
					}
					num--;
					if (buffer[num] != 57)
					{
						buffer[num]++;
						num++;
						break;
					}
				}
			}
			else
			{
				buffer[num] = (byte)(48 + num7 + 1);
				num++;
			}
			return (uint)num;
		}

		public unsafe static string FormatDecimal(decimal value, ReadOnlySpan<char> format, NumberFormatInfo info)
		{
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			byte* digits2 = stackalloc byte[31];
			NumberBuffer number = new NumberBuffer(NumberBufferKind.Decimal, digits2, 31);
			DecimalToNumber(ref value, ref number);
			char* pointer = stackalloc char[32];
			System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(new Span<char>(pointer, 32));
			if (c != 0)
			{
				NumberToString(ref sb, ref number, c, digits, info);
			}
			else
			{
				NumberToStringFormat(ref sb, ref number, format, info);
			}
			return sb.ToString();
		}

		public unsafe static bool TryFormatDecimal(decimal value, ReadOnlySpan<char> format, NumberFormatInfo info, Span<char> destination, out int charsWritten)
		{
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			byte* digits2 = stackalloc byte[31];
			NumberBuffer number = new NumberBuffer(NumberBufferKind.Decimal, digits2, 31);
			DecimalToNumber(ref value, ref number);
			char* pointer = stackalloc char[32];
			System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(new Span<char>(pointer, 32));
			if (c != 0)
			{
				NumberToString(ref sb, ref number, c, digits, info);
			}
			else
			{
				NumberToStringFormat(ref sb, ref number, format, info);
			}
			return sb.TryCopyTo(destination, out charsWritten);
		}

		internal unsafe static void DecimalToNumber(ref decimal d, ref NumberBuffer number)
		{
			byte* digitsPointer = number.GetDigitsPointer();
			number.DigitsCount = 29;
			number.IsNegative = d.IsNegative();
			byte* bufferEnd = digitsPointer + 29;
			while ((d.Mid() | d.High()) != 0)
			{
				bufferEnd = UInt32ToDecChars(bufferEnd, DecimalEx.DecDivMod1E9(ref d), 9);
			}
			bufferEnd = UInt32ToDecChars(bufferEnd, d.Low(), 0);
			int num = (number.DigitsCount = (int)(digitsPointer + 29 - bufferEnd));
			number.Scale = num - d.Scale();
			byte* digitsPointer2 = number.GetDigitsPointer();
			while (--num >= 0)
			{
				*(digitsPointer2++) = *(bufferEnd++);
			}
			*digitsPointer2 = 0;
		}

		public static string FormatDouble(double value, string format, NumberFormatInfo info)
		{
			Span<char> initialBuffer = stackalloc char[32];
			System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(initialBuffer);
			return FormatDouble(ref sb, value, format.AsSpan(), info) ?? sb.ToString();
		}

		public static bool TryFormatDouble(double value, ReadOnlySpan<char> format, NumberFormatInfo info, Span<char> destination, out int charsWritten)
		{
			Span<char> initialBuffer = stackalloc char[32];
			System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(initialBuffer);
			string text = FormatDouble(ref sb, value, format, info);
			if (text == null)
			{
				return sb.TryCopyTo(destination, out charsWritten);
			}
			return TryCopyTo(text, destination, out charsWritten);
		}

		private static int GetFloatingPointMaxDigitsAndPrecision(char fmt, ref int precision, NumberFormatInfo info, out bool isSignificantDigits)
		{
			if (fmt == '\0')
			{
				isSignificantDigits = true;
				return precision;
			}
			int result = precision;
			switch (fmt)
			{
			case 'C':
			case 'c':
				if (precision == -1)
				{
					precision = info.CurrencyDecimalDigits;
				}
				isSignificantDigits = false;
				break;
			case 'E':
			case 'e':
				if (precision == -1)
				{
					precision = 6;
				}
				precision++;
				isSignificantDigits = true;
				break;
			case 'F':
			case 'N':
			case 'f':
			case 'n':
				if (precision == -1)
				{
					precision = info.NumberDecimalDigits;
				}
				isSignificantDigits = false;
				break;
			case 'G':
			case 'g':
				if (precision == 0)
				{
					precision = -1;
				}
				isSignificantDigits = true;
				break;
			case 'P':
			case 'p':
				if (precision == -1)
				{
					precision = info.PercentDecimalDigits;
				}
				precision += 2;
				isSignificantDigits = false;
				break;
			case 'R':
			case 'r':
				precision = -1;
				isSignificantDigits = true;
				break;
			default:
				throw new FormatException("SR.Argument_BadFormatSpecifier");
			}
			return result;
		}

		private unsafe static string FormatDouble(ref System.Text.ValueStringBuilder sb, double value, ReadOnlySpan<char> format, NumberFormatInfo info)
		{
			if (!FloatEx.IsFinite(value))
			{
				if (double.IsNaN(value))
				{
					return info.NaNSymbol;
				}
				if (!FloatEx.IsNegative(value))
				{
					return info.PositiveInfinitySymbol;
				}
				return info.NegativeInfinitySymbol;
			}
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			byte* digits2 = stackalloc byte[769];
			if (c == '\0')
			{
				digits = 15;
			}
			NumberBuffer number = new NumberBuffer(NumberBufferKind.FloatingPoint, digits2, 769);
			number.IsNegative = FloatEx.IsNegative(value);
			bool isSignificantDigits;
			int nMaxDigits = GetFloatingPointMaxDigitsAndPrecision(c, ref digits, info, out isSignificantDigits);
			if (value != 0.0 && (!isSignificantDigits || !Grisu3.TryRunDouble(value, digits, ref number)))
			{
				Dragon4Double(value, digits, isSignificantDigits, ref number);
			}
			if (c != 0)
			{
				if (digits == -1)
				{
					nMaxDigits = Math.Max(number.DigitsCount, 17);
				}
				NumberToString(ref sb, ref number, c, nMaxDigits, info);
			}
			else
			{
				NumberToStringFormat(ref sb, ref number, format, info);
			}
			return null;
		}

		public static string FormatSingle(float value, string format, NumberFormatInfo info)
		{
			Span<char> initialBuffer = stackalloc char[32];
			System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(initialBuffer);
			return FormatSingle(ref sb, value, format.AsSpan(), info) ?? sb.ToString();
		}

		public static bool TryFormatSingle(float value, ReadOnlySpan<char> format, NumberFormatInfo info, Span<char> destination, out int charsWritten)
		{
			Span<char> initialBuffer = stackalloc char[32];
			System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(initialBuffer);
			string text = FormatSingle(ref sb, value, format, info);
			if (text == null)
			{
				return sb.TryCopyTo(destination, out charsWritten);
			}
			return TryCopyTo(text, destination, out charsWritten);
		}

		private unsafe static string FormatSingle(ref System.Text.ValueStringBuilder sb, float value, ReadOnlySpan<char> format, NumberFormatInfo info)
		{
			if (!FloatEx.IsFinite(value))
			{
				if (float.IsNaN(value))
				{
					return info.NaNSymbol;
				}
				if (!FloatEx.IsNegative(value))
				{
					return info.PositiveInfinitySymbol;
				}
				return info.NegativeInfinitySymbol;
			}
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			byte* digits2 = stackalloc byte[114];
			if (c == '\0')
			{
				digits = 7;
			}
			NumberBuffer number = new NumberBuffer(NumberBufferKind.FloatingPoint, digits2, 114);
			number.IsNegative = FloatEx.IsNegative(value);
			bool isSignificantDigits;
			int nMaxDigits = GetFloatingPointMaxDigitsAndPrecision(c, ref digits, info, out isSignificantDigits);
			if (value != 0f && (!isSignificantDigits || !Grisu3.TryRunSingle(value, digits, ref number)))
			{
				Dragon4Single(value, digits, isSignificantDigits, ref number);
			}
			if (c != 0)
			{
				if (digits == -1)
				{
					nMaxDigits = Math.Max(number.DigitsCount, 9);
				}
				NumberToString(ref sb, ref number, c, nMaxDigits, info);
			}
			else
			{
				NumberToStringFormat(ref sb, ref number, format, info);
			}
			return null;
		}

		private static bool TryCopyTo(string source, Span<char> destination, out int charsWritten)
		{
			if (source.AsSpan().TryCopyTo(destination))
			{
				charsWritten = source.Length;
				return true;
			}
			charsWritten = 0;
			return false;
		}

		public unsafe static string FormatInt32(int value, ReadOnlySpan<char> format, IFormatProvider provider)
		{
			if (value >= 0 && format.Length == 0)
			{
				return UInt32ToDecStr((uint)value, -1);
			}
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			char c2 = (char)(c & 0xFFDF);
			if (c2 != 'G' || digits >= 1)
			{
				switch (c2)
				{
				case 'D':
					break;
				case 'X':
					return Int32ToHexStr(value, (char)(c - 33), digits);
				default:
				{
					NumberFormatInfo instance = NumberFormatInfo.GetInstance(provider);
					byte* digits2 = stackalloc byte[11];
					NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits2, 11);
					Int32ToNumber(value, ref number);
					char* pointer = stackalloc char[32];
					System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(new Span<char>(pointer, 32));
					if (c != 0)
					{
						NumberToString(ref sb, ref number, c, digits, instance);
					}
					else
					{
						NumberToStringFormat(ref sb, ref number, format, instance);
					}
					return sb.ToString();
				}
				}
			}
			if (value < 0)
			{
				return NegativeInt32ToDecStr(value, digits, NumberFormatInfo.GetInstance(provider).NegativeSign);
			}
			return UInt32ToDecStr((uint)value, digits);
		}

		public unsafe static bool TryFormatInt32(int value, ReadOnlySpan<char> format, IFormatProvider provider, Span<char> destination, out int charsWritten)
		{
			if (value >= 0 && format.Length == 0)
			{
				return TryUInt32ToDecStr((uint)value, -1, destination, out charsWritten);
			}
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			char c2 = (char)(c & 0xFFDF);
			if (c2 != 'G' || digits >= 1)
			{
				switch (c2)
				{
				case 'D':
					break;
				case 'X':
					return TryInt32ToHexStr(value, (char)(c - 33), digits, destination, out charsWritten);
				default:
				{
					NumberFormatInfo instance = NumberFormatInfo.GetInstance(provider);
					byte* digits2 = stackalloc byte[11];
					NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits2, 11);
					Int32ToNumber(value, ref number);
					char* pointer = stackalloc char[32];
					System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(new Span<char>(pointer, 32));
					if (c != 0)
					{
						NumberToString(ref sb, ref number, c, digits, instance);
					}
					else
					{
						NumberToStringFormat(ref sb, ref number, format, instance);
					}
					return sb.TryCopyTo(destination, out charsWritten);
				}
				}
			}
			if (value < 0)
			{
				return TryNegativeInt32ToDecStr(value, digits, NumberFormatInfo.GetInstance(provider).NegativeSign, destination, out charsWritten);
			}
			return TryUInt32ToDecStr((uint)value, digits, destination, out charsWritten);
		}

		public unsafe static string FormatUInt32(uint value, ReadOnlySpan<char> format, IFormatProvider provider)
		{
			if (format.Length == 0)
			{
				return UInt32ToDecStr(value, -1);
			}
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			char c2 = (char)(c & 0xFFDF);
			if (c2 != 'G' || digits >= 1)
			{
				switch (c2)
				{
				case 'D':
					break;
				case 'X':
					return Int32ToHexStr((int)value, (char)(c - 33), digits);
				default:
				{
					NumberFormatInfo instance = NumberFormatInfo.GetInstance(provider);
					byte* digits2 = stackalloc byte[11];
					NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits2, 11);
					UInt32ToNumber(value, ref number);
					char* pointer = stackalloc char[32];
					System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(new Span<char>(pointer, 32));
					if (c != 0)
					{
						NumberToString(ref sb, ref number, c, digits, instance);
					}
					else
					{
						NumberToStringFormat(ref sb, ref number, format, instance);
					}
					return sb.ToString();
				}
				}
			}
			return UInt32ToDecStr(value, digits);
		}

		public unsafe static bool TryFormatUInt32(uint value, ReadOnlySpan<char> format, IFormatProvider provider, Span<char> destination, out int charsWritten)
		{
			if (format.Length == 0)
			{
				return TryUInt32ToDecStr(value, -1, destination, out charsWritten);
			}
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			char c2 = (char)(c & 0xFFDF);
			if (c2 != 'G' || digits >= 1)
			{
				switch (c2)
				{
				case 'D':
					break;
				case 'X':
					return TryInt32ToHexStr((int)value, (char)(c - 33), digits, destination, out charsWritten);
				default:
				{
					NumberFormatInfo instance = NumberFormatInfo.GetInstance(provider);
					byte* digits2 = stackalloc byte[11];
					NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits2, 11);
					UInt32ToNumber(value, ref number);
					char* pointer = stackalloc char[32];
					System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(new Span<char>(pointer, 32));
					if (c != 0)
					{
						NumberToString(ref sb, ref number, c, digits, instance);
					}
					else
					{
						NumberToStringFormat(ref sb, ref number, format, instance);
					}
					return sb.TryCopyTo(destination, out charsWritten);
				}
				}
			}
			return TryUInt32ToDecStr(value, digits, destination, out charsWritten);
		}

		public unsafe static string FormatInt64(long value, ReadOnlySpan<char> format, IFormatProvider provider)
		{
			if (value >= 0 && format.Length == 0)
			{
				return UInt64ToDecStr((ulong)value, -1);
			}
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			char c2 = (char)(c & 0xFFDF);
			if (c2 != 'G' || digits >= 1)
			{
				switch (c2)
				{
				case 'D':
					break;
				case 'X':
					return Int64ToHexStr(value, (char)(c - 33), digits);
				default:
				{
					NumberFormatInfo instance = NumberFormatInfo.GetInstance(provider);
					byte* digits2 = stackalloc byte[20];
					NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits2, 20);
					Int64ToNumber(value, ref number);
					char* pointer = stackalloc char[32];
					System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(new Span<char>(pointer, 32));
					if (c != 0)
					{
						NumberToString(ref sb, ref number, c, digits, instance);
					}
					else
					{
						NumberToStringFormat(ref sb, ref number, format, instance);
					}
					return sb.ToString();
				}
				}
			}
			if (value < 0)
			{
				return NegativeInt64ToDecStr(value, digits, NumberFormatInfo.GetInstance(provider).NegativeSign);
			}
			return UInt64ToDecStr((ulong)value, digits);
		}

		public unsafe static bool TryFormatInt64(long value, ReadOnlySpan<char> format, IFormatProvider provider, Span<char> destination, out int charsWritten)
		{
			if (value >= 0 && format.Length == 0)
			{
				return TryUInt64ToDecStr((ulong)value, -1, destination, out charsWritten);
			}
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			char c2 = (char)(c & 0xFFDF);
			if (c2 != 'G' || digits >= 1)
			{
				switch (c2)
				{
				case 'D':
					break;
				case 'X':
					return TryInt64ToHexStr(value, (char)(c - 33), digits, destination, out charsWritten);
				default:
				{
					NumberFormatInfo instance = NumberFormatInfo.GetInstance(provider);
					byte* digits2 = stackalloc byte[20];
					NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits2, 20);
					Int64ToNumber(value, ref number);
					char* pointer = stackalloc char[32];
					System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(new Span<char>(pointer, 32));
					if (c != 0)
					{
						NumberToString(ref sb, ref number, c, digits, instance);
					}
					else
					{
						NumberToStringFormat(ref sb, ref number, format, instance);
					}
					return sb.TryCopyTo(destination, out charsWritten);
				}
				}
			}
			if (value < 0)
			{
				return TryNegativeInt64ToDecStr(value, digits, NumberFormatInfo.GetInstance(provider).NegativeSign, destination, out charsWritten);
			}
			return TryUInt64ToDecStr((ulong)value, digits, destination, out charsWritten);
		}

		public unsafe static string FormatUInt64(ulong value, ReadOnlySpan<char> format, IFormatProvider provider)
		{
			if (format.Length == 0)
			{
				return UInt64ToDecStr(value, -1);
			}
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			char c2 = (char)(c & 0xFFDF);
			if (c2 != 'G' || digits >= 1)
			{
				switch (c2)
				{
				case 'D':
					break;
				case 'X':
					return Int64ToHexStr((long)value, (char)(c - 33), digits);
				default:
				{
					NumberFormatInfo instance = NumberFormatInfo.GetInstance(provider);
					byte* digits2 = stackalloc byte[21];
					NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits2, 21);
					UInt64ToNumber(value, ref number);
					char* pointer = stackalloc char[32];
					System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(new Span<char>(pointer, 32));
					if (c != 0)
					{
						NumberToString(ref sb, ref number, c, digits, instance);
					}
					else
					{
						NumberToStringFormat(ref sb, ref number, format, instance);
					}
					return sb.ToString();
				}
				}
			}
			return UInt64ToDecStr(value, digits);
		}

		public unsafe static bool TryFormatUInt64(ulong value, ReadOnlySpan<char> format, IFormatProvider provider, Span<char> destination, out int charsWritten)
		{
			if (format.Length == 0)
			{
				return TryUInt64ToDecStr(value, -1, destination, out charsWritten);
			}
			int digits;
			char c = ParseFormatSpecifier(format, out digits);
			char c2 = (char)(c & 0xFFDF);
			if (c2 != 'G' || digits >= 1)
			{
				switch (c2)
				{
				case 'D':
					break;
				case 'X':
					return TryInt64ToHexStr((long)value, (char)(c - 33), digits, destination, out charsWritten);
				default:
				{
					NumberFormatInfo instance = NumberFormatInfo.GetInstance(provider);
					byte* digits2 = stackalloc byte[21];
					NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits2, 21);
					UInt64ToNumber(value, ref number);
					char* pointer = stackalloc char[32];
					System.Text.ValueStringBuilder sb = new System.Text.ValueStringBuilder(new Span<char>(pointer, 32));
					if (c != 0)
					{
						NumberToString(ref sb, ref number, c, digits, instance);
					}
					else
					{
						NumberToStringFormat(ref sb, ref number, format, instance);
					}
					return sb.TryCopyTo(destination, out charsWritten);
				}
				}
			}
			return TryUInt64ToDecStr(value, digits, destination, out charsWritten);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static void Int32ToNumber(int value, ref NumberBuffer number)
		{
			number.DigitsCount = 10;
			if (value >= 0)
			{
				number.IsNegative = false;
			}
			else
			{
				number.IsNegative = true;
				value = -value;
			}
			byte* digitsPointer = number.GetDigitsPointer();
			byte* ptr = UInt32ToDecChars(digitsPointer + 10, (uint)value, 0);
			int num = (number.Scale = (number.DigitsCount = (int)(digitsPointer + 10 - ptr)));
			byte* digitsPointer2 = number.GetDigitsPointer();
			while (--num >= 0)
			{
				*(digitsPointer2++) = *(ptr++);
			}
			*digitsPointer2 = 0;
		}

		private unsafe static string NegativeInt32ToDecStr(int value, int digits, string sNegative)
		{
			if (digits < 1)
			{
				digits = 1;
			}
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountDigits((uint)(-value))) + sNegative.Length;
			string text = FastAllocateString(num);
			fixed (char* ptr = text)
			{
				char* ptr2 = UInt32ToDecChars(ptr + num, (uint)(-value), digits);
				for (int num2 = sNegative.Length - 1; num2 >= 0; num2--)
				{
					*(--ptr2) = sNegative[num2];
				}
			}
			return text;
		}

		private unsafe static bool TryNegativeInt32ToDecStr(int value, int digits, string sNegative, Span<char> destination, out int charsWritten)
		{
			if (digits < 1)
			{
				digits = 1;
			}
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountDigits((uint)(-value))) + sNegative.Length;
			if (num > destination.Length)
			{
				charsWritten = 0;
				return false;
			}
			charsWritten = num;
			fixed (char* reference = &MemoryMarshal.GetReference(destination))
			{
				char* ptr = UInt32ToDecChars(reference + num, (uint)(-value), digits);
				for (int num2 = sNegative.Length - 1; num2 >= 0; num2--)
				{
					*(--ptr) = sNegative[num2];
				}
			}
			return true;
		}

		private unsafe static string Int32ToHexStr(int value, char hexBase, int digits)
		{
			if (digits < 1)
			{
				digits = 1;
			}
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountHexDigits((uint)value));
			string text = FastAllocateString(num);
			fixed (char* ptr = text)
			{
				Int32ToHexChars(ptr + num, (uint)value, hexBase, digits);
			}
			return text;
		}

		private unsafe static bool TryInt32ToHexStr(int value, char hexBase, int digits, Span<char> destination, out int charsWritten)
		{
			if (digits < 1)
			{
				digits = 1;
			}
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountHexDigits((uint)value));
			if (num > destination.Length)
			{
				charsWritten = 0;
				return false;
			}
			charsWritten = num;
			fixed (char* reference = &MemoryMarshal.GetReference(destination))
			{
				Int32ToHexChars(reference + num, (uint)value, hexBase, digits);
			}
			return true;
		}

		private unsafe static char* Int32ToHexChars(char* buffer, uint value, int hexBase, int digits)
		{
			while (--digits >= 0 || value != 0)
			{
				byte b = (byte)(value & 0xF);
				*(--buffer) = (char)(b + ((b < 10) ? 48 : hexBase));
				value >>= 4;
			}
			return buffer;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static void UInt32ToNumber(uint value, ref NumberBuffer number)
		{
			number.DigitsCount = 10;
			number.IsNegative = false;
			byte* digitsPointer = number.GetDigitsPointer();
			byte* ptr = UInt32ToDecChars(digitsPointer + 10, value, 0);
			int num = (number.Scale = (number.DigitsCount = (int)(digitsPointer + 10 - ptr)));
			byte* digitsPointer2 = number.GetDigitsPointer();
			while (--num >= 0)
			{
				*(digitsPointer2++) = *(ptr++);
			}
			*digitsPointer2 = 0;
		}

		internal unsafe static byte* UInt32ToDecChars(byte* bufferEnd, uint value, int digits)
		{
			while (--digits >= 0 || value != 0)
			{
				value = MathEx.DivRem(value, 10u, out var result);
				*(--bufferEnd) = (byte)(result + 48);
			}
			return bufferEnd;
		}

		internal unsafe static char* UInt32ToDecChars(char* bufferEnd, uint value, int digits)
		{
			while (--digits >= 0 || value != 0)
			{
				value = MathEx.DivRem(value, 10u, out var result);
				*(--bufferEnd) = (char)(result + 48);
			}
			return bufferEnd;
		}

		internal unsafe static string UInt32ToDecStr(uint value, int digits)
		{
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountDigits(value));
			if (num == 1)
			{
				return s_singleDigitStringCache[value];
			}
			string text = FastAllocateString(num);
			fixed (char* ptr = text)
			{
				char* ptr2 = ptr + num;
				if (digits <= 1)
				{
					do
					{
						value = MathEx.DivRem(value, 10u, out var result);
						*(--ptr2) = (char)(result + 48);
					}
					while (value != 0);
				}
				else
				{
					ptr2 = UInt32ToDecChars(ptr2, value, digits);
				}
			}
			return text;
		}

		private unsafe static bool TryUInt32ToDecStr(uint value, int digits, Span<char> destination, out int charsWritten)
		{
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountDigits(value));
			if (num > destination.Length)
			{
				charsWritten = 0;
				return false;
			}
			charsWritten = num;
			fixed (char* reference = &MemoryMarshal.GetReference(destination))
			{
				char* ptr = reference + num;
				if (digits <= 1)
				{
					do
					{
						value = MathEx.DivRem(value, 10u, out var result);
						*(--ptr) = (char)(result + 48);
					}
					while (value != 0);
				}
				else
				{
					ptr = UInt32ToDecChars(ptr, value, digits);
				}
			}
			return true;
		}

		private unsafe static void Int64ToNumber(long input, ref NumberBuffer number)
		{
			ulong value = (ulong)input;
			number.IsNegative = input < 0;
			number.DigitsCount = 19;
			if (number.IsNegative)
			{
				value = (ulong)(-input);
			}
			byte* digitsPointer = number.GetDigitsPointer();
			byte* bufferEnd = digitsPointer + 19;
			while (High32(value) != 0)
			{
				bufferEnd = UInt32ToDecChars(bufferEnd, Int64DivMod1E9(ref value), 9);
			}
			bufferEnd = UInt32ToDecChars(bufferEnd, Low32(value), 0);
			int num = (number.Scale = (number.DigitsCount = (int)(digitsPointer + 19 - bufferEnd)));
			byte* digitsPointer2 = number.GetDigitsPointer();
			while (--num >= 0)
			{
				*(digitsPointer2++) = *(bufferEnd++);
			}
			*digitsPointer2 = 0;
		}

		private unsafe static string NegativeInt64ToDecStr(long input, int digits, string sNegative)
		{
			if (digits < 1)
			{
				digits = 1;
			}
			ulong value = (ulong)(-input);
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountDigits(value)) + sNegative.Length;
			string text = FastAllocateString(num);
			fixed (char* ptr = text)
			{
				char* bufferEnd = ptr + num;
				while (High32(value) != 0)
				{
					bufferEnd = UInt32ToDecChars(bufferEnd, Int64DivMod1E9(ref value), 9);
					digits -= 9;
				}
				bufferEnd = UInt32ToDecChars(bufferEnd, Low32(value), digits);
				for (int num2 = sNegative.Length - 1; num2 >= 0; num2--)
				{
					*(--bufferEnd) = sNegative[num2];
				}
			}
			return text;
		}

		private unsafe static bool TryNegativeInt64ToDecStr(long input, int digits, string sNegative, Span<char> destination, out int charsWritten)
		{
			if (digits < 1)
			{
				digits = 1;
			}
			ulong value = (ulong)(-input);
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountDigits((ulong)(-input))) + sNegative.Length;
			if (num > destination.Length)
			{
				charsWritten = 0;
				return false;
			}
			charsWritten = num;
			fixed (char* reference = &MemoryMarshal.GetReference(destination))
			{
				char* bufferEnd = reference + num;
				while (High32(value) != 0)
				{
					bufferEnd = UInt32ToDecChars(bufferEnd, Int64DivMod1E9(ref value), 9);
					digits -= 9;
				}
				bufferEnd = UInt32ToDecChars(bufferEnd, Low32(value), digits);
				for (int num2 = sNegative.Length - 1; num2 >= 0; num2--)
				{
					*(--bufferEnd) = sNegative[num2];
				}
			}
			return true;
		}

		private unsafe static string Int64ToHexStr(long value, char hexBase, int digits)
		{
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountHexDigits((ulong)value));
			string text = FastAllocateString(num);
			fixed (char* ptr = text)
			{
				char* buffer = ptr + num;
				if (High32((ulong)value) != 0)
				{
					buffer = Int32ToHexChars(buffer, Low32((ulong)value), hexBase, 8);
					buffer = Int32ToHexChars(buffer, High32((ulong)value), hexBase, digits - 8);
				}
				else
				{
					buffer = Int32ToHexChars(buffer, Low32((ulong)value), hexBase, Math.Max(digits, 1));
				}
			}
			return text;
		}

		private unsafe static bool TryInt64ToHexStr(long value, char hexBase, int digits, Span<char> destination, out int charsWritten)
		{
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountHexDigits((ulong)value));
			if (num > destination.Length)
			{
				charsWritten = 0;
				return false;
			}
			charsWritten = num;
			fixed (char* reference = &MemoryMarshal.GetReference(destination))
			{
				char* buffer = reference + num;
				if (High32((ulong)value) != 0)
				{
					buffer = Int32ToHexChars(buffer, Low32((ulong)value), hexBase, 8);
					buffer = Int32ToHexChars(buffer, High32((ulong)value), hexBase, digits - 8);
				}
				else
				{
					buffer = Int32ToHexChars(buffer, Low32((ulong)value), hexBase, Math.Max(digits, 1));
				}
			}
			return true;
		}

		private unsafe static void UInt64ToNumber(ulong value, ref NumberBuffer number)
		{
			number.DigitsCount = 20;
			number.IsNegative = false;
			byte* digitsPointer = number.GetDigitsPointer();
			byte* bufferEnd = digitsPointer + 20;
			while (High32(value) != 0)
			{
				bufferEnd = UInt32ToDecChars(bufferEnd, Int64DivMod1E9(ref value), 9);
			}
			bufferEnd = UInt32ToDecChars(bufferEnd, Low32(value), 0);
			int num = (number.Scale = (number.DigitsCount = (int)(digitsPointer + 20 - bufferEnd)));
			byte* digitsPointer2 = number.GetDigitsPointer();
			while (--num >= 0)
			{
				*(digitsPointer2++) = *(bufferEnd++);
			}
			*digitsPointer2 = 0;
		}

		internal unsafe static string UInt64ToDecStr(ulong value, int digits)
		{
			if (digits < 1)
			{
				digits = 1;
			}
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountDigits(value));
			if (num == 1)
			{
				return s_singleDigitStringCache[value];
			}
			string text = FastAllocateString(num);
			fixed (char* ptr = text)
			{
				char* bufferEnd = ptr + num;
				while (High32(value) != 0)
				{
					bufferEnd = UInt32ToDecChars(bufferEnd, Int64DivMod1E9(ref value), 9);
					digits -= 9;
				}
				bufferEnd = UInt32ToDecChars(bufferEnd, Low32(value), digits);
			}
			return text;
		}

		private unsafe static bool TryUInt64ToDecStr(ulong value, int digits, Span<char> destination, out int charsWritten)
		{
			if (digits < 1)
			{
				digits = 1;
			}
			int num = Math.Max(digits, System.Buffers.Text.FormattingHelpers.CountDigits(value));
			if (num > destination.Length)
			{
				charsWritten = 0;
				return false;
			}
			charsWritten = num;
			fixed (char* reference = &MemoryMarshal.GetReference(destination))
			{
				char* bufferEnd = reference + num;
				while (High32(value) != 0)
				{
					bufferEnd = UInt32ToDecChars(bufferEnd, Int64DivMod1E9(ref value), 9);
					digits -= 9;
				}
				bufferEnd = UInt32ToDecChars(bufferEnd, Low32(value), digits);
			}
			return true;
		}

		internal static char ParseFormatSpecifier(ReadOnlySpan<char> format, out int digits)
		{
			char c = '\0';
			if (format.Length > 0)
			{
				c = format[0];
				if ((uint)(c - 65) <= 25u || (uint)(c - 97) <= 25u)
				{
					if (format.Length == 1)
					{
						digits = -1;
						return c;
					}
					if (format.Length == 2)
					{
						int num = format[1] - 48;
						if ((uint)num < 10u)
						{
							digits = num;
							return c;
						}
					}
					else if (format.Length == 3)
					{
						int num2 = format[1] - 48;
						int num3 = format[2] - 48;
						if ((uint)num2 < 10u && (uint)num3 < 10u)
						{
							digits = num2 * 10 + num3;
							return c;
						}
					}
					int num4 = 0;
					int num5 = 1;
					while (num5 < format.Length && (uint)(format[num5] - 48) < 10u && num4 < 10)
					{
						num4 = num4 * 10 + format[num5++] - 48;
					}
					if (num5 == format.Length || format[num5] == '\0')
					{
						digits = num4;
						return c;
					}
				}
			}
			digits = -1;
			if (format.Length != 0 && c != 0)
			{
				return '\0';
			}
			return 'G';
		}

		internal static void NumberToString(ref System.Text.ValueStringBuilder sb, ref NumberBuffer number, char format, int nMaxDigits, NumberFormatInfo info)
		{
			bool isCorrectlyRounded = number.Kind == NumberBufferKind.FloatingPoint;
			bool bSuppressScientific;
			switch (format)
			{
			case 'C':
			case 'c':
				if (nMaxDigits < 0)
				{
					nMaxDigits = info.CurrencyDecimalDigits;
				}
				RoundNumber(ref number, number.Scale + nMaxDigits, isCorrectlyRounded);
				FormatCurrency(ref sb, ref number, nMaxDigits, info);
				return;
			case 'F':
			case 'f':
				if (nMaxDigits < 0)
				{
					nMaxDigits = info.NumberDecimalDigits;
				}
				RoundNumber(ref number, number.Scale + nMaxDigits, isCorrectlyRounded);
				if (number.IsNegative)
				{
					sb.Append(info.NegativeSign);
				}
				FormatFixed(ref sb, ref number, nMaxDigits, null, info.NumberDecimalSeparator, null);
				return;
			case 'N':
			case 'n':
				if (nMaxDigits < 0)
				{
					nMaxDigits = info.NumberDecimalDigits;
				}
				RoundNumber(ref number, number.Scale + nMaxDigits, isCorrectlyRounded);
				FormatNumber(ref sb, ref number, nMaxDigits, info);
				return;
			case 'E':
			case 'e':
				if (nMaxDigits < 0)
				{
					nMaxDigits = 6;
				}
				nMaxDigits++;
				RoundNumber(ref number, nMaxDigits, isCorrectlyRounded);
				if (number.IsNegative)
				{
					sb.Append(info.NegativeSign);
				}
				FormatScientific(ref sb, ref number, nMaxDigits, info, format);
				return;
			case 'G':
			case 'g':
				bSuppressScientific = false;
				if (nMaxDigits < 1)
				{
					if (number.Kind == NumberBufferKind.Decimal && nMaxDigits == -1)
					{
						bSuppressScientific = true;
						if (number.Digits[0] != 0)
						{
							goto IL_0189;
						}
						goto IL_019e;
					}
					nMaxDigits = number.DigitsCount;
				}
				RoundNumber(ref number, nMaxDigits, isCorrectlyRounded);
				goto IL_0189;
			case 'P':
			case 'p':
				if (nMaxDigits < 0)
				{
					nMaxDigits = info.PercentDecimalDigits;
				}
				number.Scale += 2;
				RoundNumber(ref number, number.Scale + nMaxDigits, isCorrectlyRounded);
				FormatPercent(ref sb, ref number, nMaxDigits, info);
				return;
			case 'R':
			case 'r':
				{
					if (number.Kind != NumberBufferKind.FloatingPoint)
					{
						break;
					}
					format = (char)(format - 11);
					goto case 'G';
				}
				IL_0189:
				if (number.IsNegative)
				{
					sb.Append(info.NegativeSign);
				}
				goto IL_019e;
				IL_019e:
				FormatGeneral(ref sb, ref number, nMaxDigits, info, (char)(format - 2), bSuppressScientific);
				return;
			}
			throw new FormatException("SR.Argument_BadFormatSpecifier");
		}

		internal unsafe static void NumberToStringFormat(ref System.Text.ValueStringBuilder sb, ref NumberBuffer number, ReadOnlySpan<char> format, NumberFormatInfo info)
		{
			int num = 0;
			byte* digitsPointer = number.GetDigitsPointer();
			int num2 = FindSection(format, (*digitsPointer == 0) ? 2 : (number.IsNegative ? 1 : 0));
			int num3;
			int num4;
			bool flag;
			bool flag2;
			int num5;
			int num6;
			int num9;
			while (true)
			{
				num3 = 0;
				num4 = -1;
				num5 = int.MaxValue;
				num6 = 0;
				flag = false;
				int num7 = -1;
				flag2 = false;
				int num8 = 0;
				num9 = num2;
				fixed (char* reference = &MemoryMarshal.GetReference(format))
				{
					char c;
					while (num9 < format.Length && (c = reference[num9++]) != 0)
					{
						switch (c)
						{
						case ';':
							break;
						case '#':
							num3++;
							continue;
						case '0':
							if (num5 == int.MaxValue)
							{
								num5 = num3;
							}
							num3++;
							num6 = num3;
							continue;
						case '.':
							if (num4 < 0)
							{
								num4 = num3;
							}
							continue;
						case ',':
							if (num3 <= 0 || num4 >= 0)
							{
								continue;
							}
							if (num7 >= 0)
							{
								if (num7 == num3)
								{
									num++;
									continue;
								}
								flag2 = true;
							}
							num7 = num3;
							num = 1;
							continue;
						case '%':
							num8 += 2;
							continue;
						case '':
							num8 += 3;
							continue;
						case '"':
						case '\'':
							while (num9 < format.Length && reference[num9] != 0 && reference[num9++] != c)
							{
							}
							continue;
						case '\\':
							if (num9 < format.Length && reference[num9] != 0)
							{
								num9++;
							}
							continue;
						case 'E':
						case 'e':
							if ((num9 < format.Length && reference[num9] == '0') || (num9 + 1 < format.Length && (reference[num9] == '+' || reference[num9] == '-') && reference[num9 + 1] == '0'))
							{
								while (++num9 < format.Length && reference[num9] == '0')
								{
								}
								flag = true;
							}
							continue;
						default:
							continue;
						}
						break;
					}
				}
				if (num4 < 0)
				{
					num4 = num3;
				}
				if (num7 >= 0)
				{
					if (num7 == num4)
					{
						num8 -= num * 3;
					}
					else
					{
						flag2 = true;
					}
				}
				if (*digitsPointer != 0)
				{
					number.Scale += num8;
					int pos = (flag ? num3 : (number.Scale + num3 - num4));
					RoundNumber(ref number, pos, isCorrectlyRounded: false);
					if (*digitsPointer != 0)
					{
						break;
					}
					num9 = FindSection(format, 2);
					if (num9 == num2)
					{
						break;
					}
					num2 = num9;
					continue;
				}
				if (number.Kind != NumberBufferKind.FloatingPoint)
				{
					number.IsNegative = false;
				}
				number.Scale = 0;
				break;
			}
			num5 = ((num5 < num4) ? (num4 - num5) : 0);
			num6 = ((num6 > num4) ? (num4 - num6) : 0);
			int num10;
			int num11;
			if (flag)
			{
				num10 = num4;
				num11 = 0;
			}
			else
			{
				num10 = ((number.Scale > num4) ? number.Scale : num4);
				num11 = number.Scale - num4;
			}
			num9 = num2;
			Span<int> span = stackalloc int[4];
			int num12 = -1;
			if (flag2 && info.NumberGroupSeparator.Length > 0)
			{
				int[] numberGroupSizes = info.NumberGroupSizes;
				int num13 = 0;
				int i = 0;
				int num14 = numberGroupSizes.Length;
				if (num14 != 0)
				{
					i = numberGroupSizes[num13];
				}
				int num15 = i;
				int num16 = num10 + ((num11 < 0) ? num11 : 0);
				for (int num17 = ((num5 > num16) ? num5 : num16); num17 > i; i += num15)
				{
					if (num15 == 0)
					{
						break;
					}
					num12++;
					if (num12 >= span.Length)
					{
						int[] array = new int[span.Length * 2];
						span.CopyTo(array);
						span = array;
					}
					span[num12] = i;
					if (num13 < num14 - 1)
					{
						num13++;
						num15 = numberGroupSizes[num13];
					}
				}
			}
			if (number.IsNegative && num2 == 0 && number.Scale != 0)
			{
				sb.Append(info.NegativeSign);
			}
			bool flag3 = false;
			fixed (char* reference2 = &MemoryMarshal.GetReference(format))
			{
				byte* ptr = digitsPointer;
				char c;
				while (num9 < format.Length && (c = reference2[num9++]) != 0 && c != ';')
				{
					if (num11 > 0 && (c == '#' || c == '.' || c == '0'))
					{
						while (num11 > 0)
						{
							sb.Append((char)((*ptr != 0) ? (*(ptr++)) : 48));
							if (flag2 && num10 > 1 && num12 >= 0 && num10 == span[num12] + 1)
							{
								sb.Append(info.NumberGroupSeparator);
								num12--;
							}
							num10--;
							num11--;
						}
					}
					switch (c)
					{
					case '#':
					case '0':
						if (num11 < 0)
						{
							num11++;
							c = ((num10 <= num5) ? '0' : '\0');
						}
						else
						{
							c = ((*ptr != 0) ? ((char)(*(ptr++))) : ((num10 > num6) ? '0' : '\0'));
						}
						if (c != 0)
						{
							sb.Append(c);
							if (flag2 && num10 > 1 && num12 >= 0 && num10 == span[num12] + 1)
							{
								sb.Append(info.NumberGroupSeparator);
								num12--;
							}
						}
						num10--;
						break;
					case '.':
						if (!(num10 != 0 || flag3) && (num6 < 0 || (num4 < num3 && *ptr != 0)))
						{
							sb.Append(info.NumberDecimalSeparator);
							flag3 = true;
						}
						break;
					case '':
						sb.Append(info.PerMilleSymbol);
						break;
					case '%':
						sb.Append(info.PercentSymbol);
						break;
					case '"':
					case '\'':
						while (num9 < format.Length && reference2[num9] != 0 && reference2[num9] != c)
						{
							sb.Append(reference2[num9++]);
						}
						if (num9 < format.Length && reference2[num9] != 0)
						{
							num9++;
						}
						break;
					case '\\':
						if (num9 < format.Length && reference2[num9] != 0)
						{
							sb.Append(reference2[num9++]);
						}
						break;
					case 'E':
					case 'e':
					{
						bool positiveSign = false;
						int num18 = 0;
						if (flag)
						{
							if (num9 < format.Length && reference2[num9] == '0')
							{
								num18++;
							}
							else if (num9 + 1 < format.Length && reference2[num9] == '+' && reference2[num9 + 1] == '0')
							{
								positiveSign = true;
							}
							else if (num9 + 1 >= format.Length || reference2[num9] != '-' || reference2[num9 + 1] != '0')
							{
								sb.Append(c);
								break;
							}
							while (++num9 < format.Length && reference2[num9] == '0')
							{
								num18++;
							}
							if (num18 > 10)
							{
								num18 = 10;
							}
							int value = ((*digitsPointer != 0) ? (number.Scale - num4) : 0);
							FormatExponent(ref sb, info, value, c, num18, positiveSign);
							flag = false;
							break;
						}
						sb.Append(c);
						if (num9 < format.Length)
						{
							if (reference2[num9] == '+' || reference2[num9] == '-')
							{
								sb.Append(reference2[num9++]);
							}
							while (num9 < format.Length && reference2[num9] == '0')
							{
								sb.Append(reference2[num9++]);
							}
						}
						break;
					}
					default:
						sb.Append(c);
						break;
					case ',':
						break;
					}
				}
			}
			if (number.IsNegative && num2 == 0 && number.Scale == 0 && sb.Length > 0)
			{
				sb.Insert(0, info.NegativeSign);
			}
		}

		private static void FormatCurrency(ref System.Text.ValueStringBuilder sb, ref NumberBuffer number, int nMaxDigits, NumberFormatInfo info)
		{
			string text = (number.IsNegative ? s_negCurrencyFormats[info.CurrencyNegativePattern] : s_posCurrencyFormats[info.CurrencyPositivePattern]);
			foreach (char c in text)
			{
				switch (c)
				{
				case '#':
					FormatFixed(ref sb, ref number, nMaxDigits, info.CurrencyGroupSizes, info.CurrencyDecimalSeparator, info.CurrencyGroupSeparator);
					break;
				case '-':
					sb.Append(info.NegativeSign);
					break;
				case '$':
					sb.Append(info.CurrencySymbol);
					break;
				default:
					sb.Append(c);
					break;
				}
			}
		}

		private unsafe static void FormatFixed(ref System.Text.ValueStringBuilder sb, ref NumberBuffer number, int nMaxDigits, int[] groupDigits, string sDecimal, string sGroup)
		{
			int num = number.Scale;
			byte* ptr = number.GetDigitsPointer();
			if (num > 0)
			{
				if (groupDigits != null)
				{
					int num2 = 0;
					int num3 = num;
					int num4 = 0;
					if (groupDigits.Length != 0)
					{
						int num5 = groupDigits[num2];
						while (num > num5 && groupDigits[num2] != 0)
						{
							num3 += sGroup.Length;
							if (num2 < groupDigits.Length - 1)
							{
								num2++;
							}
							num5 += groupDigits[num2];
							if (num5 < 0 || num3 < 0)
							{
								throw new ArgumentOutOfRangeException();
							}
						}
						num4 = ((num5 != 0) ? groupDigits[0] : 0);
					}
					num2 = 0;
					int num6 = 0;
					int digitsCount = number.DigitsCount;
					int num7 = ((num < digitsCount) ? num : digitsCount);
					fixed (char* reference = &MemoryMarshal.GetReference(sb.AppendSpan(num3)))
					{
						char* ptr2 = reference + num3 - 1;
						for (int num8 = num - 1; num8 >= 0; num8--)
						{
							*(ptr2--) = (char)((num8 < num7) ? ptr[num8] : 48);
							if (num4 > 0)
							{
								num6++;
								if (num6 == num4 && num8 != 0)
								{
									for (int num9 = sGroup.Length - 1; num9 >= 0; num9--)
									{
										*(ptr2--) = sGroup[num9];
									}
									if (num2 < groupDigits.Length - 1)
									{
										num2++;
										num4 = groupDigits[num2];
									}
									num6 = 0;
								}
							}
						}
						ptr += num7;
					}
				}
				else
				{
					do
					{
						sb.Append((char)((*ptr != 0) ? (*(ptr++)) : 48));
					}
					while (--num > 0);
				}
			}
			else
			{
				sb.Append('0');
			}
			if (nMaxDigits > 0)
			{
				sb.Append(sDecimal);
				if (num < 0 && nMaxDigits > 0)
				{
					int num10 = Math.Min(-num, nMaxDigits);
					sb.Append('0', num10);
					num += num10;
					nMaxDigits -= num10;
				}
				while (nMaxDigits > 0)
				{
					sb.Append((char)((*ptr != 0) ? (*(ptr++)) : 48));
					nMaxDigits--;
				}
			}
		}

		private static void FormatNumber(ref System.Text.ValueStringBuilder sb, ref NumberBuffer number, int nMaxDigits, NumberFormatInfo info)
		{
			string text = (number.IsNegative ? s_negNumberFormats[info.NumberNegativePattern] : "#");
			foreach (char c in text)
			{
				switch (c)
				{
				case '#':
					FormatFixed(ref sb, ref number, nMaxDigits, info.NumberGroupSizes, info.NumberDecimalSeparator, info.NumberGroupSeparator);
					break;
				case '-':
					sb.Append(info.NegativeSign);
					break;
				default:
					sb.Append(c);
					break;
				}
			}
		}

		private unsafe static void FormatScientific(ref System.Text.ValueStringBuilder sb, ref NumberBuffer number, int nMaxDigits, NumberFormatInfo info, char expChar)
		{
			byte* digitsPointer = number.GetDigitsPointer();
			sb.Append((char)((*digitsPointer != 0) ? (*(digitsPointer++)) : 48));
			if (nMaxDigits != 1)
			{
				sb.Append(info.NumberDecimalSeparator);
			}
			while (--nMaxDigits > 0)
			{
				sb.Append((char)((*digitsPointer != 0) ? (*(digitsPointer++)) : 48));
			}
			int value = ((number.Digits[0] != 0) ? (number.Scale - 1) : 0);
			FormatExponent(ref sb, info, value, expChar, 3, positiveSign: true);
		}

		private unsafe static void FormatExponent(ref System.Text.ValueStringBuilder sb, NumberFormatInfo info, int value, char expChar, int minDigits, bool positiveSign)
		{
			sb.Append(expChar);
			if (value < 0)
			{
				sb.Append(info.NegativeSign);
				value = -value;
			}
			else if (positiveSign)
			{
				sb.Append(info.PositiveSign);
			}
			char* ptr = stackalloc char[10];
			char* ptr2 = UInt32ToDecChars(ptr + 10, (uint)value, minDigits);
			sb.Append(ptr2, (int)(ptr + 10 - ptr2));
		}

		private unsafe static void FormatGeneral(ref System.Text.ValueStringBuilder sb, ref NumberBuffer number, int nMaxDigits, NumberFormatInfo info, char expChar, bool bSuppressScientific)
		{
			int i = number.Scale;
			bool flag = false;
			if (!bSuppressScientific && (i > nMaxDigits || i < -3))
			{
				i = 1;
				flag = true;
			}
			byte* digitsPointer = number.GetDigitsPointer();
			if (i > 0)
			{
				do
				{
					sb.Append((char)((*digitsPointer != 0) ? (*(digitsPointer++)) : 48));
				}
				while (--i > 0);
			}
			else
			{
				sb.Append('0');
			}
			if (*digitsPointer != 0 || i < 0)
			{
				sb.Append(info.NumberDecimalSeparator);
				for (; i < 0; i++)
				{
					sb.Append('0');
				}
				while (*digitsPointer != 0)
				{
					sb.Append((char)(*(digitsPointer++)));
				}
			}
			if (flag)
			{
				FormatExponent(ref sb, info, number.Scale - 1, expChar, 2, positiveSign: true);
			}
		}

		private static void FormatPercent(ref System.Text.ValueStringBuilder sb, ref NumberBuffer number, int nMaxDigits, NumberFormatInfo info)
		{
			string text = (number.IsNegative ? s_negPercentFormats[info.PercentNegativePattern] : s_posPercentFormats[info.PercentPositivePattern]);
			foreach (char c in text)
			{
				switch (c)
				{
				case '#':
					FormatFixed(ref sb, ref number, nMaxDigits, info.PercentGroupSizes, info.PercentDecimalSeparator, info.PercentGroupSeparator);
					break;
				case '-':
					sb.Append(info.NegativeSign);
					break;
				case '%':
					sb.Append(info.PercentSymbol);
					break;
				default:
					sb.Append(c);
					break;
				}
			}
		}

		internal unsafe static void RoundNumber(ref NumberBuffer number, int pos, bool isCorrectlyRounded)
		{
			byte* digitsPointer = number.GetDigitsPointer();
			int i;
			for (i = 0; i < pos && digitsPointer[i] != 0; i++)
			{
			}
			if (i == pos && ShouldRoundUp(digitsPointer, i, number.Kind, isCorrectlyRounded))
			{
				while (i > 0 && digitsPointer[i - 1] == 57)
				{
					i--;
				}
				if (i > 0)
				{
					byte* num = digitsPointer + (i - 1);
					(*num)++;
				}
				else
				{
					number.Scale++;
					*digitsPointer = 49;
					i = 1;
				}
			}
			else
			{
				while (i > 0 && digitsPointer[i - 1] == 48)
				{
					i--;
				}
			}
			if (i == 0)
			{
				if (number.Kind != NumberBufferKind.FloatingPoint)
				{
					number.IsNegative = false;
				}
				number.Scale = 0;
			}
			digitsPointer[i] = 0;
			number.DigitsCount = i;
			unsafe static bool ShouldRoundUp(byte* _dig, int _i, NumberBufferKind numberKind, bool _isCorrectlyRounded)
			{
				byte b = _dig[_i];
				if (b == 0 || _isCorrectlyRounded)
				{
					return false;
				}
				return b >= 53;
			}
		}

		private unsafe static int FindSection(ReadOnlySpan<char> format, int section)
		{
			if (section == 0)
			{
				return 0;
			}
			fixed (char* reference = &MemoryMarshal.GetReference(format))
			{
				int num = 0;
				while (true)
				{
					if (num >= format.Length)
					{
						return 0;
					}
					char c2;
					char c = (c2 = reference[num++]);
					if ((uint)c <= 34u)
					{
						if (c == '\0')
						{
							break;
						}
						if (c != '"')
						{
							continue;
						}
					}
					else if (c != '\'')
					{
						switch (c)
						{
						default:
							continue;
						case '\\':
							if (num < format.Length && reference[num] != 0)
							{
								num++;
							}
							continue;
						case ';':
							break;
						}
						if (--section == 0)
						{
							if (num >= format.Length || reference[num] == '\0' || reference[num] == ';')
							{
								break;
							}
							return num;
						}
						continue;
					}
					while (num < format.Length && reference[num] != 0 && reference[num++] != c2)
					{
					}
				}
				return 0;
			}
		}

		private static uint Low32(ulong value)
		{
			return (uint)value;
		}

		private static uint High32(ulong value)
		{
			return (uint)((value & 0xFFFFFFFF00000000uL) >> 32);
		}

		private static uint Int64DivMod1E9(ref ulong value)
		{
			int result = (int)(value % 1000000000);
			value /= 1000000000uL;
			return (uint)result;
		}

		private static ulong ExtractFractionAndBiasedExponent(double value, out int exponent)
		{
			ulong num = (ulong)BitConverter.DoubleToInt64Bits(value);
			ulong num2 = num & 0xFFFFFFFFFFFFFL;
			exponent = (int)(num >> 52) & 0x7FF;
			if (exponent != 0)
			{
				num2 |= 0x10000000000000L;
				exponent -= 1075;
			}
			else
			{
				exponent = -1074;
			}
			return num2;
		}

		private static uint ExtractFractionAndBiasedExponent(float value, out int exponent)
		{
			uint num = (uint)SingleToInt32Bits(value);
			uint num2 = num & 0x7FFFFF;
			exponent = (int)((num >> 23) & 0xFF);
			if (exponent != 0)
			{
				num2 |= 0x800000;
				exponent -= 150;
			}
			else
			{
				exponent = -149;
			}
			return num2;
		}

		private static string FastAllocateString(int length)
		{
			return new string('\0', length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static int SingleToInt32Bits(float value)
		{
			return *(int*)(&value);
		}

		private unsafe static void AccumulateDecimalDigitsIntoBigInteger(ref NumberBuffer number, uint firstIndex, uint lastIndex, out BigInteger result)
		{
			BigInteger.SetZero(out result);
			byte* ptr = number.GetDigitsPointer() + firstIndex;
			uint num = lastIndex - firstIndex;
			while (num != 0)
			{
				uint num2 = Math.Min(num, 9u);
				uint value = DigitsToUInt32(ptr, (int)num2);
				result.MultiplyPow10(num2);
				result.Add(value);
				ptr += num2;
				num -= num2;
			}
		}

		private static ulong AssembleFloatingPointBits(in FloatingPointInfo info, ulong initialMantissa, int initialExponent, bool hasZeroTail)
		{
			uint num = BigInteger.CountSignificantBits(initialMantissa);
			int num2 = (int)(info.NormalMantissaBits - num);
			int num3 = initialExponent - num2;
			ulong num4 = initialMantissa;
			int num5 = num3;
			if (num3 > info.MaxBinaryExponent)
			{
				return info.InfinityBits;
			}
			if (num3 < info.MinBinaryExponent)
			{
				int num6 = num2 + num3 + info.ExponentBias - 1;
				num5 = -info.ExponentBias;
				if (num6 < 0)
				{
					num4 = RightShiftWithRounding(num4, -num6, hasZeroTail);
					if (num4 == 0L)
					{
						return info.ZeroBits;
					}
					if (num4 > info.DenormalMantissaMask)
					{
						num5 = initialExponent - (num6 + 1) - num2;
					}
				}
				else
				{
					num4 <<= num6;
				}
			}
			else if (num2 < 0)
			{
				num4 = RightShiftWithRounding(num4, -num2, hasZeroTail);
				if (num4 > info.NormalMantissaMask)
				{
					num4 >>= 1;
					num5++;
					if (num5 > info.MaxBinaryExponent)
					{
						return info.InfinityBits;
					}
				}
			}
			else if (num2 > 0)
			{
				num4 <<= num2;
			}
			num4 &= info.DenormalMantissaMask;
			return (ulong)((long)(num5 + info.ExponentBias) << (int)info.DenormalMantissaBits) | num4;
		}

		private static ulong ConvertBigIntegerToFloatingPointBits(ref BigInteger value, in FloatingPointInfo info, uint integerBitsOfPrecision, bool hasNonZeroFractionalPart)
		{
			int denormalMantissaBits = info.DenormalMantissaBits;
			if (integerBitsOfPrecision <= 64)
			{
				return AssembleFloatingPointBits(in info, value.ToUInt64(), denormalMantissaBits, !hasNonZeroFractionalPart);
			}
			uint result;
			uint num = MathEx.DivRem(integerBitsOfPrecision, 32u, out result);
			uint num2 = num - 1;
			uint num3 = num2 - 1;
			int num4 = denormalMantissaBits + (int)(num3 * 32);
			bool flag = !hasNonZeroFractionalPart;
			ulong initialMantissa;
			if (result == 0)
			{
				initialMantissa = ((ulong)value.GetBlock(num2) << 32) + value.GetBlock(num3);
			}
			else
			{
				int num5 = (int)result;
				int num6 = 64 - num5;
				int num7 = num6 - 32;
				num4 += (int)result;
				uint block = value.GetBlock(num3);
				uint num8 = block >> num5;
				ulong num9 = (ulong)value.GetBlock(num2) << num7;
				initialMantissa = ((ulong)value.GetBlock(num) << num6) + num9 + num8;
				uint num10 = (uint)((1 << (int)result) - 1);
				flag = flag && (block & num10) == 0;
			}
			for (uint num11 = 0u; num11 != num3; num11++)
			{
				flag &= value.GetBlock(num11) == 0;
			}
			return AssembleFloatingPointBits(in info, initialMantissa, num4, flag);
		}

		private unsafe static uint DigitsToUInt32(byte* p, int count)
		{
			byte* ptr = p + count;
			uint num = (uint)(*p - 48);
			for (p++; p < ptr; p++)
			{
				num = 10 * num + *p - 48;
			}
			return num;
		}

		private unsafe static ulong DigitsToUInt64(byte* p, int count)
		{
			byte* ptr = p + count;
			ulong num = (ulong)(*p - 48);
			for (p++; p < ptr; p++)
			{
				num = 10 * num + *p - 48;
			}
			return num;
		}

		private unsafe static ulong NumberToFloatingPointBits(ref NumberBuffer number, in FloatingPointInfo info)
		{
			uint digitsCount = (uint)number.DigitsCount;
			uint num = (uint)Math.Max(0, number.Scale);
			uint num2 = Math.Min(num, digitsCount);
			uint num3 = digitsCount - num2;
			uint num4 = (uint)Math.Abs(number.Scale - num2 - num3);
			byte* digitsPointer = number.GetDigitsPointer();
			if (info.DenormalMantissaBits == 23 && digitsCount <= 7 && num4 <= 10)
			{
				float num5 = DigitsToUInt32(digitsPointer, (int)digitsCount);
				float num6 = s_Pow10SingleTable[num4];
				num5 = ((num3 == 0) ? (num5 * num6) : (num5 / num6));
				return (uint)SingleToInt32Bits(num5);
			}
			if (digitsCount <= 15 && num4 <= 22)
			{
				double num7 = DigitsToUInt64(digitsPointer, (int)digitsCount);
				double num8 = s_Pow10DoubleTable[num4];
				num7 = ((num3 == 0) ? (num7 * num8) : (num7 / num8));
				if (info.DenormalMantissaBits == 52)
				{
					return (ulong)BitConverter.DoubleToInt64Bits(num7);
				}
				return (uint)SingleToInt32Bits((float)num7);
			}
			return NumberToFloatingPointBitsSlow(ref number, in info, num, num2, num3);
		}

		private static ulong NumberToFloatingPointBitsSlow(ref NumberBuffer number, in FloatingPointInfo info, uint positiveExponent, uint integerDigitsPresent, uint fractionalDigitsPresent)
		{
			uint num = (uint)(info.NormalMantissaBits + 1);
			uint digitsCount = (uint)number.DigitsCount;
			uint num2 = positiveExponent - integerDigitsPresent;
			uint lastIndex = digitsCount;
			AccumulateDecimalDigitsIntoBigInteger(ref number, 0u, integerDigitsPresent, out var result);
			if (num2 != 0)
			{
				if (num2 > info.OverflowDecimalExponent)
				{
					return info.InfinityBits;
				}
				result.MultiplyPow10(num2);
			}
			uint num3 = BigInteger.CountSignificantBits(ref result);
			if (num3 >= num || fractionalDigitsPresent == 0)
			{
				return ConvertBigIntegerToFloatingPointBits(ref result, in info, num3, fractionalDigitsPresent != 0);
			}
			uint num4 = fractionalDigitsPresent;
			if (number.Scale < 0)
			{
				num4 += (uint)(-number.Scale);
			}
			if (num3 == 0 && num4 - (int)digitsCount > info.OverflowDecimalExponent)
			{
				return info.ZeroBits;
			}
			AccumulateDecimalDigitsIntoBigInteger(ref number, integerDigitsPresent, lastIndex, out var result2);
			if (result2.IsZero())
			{
				return ConvertBigIntegerToFloatingPointBits(ref result, in info, num3, fractionalDigitsPresent != 0);
			}
			BigInteger.Pow10(num4, out var result3);
			uint num5 = BigInteger.CountSignificantBits(ref result2);
			uint num6 = BigInteger.CountSignificantBits(ref result3);
			uint num7 = 0u;
			if (num6 > num5)
			{
				num7 = num6 - num5;
			}
			if (num7 != 0)
			{
				result2.ShiftLeft(num7);
			}
			uint num8 = num - num3;
			uint num9 = num8;
			if (num3 != 0)
			{
				if (num7 > num9)
				{
					return ConvertBigIntegerToFloatingPointBits(ref result, in info, num3, fractionalDigitsPresent != 0);
				}
				num9 -= num7;
			}
			uint num10 = num7;
			if (BigInteger.Compare(ref result2, ref result3) < 0)
			{
				num10++;
			}
			result2.ShiftLeft(num9);
			BigInteger.DivRem(ref result2, ref result3, out var quo, out var rem);
			ulong num11 = quo.ToUInt64();
			bool flag = !number.HasNonZeroTail && rem.IsZero();
			uint num12 = BigInteger.CountSignificantBits(num11);
			if (num12 > num8)
			{
				int num13 = (int)(num12 - num8);
				flag = flag && (num11 & (ulong)((1L << num13) - 1)) == 0;
				num11 >>= num13;
			}
			ulong initialMantissa = (result.ToUInt64() << (int)num8) + num11;
			int initialExponent = (int)((num3 != 0) ? (num3 - 2) : (0 - num10 - 1));
			return AssembleFloatingPointBits(in info, initialMantissa, initialExponent, flag);
		}

		private static ulong RightShiftWithRounding(ulong value, int shift, bool hasZeroTail)
		{
			if (shift >= 64)
			{
				return 0uL;
			}
			ulong num = (ulong)((1L << shift - 1) - 1);
			ulong num2 = (ulong)(1L << shift - 1);
			ulong num3 = (ulong)(1L << shift);
			bool lsbBit = (value & num3) != 0;
			bool roundBit = (value & num2) != 0;
			bool hasTailBits = !hasZeroTail || (value & num) != 0;
			return (value >> shift) + (ulong)(ShouldRoundUp(lsbBit, roundBit, hasTailBits) ? 1 : 0);
		}

		private static bool ShouldRoundUp(bool lsbBit, bool roundBit, bool hasTailBits)
		{
			if (roundBit)
			{
				return hasTailBits || lsbBit;
			}
			return false;
		}

		private unsafe static bool TryNumberToInt32(ref NumberBuffer number, ref int value)
		{
			int num = number.Scale;
			if (num > 10 || num < number.DigitsCount)
			{
				return false;
			}
			byte* digitsPointer = number.GetDigitsPointer();
			int num2 = 0;
			while (--num >= 0)
			{
				if ((uint)num2 > 214748364u)
				{
					return false;
				}
				num2 *= 10;
				if (*digitsPointer != 0)
				{
					num2 += *(digitsPointer++) - 48;
				}
			}
			if (number.IsNegative)
			{
				num2 = -num2;
				if (num2 > 0)
				{
					return false;
				}
			}
			else if (num2 < 0)
			{
				return false;
			}
			value = num2;
			return true;
		}

		private unsafe static bool TryNumberToInt64(ref NumberBuffer number, ref long value)
		{
			int num = number.Scale;
			if (num > 19 || num < number.DigitsCount)
			{
				return false;
			}
			byte* digitsPointer = number.GetDigitsPointer();
			long num2 = 0L;
			while (--num >= 0)
			{
				if ((ulong)num2 > 922337203685477580uL)
				{
					return false;
				}
				num2 *= 10;
				if (*digitsPointer != 0)
				{
					num2 += *(digitsPointer++) - 48;
				}
			}
			if (number.IsNegative)
			{
				num2 = -num2;
				if (num2 > 0)
				{
					return false;
				}
			}
			else if (num2 < 0)
			{
				return false;
			}
			value = num2;
			return true;
		}

		private unsafe static bool TryNumberToUInt32(ref NumberBuffer number, ref uint value)
		{
			int num = number.Scale;
			if (num > 10 || num < number.DigitsCount || number.IsNegative)
			{
				return false;
			}
			byte* digitsPointer = number.GetDigitsPointer();
			uint num2 = 0u;
			while (--num >= 0)
			{
				if (num2 > 429496729)
				{
					return false;
				}
				num2 *= 10;
				if (*digitsPointer != 0)
				{
					uint num3 = num2 + (uint)(*(digitsPointer++) - 48);
					if (num3 < num2)
					{
						return false;
					}
					num2 = num3;
				}
			}
			value = num2;
			return true;
		}

		private unsafe static bool TryNumberToUInt64(ref NumberBuffer number, ref ulong value)
		{
			int num = number.Scale;
			if (num > 20 || num < number.DigitsCount || number.IsNegative)
			{
				return false;
			}
			byte* digitsPointer = number.GetDigitsPointer();
			ulong num2 = 0uL;
			while (--num >= 0)
			{
				if (num2 > 1844674407370955161L)
				{
					return false;
				}
				num2 *= 10;
				if (*digitsPointer != 0)
				{
					ulong num3 = num2 + (ulong)(*(digitsPointer++) - 48);
					if (num3 < num2)
					{
						return false;
					}
					num2 = num3;
				}
			}
			value = num2;
			return true;
		}

		internal static int ParseInt32(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info)
		{
			int result;
			ParsingStatus parsingStatus = TryParseInt32(value, styles, info, out result);
			if (parsingStatus != ParsingStatus.OK)
			{
				ThrowOverflowOrFormatException(parsingStatus, TypeCode.Int32);
			}
			return result;
		}

		internal static long ParseInt64(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info)
		{
			long result;
			ParsingStatus parsingStatus = TryParseInt64(value, styles, info, out result);
			if (parsingStatus != ParsingStatus.OK)
			{
				ThrowOverflowOrFormatException(parsingStatus, TypeCode.Int64);
			}
			return result;
		}

		internal static uint ParseUInt32(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info)
		{
			uint result;
			ParsingStatus parsingStatus = TryParseUInt32(value, styles, info, out result);
			if (parsingStatus != ParsingStatus.OK)
			{
				ThrowOverflowOrFormatException(parsingStatus, TypeCode.UInt32);
			}
			return result;
		}

		internal static ulong ParseUInt64(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info)
		{
			ulong result;
			ParsingStatus parsingStatus = TryParseUInt64(value, styles, info, out result);
			if (parsingStatus != ParsingStatus.OK)
			{
				ThrowOverflowOrFormatException(parsingStatus, TypeCode.UInt64);
			}
			return result;
		}

		private unsafe static bool TryParseNumber(ref char* str, char* strEnd, NumberStyles styles, ref NumberBuffer number, NumberFormatInfo info)
		{
			string text = null;
			bool flag = false;
			string value;
			string value2;
			if ((styles & NumberStyles.AllowCurrencySymbol) != NumberStyles.None)
			{
				text = info.CurrencySymbol;
				value = info.CurrencyDecimalSeparator;
				value2 = info.CurrencyGroupSeparator;
				flag = true;
			}
			else
			{
				value = info.NumberDecimalSeparator;
				value2 = info.NumberGroupSeparator;
			}
			int num = 0;
			char* ptr = str;
			char c = ((ptr < strEnd) ? (*ptr) : '\0');
			while (true)
			{
				if (!IsWhite(c) || (styles & NumberStyles.AllowLeadingWhite) == 0 || ((num & 1) != 0 && (num & 0x20) == 0 && info.NumberNegativePattern != 2))
				{
					char* ptr2;
					if ((styles & NumberStyles.AllowLeadingSign) != NumberStyles.None && (num & 1) == 0 && ((ptr2 = MatchChars(ptr, strEnd, info.PositiveSign)) != null || ((ptr2 = MatchChars(ptr, strEnd, info.NegativeSign)) != null && (number.IsNegative = true))))
					{
						num |= 1;
						ptr = ptr2 - 1;
					}
					else if (c == '(' && (styles & NumberStyles.AllowParentheses) != NumberStyles.None && (num & 1) == 0)
					{
						num |= 3;
						number.IsNegative = true;
					}
					else
					{
						if (text == null || (ptr2 = MatchChars(ptr, strEnd, text)) == null)
						{
							break;
						}
						num |= 0x20;
						text = null;
						ptr = ptr2 - 1;
					}
				}
				c = ((++ptr < strEnd) ? (*ptr) : '\0');
			}
			int num2 = 0;
			int num3 = 0;
			int num4 = number.Digits.Length - 1;
			while (true)
			{
				char* ptr2;
				if (IsDigit(c))
				{
					num |= 4;
					if (c != '0' || (num & 8) != 0)
					{
						if (num2 < num4)
						{
							number.Digits[num2++] = (byte)c;
							if (c != '0' || number.Kind != NumberBufferKind.Integer)
							{
								num3 = num2;
							}
						}
						else if (c != '0')
						{
							number.HasNonZeroTail = true;
						}
						if ((num & 0x10) == 0)
						{
							number.Scale++;
						}
						num |= 8;
					}
					else if ((num & 0x10) != 0)
					{
						number.Scale--;
					}
				}
				else if ((styles & NumberStyles.AllowDecimalPoint) != NumberStyles.None && (num & 0x10) == 0 && ((ptr2 = MatchChars(ptr, strEnd, value)) != null || (flag && (num & 0x20) == 0 && (ptr2 = MatchChars(ptr, strEnd, info.NumberDecimalSeparator)) != null)))
				{
					num |= 0x10;
					ptr = ptr2 - 1;
				}
				else
				{
					if ((styles & NumberStyles.AllowThousands) == 0 || (num & 4) == 0 || (num & 0x10) != 0 || ((ptr2 = MatchChars(ptr, strEnd, value2)) == null && (!flag || (num & 0x20) != 0 || (ptr2 = MatchChars(ptr, strEnd, info.NumberGroupSeparator)) == null)))
					{
						break;
					}
					ptr = ptr2 - 1;
				}
				c = ((++ptr < strEnd) ? (*ptr) : '\0');
			}
			bool flag2 = false;
			number.DigitsCount = num3;
			number.Digits[num3] = 0;
			if ((num & 4) != 0)
			{
				if ((c == 'E' || c == 'e') && (styles & NumberStyles.AllowExponent) != NumberStyles.None)
				{
					char* ptr3 = ptr;
					c = ((++ptr < strEnd) ? (*ptr) : '\0');
					char* ptr2;
					if ((ptr2 = MatchChars(ptr, strEnd, info.PositiveSign)) != null)
					{
						c = (((ptr = ptr2) < strEnd) ? (*ptr) : '\0');
					}
					else if ((ptr2 = MatchChars(ptr, strEnd, info.NegativeSign)) != null)
					{
						c = (((ptr = ptr2) < strEnd) ? (*ptr) : '\0');
						flag2 = true;
					}
					if (IsDigit(c))
					{
						int num5 = 0;
						do
						{
							num5 = num5 * 10 + (c - 48);
							c = ((++ptr < strEnd) ? (*ptr) : '\0');
							if (num5 > 1000)
							{
								num5 = 9999;
								while (IsDigit(c))
								{
									c = ((++ptr < strEnd) ? (*ptr) : '\0');
								}
							}
						}
						while (IsDigit(c));
						if (flag2)
						{
							num5 = -num5;
						}
						number.Scale += num5;
					}
					else
					{
						ptr = ptr3;
						c = ((ptr < strEnd) ? (*ptr) : '\0');
					}
				}
				while (true)
				{
					if (!IsWhite(c) || (styles & NumberStyles.AllowTrailingWhite) == 0)
					{
						char* ptr2;
						if ((styles & NumberStyles.AllowTrailingSign) != NumberStyles.None && (num & 1) == 0 && ((ptr2 = MatchChars(ptr, strEnd, info.PositiveSign)) != null || ((ptr2 = MatchChars(ptr, strEnd, info.NegativeSign)) != null && (number.IsNegative = true))))
						{
							num |= 1;
							ptr = ptr2 - 1;
						}
						else if (c == ')' && (num & 2) != 0)
						{
							num &= -3;
						}
						else
						{
							if (text == null || (ptr2 = MatchChars(ptr, strEnd, text)) == null)
							{
								break;
							}
							text = null;
							ptr = ptr2 - 1;
						}
					}
					c = ((++ptr < strEnd) ? (*ptr) : '\0');
				}
				if ((num & 2) == 0)
				{
					if ((num & 8) == 0)
					{
						if (number.Kind != NumberBufferKind.Decimal)
						{
							number.Scale = 0;
						}
						if (number.Kind == NumberBufferKind.Integer && (num & 0x10) == 0)
						{
							number.IsNegative = false;
						}
					}
					str = ptr;
					return true;
				}
			}
			str = ptr;
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ParsingStatus TryParseInt32(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out int result)
		{
			if ((styles & ~NumberStyles.Integer) == 0)
			{
				return TryParseInt32IntegerStyle(value, styles, info, out result);
			}
			if ((styles & NumberStyles.AllowHexSpecifier) != NumberStyles.None)
			{
				result = 0;
				return TryParseUInt32HexNumberStyle(value, styles, out Unsafe.As<int, uint>(ref result));
			}
			return TryParseInt32Number(value, styles, info, out result);
		}

		private unsafe static ParsingStatus TryParseInt32Number(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out int result)
		{
			result = 0;
			byte* digits = stackalloc byte[11];
			NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits, 11);
			if (!TryStringToNumber(value, styles, ref number, info))
			{
				return ParsingStatus.Failed;
			}
			if (!TryNumberToInt32(ref number, ref result))
			{
				return ParsingStatus.Overflow;
			}
			return ParsingStatus.OK;
		}

		internal static ParsingStatus TryParseInt32IntegerStyle(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out int result)
		{
			int i;
			int num;
			if (!value.IsEmpty)
			{
				i = 0;
				num = value[0];
				if ((styles & NumberStyles.AllowLeadingWhite) == 0 || !IsWhite(num))
				{
					goto IL_0048;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (IsWhite(num))
					{
						continue;
					}
					goto IL_0048;
				}
			}
			goto IL_025a;
			IL_024e:
			int num2;
			int num3;
			result = num2 * num3;
			return ParsingStatus.OK;
			IL_0170:
			if (IsDigit(num))
			{
				goto IL_017b;
			}
			goto IL_026a;
			IL_017b:
			num2 = num - 48;
			i++;
			int num4 = 0;
			while (num4 < 8)
			{
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_024e;
				}
				num = value[i];
				if (IsDigit(num))
				{
					i++;
					num2 = 10 * num2 + num - 48;
					num4++;
					continue;
				}
				goto IL_026a;
			}
			if ((uint)i >= (uint)value.Length)
			{
				goto IL_024e;
			}
			num = value[i];
			bool flag;
			if (IsDigit(num))
			{
				i++;
				flag = num2 > 214748364;
				num2 = num2 * 10 + num - 48;
				flag = flag || (uint)num2 > (uint)(int.MaxValue + (num3 >>> 31));
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_024b;
				}
				num = value[i];
				while (IsDigit(num))
				{
					flag = true;
					i++;
					if ((uint)i < (uint)value.Length)
					{
						num = value[i];
						continue;
					}
					goto IL_0262;
				}
			}
			goto IL_026a;
			IL_024b:
			if (!flag)
			{
				goto IL_024e;
			}
			goto IL_0262;
			IL_0048:
			num3 = 1;
			if ((styles & NumberStyles.AllowLeadingSign) != NumberStyles.None)
			{
				if (info.HasInvariantNumberSigns())
				{
					if (num == 45)
					{
						num3 = -1;
						i++;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_025a;
						}
						num = value[i];
					}
					else if (num == 43)
					{
						i++;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_025a;
						}
						num = value[i];
					}
				}
				else
				{
					value = value.Slice(i);
					i = 0;
					string positiveSign = info.PositiveSign;
					string negativeSign = info.NegativeSign;
					if (!string.IsNullOrEmpty(positiveSign) && value.StartsWith(positiveSign.AsSpan()))
					{
						i += positiveSign.Length;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_025a;
						}
						num = value[i];
					}
					else if (!string.IsNullOrEmpty(negativeSign) && value.StartsWith(negativeSign.AsSpan()))
					{
						num3 = -1;
						i += negativeSign.Length;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_025a;
						}
						num = value[i];
					}
				}
			}
			flag = false;
			num2 = 0;
			if (IsDigit(num))
			{
				if (num != 48)
				{
					goto IL_017b;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (num == 48)
					{
						continue;
					}
					goto IL_0170;
				}
				goto IL_024e;
			}
			goto IL_025a;
			IL_026a:
			if (IsWhite(num))
			{
				if ((styles & NumberStyles.AllowTrailingWhite) == 0)
				{
					goto IL_025a;
				}
				for (i++; i < value.Length && IsWhite(value[i]); i++)
				{
				}
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_024b;
				}
			}
			if (TrailingZeros(value, i))
			{
				goto IL_024b;
			}
			goto IL_025a;
			IL_025a:
			result = 0;
			return ParsingStatus.Failed;
			IL_0262:
			result = 0;
			return ParsingStatus.Overflow;
		}

		internal static ParsingStatus TryParseInt64IntegerStyle(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out long result)
		{
			int i;
			int num;
			if (!value.IsEmpty)
			{
				i = 0;
				num = value[0];
				if ((styles & NumberStyles.AllowLeadingWhite) == 0 || !IsWhite(num))
				{
					goto IL_0048;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (IsWhite(num))
					{
						continue;
					}
					goto IL_0048;
				}
			}
			goto IL_0270;
			IL_0263:
			long num2;
			int num3;
			result = num2 * num3;
			return ParsingStatus.OK;
			IL_0171:
			if (IsDigit(num))
			{
				goto IL_017c;
			}
			goto IL_0282;
			IL_017c:
			num2 = num - 48;
			i++;
			int num4 = 0;
			while (num4 < 17)
			{
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_0263;
				}
				num = value[i];
				if (IsDigit(num))
				{
					i++;
					num2 = 10 * num2 + num - 48;
					num4++;
					continue;
				}
				goto IL_0282;
			}
			if ((uint)i >= (uint)value.Length)
			{
				goto IL_0263;
			}
			num = value[i];
			bool flag;
			if (IsDigit(num))
			{
				i++;
				flag = num2 > 922337203685477580L;
				num2 = num2 * 10 + num - 48;
				flag = flag || (ulong)num2 > (ulong)(long.MaxValue + (long)(uint)(num3 >>> 31));
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_0260;
				}
				num = value[i];
				while (IsDigit(num))
				{
					flag = true;
					i++;
					if ((uint)i < (uint)value.Length)
					{
						num = value[i];
						continue;
					}
					goto IL_0279;
				}
			}
			goto IL_0282;
			IL_0260:
			if (!flag)
			{
				goto IL_0263;
			}
			goto IL_0279;
			IL_0048:
			num3 = 1;
			if ((styles & NumberStyles.AllowLeadingSign) != NumberStyles.None)
			{
				if (info.HasInvariantNumberSigns())
				{
					if (num == 45)
					{
						num3 = -1;
						i++;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0270;
						}
						num = value[i];
					}
					else if (num == 43)
					{
						i++;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0270;
						}
						num = value[i];
					}
				}
				else
				{
					value = value.Slice(i);
					i = 0;
					string positiveSign = info.PositiveSign;
					string negativeSign = info.NegativeSign;
					if (!string.IsNullOrEmpty(positiveSign) && value.StartsWith(positiveSign.AsSpan()))
					{
						i += positiveSign.Length;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0270;
						}
						num = value[i];
					}
					else if (!string.IsNullOrEmpty(negativeSign) && value.StartsWith(negativeSign.AsSpan()))
					{
						num3 = -1;
						i += negativeSign.Length;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0270;
						}
						num = value[i];
					}
				}
			}
			flag = false;
			num2 = 0L;
			if (IsDigit(num))
			{
				if (num != 48)
				{
					goto IL_017c;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (num == 48)
					{
						continue;
					}
					goto IL_0171;
				}
				goto IL_0263;
			}
			goto IL_0270;
			IL_0282:
			if (IsWhite(num))
			{
				if ((styles & NumberStyles.AllowTrailingWhite) == 0)
				{
					goto IL_0270;
				}
				for (i++; i < value.Length && IsWhite(value[i]); i++)
				{
				}
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_0260;
				}
			}
			if (TrailingZeros(value, i))
			{
				goto IL_0260;
			}
			goto IL_0270;
			IL_0270:
			result = 0L;
			return ParsingStatus.Failed;
			IL_0279:
			result = 0L;
			return ParsingStatus.Overflow;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ParsingStatus TryParseInt64(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out long result)
		{
			if ((styles & ~NumberStyles.Integer) == 0)
			{
				return TryParseInt64IntegerStyle(value, styles, info, out result);
			}
			if ((styles & NumberStyles.AllowHexSpecifier) != NumberStyles.None)
			{
				result = 0L;
				return TryParseUInt64HexNumberStyle(value, styles, out Unsafe.As<long, ulong>(ref result));
			}
			return TryParseInt64Number(value, styles, info, out result);
		}

		private unsafe static ParsingStatus TryParseInt64Number(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out long result)
		{
			result = 0L;
			byte* digits = stackalloc byte[20];
			NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits, 20);
			if (!TryStringToNumber(value, styles, ref number, info))
			{
				return ParsingStatus.Failed;
			}
			if (!TryNumberToInt64(ref number, ref result))
			{
				return ParsingStatus.Overflow;
			}
			return ParsingStatus.OK;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ParsingStatus TryParseUInt32(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out uint result)
		{
			if ((styles & ~NumberStyles.Integer) == 0)
			{
				return TryParseUInt32IntegerStyle(value, styles, info, out result);
			}
			if ((styles & NumberStyles.AllowHexSpecifier) != NumberStyles.None)
			{
				return TryParseUInt32HexNumberStyle(value, styles, out result);
			}
			return TryParseUInt32Number(value, styles, info, out result);
		}

		private unsafe static ParsingStatus TryParseUInt32Number(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out uint result)
		{
			result = 0u;
			byte* digits = stackalloc byte[11];
			NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits, 11);
			if (!TryStringToNumber(value, styles, ref number, info))
			{
				return ParsingStatus.Failed;
			}
			if (!TryNumberToUInt32(ref number, ref result))
			{
				return ParsingStatus.Overflow;
			}
			return ParsingStatus.OK;
		}

		internal static ParsingStatus TryParseUInt32IntegerStyle(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out uint result)
		{
			int i;
			int num;
			if (!value.IsEmpty)
			{
				i = 0;
				num = value[0];
				if ((styles & NumberStyles.AllowLeadingWhite) == 0 || !IsWhite(num))
				{
					goto IL_0048;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (IsWhite(num))
					{
						continue;
					}
					goto IL_0048;
				}
			}
			goto IL_0252;
			IL_0178:
			int num2 = num - 48;
			i++;
			int num3 = 0;
			while (num3 < 8)
			{
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_0246;
				}
				num = value[i];
				if (IsDigit(num))
				{
					i++;
					num2 = 10 * num2 + num - 48;
					num3++;
					continue;
				}
				goto IL_0264;
			}
			if ((uint)i >= (uint)value.Length)
			{
				goto IL_0246;
			}
			num = value[i];
			bool flag;
			if (IsDigit(num))
			{
				i++;
				flag = flag || (uint)num2 > 429496729u || (num2 == 429496729 && num > 53);
				num2 = num2 * 10 + num - 48;
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_0246;
				}
				num = value[i];
				while (IsDigit(num))
				{
					flag = true;
					i++;
					if ((uint)i < (uint)value.Length)
					{
						num = value[i];
						continue;
					}
					goto IL_025a;
				}
			}
			goto IL_0264;
			IL_016d:
			if (IsDigit(num))
			{
				goto IL_0178;
			}
			flag = false;
			goto IL_0264;
			IL_0264:
			if (IsWhite(num))
			{
				if ((styles & NumberStyles.AllowTrailingWhite) == 0)
				{
					goto IL_0252;
				}
				for (i++; i < value.Length && IsWhite(value[i]); i++)
				{
				}
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_0246;
				}
			}
			if (TrailingZeros(value, i))
			{
				goto IL_0246;
			}
			goto IL_0252;
			IL_0246:
			if (!flag)
			{
				goto IL_0249;
			}
			goto IL_025a;
			IL_0048:
			flag = false;
			if ((styles & NumberStyles.AllowLeadingSign) != NumberStyles.None)
			{
				if (info.HasInvariantNumberSigns())
				{
					if (num == 43)
					{
						i++;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0252;
						}
						num = value[i];
					}
					else if (num == 45)
					{
						flag = true;
						i++;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0252;
						}
						num = value[i];
					}
				}
				else
				{
					value = value.Slice(i);
					i = 0;
					string positiveSign = info.PositiveSign;
					string negativeSign = info.NegativeSign;
					if (!string.IsNullOrEmpty(positiveSign) && value.StartsWith(positiveSign.AsSpan()))
					{
						i += positiveSign.Length;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0252;
						}
						num = value[i];
					}
					else if (!string.IsNullOrEmpty(negativeSign) && value.StartsWith(negativeSign.AsSpan()))
					{
						flag = true;
						i += negativeSign.Length;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0252;
						}
						num = value[i];
					}
				}
			}
			num2 = 0;
			if (IsDigit(num))
			{
				if (num != 48)
				{
					goto IL_0178;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (num == 48)
					{
						continue;
					}
					goto IL_016d;
				}
				goto IL_0249;
			}
			goto IL_0252;
			IL_025a:
			result = 0u;
			return ParsingStatus.Overflow;
			IL_0252:
			result = 0u;
			return ParsingStatus.Failed;
			IL_0249:
			result = (uint)num2;
			return ParsingStatus.OK;
		}

		private static ParsingStatus TryParseUInt32HexNumberStyle(ReadOnlySpan<char> value, NumberStyles styles, out uint result)
		{
			int i;
			int num;
			if (!value.IsEmpty)
			{
				i = 0;
				num = value[0];
				if ((styles & NumberStyles.AllowLeadingWhite) == 0 || !IsWhite(num))
				{
					goto IL_0048;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (IsWhite(num))
					{
						continue;
					}
					goto IL_0048;
				}
			}
			goto IL_018c;
			IL_0098:
			ReadOnlySpan<byte> charToHexLookup;
			if ((uint)num < (uint)charToHexLookup.Length && charToHexLookup[num] != byte.MaxValue)
			{
				goto IL_00b8;
			}
			goto IL_019c;
			IL_0183:
			uint num2;
			result = num2;
			return ParsingStatus.OK;
			IL_00b8:
			num2 = charToHexLookup[num];
			i++;
			int num3 = 0;
			while (num3 < 7)
			{
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_0183;
				}
				num = value[i];
				uint num4;
				if ((uint)num < (uint)charToHexLookup.Length && (num4 = charToHexLookup[num]) != 255)
				{
					i++;
					num2 = 16 * num2 + num4;
					num3++;
					continue;
				}
				goto IL_019c;
			}
			if ((uint)i >= (uint)value.Length)
			{
				goto IL_0183;
			}
			num = value[i];
			if ((uint)num < (uint)charToHexLookup.Length && charToHexLookup[num] != byte.MaxValue)
			{
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if ((uint)num < (uint)charToHexLookup.Length && charToHexLookup[num] != byte.MaxValue)
					{
						continue;
					}
					goto IL_017c;
				}
				goto IL_0194;
			}
			goto IL_019c;
			IL_017c:
			bool flag = true;
			goto IL_019c;
			IL_0048:
			flag = false;
			num2 = 0u;
			charToHexLookup = CharToHexLookup;
			if ((uint)num < (uint)charToHexLookup.Length && charToHexLookup[num] != byte.MaxValue)
			{
				if (num != 48)
				{
					goto IL_00b8;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (num == 48)
					{
						continue;
					}
					goto IL_0098;
				}
				goto IL_0183;
			}
			goto IL_018c;
			IL_018c:
			result = 0u;
			return ParsingStatus.Failed;
			IL_0194:
			result = 0u;
			return ParsingStatus.Overflow;
			IL_0180:
			if (!flag)
			{
				goto IL_0183;
			}
			goto IL_0194;
			IL_019c:
			if (IsWhite(num))
			{
				if ((styles & NumberStyles.AllowTrailingWhite) == 0)
				{
					goto IL_018c;
				}
				for (i++; i < value.Length && IsWhite(value[i]); i++)
				{
				}
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_0180;
				}
			}
			if (TrailingZeros(value, i))
			{
				goto IL_0180;
			}
			goto IL_018c;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ParsingStatus TryParseUInt64(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out ulong result)
		{
			if ((styles & ~NumberStyles.Integer) == 0)
			{
				return TryParseUInt64IntegerStyle(value, styles, info, out result);
			}
			if ((styles & NumberStyles.AllowHexSpecifier) != NumberStyles.None)
			{
				return TryParseUInt64HexNumberStyle(value, styles, out result);
			}
			return TryParseUInt64Number(value, styles, info, out result);
		}

		private unsafe static ParsingStatus TryParseUInt64Number(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out ulong result)
		{
			result = 0uL;
			byte* digits = stackalloc byte[21];
			NumberBuffer number = new NumberBuffer(NumberBufferKind.Integer, digits, 21);
			if (!TryStringToNumber(value, styles, ref number, info))
			{
				return ParsingStatus.Failed;
			}
			if (!TryNumberToUInt64(ref number, ref result))
			{
				return ParsingStatus.Overflow;
			}
			return ParsingStatus.OK;
		}

		internal static ParsingStatus TryParseUInt64IntegerStyle(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out ulong result)
		{
			int i;
			int num;
			if (!value.IsEmpty)
			{
				i = 0;
				num = value[0];
				if ((styles & NumberStyles.AllowLeadingWhite) == 0 || !IsWhite(num))
				{
					goto IL_0048;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (IsWhite(num))
					{
						continue;
					}
					goto IL_0048;
				}
			}
			goto IL_0266;
			IL_0179:
			long num2 = num - 48;
			i++;
			int num3 = 0;
			while (num3 < 18)
			{
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_025a;
				}
				num = value[i];
				if (IsDigit(num))
				{
					i++;
					num2 = 10 * num2 + num - 48;
					num3++;
					continue;
				}
				goto IL_027a;
			}
			if ((uint)i >= (uint)value.Length)
			{
				goto IL_025a;
			}
			num = value[i];
			bool flag;
			if (IsDigit(num))
			{
				i++;
				flag = flag || (ulong)num2 > 1844674407370955161uL || (num2 == 1844674407370955161L && num > 53);
				num2 = num2 * 10 + num - 48;
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_025a;
				}
				num = value[i];
				while (IsDigit(num))
				{
					flag = true;
					i++;
					if ((uint)i < (uint)value.Length)
					{
						num = value[i];
						continue;
					}
					goto IL_026f;
				}
			}
			goto IL_027a;
			IL_016e:
			if (IsDigit(num))
			{
				goto IL_0179;
			}
			flag = false;
			goto IL_027a;
			IL_027a:
			if (IsWhite(num))
			{
				if ((styles & NumberStyles.AllowTrailingWhite) == 0)
				{
					goto IL_0266;
				}
				for (i++; i < value.Length && IsWhite(value[i]); i++)
				{
				}
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_025a;
				}
			}
			if (TrailingZeros(value, i))
			{
				goto IL_025a;
			}
			goto IL_0266;
			IL_025a:
			if (!flag)
			{
				goto IL_025d;
			}
			goto IL_026f;
			IL_0048:
			flag = false;
			if ((styles & NumberStyles.AllowLeadingSign) != NumberStyles.None)
			{
				if (info.HasInvariantNumberSigns())
				{
					if (num == 43)
					{
						i++;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0266;
						}
						num = value[i];
					}
					else if (num == 45)
					{
						flag = true;
						i++;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0266;
						}
						num = value[i];
					}
				}
				else
				{
					value = value.Slice(i);
					i = 0;
					string positiveSign = info.PositiveSign;
					string negativeSign = info.NegativeSign;
					if (!string.IsNullOrEmpty(positiveSign) && value.StartsWith(positiveSign.AsSpan()))
					{
						i += positiveSign.Length;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0266;
						}
						num = value[i];
					}
					else if (!string.IsNullOrEmpty(negativeSign) && value.StartsWith(negativeSign.AsSpan()))
					{
						flag = true;
						i += negativeSign.Length;
						if ((uint)i >= (uint)value.Length)
						{
							goto IL_0266;
						}
						num = value[i];
					}
				}
			}
			num2 = 0L;
			if (IsDigit(num))
			{
				if (num != 48)
				{
					goto IL_0179;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (num == 48)
					{
						continue;
					}
					goto IL_016e;
				}
				goto IL_025d;
			}
			goto IL_0266;
			IL_026f:
			result = 0uL;
			return ParsingStatus.Overflow;
			IL_0266:
			result = 0uL;
			return ParsingStatus.Failed;
			IL_025d:
			result = (ulong)num2;
			return ParsingStatus.OK;
		}

		private static ParsingStatus TryParseUInt64HexNumberStyle(ReadOnlySpan<char> value, NumberStyles styles, out ulong result)
		{
			int i;
			int num;
			if (!value.IsEmpty)
			{
				i = 0;
				num = value[0];
				if ((styles & NumberStyles.AllowLeadingWhite) == 0 || !IsWhite(num))
				{
					goto IL_0048;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (IsWhite(num))
					{
						continue;
					}
					goto IL_0048;
				}
			}
			goto IL_0191;
			IL_0099:
			ReadOnlySpan<byte> charToHexLookup;
			if ((uint)num < (uint)charToHexLookup.Length && charToHexLookup[num] != byte.MaxValue)
			{
				goto IL_00b9;
			}
			goto IL_01a3;
			IL_0188:
			ulong num2;
			result = num2;
			return ParsingStatus.OK;
			IL_00b9:
			num2 = charToHexLookup[num];
			i++;
			int num3 = 0;
			while (num3 < 15)
			{
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_0188;
				}
				num = value[i];
				uint num4;
				if ((uint)num < (uint)charToHexLookup.Length && (num4 = charToHexLookup[num]) != 255)
				{
					i++;
					num2 = 16 * num2 + num4;
					num3++;
					continue;
				}
				goto IL_01a3;
			}
			if ((uint)i >= (uint)value.Length)
			{
				goto IL_0188;
			}
			num = value[i];
			if ((uint)num < (uint)charToHexLookup.Length && charToHexLookup[num] != byte.MaxValue)
			{
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if ((uint)num < (uint)charToHexLookup.Length && charToHexLookup[num] != byte.MaxValue)
					{
						continue;
					}
					goto IL_0181;
				}
				goto IL_019a;
			}
			goto IL_01a3;
			IL_0181:
			bool flag = true;
			goto IL_01a3;
			IL_0048:
			flag = false;
			num2 = 0uL;
			charToHexLookup = CharToHexLookup;
			if ((uint)num < (uint)charToHexLookup.Length && charToHexLookup[num] != byte.MaxValue)
			{
				if (num != 48)
				{
					goto IL_00b9;
				}
				while (true)
				{
					i++;
					if ((uint)i >= (uint)value.Length)
					{
						break;
					}
					num = value[i];
					if (num == 48)
					{
						continue;
					}
					goto IL_0099;
				}
				goto IL_0188;
			}
			goto IL_0191;
			IL_0191:
			result = 0uL;
			return ParsingStatus.Failed;
			IL_019a:
			result = 0uL;
			return ParsingStatus.Overflow;
			IL_0185:
			if (!flag)
			{
				goto IL_0188;
			}
			goto IL_019a;
			IL_01a3:
			if (IsWhite(num))
			{
				if ((styles & NumberStyles.AllowTrailingWhite) == 0)
				{
					goto IL_0191;
				}
				for (i++; i < value.Length && IsWhite(value[i]); i++)
				{
				}
				if ((uint)i >= (uint)value.Length)
				{
					goto IL_0185;
				}
			}
			if (TrailingZeros(value, i))
			{
				goto IL_0185;
			}
			goto IL_0191;
		}

		internal static decimal ParseDecimal(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info)
		{
			decimal result;
			ParsingStatus parsingStatus = TryParseDecimal(value, styles, info, out result);
			if (parsingStatus != ParsingStatus.OK)
			{
				ThrowOverflowOrFormatException(parsingStatus, TypeCode.Decimal);
			}
			return result;
		}

		internal unsafe static bool TryNumberToDecimal(ref NumberBuffer number, ref decimal value)
		{
			byte* ptr = number.GetDigitsPointer();
			int num = number.Scale;
			bool isNegative = number.IsNegative;
			uint num2 = *ptr;
			if (num2 == 0)
			{
				value = new decimal(0, 0, 0, isNegative, (byte)MathEx.Clamp(-num, 0, 28));
				return true;
			}
			if (num > 29)
			{
				return false;
			}
			ulong num3 = 0uL;
			while (num > -28)
			{
				num--;
				num3 *= 10;
				num3 += num2 - 48;
				num2 = *(++ptr);
				if (num3 >= 1844674407370955161L)
				{
					break;
				}
				if (num2 != 0)
				{
					continue;
				}
				while (num > 0)
				{
					num--;
					num3 *= 10;
					if (num3 >= 1844674407370955161L)
					{
						break;
					}
				}
				break;
			}
			uint num4 = 0u;
			while ((num > 0 || (num2 != 0 && num > -28)) && (num4 < 429496729 || (num4 == 429496729 && (num3 < 11068046444225730969uL || (num3 == 11068046444225730969uL && num2 <= 53)))))
			{
				ulong num5 = (ulong)(uint)num3 * 10uL;
				ulong num6 = (ulong)((long)(uint)(num3 >> 32) * 10L) + (num5 >> 32);
				num3 = (uint)num5 + (num6 << 32);
				num4 = (uint)(int)(num6 >> 32) + num4 * 10;
				if (num2 != 0)
				{
					num2 -= 48;
					num3 += num2;
					if (num3 < num2)
					{
						num4++;
					}
					num2 = *(++ptr);
				}
				num--;
			}
			if (num2 >= 53)
			{
				if (num2 == 53 && (num3 & 1) == 0L)
				{
					num2 = *(++ptr);
					bool flag = !number.HasNonZeroTail;
					while (num2 != 0 && flag)
					{
						flag = flag && num2 == 48;
						num2 = *(++ptr);
					}
					if (flag)
					{
						goto IL_01a8;
					}
				}
				if (++num3 == 0L && ++num4 == 0)
				{
					num3 = 11068046444225730970uL;
					num4 = 429496729u;
					num++;
				}
			}
			goto IL_01a8;
			IL_01a8:
			if (num > 0)
			{
				return false;
			}
			if (num <= -29)
			{
				value = new decimal(0, 0, 0, isNegative, 28);
			}
			else
			{
				value = new decimal((int)num3, (int)(num3 >> 32), (int)num4, isNegative, (byte)(-num));
			}
			return true;
		}

		internal static double ParseDouble(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info)
		{
			if (!TryParseDouble(value, styles, info, out var result))
			{
				ThrowOverflowOrFormatException(ParsingStatus.Failed);
			}
			return result;
		}

		internal static float ParseSingle(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info)
		{
			if (!TryParseSingle(value, styles, info, out var result))
			{
				ThrowOverflowOrFormatException(ParsingStatus.Failed);
			}
			return result;
		}

		internal unsafe static ParsingStatus TryParseDecimal(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out decimal result)
		{
			byte* digits = stackalloc byte[31];
			NumberBuffer number = new NumberBuffer(NumberBufferKind.Decimal, digits, 31);
			result = default(decimal);
			if (!TryStringToNumber(value, styles, ref number, info))
			{
				return ParsingStatus.Failed;
			}
			if (!TryNumberToDecimal(ref number, ref result))
			{
				return ParsingStatus.Overflow;
			}
			return ParsingStatus.OK;
		}

		internal unsafe static bool TryParseDouble(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out double result)
		{
			byte* digits = stackalloc byte[769];
			NumberBuffer number = new NumberBuffer(NumberBufferKind.FloatingPoint, digits, 769);
			if (!TryStringToNumber(value, styles, ref number, info))
			{
				ReadOnlySpan<char> span = value.Trim();
				if (span.EqualsOrdinalIgnoreCase(info.PositiveInfinitySymbol.AsSpan()))
				{
					result = double.PositiveInfinity;
				}
				else if (span.EqualsOrdinalIgnoreCase(info.NegativeInfinitySymbol.AsSpan()))
				{
					result = double.NegativeInfinity;
				}
				else if (span.EqualsOrdinalIgnoreCase(info.NaNSymbol.AsSpan()))
				{
					result = double.NaN;
				}
				else if (span.StartsWith(info.PositiveSign.AsSpan(), StringComparison.OrdinalIgnoreCase))
				{
					span = span.Slice(info.PositiveSign.Length);
					if (span.EqualsOrdinalIgnoreCase(info.PositiveInfinitySymbol.AsSpan()))
					{
						result = double.PositiveInfinity;
					}
					else
					{
						if (!span.EqualsOrdinalIgnoreCase(info.NaNSymbol.AsSpan()))
						{
							result = 0.0;
							return false;
						}
						result = double.NaN;
					}
				}
				else
				{
					if (!span.StartsWith(info.NegativeSign.AsSpan(), StringComparison.OrdinalIgnoreCase) || !span.Slice(info.NegativeSign.Length).EqualsOrdinalIgnoreCase(info.NaNSymbol.AsSpan()))
					{
						result = 0.0;
						return false;
					}
					result = double.NaN;
				}
			}
			else
			{
				result = NumberToDouble(ref number);
			}
			return true;
		}

		internal unsafe static bool TryParseSingle(ReadOnlySpan<char> value, NumberStyles styles, NumberFormatInfo info, out float result)
		{
			byte* digits = stackalloc byte[114];
			NumberBuffer number = new NumberBuffer(NumberBufferKind.FloatingPoint, digits, 114);
			if (!TryStringToNumber(value, styles, ref number, info))
			{
				ReadOnlySpan<char> span = value.Trim();
				if (span.EqualsOrdinalIgnoreCase(info.PositiveInfinitySymbol.AsSpan()))
				{
					result = float.PositiveInfinity;
				}
				else if (span.EqualsOrdinalIgnoreCase(info.NegativeInfinitySymbol.AsSpan()))
				{
					result = float.NegativeInfinity;
				}
				else if (span.EqualsOrdinalIgnoreCase(info.NaNSymbol.AsSpan()))
				{
					result = float.NaN;
				}
				else if (span.StartsWith(info.PositiveSign.AsSpan(), StringComparison.OrdinalIgnoreCase))
				{
					span = span.Slice(info.PositiveSign.Length);
					if (!info.PositiveInfinitySymbol.StartsWith(info.PositiveSign, StringComparison.OrdinalIgnoreCase) && span.EqualsOrdinalIgnoreCase(info.PositiveInfinitySymbol.AsSpan()))
					{
						result = float.PositiveInfinity;
					}
					else
					{
						if (info.NaNSymbol.StartsWith(info.PositiveSign, StringComparison.OrdinalIgnoreCase) || !span.EqualsOrdinalIgnoreCase(info.NaNSymbol.AsSpan()))
						{
							result = 0f;
							return false;
						}
						result = float.NaN;
					}
				}
				else
				{
					if (!span.StartsWith(info.NegativeSign.AsSpan(), StringComparison.OrdinalIgnoreCase) || info.NaNSymbol.StartsWith(info.NegativeSign, StringComparison.OrdinalIgnoreCase) || !span.Slice(info.NegativeSign.Length).EqualsOrdinalIgnoreCase(info.NaNSymbol.AsSpan()))
					{
						result = 0f;
						return false;
					}
					result = float.NaN;
				}
			}
			else
			{
				result = NumberToSingle(ref number);
			}
			return true;
		}

		internal unsafe static bool TryStringToNumber(ReadOnlySpan<char> value, NumberStyles styles, ref NumberBuffer number, NumberFormatInfo info)
		{
			fixed (char* reference = &MemoryMarshal.GetReference(value))
			{
				char* str = reference;
				if (!TryParseNumber(ref str, str + value.Length, styles, ref number, info) || ((int)(str - reference) < value.Length && !TrailingZeros(value, (int)(str - reference))))
				{
					return false;
				}
			}
			return true;
		}

		private static bool TrailingZeros(ReadOnlySpan<char> value, int index)
		{
			for (int i = index; (uint)i < (uint)value.Length; i++)
			{
				if (value[i] != 0)
				{
					return false;
				}
			}
			return true;
		}

		private static bool IsSpaceReplacingChar(char c)
		{
			if (c != '\u00a0')
			{
				return c == '\u202f';
			}
			return true;
		}

		private unsafe static char* MatchChars(char* p, char* pEnd, string value)
		{
			fixed (char* ptr = value)
			{
				char* ptr2 = ptr;
				if (*ptr2 != 0)
				{
					while (true)
					{
						char c = ((p < pEnd) ? (*p) : '\0');
						if (c != *ptr2 && (!IsSpaceReplacingChar(*ptr2) || c != ' '))
						{
							break;
						}
						p++;
						ptr2++;
						if (*ptr2 == '\0')
						{
							return p;
						}
					}
				}
			}
			return null;
		}

		private static bool IsWhite(int ch)
		{
			if (ch != 32 && (uint)(ch - 9) > 4u)
			{
				return false;
			}
			return true;
		}

		private static bool IsDigit(int ch)
		{
			return (uint)(ch - 48) <= 9u;
		}

		internal static void ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type = TypeCode.Empty)
		{
			throw GetException(status, type);
		}

		internal static void ThrowOverflowException(TypeCode type)
		{
			throw GetException(ParsingStatus.Overflow, type);
		}

		private static Exception GetException(ParsingStatus status, TypeCode type)
		{
			if (status == ParsingStatus.Failed)
			{
				return new FormatException();
			}
			return new OverflowException(type switch
			{
				TypeCode.SByte => "SR.Overflow_SByte", 
				TypeCode.Byte => "SR.Overflow_Byte", 
				TypeCode.Int16 => "SR.Overflow_Int16", 
				TypeCode.UInt16 => "SR.Overflow_UInt16", 
				TypeCode.Int32 => "SR.Overflow_Int32", 
				TypeCode.UInt32 => "SR.Overflow_UInt32", 
				TypeCode.Int64 => "SR.Overflow_Int64", 
				TypeCode.UInt64 => "SR.Overflow_UInt64", 
				_ => "SR.Overflow_Decimal", 
			});
		}

		internal static double NumberToDouble(ref NumberBuffer number)
		{
			double num = ((number.DigitsCount == 0 || number.Scale < -324) ? 0.0 : ((number.Scale <= 309) ? BitConverter.Int64BitsToDouble((long)NumberToFloatingPointBits(ref number, in FloatingPointInfo.Double)) : double.PositiveInfinity));
			if (!number.IsNegative)
			{
				return num;
			}
			return 0.0 - num;
		}

		internal static float NumberToSingle(ref NumberBuffer number)
		{
			float num = ((number.DigitsCount == 0 || number.Scale < -45) ? 0f : ((number.Scale <= 39) ? Int32BitsToSingle((int)NumberToFloatingPointBits(ref number, in FloatingPointInfo.Single)) : float.PositiveInfinity));
			if (!number.IsNegative)
			{
				return num;
			}
			return 0f - num;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static float Int32BitsToSingle(int value)
		{
			return *(float*)(&value);
		}
	}
	internal static class NumberFormatInfoEx
	{
		internal static bool HasInvariantNumberSigns(this NumberFormatInfo info)
		{
			if (info.PositiveSign == "+")
			{
				return info.NegativeSign == "-";
			}
			return false;
		}
	}
}
namespace System.Text
{
	internal ref struct ValueStringBuilder
	{
		private char[]? _arrayToReturnToPool;

		private Span<char> _chars;

		private int _pos;

		public int Length
		{
			get
			{
				return _pos;
			}
			set
			{
				_pos = value;
			}
		}

		public int Capacity => _chars.Length;

		public ref char this[int index] => ref _chars[index];

		public Span<char> RawChars => _chars;

		public ValueStringBuilder(Span<char> initialBuffer)
		{
			_arrayToReturnToPool = null;
			_chars = initialBuffer;
			_pos = 0;
		}

		public ValueStringBuilder(int initialCapacity)
		{
			_arrayToReturnToPool = ArrayPool<char>.Shared.Rent(initialCapacity);
			_chars = _arrayToReturnToPool;
			_pos = 0;
		}

		public void EnsureCapacity(int capacity)
		{
			if (capacity > _chars.Length)
			{
				Grow(capacity - _pos);
			}
		}

		public ref char GetPinnableReference()
		{
			return ref MemoryMarshal.GetReference(_chars);
		}

		public ref char GetPinnableReference(bool terminate)
		{
			if (terminate)
			{
				EnsureCapacity(Length + 1);
				_chars[Length] = '\0';
			}
			return ref MemoryMarshal.GetReference(_chars);
		}

		public override string ToString()
		{
			string result = _chars.Slice(0, _pos).ToString();
			Dispose();
			return result;
		}

		public ReadOnlySpan<char> AsSpan(bool terminate)
		{
			if (terminate)
			{
				EnsureCapacity(Length + 1);
				_chars[Length] = '\0';
			}
			return _chars.Slice(0, _pos);
		}

		public ReadOnlySpan<char> AsSpan()
		{
			return _chars.Slice(0, _pos);
		}

		public ReadOnlySpan<char> AsSpan(int start)
		{
			return _chars.Slice(start, _pos - start);
		}

		public ReadOnlySpan<char> AsSpan(int start, int length)
		{
			return _chars.Slice(start, length);
		}

		public bool TryCopyTo(Span<char> destination, out int charsWritten)
		{
			if (_chars.Slice(0, _pos).TryCopyTo(destination))
			{
				charsWritten = _pos;
				Dispose();
				return true;
			}
			charsWritten = 0;
			Dispose();
			return false;
		}

		public void Insert(int index, char value, int count)
		{
			if (_pos > _chars.Length - count)
			{
				Grow(count);
			}
			int length = _pos - index;
			_chars.Slice(index, length).CopyTo(_chars.Slice(index + count));
			_chars.Slice(index, count).Fill(value);
			_pos += count;
		}

		public void Insert(int index, string s)
		{
			if (s != null)
			{
				int length = s.Length;
				if (_pos > _chars.Length - length)
				{
					Grow(length);
				}
				int length2 = _pos - index;
				_chars.Slice(index, length2).CopyTo(_chars.Slice(index + length));
				s.AsSpan().CopyTo(_chars.Slice(index));
				_pos += length;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(char c)
		{
			int pos = _pos;
			if ((uint)pos < (uint)_chars.Length)
			{
				_chars[pos] = c;
				_pos = pos + 1;
			}
			else
			{
				GrowAndAppend(c);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(string s)
		{
			if (s != null)
			{
				int pos = _pos;
				if (s.Length == 1 && (uint)pos < (uint)_chars.Length)
				{
					_chars[pos] = s[0];
					_pos = pos + 1;
				}
				else
				{
					AppendSlow(s);
				}
			}
		}

		private void AppendSlow(string s)
		{
			int pos = _pos;
			if (pos > _chars.Length - s.Length)
			{
				Grow(s.Length);
			}
			s.AsSpan().CopyTo(_chars.Slice(pos));
			_pos += s.Length;
		}

		public void Append(char c, int count)
		{
			if (_pos > _chars.Length - count)
			{
				Grow(count);
			}
			Span<char> span = _chars.Slice(_pos, count);
			for (int i = 0; i < span.Length; i++)
			{
				span[i] = c;
			}
			_pos += count;
		}

		public unsafe void Append(char* value, int length)
		{
			if (_pos > _chars.Length - length)
			{
				Grow(length);
			}
			Span<char> span = _chars.Slice(_pos, length);
			for (int i = 0; i < span.Length; i++)
			{
				span[i] = *(value++);
			}
			_pos += length;
		}

		public void Append(ReadOnlySpan<char> value)
		{
			if (_pos > _chars.Length - value.Length)
			{
				Grow(value.Length);
			}
			value.CopyTo(_chars.Slice(_pos));
			_pos += value.Length;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Span<char> AppendSpan(int length)
		{
			int pos = _pos;
			if (pos > _chars.Length - length)
			{
				Grow(length);
			}
			_pos = pos + length;
			return _chars.Slice(pos, length);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private void GrowAndAppend(char c)
		{
			Grow(1);
			Append(c);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private void Grow(int additionalCapacityBeyondPos)
		{
			char[] array = ArrayPool<char>.Shared.Rent(Math.Max(_pos + additionalCapacityBeyondPos, _chars.Length * 2));
			_chars.Slice(0, _pos).CopyTo(array);
			char[] arrayToReturnToPool = _arrayToReturnToPool;
			_chars = (_arrayToReturnToPool = array);
			if (arrayToReturnToPool != null)
			{
				ArrayPool<char>.Shared.Return(arrayToReturnToPool);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Dispose()
		{
			char[] arrayToReturnToPool = _arrayToReturnToPool;
			this = default(System.Text.ValueStringBuilder);
			if (arrayToReturnToPool != null)
			{
				ArrayPool<char>.Shared.Return(arrayToReturnToPool);
			}
		}
	}
}
namespace System.Buffers.Text
{
	internal static class FormattingHelpers
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int CountDigits(ulong value)
		{
			int num = 1;
			uint num2;
			if (value >= 10000000)
			{
				if (value >= 100000000000000L)
				{
					num2 = (uint)(value / 100000000000000L);
					num += 14;
				}
				else
				{
					num2 = (uint)(value / 10000000);
					num += 7;
				}
			}
			else
			{
				num2 = (uint)value;
			}
			if (num2 >= 10)
			{
				num = ((num2 < 100) ? (num + 1) : ((num2 < 1000) ? (num + 2) : ((num2 < 10000) ? (num + 3) : ((num2 < 100000) ? (num + 4) : ((num2 >= 1000000) ? (num + 6) : (num + 5))))));
			}
			return num;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int CountDigits(uint value)
		{
			int num = 1;
			if (value >= 100000)
			{
				value /= 100000;
				num += 5;
			}
			if (value >= 10)
			{
				num = ((value < 100) ? (num + 1) : ((value < 1000) ? (num + 2) : ((value >= 10000) ? (num + 4) : (num + 3))));
			}
			return num;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int CountHexDigits(ulong value)
		{
			return 64 - BitOperations.LeadingZeroCount(value | 1) + 3 >> 2;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int CountDecimalTrailingZeros(uint value, out uint valueWithoutTrailingZeros)
		{
			int num = 0;
			if (value != 0)
			{
				while (true)
				{
					uint num2 = value / 10;
					if (value != num2 * 10)
					{
						break;
					}
					value = num2;
					num++;
				}
			}
			valueWithoutTrailingZeros = value;
			return num;
		}
	}
}
namespace System.Numerics
{
	internal static class BitOperations
	{
		private static ReadOnlySpan<byte> TrailingZeroCountDeBruijn => new byte[32]
		{
			0, 1, 28, 2, 29, 14, 24, 3, 30, 22,
			20, 15, 25, 17, 4, 8, 31, 27, 13, 23,
			21, 19, 16, 7, 26, 12, 18, 6, 11, 5,
			10, 9
		};

		private static ReadOnlySpan<byte> Log2DeBruijn => new byte[32]
		{
			0, 9, 1, 10, 13, 21, 2, 29, 11, 14,
			16, 18, 22, 25, 3, 30, 8, 12, 20, 28,
			15, 17, 24, 7, 19, 27, 23, 6, 26, 5,
			4, 31
		};

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int LeadingZeroCount(uint value)
		{
			if (value == 0)
			{
				return 32;
			}
			return 31 - Log2SoftwareFallback(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int LeadingZeroCount(ulong value)
		{
			uint num = (uint)(value >> 32);
			if (num == 0)
			{
				return 32 + LeadingZeroCount((uint)value);
			}
			return LeadingZeroCount(num);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int Log2(uint value)
		{
			return Log2SoftwareFallback(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int Log2(ulong value)
		{
			uint num = (uint)(value >> 32);
			if (num == 0)
			{
				return Log2((uint)value);
			}
			return 32 + Log2(num);
		}

		private static int Log2SoftwareFallback(uint value)
		{
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			return Unsafe.AddByteOffset(ref MemoryMarshal.GetReference(Log2DeBruijn), (IntPtr)(int)(value * 130329821 >> 27));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int PopCount(uint value)
		{
			value -= (value >> 1) & 0x55555555;
			value = (value & 0x33333333) + ((value >> 2) & 0x33333333);
			value = ((value + (value >> 4)) & 0xF0F0F0F) * 16843009 >> 24;
			return (int)value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int PopCount(ulong value)
		{
			if (IntPtr.Size == 4)
			{
				return PopCount((uint)value) + PopCount((uint)(value >> 32));
			}
			value -= (value >> 1) & 0x5555555555555555L;
			value = (value & 0x3333333333333333L) + ((value >> 2) & 0x3333333333333333L);
			value = ((value + (value >> 4)) & 0xF0F0F0F0F0F0F0FL) * 72340172838076673L >> 56;
			return (int)value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int TrailingZeroCount(int value)
		{
			return TrailingZeroCount((uint)value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int TrailingZeroCount(uint value)
		{
			if (value == 0)
			{
				return 32;
			}
			return Unsafe.AddByteOffset(ref MemoryMarshal.GetReference(TrailingZeroCountDeBruijn), (IntPtr)(int)((value & (0 - value)) * 125613361 >> 27));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int TrailingZeroCount(long value)
		{
			return TrailingZeroCount((ulong)value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int TrailingZeroCount(ulong value)
		{
			uint num = (uint)value;
			if (num == 0)
			{
				return 32 + TrailingZeroCount((uint)(value >> 32));
			}
			return TrailingZeroCount(num);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static uint RotateLeft(uint value, int offset)
		{
			return (value << offset) | (value >> 32 - offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ulong RotateLeft(ulong value, int offset)
		{
			return (value << offset) | (value >> 64 - offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static uint RotateRight(uint value, int offset)
		{
			return (value >> offset) | (value << 32 - offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ulong RotateRight(ulong value, int offset)
		{
			return (value >> offset) | (value << 64 - offset);
		}
	}
}
namespace Cysharp.Text
{
	internal static class EnumUtil<T>
	{
		private const string InvalidName = "$";

		private static readonly Dictionary<T, string> names;

		private static readonly Dictionary<T, byte[]> utf8names;

		static EnumUtil()
		{
			string[] array = Enum.GetNames(typeof(T));
			Array values = Enum.GetValues(typeof(T));
			names = new Dictionary<T, string>(array.Length);
			utf8names = new Dictionary<T, byte[]>(array.Length);
			for (int i = 0; i < array.Length; i++)
			{
				T key = (T)values.GetValue(i);
				if (names.ContainsKey(key))
				{
					names[key] = "$";
					utf8names[key] = Array.Empty<byte>();
				}
				else
				{
					names.Add(key, array[i]);
					utf8names.Add(key, Encoding.UTF8.GetBytes(array[i]));
				}
			}
		}

		public static bool TryFormatUtf16(T value, Span<char> dest, out int written, ReadOnlySpan<char> _)
		{
			if (!names.TryGetValue(value, out string value2) || value2 == "$")
			{
				value2 = value.ToString();
			}
			written = value2.Length;
			return value2.AsSpan().TryCopyTo(dest);
		}

		public static bool TryFormatUtf8(T value, Span<byte> dest, out int written, StandardFormat _)
		{
			if (!utf8names.TryGetValue(value, out byte[] value2) || value2.Length == 0)
			{
				value2 = Encoding.UTF8.GetBytes(value.ToString());
			}
			written = value2.Length;
			return value2.AsSpan().TryCopyTo(dest);
		}
	}
	internal static class ExceptionUtil
	{
		internal static void ThrowArgumentException(string paramName)
		{
			throw new ArgumentException("Can't format argument.", paramName);
		}

		internal static void ThrowFormatException()
		{
			throw new FormatException("Index (zero based) must be greater than or equal to zero and less than the size of the argument list.");
		}

		internal static void ThrowFormatError()
		{
			throw new FormatException("Input string was not in a correct format.");
		}
	}
	internal static class FastNumberWriter
	{
		public static bool TryWriteInt64(Span<char> buffer, out int charsWritten, long value)
		{
			int num = 0;
			charsWritten = 0;
			long num2 = value;
			if (value < 0)
			{
				if (value == long.MinValue)
				{
					if (buffer.Length < 20)
					{
						return false;
					}
					buffer[num++] = '-';
					buffer[num++] = '9';
					buffer[num++] = '2';
					buffer[num++] = '2';
					buffer[num++] = '3';
					buffer[num++] = '3';
					buffer[num++] = '7';
					buffer[num++] = '2';
					buffer[num++] = '0';
					buffer[num++] = '3';
					buffer[num++] = '6';
					buffer[num++] = '8';
					buffer[num++] = '5';
					buffer[num++] = '4';
					buffer[num++] = '7';
					buffer[num++] = '7';
					buffer[num++] = '5';
					buffer[num++] = '8';
					buffer[num++] = '0';
					buffer[num++] = '8';
					charsWritten = num;
					return true;
				}
				if (buffer.Length < 1)
				{
					return false;
				}
				buffer[num++] = '-';
				num2 = -value;
			}
			if (num2 < 10000)
			{
				if (num2 < 10)
				{
					if (buffer.Length < 1)
					{
						return false;
					}
					goto IL_0677;
				}
				if (num2 < 100)
				{
					if (buffer.Length < 2)
					{
						return false;
					}
					goto IL_064e;
				}
				if (num2 < 1000)
				{
					if (buffer.Length < 3)
					{
						return false;
					}
					goto IL_0625;
				}
				if (buffer.Length < 4)
				{
					return false;
				}
				goto IL_05f9;
			}
			long num3 = num2 / 10000;
			num2 -= num3 * 10000;
			if (num3 < 10000)
			{
				if (num3 < 10)
				{
					if (buffer.Length < 5)
					{
						return false;
					}
					goto IL_05e6;
				}
				if (num3 < 100)
				{
					if (buffer.Length < 6)
					{
						return false;
					}
					goto IL_05bd;
				}
				if (num3 < 1000)
				{
					if (buffer.Length < 7)
					{
						return false;
					}
					goto IL_0594;
				}
				if (buffer.Length < 8)
				{
					return false;
				}
				goto IL_0568;
			}
			long num4 = num3 / 10000;
			num3 -= num4 * 10000;
			if (num4 < 10000)
			{
				if (num4 < 10)
				{
					if (buffer.Length < 9)
					{
						return false;
					}
					goto IL_0555;
				}
				if (num4 < 100)
				{
					if (buffer.Length < 10)
					{
						return false;
					}
					goto IL_052c;
				}
				if (num4 < 1000)
				{
					if (buffer.Length < 11)
					{
						return false;
					}
					goto IL_0503;
				}
				if (buffer.Length < 12)
				{
					return false;
				}
				goto IL_04d7;
			}
			long num5 = num4 / 10000;
			num4 -= num5 * 10000;
			if (num5 < 10000)
			{
				if (num5 < 10)
				{
					if (buffer.Length < 13)
					{
						return false;
					}
					goto IL_04c3;
				}
				if (num5 < 100)
				{
					if (buffer.Length < 14)
					{
						return false;
					}
					goto IL_0497;
				}
				if (num5 < 1000)
				{
					if (buffer.Length < 15)
					{
						return false;
					}
					goto IL_046b;
				}
				if (buffer.Length < 16)
				{
					return false;
				}
				goto IL_043c;
			}
			long num6 = num5 / 10000;
			num5 -= num6 * 10000;
			if (num6 < 10000)
			{
				if (num6 < 10)
				{
					if (buffer.Length < 17)
					{
						return false;
					}
					goto IL_0428;
				}
				if (num6 < 100)
				{
					if (buffer.Length < 18)
					{
						return false;
					}
					goto IL_03fc;
				}
				if (num6 < 1000)
				{
					if (buffer.Length < 19)
					{
						return false;
					}
					goto IL_03d0;
				}
				if (buffer.Length < 20)
				{
					return false;
				}
			}
			long num7;
			buffer[num++] = (char)(48 + (num7 = num6 * 8389 >> 23));
			num6 -= num7 * 1000;
			goto IL_03d0;
			IL_043c:
			buffer[num++] = (char)(48 + (num7 = num5 * 8389 >> 23));
			num5 -= num7 * 1000;
			goto IL_046b;
			IL_0497:
			buffer[num++] = (char)(48 + (num7 = num5 * 6554 >> 16));
			num5 -= num7 * 10;
			goto IL_04c3;
			IL_05f9:
			buffer[num++] = (char)(48 + (num7 = num2 * 8389 >> 23));
			num2 -= num7 * 1000;
			goto IL_0625;
			IL_0555:
			buffer[num++] = (char)(48 + num4);
			goto IL_0568;
			IL_0594:
			buffer[num++] = (char)(48 + (num7 = num3 * 5243 >> 19));
			num3 -= num7 * 100;
			goto IL_05bd;
			IL_0568:
			buffer[num++] = (char)(48 + (num7 = num3 * 8389 >> 23));
			num3 -= num7 * 1000;
			goto IL_0594;
			IL_0503:
			buffer[num++] = (char)(48 + (num7 = num4 * 5243 >> 19));
			num4 -= num7 * 100;
			goto IL_052c;
			IL_04d7:
			buffer[num++] = (char)(48 + (num7 = num4 * 8389 >> 23));
			num4 -= num7 * 1000;
			goto IL_0503;
			IL_052c:
			buffer[num++] = (char)(48 + (num7 = num4 * 6554 >> 16));
			num4 -= num7 * 10;
			goto IL_0555;
			IL_064e:
			buffer[num++] = (char)(48 + (num7 = num2 * 6554 >> 16));
			num2 -= num7 * 10;
			goto IL_0677;
			IL_0677:
			buffer[num++] = (char)(48 + num2);
			charsWritten = num;
			return true;
			IL_0428:
			buffer[num++] = (char)(48 + num6);
			goto IL_043c;
			IL_0625:
			buffer[num++] = (char)(48 + (num7 = num2 * 5243 >> 19));
			num2 -= num7 * 100;
			goto IL_064e;
			IL_05bd:
			buffer[num++] = (char)(48 + (num7 = num3 * 6554 >> 16));
			num3 -= num7 * 10;
			goto IL_05e6;
			IL_046b:
			buffer[num++] = (char)(48 + (num7 = num5 * 5243 >> 19));
			num5 -= num7 * 100;
			goto IL_0497;
			IL_03d0:
			buffer[num++] = (char)(48 + (num7 = num6 * 5243 >> 19));
			num6 -= num7 * 100;
			goto IL_03fc;
			IL_05e6:
			buffer[num++] = (char)(48 + num3);
			goto IL_05f9;
			IL_04c3:
			buffer[num++] = (char)(48 + num5);
			goto IL_04d7;
			IL_03fc:
			buffer[num++] = (char)(48 + (num7 = num6 * 6554 >> 16));
			num6 -= num7 * 10;
			goto IL_0428;
		}

		public static bool TryWriteUInt64(Span<char> buffer, out int charsWritten, ulong value)
		{
			ulong num = value;
			charsWritten = 0;
			int num2 = 0;
			if (num < 10000)
			{
				if (num < 10)
				{
					if (buffer.Length < 1)
					{
						return false;
					}
					goto IL_0518;
				}
				if (num < 100)
				{
					if (buffer.Length < 2)
					{
						return false;
					}
					goto IL_04ed;
				}
				if (num < 1000)
				{
					if (buffer.Length < 3)
					{
						return false;
					}
					goto IL_04c2;
				}
				if (buffer.Length < 4)
				{
					return false;
				}
				goto IL_0494;
			}
			ulong num3 = num / 10000;
			num -= num3 * 10000;
			if (num3 < 10000)
			{
				if (num3 < 10)
				{
					if (buffer.Length < 5)
					{
						return false;
					}
					goto IL_047f;
				}
				if (num3 < 100)
				{
					if (buffer.Length < 6)
					{
						return false;
					}
					goto IL_0454;
				}
				if (num3 < 1000)
				{
					if (buffer.Length < 7)
					{
						return false;
					}
					goto IL_0429;
				}
				if (buffer.Length < 8)
				{
					return false;
				}
				goto IL_03fb;
			}
			ulong num4 = num3 / 10000;
			num3 -= num4 * 10000;
			if (num4 < 10000)
			{
				if (num4 < 10)
				{
					if (buffer.Length < 9)
					{
						return false;
					}
					goto IL_03e6;
				}
				if (num4 < 100)
				{
					if (buffer.Length < 10)
					{
						return false;
					}
					goto IL_03bb;
				}
				if (num4 < 1000)
				{
					if (buffer.Length < 11)
					{
						return false;
					}
					goto IL_0390;
				}
				if (buffer.Length < 12)
				{
					return false;
				}
				goto IL_0362;
			}
			ulong num5 = num4 / 10000;
			num4 -= num5 * 10000;
			if (num5 < 10000)
			{
				if (num5 < 10)
				{
					if (buffer.Length < 13)
					{
						return false;
					}
					goto IL_034d;
				}
				if (num5 < 100)
				{
					if (buffer.Length < 14)
					{
						return false;
					}
					goto IL_0322;
				}
				if (num5 < 1000)
				{
					if (buffer.Length < 15)
					{
						return false;
					}
					goto IL_02f7;
				}
				if (buffer.Length < 16)
				{
					return false;
				}
				goto IL_02c9;
			}
			ulong num6 = num5 / 10000;
			num5 -= num6 * 10000;
			if (num6 < 10000)
			{
				if (num6 < 10)
				{
					if (buffer.Length < 17)
					{
						return false;
					}
					goto IL_02b3;
				}
				if (num6 < 100)
				{
					if (buffer.Length < 18)
					{
						return false;
					}
					goto IL_0285;
				}
				if (num6 < 1000)
				{
					if (buffer.Length < 19)
					{
						return false;
					}
					goto IL_0257;
				}
				if (buffer.Length < 20)
				{
					return false;
				}
			}
			ulong num7;
			buffer[num2++] = (char)(48 + (num7 = num6 * 8389 >> 23));
			num6 -= num7 * 1000;
			goto IL_0257;
			IL_0390:
			buffer[num2++] = (char)(48 + (num7 = num4 * 5243 >> 19));
			num4 -= num7 * 100;
			goto IL_03bb;
			IL_034d:
			buffer[num2++] = (char)(48 + num5);
			goto IL_0362;
			IL_03bb:
			buffer[num2++] = (char)(48 + (num7 = num4 * 6554 >> 16));
			num4 -= num7 * 10;
			goto IL_03e6;
			IL_0429:
			buffer[num2++] = (char)(48 + (num7 = num3 * 5243 >> 19));
			num3 -= num7 * 100;
			goto IL_0454;
			IL_0494:
			buffer[num2++] = (char)(48 + (num7 = num * 8389 >> 23));
			num -= num7 * 1000;
			goto IL_04c2;
			IL_03fb:
			buffer[num2++] = (char)(48 + (num7 = num3 * 8389 >> 23));
			num3 -= num7 * 1000;
			goto IL_0429;
			IL_03e6:
			buffer[num2++] = (char)(48 + num4);
			goto IL_03fb;
			IL_0454:
			buffer[num2++] = (char)(48 + (num7 = num3 * 6554 >> 16));
			num3 -= num7 * 10;
			goto IL_047f;
			IL_0362:
			buffer[num2++] = (char)(48 + (num7 = num4 * 8389 >> 23));
			num4 -= num7 * 1000;
			goto IL_0390;
			IL_02c9:
			buffer[num2++] = (char)(48 + (num7 = num5 * 8389 >> 23));
			num5 -= num7 * 1000;
			goto IL_02f7;
			IL_02f7:
			buffer[num2++] = (char)(48 + (num7 = num5 * 5243 >> 19));
			num5 -= num7 * 100;
			goto IL_0322;
			IL_0257:
			buffer[num2++] = (char)(48 + (num7 = num6 * 5243 >> 19));
			num6 -= num7 * 100;
			goto IL_0285;
			IL_0518:
			buffer[num2++] = (char)(48 + num);
			charsWritten = num2;
			return true;
			IL_0322:
			buffer[num2++] = (char)(48 + (num7 = num5 * 6554 >> 16));
			num5 -= num7 * 10;
			goto IL_034d;
			IL_0285:
			buffer[num2++] = (char)(48 + (num7 = num6 * 6554 >> 16));
			num6 -= num7 * 10;
			goto IL_02b3;
			IL_04ed:
			buffer[num2++] = (char)(48 + (num7 = num * 6554 >> 16));
			num -= num7 * 10;
			goto IL_0518;
			IL_047f:
			buffer[num2++] = (char)(48 + num3);
			goto IL_0494;
			IL_02b3:
			buffer[num2++] = (char)(48 + num6);
			goto IL_02c9;
			IL_04c2:
			buffer[num2++] = (char)(48 + (num7 = num * 5243 >> 19));
			num -= num7 * 100;
			goto IL_04ed;
		}
	}
	internal static class Utf16FormatHelper
	{
		private const char sp = ' ';

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void FormatTo<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, ReadOnlySpan<char> format, string argName) where TBufferWriter : IBufferWriter<char>
		{
			if (width <= 0)
			{
				Span<char> span = sb.GetSpan();
				if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out var charsWritten, format))
				{
					sb.Advance(0);
					int sizeHint = Math.Max(span.Length + 1, charsWritten);
					span = sb.GetSpan(sizeHint);
					if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out charsWritten, format))
					{
						ExceptionUtil.ThrowArgumentException(argName);
					}
				}
				int count = charsWritten;
				sb.Advance(count);
				width *= -1;
				int num = width - charsWritten;
				if (width > 0 && num > 0)
				{
					sb.GetSpan(num).Fill(' ');
					sb.Advance(num);
				}
			}
			else
			{
				FormatToRightJustify(ref sb, arg, width, format, argName);
			}
		}

		private static void FormatToRightJustify<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, ReadOnlySpan<char> format, string argName) where TBufferWriter : IBufferWriter<char>
		{
			if (typeof(T) == typeof(string))
			{
				string text = Unsafe.As<string>(arg);
				int num = width - text.Length;
				if (num > 0)
				{
					sb.GetSpan(num).Fill(' ');
					sb.Advance(num);
				}
				int length = text.Length;
				Span<char> span = sb.GetSpan(length);
				text.AsSpan().CopyTo(span);
				int length2 = text.Length;
				sb.Advance(length2);
				return;
			}
			Span<char> destination = stackalloc char[typeof(T).IsValueType ? (Unsafe.SizeOf<T>() * 8) : 1024];
			if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, destination, out var charsWritten, format))
			{
				destination = stackalloc char[destination.Length * 2];
				if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, destination, out charsWritten, format))
				{
					ExceptionUtil.ThrowArgumentException(argName);
				}
			}
			int num2 = width - charsWritten;
			if (num2 > 0)
			{
				sb.GetSpan(num2).Fill(' ');
				sb.Advance(num2);
			}
			int sizeHint = charsWritten;
			Span<char> span2 = sb.GetSpan(sizeHint);
			destination.CopyTo(span2);
			int count = charsWritten;
			sb.Advance(count);
		}
	}
	internal static class Utf8FormatHelper
	{
		private const byte sp = 32;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void FormatTo<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, StandardFormat format, string argName) where TBufferWriter : IBufferWriter<byte>
		{
			if (width <= 0)
			{
				Span<byte> span = sb.GetSpan();
				if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out var written, format))
				{
					sb.Advance(0);
					int sizeHint = Math.Max(span.Length + 1, written);
					span = sb.GetSpan(sizeHint);
					if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out written, format))
					{
						ExceptionUtil.ThrowArgumentException(argName);
					}
				}
				int count = written;
				sb.Advance(count);
				width *= -1;
				int num = width - written;
				if (width > 0 && num > 0)
				{
					sb.GetSpan(num).Fill(32);
					sb.Advance(num);
				}
			}
			else
			{
				FormatToRightJustify(ref sb, arg, width, format, argName);
			}
		}

		private static void FormatToRightJustify<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, StandardFormat format, string argName) where TBufferWriter : IBufferWriter<byte>
		{
			if (typeof(T) == typeof(string))
			{
				string text = Unsafe.As<string>(arg);
				int num = width - text.Length;
				if (num > 0)
				{
					sb.GetSpan(num).Fill(32);
					sb.Advance(num);
				}
				ZString.AppendChars(ref sb, text.AsSpan());
				return;
			}
			Span<byte> destination = stackalloc byte[typeof(T).IsValueType ? (Unsafe.SizeOf<T>() * 8) : 1024];
			if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, destination, out var written, format))
			{
				destination = stackalloc byte[destination.Length * 2];
				if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, destination, out written, format))
				{
					ExceptionUtil.ThrowArgumentException(argName);
				}
			}
			int num2 = width - written;
			if (num2 > 0)
			{
				sb.GetSpan(num2).Fill(32);
				sb.Advance(num2);
			}
			int sizeHint = written;
			Span<byte> span = sb.GetSpan(sizeHint);
			destination.CopyTo(span);
			int count = written;
			sb.Advance(count);
		}
	}
	internal static class FormatParser
	{
		public readonly ref struct ParseResult
		{
			public readonly int Index;

			public readonly ReadOnlySpan<char> FormatString;

			public readonly int LastIndex;

			public readonly int Alignment;

			public ParseResult(int index, ReadOnlySpan<char> formatString, int lastIndex, int alignment)
			{
				Index = index;
				FormatString = formatString;
				LastIndex = lastIndex;
				Alignment = alignment;
			}
		}

		internal const int ArgLengthLimit = 16;

		internal const int WidthLimit = 1000;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ParserScanResult ScanFormatString(string format, ref int i)
		{
			int length = format.Length;
			char c = format[i];
			i++;
			switch (c)
			{
			case '}':
				if (i < length && format[i] == '}')
				{
					i++;
					return ParserScanResult.EscapedChar;
				}
				ExceptionUtil.ThrowFormatError();
				return ParserScanResult.NormalChar;
			case '{':
				if (i < length && format[i] == '{')
				{
					i++;
					return ParserScanResult.EscapedChar;
				}
				i--;
				return ParserScanResult.BraceOpen;
			default:
				return ParserScanResult.NormalChar;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ParserScanResult ScanFormatString(ReadOnlySpan<char> format, ref int i)
		{
			int length = format.Length;
			char c = format[i];
			i++;
			switch (c)
			{
			case '}':
				if (i < length && format[i] == '}')
				{
					i++;
					return ParserScanResult.EscapedChar;
				}
				ExceptionUtil.ThrowFormatError();
				return ParserScanResult.NormalChar;
			case '{':
				if (i < length && format[i] == '{')
				{
					i++;
					return ParserScanResult.EscapedChar;
				}
				i--;
				return ParserScanResult.BraceOpen;
			default:
				return ParserScanResult.NormalChar;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static bool IsDigit(char c)
		{
			if ('0' <= c)
			{
				return c <= '9';
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ParseResult Parse(ReadOnlySpan<char> format, int i)
		{
			char c = '\0';
			int length = format.Length;
			i++;
			if (i == length || !IsDigit(c = format[i]))
			{
				ExceptionUtil.ThrowFormatError();
			}
			int num = 0;
			do
			{
				num = num * 10 + c - 48;
				if (++i == length)
				{
					ExceptionUtil.ThrowFormatError();
				}
				c = format[i];
			}
			while (IsDigit(c) && num < 16);
			if (num >= 16)
			{
				ExceptionUtil.ThrowFormatException();
			}
			while (i < length && (c = format[i]) == ' ')
			{
				i++;
			}
			int num2 = 0;
			if (c == ',')
			{
				i++;
				while (i < length && (c = format[i]) == ' ')
				{
					i++;
				}
				if (i == length)
				{
					ExceptionUtil.ThrowFormatError();
				}
				bool flag = false;
				if (c == '-')
				{
					flag = true;
					if (++i == length)
					{
						ExceptionUtil.ThrowFormatError();
					}
					c = format[i];
				}
				if (!IsDigit(c))
				{
					ExceptionUtil.ThrowFormatError();
				}
				do
				{
					num2 = num2 * 10 + c - 48;
					if (++i == length)
					{
						ExceptionUtil.ThrowFormatError();
					}
					c = format[i];
				}
				while (IsDigit(c) && num2 < 1000);
				if (flag)
				{
					num2 *= -1;
				}
			}
			while (i < length && (c = format[i]) == ' ')
			{
				i++;
			}
			ReadOnlySpan<char> formatString = default(ReadOnlySpan<char>);
			switch (c)
			{
			case ':':
			{
				i++;
				int num3 = i;
				while (true)
				{
					if (i == length)
					{
						ExceptionUtil.ThrowFormatError();
					}
					switch (format[i])
					{
					case '{':
						ExceptionUtil.ThrowFormatError();
						goto IL_016c;
					default:
						goto IL_016c;
					case '}':
						break;
					}
					break;
					IL_016c:
					i++;
				}
				if (i > num3)
				{
					formatString = format.Slice(num3, i - num3);
				}
				break;
			}
			default:
				ExceptionUtil.ThrowFormatError();
				break;
			case '}':
				break;
			}
			i++;
			return new ParseResult(num, formatString, i, num2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ParseResult Parse(string format, int i)
		{
			char c = '\0';
			int length = format.Length;
			i++;
			if (i == length || !IsDigit(c = format[i]))
			{
				ExceptionUtil.ThrowFormatError();
			}
			int num = 0;
			do
			{
				num = num * 10 + c - 48;
				if (++i == length)
				{
					ExceptionUtil.ThrowFormatError();
				}
				c = format[i];
			}
			while (IsDigit(c) && num < 16);
			if (num >= 16)
			{
				ExceptionUtil.ThrowFormatException();
			}
			while (i < length && (c = format[i]) == ' ')
			{
				i++;
			}
			int num2 = 0;
			if (c == ',')
			{
				i++;
				while (i < length && (c = format[i]) == ' ')
				{
					i++;
				}
				if (i == length)
				{
					ExceptionUtil.ThrowFormatError();
				}
				bool flag = false;
				if (c == '-')
				{
					flag = true;
					if (++i == length)
					{
						ExceptionUtil.ThrowFormatError();
					}
					c = format[i];
				}
				if (!IsDigit(c))
				{
					ExceptionUtil.ThrowFormatError();
				}
				do
				{
					num2 = num2 * 10 + c - 48;
					if (++i == length)
					{
						ExceptionUtil.ThrowFormatError();
					}
					c = format[i];
				}
				while (IsDigit(c) && num2 < 1000);
				if (flag)
				{
					num2 *= -1;
				}
			}
			while (i < length && (c = format[i]) == ' ')
			{
				i++;
			}
			ReadOnlySpan<char> formatString = default(ReadOnlySpan<char>);
			switch (c)
			{
			case ':':
			{
				i++;
				int num3 = i;
				while (true)
				{
					if (i == length)
					{
						ExceptionUtil.ThrowFormatError();
					}
					switch (format[i])
					{
					case '{':
						ExceptionUtil.ThrowFormatError();
						goto IL_015b;
					default:
						goto IL_015b;
					case '}':
						break;
					}
					break;
					IL_015b:
					i++;
				}
				if (i > num3)
				{
					formatString = format.AsSpan(num3, i - num3);
				}
				break;
			}
			default:
				ExceptionUtil.ThrowFormatError();
				break;
			case '}':
				break;
			}
			i++;
			return new ParseResult(num, formatString, i, num2);
		}
	}
	internal enum ParserScanResult
	{
		BraceOpen,
		EscapedChar,
		NormalChar
	}
	public interface IResettableBufferWriter<T> : IBufferWriter<T>
	{
		void Reset();
	}
	internal class NestedStringBuilderCreationException : InvalidOperationException
	{
		protected internal NestedStringBuilderCreationException(string typeName, string extraMessage = "")
			: base("A nested call with `notNested: true`, or Either You forgot to call " + typeName + ".Dispose() of  in the past." + extraMessage)
		{
		}

		protected internal NestedStringBuilderCreationException(string message, Exception innerException)
			: base(message, innerException)
		{
		}
	}
	public sealed class Utf16PreparedFormat<T1>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5, T6>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				case 5:
					Utf16FormatHelper.FormatTo(ref sb, arg6, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg6");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				case 5:
					Utf16FormatHelper.FormatTo(ref sb, arg6, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg6");
					break;
				case 6:
					Utf16FormatHelper.FormatTo(ref sb, arg7, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg7");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				case 5:
					Utf16FormatHelper.FormatTo(ref sb, arg6, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg6");
					break;
				case 6:
					Utf16FormatHelper.FormatTo(ref sb, arg7, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg7");
					break;
				case 7:
					Utf16FormatHelper.FormatTo(ref sb, arg8, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg8");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				case 5:
					Utf16FormatHelper.FormatTo(ref sb, arg6, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg6");
					break;
				case 6:
					Utf16FormatHelper.FormatTo(ref sb, arg7, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg7");
					break;
				case 7:
					Utf16FormatHelper.FormatTo(ref sb, arg8, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg8");
					break;
				case 8:
					Utf16FormatHelper.FormatTo(ref sb, arg9, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg9");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				case 5:
					Utf16FormatHelper.FormatTo(ref sb, arg6, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg6");
					break;
				case 6:
					Utf16FormatHelper.FormatTo(ref sb, arg7, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg7");
					break;
				case 7:
					Utf16FormatHelper.FormatTo(ref sb, arg8, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg8");
					break;
				case 8:
					Utf16FormatHelper.FormatTo(ref sb, arg9, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg9");
					break;
				case 9:
					Utf16FormatHelper.FormatTo(ref sb, arg10, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg10");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				case 5:
					Utf16FormatHelper.FormatTo(ref sb, arg6, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg6");
					break;
				case 6:
					Utf16FormatHelper.FormatTo(ref sb, arg7, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg7");
					break;
				case 7:
					Utf16FormatHelper.FormatTo(ref sb, arg8, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg8");
					break;
				case 8:
					Utf16FormatHelper.FormatTo(ref sb, arg9, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg9");
					break;
				case 9:
					Utf16FormatHelper.FormatTo(ref sb, arg10, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg10");
					break;
				case 10:
					Utf16FormatHelper.FormatTo(ref sb, arg11, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg11");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				case 5:
					Utf16FormatHelper.FormatTo(ref sb, arg6, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg6");
					break;
				case 6:
					Utf16FormatHelper.FormatTo(ref sb, arg7, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg7");
					break;
				case 7:
					Utf16FormatHelper.FormatTo(ref sb, arg8, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg8");
					break;
				case 8:
					Utf16FormatHelper.FormatTo(ref sb, arg9, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg9");
					break;
				case 9:
					Utf16FormatHelper.FormatTo(ref sb, arg10, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg10");
					break;
				case 10:
					Utf16FormatHelper.FormatTo(ref sb, arg11, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg11");
					break;
				case 11:
					Utf16FormatHelper.FormatTo(ref sb, arg12, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg12");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				case 5:
					Utf16FormatHelper.FormatTo(ref sb, arg6, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg6");
					break;
				case 6:
					Utf16FormatHelper.FormatTo(ref sb, arg7, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg7");
					break;
				case 7:
					Utf16FormatHelper.FormatTo(ref sb, arg8, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg8");
					break;
				case 8:
					Utf16FormatHelper.FormatTo(ref sb, arg9, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg9");
					break;
				case 9:
					Utf16FormatHelper.FormatTo(ref sb, arg10, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg10");
					break;
				case 10:
					Utf16FormatHelper.FormatTo(ref sb, arg11, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg11");
					break;
				case 11:
					Utf16FormatHelper.FormatTo(ref sb, arg12, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg12");
					break;
				case 12:
					Utf16FormatHelper.FormatTo(ref sb, arg13, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg13");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				case 5:
					Utf16FormatHelper.FormatTo(ref sb, arg6, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg6");
					break;
				case 6:
					Utf16FormatHelper.FormatTo(ref sb, arg7, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg7");
					break;
				case 7:
					Utf16FormatHelper.FormatTo(ref sb, arg8, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg8");
					break;
				case 8:
					Utf16FormatHelper.FormatTo(ref sb, arg9, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg9");
					break;
				case 9:
					Utf16FormatHelper.FormatTo(ref sb, arg10, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg10");
					break;
				case 10:
					Utf16FormatHelper.FormatTo(ref sb, arg11, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg11");
					break;
				case 11:
					Utf16FormatHelper.FormatTo(ref sb, arg12, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg12");
					break;
				case 12:
					Utf16FormatHelper.FormatTo(ref sb, arg13, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg13");
					break;
				case 13:
					Utf16FormatHelper.FormatTo(ref sb, arg14, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg14");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				case 5:
					Utf16FormatHelper.FormatTo(ref sb, arg6, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg6");
					break;
				case 6:
					Utf16FormatHelper.FormatTo(ref sb, arg7, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg7");
					break;
				case 7:
					Utf16FormatHelper.FormatTo(ref sb, arg8, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg8");
					break;
				case 8:
					Utf16FormatHelper.FormatTo(ref sb, arg9, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg9");
					break;
				case 9:
					Utf16FormatHelper.FormatTo(ref sb, arg10, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg10");
					break;
				case 10:
					Utf16FormatHelper.FormatTo(ref sb, arg11, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg11");
					break;
				case 11:
					Utf16FormatHelper.FormatTo(ref sb, arg12, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg12");
					break;
				case 12:
					Utf16FormatHelper.FormatTo(ref sb, arg13, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg13");
					break;
				case 13:
					Utf16FormatHelper.FormatTo(ref sb, arg14, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg14");
					break;
				case 14:
					Utf16FormatHelper.FormatTo(ref sb, arg15, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg15");
					break;
				}
			}
		}
	}
	public sealed class Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
	{
		private readonly Utf16FormatSegment[] segments;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf16PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf16Parse(format);
			int num = 0;
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				if (!utf16FormatSegment.IsFormatArgument)
				{
					num += utf16FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
		{
			Utf16ValueStringBuilder sb = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16) where TBufferWriter : IBufferWriter<char>
		{
			ReadOnlySpan<char> readOnlySpan = FormatString.AsSpan();
			Utf16FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf16FormatSegment utf16FormatSegment = array[i];
				switch (utf16FormatSegment.FormatIndex)
				{
				case -1:
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count);
					int count = utf16FormatSegment.Count;
					Span<char> span = sb.GetSpan(count);
					readOnlySpan2.TryCopyTo(span);
					int count2 = utf16FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf16FormatHelper.FormatTo(ref sb, arg1, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg1");
					break;
				case 1:
					Utf16FormatHelper.FormatTo(ref sb, arg2, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg2");
					break;
				case 2:
					Utf16FormatHelper.FormatTo(ref sb, arg3, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg3");
					break;
				case 3:
					Utf16FormatHelper.FormatTo(ref sb, arg4, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg4");
					break;
				case 4:
					Utf16FormatHelper.FormatTo(ref sb, arg5, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg5");
					break;
				case 5:
					Utf16FormatHelper.FormatTo(ref sb, arg6, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg6");
					break;
				case 6:
					Utf16FormatHelper.FormatTo(ref sb, arg7, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg7");
					break;
				case 7:
					Utf16FormatHelper.FormatTo(ref sb, arg8, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg8");
					break;
				case 8:
					Utf16FormatHelper.FormatTo(ref sb, arg9, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg9");
					break;
				case 9:
					Utf16FormatHelper.FormatTo(ref sb, arg10, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg10");
					break;
				case 10:
					Utf16FormatHelper.FormatTo(ref sb, arg11, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg11");
					break;
				case 11:
					Utf16FormatHelper.FormatTo(ref sb, arg12, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg12");
					break;
				case 12:
					Utf16FormatHelper.FormatTo(ref sb, arg13, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg13");
					break;
				case 13:
					Utf16FormatHelper.FormatTo(ref sb, arg14, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg14");
					break;
				case 14:
					Utf16FormatHelper.FormatTo(ref sb, arg15, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg15");
					break;
				case 15:
					Utf16FormatHelper.FormatTo(ref sb, arg16, utf16FormatSegment.Alignment, readOnlySpan.Slice(utf16FormatSegment.Offset, utf16FormatSegment.Count), "arg16");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5, T6>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				case 5:
					Utf8FormatHelper.FormatTo(ref sb, arg6, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg6");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				case 5:
					Utf8FormatHelper.FormatTo(ref sb, arg6, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg6");
					break;
				case 6:
					Utf8FormatHelper.FormatTo(ref sb, arg7, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg7");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				case 5:
					Utf8FormatHelper.FormatTo(ref sb, arg6, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg6");
					break;
				case 6:
					Utf8FormatHelper.FormatTo(ref sb, arg7, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg7");
					break;
				case 7:
					Utf8FormatHelper.FormatTo(ref sb, arg8, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg8");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				case 5:
					Utf8FormatHelper.FormatTo(ref sb, arg6, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg6");
					break;
				case 6:
					Utf8FormatHelper.FormatTo(ref sb, arg7, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg7");
					break;
				case 7:
					Utf8FormatHelper.FormatTo(ref sb, arg8, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg8");
					break;
				case 8:
					Utf8FormatHelper.FormatTo(ref sb, arg9, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg9");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				case 5:
					Utf8FormatHelper.FormatTo(ref sb, arg6, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg6");
					break;
				case 6:
					Utf8FormatHelper.FormatTo(ref sb, arg7, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg7");
					break;
				case 7:
					Utf8FormatHelper.FormatTo(ref sb, arg8, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg8");
					break;
				case 8:
					Utf8FormatHelper.FormatTo(ref sb, arg9, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg9");
					break;
				case 9:
					Utf8FormatHelper.FormatTo(ref sb, arg10, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg10");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				case 5:
					Utf8FormatHelper.FormatTo(ref sb, arg6, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg6");
					break;
				case 6:
					Utf8FormatHelper.FormatTo(ref sb, arg7, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg7");
					break;
				case 7:
					Utf8FormatHelper.FormatTo(ref sb, arg8, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg8");
					break;
				case 8:
					Utf8FormatHelper.FormatTo(ref sb, arg9, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg9");
					break;
				case 9:
					Utf8FormatHelper.FormatTo(ref sb, arg10, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg10");
					break;
				case 10:
					Utf8FormatHelper.FormatTo(ref sb, arg11, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg11");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				case 5:
					Utf8FormatHelper.FormatTo(ref sb, arg6, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg6");
					break;
				case 6:
					Utf8FormatHelper.FormatTo(ref sb, arg7, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg7");
					break;
				case 7:
					Utf8FormatHelper.FormatTo(ref sb, arg8, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg8");
					break;
				case 8:
					Utf8FormatHelper.FormatTo(ref sb, arg9, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg9");
					break;
				case 9:
					Utf8FormatHelper.FormatTo(ref sb, arg10, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg10");
					break;
				case 10:
					Utf8FormatHelper.FormatTo(ref sb, arg11, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg11");
					break;
				case 11:
					Utf8FormatHelper.FormatTo(ref sb, arg12, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg12");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				case 5:
					Utf8FormatHelper.FormatTo(ref sb, arg6, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg6");
					break;
				case 6:
					Utf8FormatHelper.FormatTo(ref sb, arg7, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg7");
					break;
				case 7:
					Utf8FormatHelper.FormatTo(ref sb, arg8, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg8");
					break;
				case 8:
					Utf8FormatHelper.FormatTo(ref sb, arg9, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg9");
					break;
				case 9:
					Utf8FormatHelper.FormatTo(ref sb, arg10, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg10");
					break;
				case 10:
					Utf8FormatHelper.FormatTo(ref sb, arg11, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg11");
					break;
				case 11:
					Utf8FormatHelper.FormatTo(ref sb, arg12, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg12");
					break;
				case 12:
					Utf8FormatHelper.FormatTo(ref sb, arg13, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg13");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				case 5:
					Utf8FormatHelper.FormatTo(ref sb, arg6, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg6");
					break;
				case 6:
					Utf8FormatHelper.FormatTo(ref sb, arg7, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg7");
					break;
				case 7:
					Utf8FormatHelper.FormatTo(ref sb, arg8, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg8");
					break;
				case 8:
					Utf8FormatHelper.FormatTo(ref sb, arg9, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg9");
					break;
				case 9:
					Utf8FormatHelper.FormatTo(ref sb, arg10, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg10");
					break;
				case 10:
					Utf8FormatHelper.FormatTo(ref sb, arg11, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg11");
					break;
				case 11:
					Utf8FormatHelper.FormatTo(ref sb, arg12, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg12");
					break;
				case 12:
					Utf8FormatHelper.FormatTo(ref sb, arg13, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg13");
					break;
				case 13:
					Utf8FormatHelper.FormatTo(ref sb, arg14, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg14");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				case 5:
					Utf8FormatHelper.FormatTo(ref sb, arg6, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg6");
					break;
				case 6:
					Utf8FormatHelper.FormatTo(ref sb, arg7, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg7");
					break;
				case 7:
					Utf8FormatHelper.FormatTo(ref sb, arg8, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg8");
					break;
				case 8:
					Utf8FormatHelper.FormatTo(ref sb, arg9, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg9");
					break;
				case 9:
					Utf8FormatHelper.FormatTo(ref sb, arg10, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg10");
					break;
				case 10:
					Utf8FormatHelper.FormatTo(ref sb, arg11, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg11");
					break;
				case 11:
					Utf8FormatHelper.FormatTo(ref sb, arg12, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg12");
					break;
				case 12:
					Utf8FormatHelper.FormatTo(ref sb, arg13, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg13");
					break;
				case 13:
					Utf8FormatHelper.FormatTo(ref sb, arg14, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg14");
					break;
				case 14:
					Utf8FormatHelper.FormatTo(ref sb, arg15, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg15");
					break;
				}
			}
		}
	}
	public sealed class Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
	{
		private readonly Utf8FormatSegment[] segments;

		private readonly byte[] utf8PreEncodedbuffer;

		public string FormatString { get; }

		public int MinSize { get; }

		public Utf8PreparedFormat(string format)
		{
			FormatString = format;
			segments = PreparedFormatHelper.Utf8Parse(format, out utf8PreEncodedbuffer);
			int num = 0;
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				if (!utf8FormatSegment.IsFormatArgument)
				{
					num += utf8FormatSegment.Count;
				}
			}
			MinSize = num;
		}

		public string Format(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
		{
			Utf8ValueStringBuilder sb = new Utf8ValueStringBuilder(disposeImmediately: true);
			try
			{
				FormatTo(ref sb, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
				return sb.ToString();
			}
			finally
			{
				sb.Dispose();
			}
		}

		public void FormatTo<TBufferWriter>(ref TBufferWriter sb, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16) where TBufferWriter : IBufferWriter<byte>
		{
			Span<byte> span = utf8PreEncodedbuffer.AsSpan();
			Utf8FormatSegment[] array = segments;
			for (int i = 0; i < array.Length; i++)
			{
				Utf8FormatSegment utf8FormatSegment = array[i];
				switch (utf8FormatSegment.FormatIndex)
				{
				case -1:
				{
					Span<byte> span2 = span.Slice(utf8FormatSegment.Offset, utf8FormatSegment.Count);
					int count = utf8FormatSegment.Count;
					Span<byte> span3 = sb.GetSpan(count);
					span2.TryCopyTo(span3);
					int count2 = utf8FormatSegment.Count;
					sb.Advance(count2);
					break;
				}
				case 0:
					Utf8FormatHelper.FormatTo(ref sb, arg1, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg1");
					break;
				case 1:
					Utf8FormatHelper.FormatTo(ref sb, arg2, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg2");
					break;
				case 2:
					Utf8FormatHelper.FormatTo(ref sb, arg3, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg3");
					break;
				case 3:
					Utf8FormatHelper.FormatTo(ref sb, arg4, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg4");
					break;
				case 4:
					Utf8FormatHelper.FormatTo(ref sb, arg5, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg5");
					break;
				case 5:
					Utf8FormatHelper.FormatTo(ref sb, arg6, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg6");
					break;
				case 6:
					Utf8FormatHelper.FormatTo(ref sb, arg7, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg7");
					break;
				case 7:
					Utf8FormatHelper.FormatTo(ref sb, arg8, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg8");
					break;
				case 8:
					Utf8FormatHelper.FormatTo(ref sb, arg9, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg9");
					break;
				case 9:
					Utf8FormatHelper.FormatTo(ref sb, arg10, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg10");
					break;
				case 10:
					Utf8FormatHelper.FormatTo(ref sb, arg11, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg11");
					break;
				case 11:
					Utf8FormatHelper.FormatTo(ref sb, arg12, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg12");
					break;
				case 12:
					Utf8FormatHelper.FormatTo(ref sb, arg13, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg13");
					break;
				case 13:
					Utf8FormatHelper.FormatTo(ref sb, arg14, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg14");
					break;
				case 14:
					Utf8FormatHelper.FormatTo(ref sb, arg15, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg15");
					break;
				case 15:
					Utf8FormatHelper.FormatTo(ref sb, arg16, utf8FormatSegment.Alignment, utf8FormatSegment.StandardFormat, "arg16");
					break;
				}
			}
		}
	}
	internal static class PreparedFormatHelper
	{
		internal static Utf16FormatSegment[] Utf16Parse(string format)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			List<Utf16FormatSegment> list = new List<Utf16FormatSegment>();
			int i = 0;
			int length = format.Length;
			int num = 0;
			while (true)
			{
				if (i < length)
				{
					ParserScanResult parserScanResult = FormatParser.ScanFormatString(format, ref i);
					if (ParserScanResult.NormalChar == parserScanResult && i < length)
					{
						continue;
					}
					int num2 = i - num;
					if (ParserScanResult.EscapedChar == parserScanResult)
					{
						num2--;
					}
					if (num2 != 0)
					{
						list.Add(new Utf16FormatSegment(num, num2, -1, 0));
					}
					num = i;
					if (parserScanResult != ParserScanResult.BraceOpen)
					{
						continue;
					}
				}
				if (i >= length)
				{
					break;
				}
				FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
				num = parseResult.LastIndex;
				i = parseResult.LastIndex;
				list.Add(new Utf16FormatSegment(parseResult.LastIndex - parseResult.FormatString.Length - 1, parseResult.FormatString.Length, parseResult.Index, parseResult.Alignment));
			}
			return list.ToArray();
		}

		internal static Utf8FormatSegment[] Utf8Parse(string format, out byte[] utf8buffer)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			List<Utf8FormatSegment> list = new List<Utf8FormatSegment>();
			utf8buffer = new byte[Encoding.UTF8.GetMaxByteCount(format.Length)];
			int num = 0;
			int i = 0;
			int length = format.Length;
			int num2 = 0;
			while (true)
			{
				if (i < length)
				{
					ParserScanResult parserScanResult = FormatParser.ScanFormatString(format, ref i);
					if (ParserScanResult.NormalChar == parserScanResult && i < length)
					{
						continue;
					}
					int num3 = i - num2;
					if (ParserScanResult.EscapedChar == parserScanResult)
					{
						num3--;
					}
					if (num3 != 0)
					{
						int bytes = Encoding.UTF8.GetBytes(format, num2, num3, utf8buffer, num);
						list.Add(new Utf8FormatSegment(num, bytes, -1, default(StandardFormat), 0));
						num += bytes;
					}
					num2 = i;
					if (parserScanResult != ParserScanResult.BraceOpen)
					{
						continue;
					}
				}
				if (i >= length)
				{
					break;
				}
				FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
				num2 = parseResult.LastIndex;
				i = parseResult.LastIndex;
				list.Add(new Utf8FormatSegment(0, 0, parseResult.Index, StandardFormat.Parse(parseResult.FormatString), parseResult.Alignment));
			}
			return list.ToArray();
		}
	}
	internal readonly struct Utf8FormatSegment
	{
		public const int NotFormatIndex = -1;

		public readonly int Offset;

		public readonly int Count;

		public readonly int FormatIndex;

		public readonly StandardFormat StandardFormat;

		public readonly int Alignment;

		public bool IsFormatArgument => FormatIndex != -1;

		public Utf8FormatSegment(int offset, int count, int formatIndex, StandardFormat format, int alignment)
		{
			Offset = offset;
			Count = count;
			FormatIndex = formatIndex;
			StandardFormat = format;
			Alignment = alignment;
		}
	}
	internal readonly struct Utf16FormatSegment
	{
		public const int NotFormatIndex = -1;

		public readonly int Offset;

		public readonly int Count;

		public readonly int FormatIndex;

		public readonly int Alignment;

		public bool IsFormatArgument => FormatIndex != -1;

		public Utf16FormatSegment(int offset, int count, int formatIndex, int alignment)
		{
			Offset = offset;
			Count = count;
			FormatIndex = formatIndex;
			Alignment = alignment;
		}
	}
	internal readonly struct ReadOnlyListAdaptor<T> : IReadOnlyList<T>, IEnumerable<T>, IEnumerable, IReadOnlyCollection<T>
	{
		private readonly IList<T> _list;

		public T this[int index] => _list[index];

		public int Count => _list.Count;

		public ReadOnlyListAdaptor(IList<T> list)
		{
			_list = list;
		}

		public IEnumerator<T> GetEnumerator()
		{
			return _list.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	public static class StandardFormats
	{
		public static StandardFormat DateTime_ISO = new StandardFormat('O');
	}
	public struct Utf16ValueStringBuilder : IDisposable, IBufferWriter<char>, IResettableBufferWriter<char>
	{
		public delegate bool TryFormat<T>(T value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format);

		private static class ExceptionUtil
		{
			public static void ThrowArgumentOutOfRangeException(string paramName)
			{
				throw new ArgumentOutOfRangeException(paramName);
			}
		}

		public static class FormatterCache<T>
		{
			public static TryFormat<T> TryFormatDelegate;

			static FormatterCache()
			{
				TryFormat<T> tryFormat = (TryFormat<T>)CreateFormatter(typeof(T));
				if (tryFormat == null)
				{
					tryFormat = (typeof(T).IsEnum ? new TryFormat<T>(EnumUtil<T>.TryFormatUtf16) : ((!(typeof(T) == typeof(string))) ? new TryFormat<T>(TryFormatDefault) : new TryFormat<T>(TryFormatString)));
				}
				TryFormatDelegate = tryFormat;
			}

			private static bool TryFormatString(T value, Span<char> dest, out int written, ReadOnlySpan<char> format)
			{
				if (!(value is string text))
				{
					written = 0;
					return true;
				}
				written = text.Length;
				return text.AsSpan().TryCopyTo(dest);
			}

			private static bool TryFormatDefault(T value, Span<char> dest, out int written, ReadOnlySpan<char> format)
			{
				if (value == null)
				{
					written = 0;
					return true;
				}
				string text = ((value is IFormattable formattable && format.Length != 0) ? formattable.ToString(format.ToString(), null) : value.ToString());
				written = text.Length;
				return text.AsSpan().TryCopyTo(dest);
			}
		}

		private const int ThreadStaticBufferSize = 31111;

		private const int DefaultBufferSize = 32768;

		private static char newLine1;

		private static char newLine2;

		private static bool crlf;

		[ThreadStatic]
		private static char[]? scratchBuffer;

		[ThreadStatic]
		internal static bool scratchBufferUsed;

		private char[]? buffer;

		private int index;

		private bool disposeImmediately;

		public int Length => index;

		public void AppendJoin<T>(char separator, params T[] values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal<T>(separator2, values.AsSpan());
		}

		public void AppendJoin<T>(char separator, List<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, (IReadOnlyList<T>)values);
		}

		public void AppendJoin<T>(char separator, ReadOnlySpan<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values);
		}

		public void AppendJoin<T>(char separator, IEnumerable<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values);
		}

		public void AppendJoin<T>(char separator, ICollection<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values.AsEnumerable());
		}

		public void AppendJoin<T>(char separator, IList<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values);
		}

		public void AppendJoin<T>(char separator, IReadOnlyList<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values);
		}

		public void AppendJoin<T>(char separator, IReadOnlyCollection<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values.AsEnumerable());
		}

		public void AppendJoin<T>(string separator, params T[] values)
		{
			AppendJoinInternal<T>(separator.AsSpan(), values.AsSpan());
		}

		public void AppendJoin<T>(string separator, List<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), (IReadOnlyList<T>)values);
		}

		public void AppendJoin<T>(string separator, ReadOnlySpan<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values);
		}

		public void AppendJoin<T>(string separator, IEnumerable<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values);
		}

		public void AppendJoin<T>(string separator, ICollection<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
		}

		public void AppendJoin<T>(string separator, IList<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values);
		}

		public void AppendJoin<T>(string separator, IReadOnlyList<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values);
		}

		public void AppendJoin<T>(string separator, IReadOnlyCollection<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
		}

		internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IList<T> values)
		{
			IReadOnlyList<T> readOnlyList = values as IReadOnlyList<T>;
			readOnlyList = (IReadOnlyList<T>)(readOnlyList ?? ((object)new ReadOnlyListAdaptor<T>(values)));
			AppendJoinInternal(separator, readOnlyList);
		}

		internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IReadOnlyList<T> values)
		{
			int count = values.Count;
			for (int i = 0; i < count; i++)
			{
				if (i != 0)
				{
					Append(separator);
				}
				T val = values[i];
				if (typeof(T) == typeof(string))
				{
					string value = Unsafe.As<string>(val);
					if (!string.IsNullOrEmpty(value))
					{
						Append(value);
					}
				}
				else
				{
					Append(val);
				}
			}
		}

		internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, ReadOnlySpan<T> values)
		{
			for (int i = 0; i < values.Length; i++)
			{
				if (i != 0)
				{
					Append(separator);
				}
				T val = values[i];
				if (typeof(T) == typeof(string))
				{
					string value = Unsafe.As<string>(val);
					if (!string.IsNullOrEmpty(value))
					{
						Append(value);
					}
				}
				else
				{
					Append(val);
				}
			}
		}

		internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IEnumerable<T> values)
		{
			bool flag = true;
			foreach (T value2 in values)
			{
				if (!flag)
				{
					Append(separator);
				}
				else
				{
					flag = false;
				}
				if (typeof(T) == typeof(string))
				{
					string value = Unsafe.As<string>(value2);
					if (!string.IsNullOrEmpty(value))
					{
						Append(value);
					}
				}
				else
				{
					Append(value2);
				}
			}
		}

		public void AppendFormat<T1>(string format, T1 arg1)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					if (parseResult.Index == 0)
					{
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1>(ReadOnlySpan<char> format, T1 arg1)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					if (parseResult.Index == 0)
					{
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2>(string format, T1 arg1, T2 arg2)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2>(ReadOnlySpan<char> format, T1 arg1, T2 arg2)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3>(string format, T1 arg1, T2 arg2, T3 arg3)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, parseResult.FormatString, "arg12");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, parseResult.FormatString, "arg12");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, parseResult.FormatString, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, parseResult.FormatString, "arg13");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, parseResult.FormatString, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, parseResult.FormatString, "arg13");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, parseResult.FormatString, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, parseResult.FormatString, "arg13");
						break;
					case 13:
						AppendFormatInternal(arg14, parseResult.Alignment, parseResult.FormatString, "arg14");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, parseResult.FormatString, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, parseResult.FormatString, "arg13");
						break;
					case 13:
						AppendFormatInternal(arg14, parseResult.Alignment, parseResult.FormatString, "arg14");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, parseResult.FormatString, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, parseResult.FormatString, "arg13");
						break;
					case 13:
						AppendFormatInternal(arg14, parseResult.Alignment, parseResult.FormatString, "arg14");
						break;
					case 14:
						AppendFormatInternal(arg15, parseResult.Alignment, parseResult.FormatString, "arg15");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, parseResult.FormatString, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, parseResult.FormatString, "arg13");
						break;
					case 13:
						AppendFormatInternal(arg14, parseResult.Alignment, parseResult.FormatString, "arg14");
						break;
					case 14:
						AppendFormatInternal(arg15, parseResult.Alignment, parseResult.FormatString, "arg15");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int count3 = i - num;
					Append(format, num, count3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, parseResult.FormatString, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, parseResult.FormatString, "arg13");
						break;
					case 13:
						AppendFormatInternal(arg14, parseResult.Alignment, parseResult.FormatString, "arg14");
						break;
					case 14:
						AppendFormatInternal(arg15, parseResult.Alignment, parseResult.FormatString, "arg15");
						break;
					case 15:
						AppendFormatInternal(arg16, parseResult.Alignment, parseResult.FormatString, "arg16");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
		{
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int length2 = i - num;
						Append(format.Slice(num, length2));
						i++;
						num = i;
						break;
					}
					int length3 = i - num;
					Append(format.Slice(num, length3));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, parseResult.FormatString, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, parseResult.FormatString, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, parseResult.FormatString, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, parseResult.FormatString, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, parseResult.FormatString, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, parseResult.FormatString, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, parseResult.FormatString, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, parseResult.FormatString, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, parseResult.FormatString, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, parseResult.FormatString, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, parseResult.FormatString, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, parseResult.FormatString, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, parseResult.FormatString, "arg13");
						break;
					case 13:
						AppendFormatInternal(arg14, parseResult.Alignment, parseResult.FormatString, "arg14");
						break;
					case 14:
						AppendFormatInternal(arg15, parseResult.Alignment, parseResult.FormatString, "arg15");
						break;
					case 15:
						AppendFormatInternal(arg16, parseResult.Alignment, parseResult.FormatString, "arg16");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int length = i - num;
						Append(format.Slice(num, length));
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format.Slice(num, num2));
			}
		}

		private static object? CreateFormatter(Type type)
		{
			if (type == typeof(sbyte))
			{
				return (TryFormat<sbyte>)delegate(sbyte x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return (format.Length != 0) ? x.TryFormat(dest, out written, format) : FastNumberWriter.TryWriteInt64(dest, out written, x);
				};
			}
			if (type == typeof(short))
			{
				return (TryFormat<short>)delegate(short x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return (format.Length != 0) ? x.TryFormat(dest, out written, format) : FastNumberWriter.TryWriteInt64(dest, out written, x);
				};
			}
			if (type == typeof(int))
			{
				return (TryFormat<int>)delegate(int x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return (format.Length != 0) ? x.TryFormat(dest, out written, format) : FastNumberWriter.TryWriteInt64(dest, out written, x);
				};
			}
			if (type == typeof(long))
			{
				return (TryFormat<long>)delegate(long x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return (format.Length != 0) ? x.TryFormat(dest, out written, format) : FastNumberWriter.TryWriteInt64(dest, out written, x);
				};
			}
			if (type == typeof(byte))
			{
				return (TryFormat<byte>)delegate(byte x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return (format.Length != 0) ? x.TryFormat(dest, out written, format) : FastNumberWriter.TryWriteUInt64(dest, out written, x);
				};
			}
			if (type == typeof(ushort))
			{
				return (TryFormat<ushort>)delegate(ushort x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return (format.Length != 0) ? x.TryFormat(dest, out written, format) : FastNumberWriter.TryWriteUInt64(dest, out written, x);
				};
			}
			if (type == typeof(uint))
			{
				return (TryFormat<uint>)delegate(uint x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return (format.Length != 0) ? x.TryFormat(dest, out written, format) : FastNumberWriter.TryWriteUInt64(dest, out written, x);
				};
			}
			if (type == typeof(ulong))
			{
				return (TryFormat<ulong>)delegate(ulong x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return (format.Length != 0) ? x.TryFormat(dest, out written, format) : FastNumberWriter.TryWriteUInt64(dest, out written, x);
				};
			}
			if (type == typeof(float))
			{
				return (TryFormat<float>)delegate(float x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return x.TryFormat(dest, out written, format);
				};
			}
			if (type == typeof(double))
			{
				return (TryFormat<double>)delegate(double x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return x.TryFormat(dest, out written, format);
				};
			}
			if (type == typeof(TimeSpan))
			{
				return (TryFormat<TimeSpan>)delegate(TimeSpan x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return x.TryFormat(dest, out written, format);
				};
			}
			if (type == typeof(DateTime))
			{
				return (TryFormat<DateTime>)delegate(DateTime x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return x.TryFormat(dest, out written, format);
				};
			}
			if (type == typeof(DateTimeOffset))
			{
				return (TryFormat<DateTimeOffset>)delegate(DateTimeOffset x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return x.TryFormat(dest, out written, format);
				};
			}
			if (type == typeof(decimal))
			{
				return (TryFormat<decimal>)delegate(decimal x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return x.TryFormat(dest, out written, format);
				};
			}
			if (type == typeof(Guid))
			{
				return (TryFormat<Guid>)delegate(Guid x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return x.TryFormat(dest, out written, format);
				};
			}
			if (type == typeof(byte?))
			{
				return CreateNullableFormatter<byte>();
			}
			if (type == typeof(DateTime?))
			{
				return CreateNullableFormatter<DateTime>();
			}
			if (type == typeof(DateTimeOffset?))
			{
				return CreateNullableFormatter<DateTimeOffset>();
			}
			if (type == typeof(decimal?))
			{
				return CreateNullableFormatter<decimal>();
			}
			if (type == typeof(double?))
			{
				return CreateNullableFormatter<double>();
			}
			if (type == typeof(short?))
			{
				return CreateNullableFormatter<short>();
			}
			if (type == typeof(int?))
			{
				return CreateNullableFormatter<int>();
			}
			if (type == typeof(long?))
			{
				return CreateNullableFormatter<long>();
			}
			if (type == typeof(sbyte?))
			{
				return CreateNullableFormatter<sbyte>();
			}
			if (type == typeof(float?))
			{
				return CreateNullableFormatter<float>();
			}
			if (type == typeof(TimeSpan?))
			{
				return CreateNullableFormatter<TimeSpan>();
			}
			if (type == typeof(ushort?))
			{
				return CreateNullableFormatter<ushort>();
			}
			if (type == typeof(uint?))
			{
				return CreateNullableFormatter<uint>();
			}
			if (type == typeof(ulong?))
			{
				return CreateNullableFormatter<ulong>();
			}
			if (type == typeof(Guid?))
			{
				return CreateNullableFormatter<Guid>();
			}
			if (type == typeof(bool?))
			{
				return CreateNullableFormatter<bool>();
			}
			if (type == typeof(IntPtr))
			{
				return (TryFormat<IntPtr>)delegate(IntPtr x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return (IntPtr.Size != 4) ? x.ToInt64().TryFormat(dest, out written, format) : x.ToInt32().TryFormat(dest, out written, format);
				};
			}
			if (type == typeof(UIntPtr))
			{
				return (TryFormat<UIntPtr>)delegate(UIntPtr x, Span<char> dest, out int written, ReadOnlySpan<char> format)
				{
					return (UIntPtr.Size != 4) ? x.ToUInt64().TryFormat(dest, out written, format) : x.ToUInt32().TryFormat(dest, out written, format);
				};
			}
			return null;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(byte value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(byte value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(byte value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(byte value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(DateTime value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(DateTime value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(DateTime value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(DateTime value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(DateTimeOffset value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(DateTimeOffset value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(DateTimeOffset value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(DateTimeOffset value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(decimal value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(decimal value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(decimal value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(decimal value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(double value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(double value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(double value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(double value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(short value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(short value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(short value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(short value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(int value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(int value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(int value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(int value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(long value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(long value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(long value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(long value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(sbyte value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(sbyte value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(sbyte value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(sbyte value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(float value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(float value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(float value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(float value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(TimeSpan value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(TimeSpan value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(TimeSpan value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(TimeSpan value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(ushort value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(ushort value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(ushort value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(ushort value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(uint value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(uint value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(uint value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(uint value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(ulong value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(ulong value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(ulong value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(ulong value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(Guid value)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(Guid value, string format)
		{
			if (!value.TryFormat(buffer.AsSpan(index), out var charsWritten, format.AsSpan()))
			{
				Grow(charsWritten);
				if (!value.TryFormat(buffer.AsSpan(index), out charsWritten, format.AsSpan()))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(Guid value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(Guid value, string format)
		{
			Append(value, format);
			AppendLine();
		}

		static Utf16ValueStringBuilder()
		{
			char[] array = Environment.NewLine.ToCharArray();
			if (array.Length == 1)
			{
				newLine1 = array[0];
				crlf = false;
			}
			else
			{
				newLine1 = array[0];
				newLine2 = array[1];
				crlf = true;
			}
		}

		public ReadOnlySpan<char> AsSpan()
		{
			return buffer.AsSpan(0, index);
		}

		public ReadOnlyMemory<char> AsMemory()
		{
			return buffer.AsMemory(0, index);
		}

		public ArraySegment<char> AsArraySegment()
		{
			return new ArraySegment<char>(buffer, 0, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Utf16ValueStringBuilder(bool disposeImmediately)
		{
			if (disposeImmediately && scratchBufferUsed)
			{
				ThrowNestedException();
			}
			char[] array;
			if (disposeImmediately)
			{
				array = scratchBuffer;
				if (array == null)
				{
					array = (scratchBuffer = new char[31111]);
				}
				scratchBufferUsed = true;
			}
			else
			{
				array = ArrayPool<char>.Shared.Rent(32768);
			}
			buffer = array;
			index = 0;
			this.disposeImmediately = disposeImmediately;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Dispose()
		{
			if (buffer != null)
			{
				if (buffer.Length != 31111)
				{
					ArrayPool<char>.Shared.Return(buffer);
				}
				buffer = null;
				index = 0;
				if (disposeImmediately)
				{
					scratchBufferUsed = false;
				}
			}
		}

		public void Clear()
		{
			index = 0;
		}

		public void TryGrow(int sizeHint)
		{
			if (buffer.Length < index + sizeHint)
			{
				Grow(sizeHint);
			}
		}

		public void Grow(int sizeHint)
		{
			int num = buffer.Length * 2;
			if (sizeHint != 0)
			{
				num = Math.Max(num, index + sizeHint);
			}
			char[] array = ArrayPool<char>.Shared.Rent(num);
			buffer.CopyTo(array, 0);
			if (buffer.Length != 31111)
			{
				ArrayPool<char>.Shared.Return(buffer);
			}
			buffer = array;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine()
		{
			if (crlf)
			{
				if (buffer.Length - index < 2)
				{
					Grow(2);
				}
				buffer[index] = newLine1;
				buffer[index + 1] = newLine2;
				index += 2;
			}
			else
			{
				if (buffer.Length - index < 1)
				{
					Grow(1);
				}
				buffer[index] = newLine1;
				index++;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(char value)
		{
			if (buffer.Length - index < 1)
			{
				Grow(1);
			}
			buffer[index++] = value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(char value, int repeatCount)
		{
			if (repeatCount < 0)
			{
				throw new ArgumentOutOfRangeException("repeatCount");
			}
			GetSpan(repeatCount).Fill(value);
			Advance(repeatCount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(char value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(string value)
		{
			Append(value.AsSpan());
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(string value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(string value, int startIndex, int count)
		{
			if (value == null)
			{
				if (startIndex != 0 || count != 0)
				{
					throw new ArgumentNullException("value");
				}
			}
			else
			{
				Append(value.AsSpan(startIndex, count));
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(char[] value, int startIndex, int charCount)
		{
			if (buffer.Length - index < charCount)
			{
				Grow(charCount);
			}
			Array.Copy(value, startIndex, buffer, index, charCount);
			index += charCount;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(ReadOnlySpan<char> value)
		{
			if (buffer.Length - index < value.Length)
			{
				Grow(value.Length);
			}
			value.CopyTo(buffer.AsSpan(index));
			index += value.Length;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(ReadOnlySpan<char> value)
		{
			Append(value);
			AppendLine();
		}

		public void Append<T>(T value)
		{
			if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out var charsWritten, default(ReadOnlySpan<char>)))
			{
				Grow(charsWritten);
				if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out charsWritten, default(ReadOnlySpan<char>)))
				{
					ThrowArgumentException("value");
				}
			}
			index += charsWritten;
		}

		public void AppendLine<T>(T value)
		{
			Append(value);
			AppendLine();
		}

		public void Insert(int index, string value, int count)
		{
			Insert(index, value.AsSpan(), count);
		}

		public void Insert(int index, string value)
		{
			Insert(index, value.AsSpan(), 1);
		}

		public void Insert(int index, ReadOnlySpan<char> value, int count)
		{
			if (count < 0)
			{
				ExceptionUtil.ThrowArgumentOutOfRangeException("count");
			}
			int length = Length;
			if ((uint)index > (uint)length)
			{
				ExceptionUtil.ThrowArgumentOutOfRangeException("index");
			}
			if (value.Length != 0 && count != 0)
			{
				int val = index + value.Length * count;
				char[] array = ArrayPool<char>.Shared.Rent(Math.Max(32768, val));
				buffer.AsSpan(0, index).CopyTo(array);
				int num = index;
				for (int i = 0; i < count; i++)
				{
					value.CopyTo(array.AsSpan(num));
					num += value.Length;
				}
				int num2 = this.index - index;
				buffer.AsSpan(index, num2).CopyTo(array.AsSpan(num));
				if (buffer.Length != 31111 && buffer != null)
				{
					ArrayPool<char>.Shared.Return(buffer);
				}
				buffer = array;
				this.index = num + num2;
			}
		}

		public void Replace(char oldChar, char newChar)
		{
			Replace(oldChar, newChar, 0, Length);
		}

		public void Replace(char oldChar, char newChar, int startIndex, int count)
		{
			int length = Length;
			if ((uint)startIndex > (uint)length)
			{
				ExceptionUtil.ThrowArgumentOutOfRangeException("startIndex");
			}
			if (count < 0 || startIndex > length - count)
			{
				ExceptionUtil.ThrowArgumentOutOfRangeException("count");
			}
			int num = startIndex + count;
			for (int i = startIndex; i < num; i++)
			{
				if (buffer[i] == oldChar)
				{
					buffer[i] = newChar;
				}
			}
		}

		public void Replace(string oldValue, string newValue)
		{
			Replace(oldValue, newValue, 0, Length);
		}

		public void Replace(ReadOnlySpan<char> oldValue, ReadOnlySpan<char> newValue)
		{
			Replace(oldValue, newValue, 0, Length);
		}

		public void Replace(string oldValue, string newValue, int startIndex, int count)
		{
			if (oldValue == null)
			{
				throw new ArgumentNullException("oldValue");
			}
			Replace(oldValue.AsSpan(), newValue.AsSpan(), startIndex, count);
		}

		public void Replace(ReadOnlySpan<char> oldValue, ReadOnlySpan<char> newValue, int startIndex, int count)
		{
			int length = Length;
			if ((uint)startIndex > (uint)length)
			{
				ExceptionUtil.ThrowArgumentOutOfRangeException("startIndex");
			}
			if (count < 0 || startIndex > length - count)
			{
				ExceptionUtil.ThrowArgumentOutOfRangeException("count");
			}
			if (oldValue.Length == 0)
			{
				throw new ArgumentException("oldValue.Length is 0", "oldValue");
			}
			ReadOnlySpan<char> readOnlySpan = AsSpan();
			int num = startIndex + count;
			int num2 = 0;
			int num3;
			for (num3 = startIndex; num3 < num; num3 += oldValue.Length)
			{
				int num4 = readOnlySpan.Slice(num3, num - num3).IndexOf(oldValue, StringComparison.Ordinal);
				if (num4 == -1)
				{
					break;
				}
				num3 += num4;
				num2++;
			}
			if (num2 == 0)
			{
				return;
			}
			char[] array = ArrayPool<char>.Shared.Rent(Math.Max(32768, Length + (newValue.Length - oldValue.Length) * num2));
			buffer.AsSpan(0, startIndex).CopyTo(array);
			int num5 = startIndex;
			int num6;
			for (num6 = startIndex; num6 < num; num6 += oldValue.Length)
			{
				int num7 = readOnlySpan.Slice(num6, num - num6).IndexOf(oldValue, StringComparison.Ordinal);
				if (num7 == -1)
				{
					ReadOnlySpan<char> readOnlySpan2 = readOnlySpan.Slice(num6);
					readOnlySpan2.CopyTo(array.AsSpan(num5));
					num5 += readOnlySpan2.Length;
					break;
				}
				readOnlySpan.Slice(num6, num7).CopyTo(array.AsSpan(num5));
				newValue.CopyTo(array.AsSpan(num5 + num7));
				num5 += num7 + newValue.Length;
				num6 += num7;
			}
			if (buffer.Length != 31111)
			{
				ArrayPool<char>.Shared.Return(buffer);
			}
			buffer = array;
			index = num5;
		}

		public void ReplaceAt(char newChar, int replaceIndex)
		{
			int length = Length;
			if ((uint)replaceIndex > (uint)length)
			{
				ExceptionUtil.ThrowArgumentOutOfRangeException("replaceIndex");
			}
			buffer[replaceIndex] = newChar;
		}

		public void Remove(int startIndex, int length)
		{
			if (length < 0)
			{
				ExceptionUtil.ThrowArgumentOutOfRangeException("length");
			}
			if (startIndex < 0)
			{
				ExceptionUtil.ThrowArgumentOutOfRangeException("startIndex");
			}
			if (length > Length - startIndex)
			{
				ExceptionUtil.ThrowArgumentOutOfRangeException("length");
			}
			if (Length == length && startIndex == 0)
			{
				index = 0;
			}
			else if (length != 0)
			{
				int num = startIndex + length;
				buffer.AsSpan(num, Length - num).CopyTo(buffer.AsSpan(startIndex));
				index -= length;
			}
		}

		public bool TryCopyTo(Span<char> destination, out int charsWritten)
		{
			if (destination.Length < index)
			{
				charsWritten = 0;
				return false;
			}
			charsWritten = index;
			buffer.AsSpan(0, index).CopyTo(destination);
			return true;
		}

		public override string ToString()
		{
			if (index == 0)
			{
				return string.Empty;
			}
			return new string(buffer, 0, index);
		}

		public Memory<char> GetMemory(int sizeHint)
		{
			if (buffer.Length - index < sizeHint)
			{
				Grow(sizeHint);
			}
			return buffer.AsMemory(index);
		}

		public Span<char> GetSpan(int sizeHint)
		{
			if (buffer.Length - index < sizeHint)
			{
				Grow(sizeHint);
			}
			return buffer.AsSpan(index);
		}

		public void Advance(int count)
		{
			index += count;
		}

		void IResettableBufferWriter<char>.Reset()
		{
			index = 0;
		}

		private void ThrowArgumentException(string paramName)
		{
			throw new ArgumentException("Can't format argument.", paramName);
		}

		private static void ThrowFormatException()
		{
			throw new FormatException("Index (zero based) must be greater than or equal to zero and less than the size of the argument list.");
		}

		private void AppendFormatInternal<T>(T arg, int width, ReadOnlySpan<char> format, string argName)
		{
			if (width <= 0)
			{
				width *= -1;
				if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out var charsWritten, format))
				{
					Grow(charsWritten);
					if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out charsWritten, format))
					{
						ThrowArgumentException(argName);
					}
				}
				index += charsWritten;
				int num = width - charsWritten;
				if (width > 0 && num > 0)
				{
					Append(' ', num);
				}
				return;
			}
			if (typeof(T) == typeof(string))
			{
				string text = Unsafe.As<string>(arg);
				int num2 = width - text.Length;
				if (num2 > 0)
				{
					Append(' ', num2);
				}
				Append(text);
				return;
			}
			Span<char> destination = stackalloc char[typeof(T).IsValueType ? (Unsafe.SizeOf<T>() * 8) : 1024];
			if (!FormatterCache<T>.TryFormatDelegate(arg, destination, out var charsWritten2, format))
			{
				destination = stackalloc char[destination.Length * 2];
				if (!FormatterCache<T>.TryFormatDelegate(arg, destination, out charsWritten2, format))
				{
					ThrowArgumentException(argName);
				}
			}
			int num3 = width - charsWritten2;
			if (num3 > 0)
			{
				Append(' ', num3);
			}
			Append((ReadOnlySpan<char>)destination.Slice(0, charsWritten2));
		}

		private static void ThrowNestedException()
		{
			throw new NestedStringBuilderCreationException("Utf16ValueStringBuilder");
		}

		public static void RegisterTryFormat<T>(TryFormat<T> formatMethod)
		{
			FormatterCache<T>.TryFormatDelegate = formatMethod;
		}

		private static TryFormat<T?> CreateNullableFormatter<T>() where T : struct
		{
			return delegate(T? x, Span<char> dest, out int written, ReadOnlySpan<char> format)
			{
				if (!x.HasValue)
				{
					written = 0;
					return true;
				}
				return FormatterCache<T>.TryFormatDelegate(x.Value, dest, out written, format);
			};
		}

		public static void EnableNullableFormat<T>() where T : struct
		{
			RegisterTryFormat(CreateNullableFormatter<T>());
		}
	}
	public struct Utf8ValueStringBuilder : IDisposable, IBufferWriter<byte>, IResettableBufferWriter<byte>
	{
		public delegate bool TryFormat<T>(T value, Span<byte> destination, out int written, StandardFormat format);

		public static class FormatterCache<T>
		{
			public static TryFormat<T> TryFormatDelegate;

			static FormatterCache()
			{
				TryFormat<T> tryFormat = (TryFormat<T>)CreateFormatter(typeof(T));
				if (tryFormat == null)
				{
					tryFormat = ((!typeof(T).IsEnum) ? new TryFormat<T>(TryFormatDefault) : new TryFormat<T>(EnumUtil<T>.TryFormatUtf8));
				}
				TryFormatDelegate = tryFormat;
			}

			private static bool TryFormatDefault(T value, Span<byte> dest, out int written, StandardFormat format)
			{
				if (value == null)
				{
					written = 0;
					return true;
				}
				string text = ((typeof(T) == typeof(string)) ? Unsafe.As<string>(value) : ((value is IFormattable formattable && format != default(StandardFormat)) ? formattable.ToString(format.ToString(), null) : value.ToString()));
				written = UTF8NoBom.GetMaxByteCount(text.Length);
				if (dest.Length < written)
				{
					return false;
				}
				written = UTF8NoBom.GetBytes(text.AsSpan(), dest);
				return true;
			}
		}

		private const int ThreadStaticBufferSize = 64444;

		private const int DefaultBufferSize = 65536;

		private static Encoding UTF8NoBom;

		private static byte newLine1;

		private static byte newLine2;

		private static bool crlf;

		[ThreadStatic]
		private static byte[]? scratchBuffer;

		[ThreadStatic]
		internal static bool scratchBufferUsed;

		private byte[]? buffer;

		private int index;

		private bool disposeImmediately;

		public int Length => index;

		public void AppendJoin<T>(char separator, params T[] values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal<T>(separator2, values.AsSpan());
		}

		public void AppendJoin<T>(char separator, List<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, (IReadOnlyList<T>)values);
		}

		public void AppendJoin<T>(char separator, ReadOnlySpan<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values);
		}

		public void AppendJoin<T>(char separator, IEnumerable<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values);
		}

		public void AppendJoin<T>(char separator, ICollection<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values.AsEnumerable());
		}

		public void AppendJoin<T>(char separator, IList<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values);
		}

		public void AppendJoin<T>(char separator, IReadOnlyList<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values);
		}

		public void AppendJoin<T>(char separator, IReadOnlyCollection<T> values)
		{
			ReadOnlySpan<char> separator2 = stackalloc char[1] { separator };
			AppendJoinInternal(separator2, values.AsEnumerable());
		}

		public void AppendJoin<T>(string separator, params T[] values)
		{
			AppendJoinInternal<T>(separator.AsSpan(), values.AsSpan());
		}

		public void AppendJoin<T>(string separator, List<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), (IReadOnlyList<T>)values);
		}

		public void AppendJoin<T>(string separator, ReadOnlySpan<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values);
		}

		public void AppendJoin<T>(string separator, IEnumerable<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values);
		}

		public void AppendJoin<T>(string separator, ICollection<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
		}

		public void AppendJoin<T>(string separator, IList<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values);
		}

		public void AppendJoin<T>(string separator, IReadOnlyList<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values);
		}

		public void AppendJoin<T>(string separator, IReadOnlyCollection<T> values)
		{
			AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
		}

		internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IList<T> values)
		{
			IReadOnlyList<T> readOnlyList = values as IReadOnlyList<T>;
			readOnlyList = (IReadOnlyList<T>)(readOnlyList ?? ((object)new ReadOnlyListAdaptor<T>(values)));
			AppendJoinInternal(separator, readOnlyList);
		}

		internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IReadOnlyList<T> values)
		{
			int count = values.Count;
			for (int i = 0; i < count; i++)
			{
				if (i != 0)
				{
					Append(separator);
				}
				T val = values[i];
				if (typeof(T) == typeof(string))
				{
					string value = Unsafe.As<string>(val);
					if (!string.IsNullOrEmpty(value))
					{
						Append(value);
					}
				}
				else
				{
					Append(val);
				}
			}
		}

		internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, ReadOnlySpan<T> values)
		{
			for (int i = 0; i < values.Length; i++)
			{
				if (i != 0)
				{
					Append(separator);
				}
				T val = values[i];
				if (typeof(T) == typeof(string))
				{
					string value = Unsafe.As<string>(val);
					if (!string.IsNullOrEmpty(value))
					{
						Append(value);
					}
				}
				else
				{
					Append(val);
				}
			}
		}

		internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IEnumerable<T> values)
		{
			bool flag = true;
			foreach (T value2 in values)
			{
				if (!flag)
				{
					Append(separator);
				}
				else
				{
					flag = false;
				}
				if (typeof(T) == typeof(string))
				{
					string value = Unsafe.As<string>(value2);
					if (!string.IsNullOrEmpty(value))
					{
						Append(value);
					}
				}
				else
				{
					Append(value2);
				}
			}
		}

		public void AppendFormat<T1>(string format, T1 arg1)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					if (parseResult.Index == 0)
					{
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2>(string format, T1 arg1, T2 arg2)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3>(string format, T1 arg1, T2 arg2, T3 arg3)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, format2, "arg6");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, format2, "arg7");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, format2, "arg8");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, format2, "arg9");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, format2, "arg10");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, format2, "arg11");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, format2, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, format2, "arg12");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, format2, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, format2, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, format2, "arg13");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, format2, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, format2, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, format2, "arg13");
						break;
					case 13:
						AppendFormatInternal(arg14, parseResult.Alignment, format2, "arg14");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, format2, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, format2, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, format2, "arg13");
						break;
					case 13:
						AppendFormatInternal(arg14, parseResult.Alignment, format2, "arg14");
						break;
					case 14:
						AppendFormatInternal(arg15, parseResult.Alignment, format2, "arg15");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		public void AppendFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int count2 = i - num;
						Append(format, num, count2);
						i++;
						num = i;
						break;
					}
					int length = i - num;
					Append(format.AsSpan(num, length));
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						AppendFormatInternal(arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						AppendFormatInternal(arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						AppendFormatInternal(arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						AppendFormatInternal(arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						AppendFormatInternal(arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						AppendFormatInternal(arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						AppendFormatInternal(arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						AppendFormatInternal(arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						AppendFormatInternal(arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						AppendFormatInternal(arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						AppendFormatInternal(arg11, parseResult.Alignment, format2, "arg11");
						break;
					case 11:
						AppendFormatInternal(arg12, parseResult.Alignment, format2, "arg12");
						break;
					case 12:
						AppendFormatInternal(arg13, parseResult.Alignment, format2, "arg13");
						break;
					case 13:
						AppendFormatInternal(arg14, parseResult.Alignment, format2, "arg14");
						break;
					case 14:
						AppendFormatInternal(arg15, parseResult.Alignment, format2, "arg15");
						break;
					case 15:
						AppendFormatInternal(arg16, parseResult.Alignment, format2, "arg16");
						break;
					default:
						ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int count = i - num;
						Append(format, num, count);
						i++;
						num = i;
					}
					else
					{
						ThrowFormatException();
					}
					break;
				}
			}
			int num2 = format.Length - num;
			if (num2 > 0)
			{
				Append(format, num, num2);
			}
		}

		private static object? CreateFormatter(Type type)
		{
			if (type == typeof(byte))
			{
				return (TryFormat<byte>)delegate(byte x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(DateTime))
			{
				return (TryFormat<DateTime>)delegate(DateTime x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(DateTimeOffset))
			{
				return (TryFormat<DateTimeOffset>)delegate(DateTimeOffset x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(decimal))
			{
				return (TryFormat<decimal>)delegate(decimal x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(double))
			{
				return (TryFormat<double>)delegate(double x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(short))
			{
				return (TryFormat<short>)delegate(short x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(int))
			{
				return (TryFormat<int>)delegate(int x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(long))
			{
				return (TryFormat<long>)delegate(long x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(sbyte))
			{
				return (TryFormat<sbyte>)delegate(sbyte x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(float))
			{
				return (TryFormat<float>)delegate(float x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(TimeSpan))
			{
				return (TryFormat<TimeSpan>)delegate(TimeSpan x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(ushort))
			{
				return (TryFormat<ushort>)delegate(ushort x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(uint))
			{
				return (TryFormat<uint>)delegate(uint x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(ulong))
			{
				return (TryFormat<ulong>)delegate(ulong x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(Guid))
			{
				return (TryFormat<Guid>)delegate(Guid x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(bool))
			{
				return (TryFormat<bool>)delegate(bool x, Span<byte> dest, out int written, StandardFormat format)
				{
					return Utf8Formatter.TryFormat(x, dest, out written, format);
				};
			}
			if (type == typeof(byte?))
			{
				return CreateNullableFormatter<byte>();
			}
			if (type == typeof(DateTime?))
			{
				return CreateNullableFormatter<DateTime>();
			}
			if (type == typeof(DateTimeOffset?))
			{
				return CreateNullableFormatter<DateTimeOffset>();
			}
			if (type == typeof(decimal?))
			{
				return CreateNullableFormatter<decimal>();
			}
			if (type == typeof(double?))
			{
				return CreateNullableFormatter<double>();
			}
			if (type == typeof(short?))
			{
				return CreateNullableFormatter<short>();
			}
			if (type == typeof(int?))
			{
				return CreateNullableFormatter<int>();
			}
			if (type == typeof(long?))
			{
				return CreateNullableFormatter<long>();
			}
			if (type == typeof(sbyte?))
			{
				return CreateNullableFormatter<sbyte>();
			}
			if (type == typeof(float?))
			{
				return CreateNullableFormatter<float>();
			}
			if (type == typeof(TimeSpan?))
			{
				return CreateNullableFormatter<TimeSpan>();
			}
			if (type == typeof(ushort?))
			{
				return CreateNullableFormatter<ushort>();
			}
			if (type == typeof(uint?))
			{
				return CreateNullableFormatter<uint>();
			}
			if (type == typeof(ulong?))
			{
				return CreateNullableFormatter<ulong>();
			}
			if (type == typeof(Guid?))
			{
				return CreateNullableFormatter<Guid>();
			}
			if (type == typeof(bool?))
			{
				return CreateNullableFormatter<bool>();
			}
			if (type == typeof(IntPtr))
			{
				return (TryFormat<IntPtr>)delegate(IntPtr x, Span<byte> dest, out int written, StandardFormat format)
				{
					return (IntPtr.Size != 4) ? Utf8Formatter.TryFormat(x.ToInt64(), dest, out written, format) : Utf8Formatter.TryFormat(x.ToInt32(), dest, out written, format);
				};
			}
			if (type == typeof(UIntPtr))
			{
				return (TryFormat<UIntPtr>)delegate(UIntPtr x, Span<byte> dest, out int written, StandardFormat format)
				{
					return (UIntPtr.Size != 4) ? Utf8Formatter.TryFormat(x.ToUInt64(), dest, out written, format) : Utf8Formatter.TryFormat(x.ToUInt32(), dest, out written, format);
				};
			}
			return null;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(byte value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(byte value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(byte value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(byte value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(DateTime value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(DateTime value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(DateTime value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(DateTime value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(DateTimeOffset value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(DateTimeOffset value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(DateTimeOffset value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(DateTimeOffset value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(decimal value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(decimal value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(decimal value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(decimal value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(double value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(double value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(double value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(double value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(short value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(short value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(short value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(short value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(int value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(int value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(int value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(int value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(long value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(long value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(long value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(long value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(sbyte value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(sbyte value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(sbyte value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(sbyte value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(float value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(float value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(float value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(float value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(TimeSpan value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(TimeSpan value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(TimeSpan value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(TimeSpan value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(ushort value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(ushort value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(ushort value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(ushort value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(uint value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(uint value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(uint value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(uint value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(ulong value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(ulong value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(ulong value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(ulong value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(Guid value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(Guid value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(Guid value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(Guid value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(bool value)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(bool value, StandardFormat format)
		{
			if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var bytesWritten, format))
			{
				Grow(bytesWritten);
				if (!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out bytesWritten, format))
				{
					ThrowArgumentException("value");
				}
			}
			index += bytesWritten;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(bool value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(bool value, StandardFormat format)
		{
			Append(value, format);
			AppendLine();
		}

		static Utf8ValueStringBuilder()
		{
			UTF8NoBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
			byte[] bytes = UTF8NoBom.GetBytes(Environment.NewLine);
			if (bytes.Length == 1)
			{
				newLine1 = bytes[0];
				crlf = false;
			}
			else
			{
				newLine1 = bytes[0];
				newLine2 = bytes[1];
				crlf = true;
			}
		}

		public ReadOnlySpan<byte> AsSpan()
		{
			return buffer.AsSpan(0, index);
		}

		public ReadOnlyMemory<byte> AsMemory()
		{
			return buffer.AsMemory(0, index);
		}

		public ArraySegment<byte> AsArraySegment()
		{
			return new ArraySegment<byte>(buffer, 0, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Utf8ValueStringBuilder(bool disposeImmediately)
		{
			if (disposeImmediately && scratchBufferUsed)
			{
				ThrowNestedException();
			}
			byte[] array;
			if (disposeImmediately)
			{
				array = scratchBuffer;
				if (array == null)
				{
					array = (scratchBuffer = new byte[64444]);
				}
				scratchBufferUsed = true;
			}
			else
			{
				array = ArrayPool<byte>.Shared.Rent(65536);
			}
			buffer = array;
			index = 0;
			this.disposeImmediately = disposeImmediately;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Dispose()
		{
			if (buffer != null)
			{
				if (buffer.Length != 64444)
				{
					ArrayPool<byte>.Shared.Return(buffer);
				}
				buffer = null;
				index = 0;
				if (disposeImmediately)
				{
					scratchBufferUsed = false;
				}
			}
		}

		public void Clear()
		{
			index = 0;
		}

		public void TryGrow(int sizeHint)
		{
			if (buffer.Length < index + sizeHint)
			{
				Grow(sizeHint);
			}
		}

		public void Grow(int sizeHint)
		{
			int num = buffer.Length * 2;
			if (sizeHint != 0)
			{
				num = Math.Max(num, index + sizeHint);
			}
			byte[] array = ArrayPool<byte>.Shared.Rent(num);
			buffer.CopyTo(array, 0);
			if (buffer.Length != 64444)
			{
				ArrayPool<byte>.Shared.Return(buffer);
			}
			buffer = array;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine()
		{
			if (crlf)
			{
				if (buffer.Length - index < 2)
				{
					Grow(2);
				}
				buffer[index] = newLine1;
				buffer[index + 1] = newLine2;
				index += 2;
			}
			else
			{
				if (buffer.Length - index < 1)
				{
					Grow(1);
				}
				buffer[index] = newLine1;
				index++;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe void Append(char value)
		{
			int maxByteCount = UTF8NoBom.GetMaxByteCount(1);
			if (buffer.Length - index < maxByteCount)
			{
				Grow(maxByteCount);
			}
			fixed (byte* bytes = &buffer[index])
			{
				index += UTF8NoBom.GetBytes(&value, 1, bytes, maxByteCount);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(char value, int repeatCount)
		{
			if (repeatCount < 0)
			{
				throw new ArgumentOutOfRangeException("repeatCount");
			}
			if (value <= '\u007f')
			{
				GetSpan(repeatCount).Fill((byte)value);
				Advance(repeatCount);
				return;
			}
			Span<byte> bytes = stackalloc byte[UTF8NoBom.GetMaxByteCount(1)];
			ReadOnlySpan<char> chars = stackalloc char[1] { value };
			int bytes2 = UTF8NoBom.GetBytes(chars, bytes);
			TryGrow(bytes2 * repeatCount);
			for (int i = 0; i < repeatCount; i++)
			{
				bytes.CopyTo(GetSpan(bytes2));
				Advance(bytes2);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(char value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(string value, int startIndex, int count)
		{
			if (value == null)
			{
				if (startIndex != 0 || count != 0)
				{
					throw new ArgumentNullException("value");
				}
			}
			else
			{
				Append(value.AsSpan(startIndex, count));
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(string value)
		{
			Append(value.AsSpan());
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(string value)
		{
			Append(value);
			AppendLine();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(ReadOnlySpan<char> value)
		{
			int maxByteCount = UTF8NoBom.GetMaxByteCount(value.Length);
			if (buffer.Length - index < maxByteCount)
			{
				Grow(maxByteCount);
			}
			index += UTF8NoBom.GetBytes(value, buffer.AsSpan(index));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLine(ReadOnlySpan<char> value)
		{
			Append(value);
			AppendLine();
		}

		public void AppendLiteral(ReadOnlySpan<byte> value)
		{
			if (buffer.Length - index < value.Length)
			{
				Grow(value.Length);
			}
			value.CopyTo(buffer.AsSpan(index));
			index += value.Length;
		}

		public void Append<T>(T value)
		{
			if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out var written, default(StandardFormat)))
			{
				Grow(written);
				if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out written, default(StandardFormat)))
				{
					ThrowArgumentException("value");
				}
			}
			index += written;
		}

		public void AppendLine<T>(T value)
		{
			Append(value);
			AppendLine();
		}

		public void CopyTo(IBufferWriter<byte> bufferWriter)
		{
			Span<byte> span = bufferWriter.GetSpan(index);
			TryCopyTo(span, out var bytesWritten);
			bufferWriter.Advance(bytesWritten);
		}

		public bool TryCopyTo(Span<byte> destination, out int bytesWritten)
		{
			if (destination.Length < index)
			{
				bytesWritten = 0;
				return false;
			}
			bytesWritten = index;
			buffer.AsSpan(0, index).CopyTo(destination);
			return true;
		}

		public void WriteTo(Stream stream)
		{
			stream.Write(buffer, 0, index);
		}

		public Task WriteToAsync(Stream stream)
		{
			return stream.WriteAsync(buffer, 0, index);
		}

		public Task WriteToAsync(Stream stream, CancellationToken cancellationToken)
		{
			return stream.WriteAsync(buffer, 0, index, cancellationToken);
		}

		public override string ToString()
		{
			if (index == 0)
			{
				return string.Empty;
			}
			return UTF8NoBom.GetString(buffer, 0, index);
		}

		public Memory<byte> GetMemory(int sizeHint)
		{
			if (buffer.Length - index < sizeHint)
			{
				Grow(sizeHint);
			}
			return buffer.AsMemory(index);
		}

		public Span<byte> GetSpan(int sizeHint)
		{
			if (buffer.Length - index < sizeHint)
			{
				Grow(sizeHint);
			}
			return buffer.AsSpan(index);
		}

		public void Advance(int count)
		{
			index += count;
		}

		void IResettableBufferWriter<byte>.Reset()
		{
			index = 0;
		}

		private void ThrowArgumentException(string paramName)
		{
			throw new ArgumentException("Can't format argument.", paramName);
		}

		private void ThrowFormatException()
		{
			throw new FormatException("Index (zero based) must be greater than or equal to zero and less than the size of the argument list.");
		}

		private static void ThrowNestedException()
		{
			throw new NestedStringBuilderCreationException("Utf8ValueStringBuilder");
		}

		private void AppendFormatInternal<T>(T arg, int width, StandardFormat format, string argName)
		{
			if (width <= 0)
			{
				width *= -1;
				if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out var written, format))
				{
					Grow(written);
					if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out written, format))
					{
						ThrowArgumentException(argName);
					}
				}
				index += written;
				int num = width - written;
				if (width > 0 && num > 0)
				{
					Append(' ', num);
				}
				return;
			}
			if (typeof(T) == typeof(string))
			{
				string text = Unsafe.As<string>(arg);
				int num2 = width - text.Length;
				if (num2 > 0)
				{
					Append(' ', num2);
				}
				Append(text);
				return;
			}
			Span<byte> destination = stackalloc byte[typeof(T).IsValueType ? (Unsafe.SizeOf<T>() * 8) : 1024];
			if (!FormatterCache<T>.TryFormatDelegate(arg, destination, out var written2, format))
			{
				destination = stackalloc byte[destination.Length * 2];
				if (!FormatterCache<T>.TryFormatDelegate(arg, destination, out written2, format))
				{
					ThrowArgumentException(argName);
				}
			}
			int num3 = width - written2;
			if (num3 > 0)
			{
				Append(' ', num3);
			}
			destination.CopyTo(GetSpan(written2));
			Advance(written2);
		}

		public static void RegisterTryFormat<T>(TryFormat<T> formatMethod)
		{
			FormatterCache<T>.TryFormatDelegate = formatMethod;
		}

		private static TryFormat<T?> CreateNullableFormatter<T>() where T : struct
		{
			return delegate(T? x, Span<byte> destination, out int written, StandardFormat format)
			{
				if (!x.HasValue)
				{
					written = 0;
					return true;
				}
				return FormatterCache<T>.TryFormatDelegate(x.Value, destination, out written, format);
			};
		}

		public static void EnableNullableFormat<T>() where T : struct
		{
			RegisterTryFormat(CreateNullableFormatter<T>());
		}
	}
	public static class ZString
	{
		private static Encoding UTF8NoBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

		public static string Concat<T1>(T1 arg1)
		{
			if (typeof(T1) == typeof(string))
			{
				if (arg1 == null)
				{
					return string.Empty;
				}
				return Unsafe.As<string>(arg1);
			}
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2>(T1 arg1, T2 arg2)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3>(T1 arg1, T2 arg2, T3 arg3)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4>(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5, T6>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				if (typeof(T6) == typeof(string))
				{
					if (arg6 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T6, string>(ref arg6));
					}
				}
				else if (typeof(T6) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T6, int>(ref arg6));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg6);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5, T6, T7>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				if (typeof(T6) == typeof(string))
				{
					if (arg6 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T6, string>(ref arg6));
					}
				}
				else if (typeof(T6) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T6, int>(ref arg6));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg6);
				}
				if (typeof(T7) == typeof(string))
				{
					if (arg7 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T7, string>(ref arg7));
					}
				}
				else if (typeof(T7) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T7, int>(ref arg7));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg7);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5, T6, T7, T8>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				if (typeof(T6) == typeof(string))
				{
					if (arg6 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T6, string>(ref arg6));
					}
				}
				else if (typeof(T6) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T6, int>(ref arg6));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg6);
				}
				if (typeof(T7) == typeof(string))
				{
					if (arg7 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T7, string>(ref arg7));
					}
				}
				else if (typeof(T7) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T7, int>(ref arg7));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg7);
				}
				if (typeof(T8) == typeof(string))
				{
					if (arg8 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T8, string>(ref arg8));
					}
				}
				else if (typeof(T8) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T8, int>(ref arg8));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg8);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				if (typeof(T6) == typeof(string))
				{
					if (arg6 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T6, string>(ref arg6));
					}
				}
				else if (typeof(T6) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T6, int>(ref arg6));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg6);
				}
				if (typeof(T7) == typeof(string))
				{
					if (arg7 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T7, string>(ref arg7));
					}
				}
				else if (typeof(T7) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T7, int>(ref arg7));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg7);
				}
				if (typeof(T8) == typeof(string))
				{
					if (arg8 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T8, string>(ref arg8));
					}
				}
				else if (typeof(T8) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T8, int>(ref arg8));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg8);
				}
				if (typeof(T9) == typeof(string))
				{
					if (arg9 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T9, string>(ref arg9));
					}
				}
				else if (typeof(T9) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T9, int>(ref arg9));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg9);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				if (typeof(T6) == typeof(string))
				{
					if (arg6 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T6, string>(ref arg6));
					}
				}
				else if (typeof(T6) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T6, int>(ref arg6));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg6);
				}
				if (typeof(T7) == typeof(string))
				{
					if (arg7 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T7, string>(ref arg7));
					}
				}
				else if (typeof(T7) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T7, int>(ref arg7));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg7);
				}
				if (typeof(T8) == typeof(string))
				{
					if (arg8 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T8, string>(ref arg8));
					}
				}
				else if (typeof(T8) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T8, int>(ref arg8));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg8);
				}
				if (typeof(T9) == typeof(string))
				{
					if (arg9 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T9, string>(ref arg9));
					}
				}
				else if (typeof(T9) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T9, int>(ref arg9));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg9);
				}
				if (typeof(T10) == typeof(string))
				{
					if (arg10 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T10, string>(ref arg10));
					}
				}
				else if (typeof(T10) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T10, int>(ref arg10));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg10);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				if (typeof(T6) == typeof(string))
				{
					if (arg6 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T6, string>(ref arg6));
					}
				}
				else if (typeof(T6) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T6, int>(ref arg6));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg6);
				}
				if (typeof(T7) == typeof(string))
				{
					if (arg7 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T7, string>(ref arg7));
					}
				}
				else if (typeof(T7) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T7, int>(ref arg7));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg7);
				}
				if (typeof(T8) == typeof(string))
				{
					if (arg8 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T8, string>(ref arg8));
					}
				}
				else if (typeof(T8) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T8, int>(ref arg8));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg8);
				}
				if (typeof(T9) == typeof(string))
				{
					if (arg9 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T9, string>(ref arg9));
					}
				}
				else if (typeof(T9) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T9, int>(ref arg9));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg9);
				}
				if (typeof(T10) == typeof(string))
				{
					if (arg10 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T10, string>(ref arg10));
					}
				}
				else if (typeof(T10) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T10, int>(ref arg10));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg10);
				}
				if (typeof(T11) == typeof(string))
				{
					if (arg11 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T11, string>(ref arg11));
					}
				}
				else if (typeof(T11) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T11, int>(ref arg11));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg11);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				if (typeof(T6) == typeof(string))
				{
					if (arg6 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T6, string>(ref arg6));
					}
				}
				else if (typeof(T6) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T6, int>(ref arg6));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg6);
				}
				if (typeof(T7) == typeof(string))
				{
					if (arg7 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T7, string>(ref arg7));
					}
				}
				else if (typeof(T7) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T7, int>(ref arg7));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg7);
				}
				if (typeof(T8) == typeof(string))
				{
					if (arg8 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T8, string>(ref arg8));
					}
				}
				else if (typeof(T8) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T8, int>(ref arg8));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg8);
				}
				if (typeof(T9) == typeof(string))
				{
					if (arg9 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T9, string>(ref arg9));
					}
				}
				else if (typeof(T9) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T9, int>(ref arg9));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg9);
				}
				if (typeof(T10) == typeof(string))
				{
					if (arg10 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T10, string>(ref arg10));
					}
				}
				else if (typeof(T10) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T10, int>(ref arg10));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg10);
				}
				if (typeof(T11) == typeof(string))
				{
					if (arg11 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T11, string>(ref arg11));
					}
				}
				else if (typeof(T11) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T11, int>(ref arg11));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg11);
				}
				if (typeof(T12) == typeof(string))
				{
					if (arg12 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T12, string>(ref arg12));
					}
				}
				else if (typeof(T12) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T12, int>(ref arg12));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg12);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				if (typeof(T6) == typeof(string))
				{
					if (arg6 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T6, string>(ref arg6));
					}
				}
				else if (typeof(T6) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T6, int>(ref arg6));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg6);
				}
				if (typeof(T7) == typeof(string))
				{
					if (arg7 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T7, string>(ref arg7));
					}
				}
				else if (typeof(T7) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T7, int>(ref arg7));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg7);
				}
				if (typeof(T8) == typeof(string))
				{
					if (arg8 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T8, string>(ref arg8));
					}
				}
				else if (typeof(T8) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T8, int>(ref arg8));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg8);
				}
				if (typeof(T9) == typeof(string))
				{
					if (arg9 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T9, string>(ref arg9));
					}
				}
				else if (typeof(T9) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T9, int>(ref arg9));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg9);
				}
				if (typeof(T10) == typeof(string))
				{
					if (arg10 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T10, string>(ref arg10));
					}
				}
				else if (typeof(T10) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T10, int>(ref arg10));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg10);
				}
				if (typeof(T11) == typeof(string))
				{
					if (arg11 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T11, string>(ref arg11));
					}
				}
				else if (typeof(T11) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T11, int>(ref arg11));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg11);
				}
				if (typeof(T12) == typeof(string))
				{
					if (arg12 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T12, string>(ref arg12));
					}
				}
				else if (typeof(T12) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T12, int>(ref arg12));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg12);
				}
				if (typeof(T13) == typeof(string))
				{
					if (arg13 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T13, string>(ref arg13));
					}
				}
				else if (typeof(T13) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T13, int>(ref arg13));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg13);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				if (typeof(T6) == typeof(string))
				{
					if (arg6 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T6, string>(ref arg6));
					}
				}
				else if (typeof(T6) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T6, int>(ref arg6));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg6);
				}
				if (typeof(T7) == typeof(string))
				{
					if (arg7 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T7, string>(ref arg7));
					}
				}
				else if (typeof(T7) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T7, int>(ref arg7));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg7);
				}
				if (typeof(T8) == typeof(string))
				{
					if (arg8 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T8, string>(ref arg8));
					}
				}
				else if (typeof(T8) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T8, int>(ref arg8));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg8);
				}
				if (typeof(T9) == typeof(string))
				{
					if (arg9 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T9, string>(ref arg9));
					}
				}
				else if (typeof(T9) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T9, int>(ref arg9));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg9);
				}
				if (typeof(T10) == typeof(string))
				{
					if (arg10 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T10, string>(ref arg10));
					}
				}
				else if (typeof(T10) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T10, int>(ref arg10));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg10);
				}
				if (typeof(T11) == typeof(string))
				{
					if (arg11 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T11, string>(ref arg11));
					}
				}
				else if (typeof(T11) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T11, int>(ref arg11));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg11);
				}
				if (typeof(T12) == typeof(string))
				{
					if (arg12 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T12, string>(ref arg12));
					}
				}
				else if (typeof(T12) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T12, int>(ref arg12));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg12);
				}
				if (typeof(T13) == typeof(string))
				{
					if (arg13 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T13, string>(ref arg13));
					}
				}
				else if (typeof(T13) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T13, int>(ref arg13));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg13);
				}
				if (typeof(T14) == typeof(string))
				{
					if (arg14 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T14, string>(ref arg14));
					}
				}
				else if (typeof(T14) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T14, int>(ref arg14));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg14);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				if (typeof(T6) == typeof(string))
				{
					if (arg6 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T6, string>(ref arg6));
					}
				}
				else if (typeof(T6) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T6, int>(ref arg6));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg6);
				}
				if (typeof(T7) == typeof(string))
				{
					if (arg7 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T7, string>(ref arg7));
					}
				}
				else if (typeof(T7) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T7, int>(ref arg7));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg7);
				}
				if (typeof(T8) == typeof(string))
				{
					if (arg8 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T8, string>(ref arg8));
					}
				}
				else if (typeof(T8) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T8, int>(ref arg8));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg8);
				}
				if (typeof(T9) == typeof(string))
				{
					if (arg9 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T9, string>(ref arg9));
					}
				}
				else if (typeof(T9) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T9, int>(ref arg9));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg9);
				}
				if (typeof(T10) == typeof(string))
				{
					if (arg10 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T10, string>(ref arg10));
					}
				}
				else if (typeof(T10) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T10, int>(ref arg10));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg10);
				}
				if (typeof(T11) == typeof(string))
				{
					if (arg11 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T11, string>(ref arg11));
					}
				}
				else if (typeof(T11) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T11, int>(ref arg11));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg11);
				}
				if (typeof(T12) == typeof(string))
				{
					if (arg12 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T12, string>(ref arg12));
					}
				}
				else if (typeof(T12) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T12, int>(ref arg12));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg12);
				}
				if (typeof(T13) == typeof(string))
				{
					if (arg13 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T13, string>(ref arg13));
					}
				}
				else if (typeof(T13) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T13, int>(ref arg13));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg13);
				}
				if (typeof(T14) == typeof(string))
				{
					if (arg14 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T14, string>(ref arg14));
					}
				}
				else if (typeof(T14) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T14, int>(ref arg14));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg14);
				}
				if (typeof(T15) == typeof(string))
				{
					if (arg15 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T15, string>(ref arg15));
					}
				}
				else if (typeof(T15) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T15, int>(ref arg15));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg15);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static string Concat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				if (typeof(T1) == typeof(string))
				{
					if (arg1 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T1, string>(ref arg1));
					}
				}
				else if (typeof(T1) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T1, int>(ref arg1));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg1);
				}
				if (typeof(T2) == typeof(string))
				{
					if (arg2 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T2, string>(ref arg2));
					}
				}
				else if (typeof(T2) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T2, int>(ref arg2));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg2);
				}
				if (typeof(T3) == typeof(string))
				{
					if (arg3 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T3, string>(ref arg3));
					}
				}
				else if (typeof(T3) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T3, int>(ref arg3));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg3);
				}
				if (typeof(T4) == typeof(string))
				{
					if (arg4 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T4, string>(ref arg4));
					}
				}
				else if (typeof(T4) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T4, int>(ref arg4));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg4);
				}
				if (typeof(T5) == typeof(string))
				{
					if (arg5 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T5, string>(ref arg5));
					}
				}
				else if (typeof(T5) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T5, int>(ref arg5));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg5);
				}
				if (typeof(T6) == typeof(string))
				{
					if (arg6 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T6, string>(ref arg6));
					}
				}
				else if (typeof(T6) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T6, int>(ref arg6));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg6);
				}
				if (typeof(T7) == typeof(string))
				{
					if (arg7 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T7, string>(ref arg7));
					}
				}
				else if (typeof(T7) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T7, int>(ref arg7));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg7);
				}
				if (typeof(T8) == typeof(string))
				{
					if (arg8 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T8, string>(ref arg8));
					}
				}
				else if (typeof(T8) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T8, int>(ref arg8));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg8);
				}
				if (typeof(T9) == typeof(string))
				{
					if (arg9 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T9, string>(ref arg9));
					}
				}
				else if (typeof(T9) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T9, int>(ref arg9));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg9);
				}
				if (typeof(T10) == typeof(string))
				{
					if (arg10 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T10, string>(ref arg10));
					}
				}
				else if (typeof(T10) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T10, int>(ref arg10));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg10);
				}
				if (typeof(T11) == typeof(string))
				{
					if (arg11 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T11, string>(ref arg11));
					}
				}
				else if (typeof(T11) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T11, int>(ref arg11));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg11);
				}
				if (typeof(T12) == typeof(string))
				{
					if (arg12 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T12, string>(ref arg12));
					}
				}
				else if (typeof(T12) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T12, int>(ref arg12));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg12);
				}
				if (typeof(T13) == typeof(string))
				{
					if (arg13 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T13, string>(ref arg13));
					}
				}
				else if (typeof(T13) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T13, int>(ref arg13));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg13);
				}
				if (typeof(T14) == typeof(string))
				{
					if (arg14 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T14, string>(ref arg14));
					}
				}
				else if (typeof(T14) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T14, int>(ref arg14));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg14);
				}
				if (typeof(T15) == typeof(string))
				{
					if (arg15 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T15, string>(ref arg15));
					}
				}
				else if (typeof(T15) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T15, int>(ref arg15));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg15);
				}
				if (typeof(T16) == typeof(string))
				{
					if (arg16 != null)
					{
						utf16ValueStringBuilder.Append(Unsafe.As<T16, string>(ref arg16));
					}
				}
				else if (typeof(T16) == typeof(int))
				{
					utf16ValueStringBuilder.Append(Unsafe.As<T16, int>(ref arg16));
				}
				else
				{
					utf16ValueStringBuilder.Append(arg16);
				}
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AppendChars<TBufferWriter>(ref TBufferWriter sb, ReadOnlySpan<char> chars) where TBufferWriter : IBufferWriter<byte>
		{
			int maxByteCount = UTF8NoBom.GetMaxByteCount(chars.Length);
			Span<byte> span = sb.GetSpan(maxByteCount);
			int bytes = UTF8NoBom.GetBytes(chars, span);
			sb.Advance(bytes);
		}

		public static Utf16ValueStringBuilder CreateStringBuilder()
		{
			return new Utf16ValueStringBuilder(disposeImmediately: false);
		}

		public static Utf8ValueStringBuilder CreateUtf8StringBuilder()
		{
			return new Utf8ValueStringBuilder(disposeImmediately: false);
		}

		public static Utf16ValueStringBuilder CreateStringBuilder(bool notNested)
		{
			return new Utf16ValueStringBuilder(notNested);
		}

		public static Utf8ValueStringBuilder CreateUtf8StringBuilder(bool notNested)
		{
			return new Utf8ValueStringBuilder(notNested);
		}

		public static string Join<T>(char separator, params T[] values)
		{
			return JoinInternal<T>(stackalloc char[1] { separator }, values.AsSpan());
		}

		public static string Join<T>(char separator, List<T> values)
		{
			return JoinInternal((ReadOnlySpan<char>)stackalloc char[1] { separator }, (IReadOnlyList<T>)values);
		}

		public static string Join<T>(char separator, ReadOnlySpan<T> values)
		{
			return JoinInternal(stackalloc char[1] { separator }, values);
		}

		public static string Join<T>(char separator, IEnumerable<T> values)
		{
			return JoinInternal(stackalloc char[1] { separator }, values);
		}

		public static string Join<T>(char separator, ICollection<T> values)
		{
			return JoinInternal(stackalloc char[1] { separator }, values.AsEnumerable());
		}

		public static string Join<T>(char separator, IList<T> values)
		{
			return JoinInternal(stackalloc char[1] { separator }, values);
		}

		public static string Join<T>(char separator, IReadOnlyList<T> values)
		{
			return JoinInternal(stackalloc char[1] { separator }, values);
		}

		public static string Join<T>(char separator, IReadOnlyCollection<T> values)
		{
			return JoinInternal(stackalloc char[1] { separator }, values.AsEnumerable());
		}

		public static string Join<T>(string separator, params T[] values)
		{
			return JoinInternal<T>(separator.AsSpan(), values.AsSpan());
		}

		public static string Join<T>(string separator, List<T> values)
		{
			return JoinInternal(separator.AsSpan(), (IReadOnlyList<T>)values);
		}

		public static string Join<T>(string separator, ReadOnlySpan<T> values)
		{
			return JoinInternal(separator.AsSpan(), values);
		}

		public static string Join<T>(string separator, ICollection<T> values)
		{
			return JoinInternal(separator.AsSpan(), values.AsEnumerable());
		}

		public static string Join<T>(string separator, IList<T> values)
		{
			return JoinInternal(separator.AsSpan(), values);
		}

		public static string Join<T>(string separator, IReadOnlyList<T> values)
		{
			return JoinInternal(separator.AsSpan(), values);
		}

		public static string Join<T>(string separator, IReadOnlyCollection<T> values)
		{
			return JoinInternal(separator.AsSpan(), values.AsEnumerable());
		}

		public static string Join<T>(string separator, IEnumerable<T> values)
		{
			return JoinInternal(separator.AsSpan(), values);
		}

		public static string Concat<T>(params T[] values)
		{
			return JoinInternal<T>(default(ReadOnlySpan<char>), values.AsSpan());
		}

		public static string Concat<T>(List<T> values)
		{
			return JoinInternal(default(ReadOnlySpan<char>), (IReadOnlyList<T>)values);
		}

		public static string Concat<T>(ReadOnlySpan<T> values)
		{
			return JoinInternal(default(ReadOnlySpan<char>), values);
		}

		public static string Concat<T>(ICollection<T> values)
		{
			return JoinInternal(default(ReadOnlySpan<char>), values.AsEnumerable());
		}

		public static string Concat<T>(IList<T> values)
		{
			return JoinInternal(default(ReadOnlySpan<char>), values);
		}

		public static string Concat<T>(IReadOnlyList<T> values)
		{
			return JoinInternal(default(ReadOnlySpan<char>), values);
		}

		public static string Concat<T>(IReadOnlyCollection<T> values)
		{
			return JoinInternal(default(ReadOnlySpan<char>), values.AsEnumerable());
		}

		public static string Concat<T>(IEnumerable<T> values)
		{
			return JoinInternal(default(ReadOnlySpan<char>), values);
		}

		private static string JoinInternal<T>(ReadOnlySpan<char> separator, IList<T> values)
		{
			IReadOnlyList<T> readOnlyList = values as IReadOnlyList<T>;
			readOnlyList = (IReadOnlyList<T>)(readOnlyList ?? ((object)new ReadOnlyListAdaptor<T>(values)));
			return JoinInternal(separator, readOnlyList);
		}

		private static string JoinInternal<T>(ReadOnlySpan<char> separator, IReadOnlyList<T> values)
		{
			if (values.Count == 0)
			{
				return string.Empty;
			}
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendJoinInternal(separator, values);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		private static string JoinInternal<T>(ReadOnlySpan<char> separator, ReadOnlySpan<T> values)
		{
			if (values.Length == 0)
			{
				return string.Empty;
			}
			if (typeof(T) == typeof(string) && values.Length == 1)
			{
				return Unsafe.As<string>(values[0]);
			}
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendJoinInternal(separator, values);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		private static string JoinInternal<T>(ReadOnlySpan<char> separator, IEnumerable<T> values)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendJoinInternal(separator, values);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1>(string format, T1 arg1)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1>(ReadOnlySpan<char> format, T1 arg1)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2>(string format, T1 arg1, T2 arg2)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2>(ReadOnlySpan<char> format, T1 arg1, T2 arg2)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3>(string format, T1 arg1, T2 arg2, T3 arg3)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
		{
			Utf16ValueStringBuilder utf16ValueStringBuilder = new Utf16ValueStringBuilder(disposeImmediately: true);
			try
			{
				utf16ValueStringBuilder.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
				return utf16ValueStringBuilder.ToString();
			}
			finally
			{
				utf16ValueStringBuilder.Dispose();
			}
		}

		public static Utf16PreparedFormat<T1> PrepareUtf16<T1>(string format)
		{
			return new Utf16PreparedFormat<T1>(format);
		}

		public static Utf8PreparedFormat<T1> PrepareUtf8<T1>(string format)
		{
			return new Utf8PreparedFormat<T1>(format);
		}

		public static Utf16PreparedFormat<T1, T2> PrepareUtf16<T1, T2>(string format)
		{
			return new Utf16PreparedFormat<T1, T2>(format);
		}

		public static Utf8PreparedFormat<T1, T2> PrepareUtf8<T1, T2>(string format)
		{
			return new Utf8PreparedFormat<T1, T2>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3> PrepareUtf16<T1, T2, T3>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3> PrepareUtf8<T1, T2, T3>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4> PrepareUtf16<T1, T2, T3, T4>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4> PrepareUtf8<T1, T2, T3, T4>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5> PrepareUtf16<T1, T2, T3, T4, T5>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5> PrepareUtf8<T1, T2, T3, T4, T5>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6> PrepareUtf16<T1, T2, T3, T4, T5, T6>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6> PrepareUtf8<T1, T2, T3, T4, T5, T6>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(format);
		}

		public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format)
		{
			return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(format);
		}

		public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format)
		{
			return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(format);
		}

		public static void Utf8Format<T1>(IBufferWriter<byte> bufferWriter, string format, T1 arg1)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					if (parseResult.Index == 0)
					{
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					}
					ExceptionUtil.ThrowFormatException();
					ExceptionUtil.ThrowFormatException();
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5, T6>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg6, parseResult.Alignment, format2, "arg6");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5, T6, T7>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg7, parseResult.Alignment, format2, "arg7");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5, T6, T7, T8>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg8, parseResult.Alignment, format2, "arg8");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5, T6, T7, T8, T9>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg9, parseResult.Alignment, format2, "arg9");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg10, parseResult.Alignment, format2, "arg10");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg11, parseResult.Alignment, format2, "arg11");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg11, parseResult.Alignment, format2, "arg11");
						break;
					case 11:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg12, parseResult.Alignment, format2, "arg12");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg11, parseResult.Alignment, format2, "arg11");
						break;
					case 11:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg12, parseResult.Alignment, format2, "arg12");
						break;
					case 12:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg13, parseResult.Alignment, format2, "arg13");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg11, parseResult.Alignment, format2, "arg11");
						break;
					case 11:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg12, parseResult.Alignment, format2, "arg12");
						break;
					case 12:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg13, parseResult.Alignment, format2, "arg13");
						break;
					case 13:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg14, parseResult.Alignment, format2, "arg14");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg11, parseResult.Alignment, format2, "arg11");
						break;
					case 11:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg12, parseResult.Alignment, format2, "arg12");
						break;
					case 12:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg13, parseResult.Alignment, format2, "arg13");
						break;
					case 13:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg14, parseResult.Alignment, format2, "arg14");
						break;
					case 14:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg15, parseResult.Alignment, format2, "arg15");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}

		public static void Utf8Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(IBufferWriter<byte> bufferWriter, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = 0;
			for (int i = 0; i < format.Length; i++)
			{
				switch (format[i])
				{
				case '{':
				{
					if (i == format.Length - 1)
					{
						throw new FormatException("invalid format");
					}
					if (i != format.Length && format[i + 1] == '{')
					{
						int num3 = i - num;
						Span<byte> span2 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num3));
						int bytes2 = UTF8NoBom.GetBytes(format.AsSpan(num, num3), span2);
						bufferWriter.Advance(bytes2);
						i++;
						num = i;
						break;
					}
					int num4 = i - num;
					Span<byte> span3 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num4));
					int bytes3 = UTF8NoBom.GetBytes(format.AsSpan(num, num4), span3);
					bufferWriter.Advance(bytes3);
					FormatParser.ParseResult parseResult = FormatParser.Parse(format, i);
					num = parseResult.LastIndex;
					i = parseResult.LastIndex - 1;
					StandardFormat format2 = StandardFormat.Parse(parseResult.FormatString);
					switch (parseResult.Index)
					{
					case 0:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg1, parseResult.Alignment, format2, "arg1");
						break;
					case 1:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg2, parseResult.Alignment, format2, "arg2");
						break;
					case 2:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg3, parseResult.Alignment, format2, "arg3");
						break;
					case 3:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg4, parseResult.Alignment, format2, "arg4");
						break;
					case 4:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg5, parseResult.Alignment, format2, "arg5");
						break;
					case 5:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg6, parseResult.Alignment, format2, "arg6");
						break;
					case 6:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg7, parseResult.Alignment, format2, "arg7");
						break;
					case 7:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg8, parseResult.Alignment, format2, "arg8");
						break;
					case 8:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg9, parseResult.Alignment, format2, "arg9");
						break;
					case 9:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg10, parseResult.Alignment, format2, "arg10");
						break;
					case 10:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg11, parseResult.Alignment, format2, "arg11");
						break;
					case 11:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg12, parseResult.Alignment, format2, "arg12");
						break;
					case 12:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg13, parseResult.Alignment, format2, "arg13");
						break;
					case 13:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg14, parseResult.Alignment, format2, "arg14");
						break;
					case 14:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg15, parseResult.Alignment, format2, "arg15");
						break;
					case 15:
						Utf8FormatHelper.FormatTo(ref bufferWriter, arg16, parseResult.Alignment, format2, "arg16");
						break;
					default:
						ExceptionUtil.ThrowFormatException();
						ExceptionUtil.ThrowFormatException();
						break;
					}
					break;
				}
				case '}':
					if (i + 1 < format.Length && format[i + 1] == '}')
					{
						int num2 = i - num;
						Span<byte> span = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num2));
						int bytes = UTF8NoBom.GetBytes(format.AsSpan(num, num2), span);
						bufferWriter.Advance(bytes);
						i++;
						num = i;
					}
					else
					{
						ExceptionUtil.ThrowFormatException();
					}
					break;
				}
			}
			int num5 = format.Length - num;
			if (num5 > 0)
			{
				Span<byte> span4 = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(num5));
				int bytes4 = UTF8NoBom.GetBytes(format.AsSpan(num, num5), span4);
				bufferWriter.Advance(bytes4);
			}
		}
	}
	public sealed class ZStringWriter : TextWriter
	{
		private Utf16ValueStringBuilder sb;

		private bool isOpen;

		private UnicodeEncoding? encoding;

		public override Encoding Encoding
		{
			get
			{
				UnicodeEncoding? obj = encoding ?? new UnicodeEncoding(bigEndian: false, byteOrderMark: false);
				UnicodeEncoding result = obj;
				encoding = obj;
				return result;
			}
		}

		public ZStringWriter()
			: this(CultureInfo.CurrentCulture)
		{
		}

		public ZStringWriter(IFormatProvider formatProvider)
			: base(formatProvider)
		{
			sb = ZString.CreateStringBuilder();
			isOpen = true;
		}

		public override void Close()
		{
			Dispose(disposing: true);
		}

		protected override void Dispose(bool disposing)
		{
			sb.Dispose();
			isOpen = false;
			base.Dispose(disposing);
		}

		public override void Write(char value)
		{
			AssertNotDisposed();
			sb.Append(value);
		}

		public override void Write(char[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (buffer.Length - index < count)
			{
				throw new ArgumentException();
			}
			AssertNotDisposed();
			sb.Append(buffer, index, count);
		}

		public override void Write(string value)
		{
			AssertNotDisposed();
			if (value != null)
			{
				sb.Append(value);
			}
		}

		public override Task WriteAsync(char value)
		{
			Write(value);
			return Task.CompletedTask;
		}

		public override Task WriteAsync(string value)
		{
			Write(value);
			return Task.CompletedTask;
		}

		public override Task WriteAsync(char[] buffer, int index, int count)
		{
			Write(buffer, index, count);
			return Task.CompletedTask;
		}

		public override Task WriteLineAsync(char value)
		{
			WriteLine(value);
			return Task.CompletedTask;
		}

		public override Task WriteLineAsync(string value)
		{
			WriteLine(value);
			return Task.CompletedTask;
		}

		public override Task WriteLineAsync(char[] buffer, int index, int count)
		{
			WriteLine(buffer, index, count);
			return Task.CompletedTask;
		}

		public override void Write(bool value)
		{
			AssertNotDisposed();
			sb.Append(value);
		}

		public override void Write(decimal value)
		{
			AssertNotDisposed();
			sb.Append(value);
		}

		public override Task FlushAsync()
		{
			return Task.CompletedTask;
		}

		public override string ToString()
		{
			return sb.ToString();
		}

		private void AssertNotDisposed()
		{
			if (!isOpen)
			{
				throw new ObjectDisposedException("sb");
			}
		}
	}
}
