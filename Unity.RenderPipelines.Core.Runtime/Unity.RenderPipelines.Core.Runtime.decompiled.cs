#define UNITY_ASSERTIONS
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using JetBrains.Annotations;
using Microsoft.CodeAnalysis;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Profiling;
using UnityEngine.Assertions;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Jobs;
using UnityEngine.Profiling;
using UnityEngine.Rendering;
using UnityEngine.Rendering.RendererUtils;
using UnityEngine.Rendering.UI;
using UnityEngine.SceneManagement;
using UnityEngine.Scripting.APIUpdating;
using UnityEngine.Serialization;
using UnityEngine.UI;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: InternalsVisibleTo("Unity.RenderPipelines.Core.Editor")]
[assembly: InternalsVisibleTo("Unity.RenderPipelines.Core.Runtime.Tests")]
[assembly: InternalsVisibleTo("Unity.RenderPipelines.HighDefinition.Runtime")]
[assembly: InternalsVisibleTo("Unity.GraphicTests.Performance.Universal.Runtime")]
[assembly: InternalsVisibleTo("Unity.RenderPipelines.Core.Editor.Tests")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsUnmanagedAttribute : Attribute
	{
	}
}
[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		return new MonoScriptData
		{
			FilePathsData = new byte[18741]
			{
				0, 0, 0, 1, 0, 0, 0, 94, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 67, 97,
				109, 101, 114, 97, 92, 67, 97, 109, 101, 114,
				97, 83, 119, 105, 116, 99, 104, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 90,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				67, 97, 109, 101, 114, 97, 92, 70, 114, 101,
				101, 67, 97, 109, 101, 114, 97, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 97, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 67, 111,
				109, 109, 111, 110, 92, 67, 111, 109, 109, 97,
				110, 100, 66, 117, 102, 102, 101, 114, 80, 111,
				111, 108, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 98, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 67, 111, 109, 109, 111, 110, 92,
				67, 111, 109, 112, 111, 110, 101, 110, 116, 83,
				105, 110, 103, 108, 101, 116, 111, 110, 46, 99,
				115, 0, 0, 0, 4, 0, 0, 0, 94, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 67,
				111, 109, 109, 111, 110, 92, 67, 111, 110, 115,
				116, 97, 110, 116, 66, 117, 102, 102, 101, 114,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				94, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 67, 111, 109, 109, 111, 110, 92, 67, 111,
				114, 101, 65, 116, 116, 114, 105, 98, 117, 116,
				101, 115, 46, 99, 115, 0, 0, 0, 5, 0,
				0, 0, 95, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 67, 111, 109, 109, 111, 110, 92,
				67, 111, 114, 101, 85, 110, 115, 97, 102, 101,
				85, 116, 105, 108, 115, 46, 99, 115, 0, 0,
				0, 5, 0, 0, 0, 92, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 67, 111, 109, 109,
				111, 110, 92, 68, 121, 110, 97, 109, 105, 99,
				65, 114, 114, 97, 121, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 104, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 67, 111, 109, 109,
				111, 110, 92, 68, 121, 110, 97, 109, 105, 99,
				82, 101, 115, 111, 108, 117, 116, 105, 111, 110,
				72, 97, 110, 100, 108, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 111, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 67, 111,
				109, 109, 111, 110, 92, 71, 108, 111, 98, 97,
				108, 68, 121, 110, 97, 109, 105, 99, 82, 101,
				115, 111, 108, 117, 116, 105, 111, 110, 83, 101,
				116, 116, 105, 110, 103, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 95, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 67, 111, 109,
				109, 111, 110, 92, 73, 65, 100, 100, 105, 116,
				105, 111, 110, 97, 108, 68, 97, 116, 97, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 118,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				67, 111, 109, 109, 111, 110, 92, 73, 86, 105,
				114, 116, 117, 97, 108, 84, 101, 120, 116, 117,
				114, 105, 110, 103, 69, 110, 97, 98, 108, 101,
				100, 82, 101, 110, 100, 101, 114, 80, 105, 112,
				101, 108, 105, 110, 101, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 90, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 67, 111, 109, 109,
				111, 110, 92, 76, 105, 115, 116, 66, 117, 102,
				102, 101, 114, 46, 99, 115, 0, 0, 0, 7,
				0, 0, 0, 91, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 67, 111, 109, 109, 111, 110,
				92, 79, 98, 106, 101, 99, 116, 80, 111, 111,
				108, 115, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 94, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 67, 111, 109, 109, 111, 110, 92,
				79, 98, 115, 101, 114, 118, 97, 98, 108, 101,
				76, 105, 115, 116, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 102, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 67, 111, 109, 109, 111,
				110, 92, 82, 101, 109, 111, 118, 101, 82, 97,
				110, 103, 101, 46, 69, 120, 116, 101, 110, 115,
				105, 111, 110, 115, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 96, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 67, 111, 109, 109, 111,
				110, 92, 83, 101, 114, 105, 97, 108, 105, 122,
				97, 98, 108, 101, 69, 110, 117, 109, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 100, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 67,
				111, 109, 109, 111, 110, 92, 83, 101, 114, 105,
				97, 108, 105, 122, 101, 100, 68, 105, 99, 116,
				105, 111, 110, 97, 114, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 95, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 67, 111, 109,
				109, 111, 110, 92, 83, 119, 97, 112, 46, 69,
				120, 116, 101, 110, 115, 105, 111, 110, 115, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 90,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				67, 111, 109, 109, 111, 110, 92, 88, 82, 71,
				114, 97, 112, 104, 105, 99, 115, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 103, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 68, 101,
				98, 117, 103, 103, 105, 110, 103, 92, 68, 101,
				98, 117, 103, 68, 105, 115, 112, 108, 97, 121,
				83, 101, 116, 116, 105, 110, 103, 115, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 108, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 68,
				101, 98, 117, 103, 103, 105, 110, 103, 92, 68,
				101, 98, 117, 103, 68, 105, 115, 112, 108, 97,
				121, 83, 101, 116, 116, 105, 110, 103, 115, 80,
				97, 110, 101, 108, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 105, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 68, 101, 98, 117, 103,
				103, 105, 110, 103, 92, 68, 101, 98, 117, 103,
				68, 105, 115, 112, 108, 97, 121, 83, 101, 116,
				116, 105, 110, 103, 115, 85, 73, 46, 99, 115,
				0, 0, 0, 5, 0, 0, 0, 110, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 68, 101,
				98, 117, 103, 103, 105, 110, 103, 92, 68, 101,
				98, 117, 103, 68, 105, 115, 112, 108, 97, 121,
				83, 101, 116, 116, 105, 110, 103, 115, 86, 111,
				108, 117, 109, 101, 115, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 99, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 68, 101, 98, 117,
				103, 103, 105, 110, 103, 92, 68, 101, 98, 117,
				103, 70, 114, 97, 109, 101, 84, 105, 109, 105,
				110, 103, 46, 99, 115, 0, 0, 0, 3, 0,
				0, 0, 103, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 68, 101, 98, 117, 103, 103, 105,
				110, 103, 92, 68, 101, 98, 117, 103, 77, 97,
				110, 97, 103, 101, 114, 46, 65, 99, 116, 105,
				111, 110, 115, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 95, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 68, 101, 98, 117, 103, 103,
				105, 110, 103, 92, 68, 101, 98, 117, 103, 77,
				97, 110, 97, 103, 101, 114, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 103, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 68, 101, 98,
				117, 103, 103, 105, 110, 103, 92, 68, 101, 98,
				117, 103, 77, 97, 110, 97, 103, 101, 114, 46,
				85, 73, 83, 116, 97, 116, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 94, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 68, 101,
				98, 117, 103, 103, 105, 110, 103, 92, 68, 101,
				98, 117, 103, 83, 104, 97, 112, 101, 115, 46,
				99, 115, 0, 0, 0, 8, 0, 0, 0, 101,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				68, 101, 98, 117, 103, 103, 105, 110, 103, 92,
				68, 101, 98, 117, 103, 85, 73, 46, 67, 111,
				110, 116, 97, 105, 110, 101, 114, 115, 46, 99,
				115, 0, 0, 0, 9, 0, 0, 0, 90, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 68,
				101, 98, 117, 103, 103, 105, 110, 103, 92, 68,
				101, 98, 117, 103, 85, 73, 46, 99, 115, 0,
				0, 0, 19, 0, 0, 0, 97, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 68, 101, 98,
				117, 103, 103, 105, 110, 103, 92, 68, 101, 98,
				117, 103, 85, 73, 46, 70, 105, 101, 108, 100,
				115, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 96, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 68, 101, 98, 117, 103, 103, 105, 110,
				103, 92, 68, 101, 98, 117, 103, 85, 73, 46,
				80, 97, 110, 101, 108, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 95, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 68, 101, 98, 117,
				103, 103, 105, 110, 103, 92, 68, 101, 98, 117,
				103, 85, 112, 100, 97, 116, 101, 114, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 114, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 68,
				101, 98, 117, 103, 103, 105, 110, 103, 92, 70,
				114, 97, 109, 101, 84, 105, 109, 105, 110, 103,
				92, 70, 114, 97, 109, 101, 84, 105, 109, 101,
				66, 111, 116, 116, 108, 101, 110, 101, 99, 107,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				110, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 68, 101, 98, 117, 103, 103, 105, 110, 103,
				92, 70, 114, 97, 109, 101, 84, 105, 109, 105,
				110, 103, 92, 70, 114, 97, 109, 101, 84, 105,
				109, 101, 83, 97, 109, 112, 108, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 104, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 68,
				101, 98, 117, 103, 103, 105, 110, 103, 92, 73,
				68, 101, 98, 117, 103, 68, 105, 115, 112, 108,
				97, 121, 83, 101, 116, 116, 105, 110, 103, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				108, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 68, 101, 98, 117, 103, 103, 105, 110, 103,
				92, 73, 68, 101, 98, 117, 103, 68, 105, 115,
				112, 108, 97, 121, 83, 101, 116, 116, 105, 110,
				103, 115, 68, 97, 116, 97, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 109, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 68, 101, 98,
				117, 103, 103, 105, 110, 103, 92, 73, 68, 101,
				98, 117, 103, 68, 105, 115, 112, 108, 97, 121,
				83, 101, 116, 116, 105, 110, 103, 115, 80, 97,
				110, 101, 108, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 109, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 68, 101, 98, 117, 103, 103,
				105, 110, 103, 92, 73, 68, 101, 98, 117, 103,
				68, 105, 115, 112, 108, 97, 121, 83, 101, 116,
				116, 105, 110, 103, 115, 81, 117, 101, 114, 121,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				103, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 68, 101, 98, 117, 103, 103, 105, 110, 103,
				92, 73, 86, 111, 108, 117, 109, 101, 68, 101,
				98, 117, 103, 83, 101, 116, 116, 105, 110, 103,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 101, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 68, 101, 98, 117, 103, 103, 105, 110,
				103, 92, 77, 111, 117, 115, 101, 80, 111, 115,
				105, 116, 105, 111, 110, 68, 101, 98, 117, 103,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				121, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 68, 101, 98, 117, 103, 103, 105, 110, 103,
				92, 80, 114, 101, 102, 97, 98, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 68, 101, 98,
				117, 103, 85, 73, 72, 97, 110, 100, 108, 101,
				114, 66, 105, 116, 70, 105, 101, 108, 100, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 119,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				68, 101, 98, 117, 103, 103, 105, 110, 103, 92,
				80, 114, 101, 102, 97, 98, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				66, 117, 116, 116, 111, 110, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 119, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 68, 101, 98,
				117, 103, 103, 105, 110, 103, 92, 80, 114, 101,
				102, 97, 98, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 101, 98, 117, 103, 85, 73,
				72, 97, 110, 100, 108, 101, 114, 67, 97, 110,
				118, 97, 115, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 118, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 68, 101, 98, 117, 103, 103,
				105, 110, 103, 92, 80, 114, 101, 102, 97, 98,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				68, 101, 98, 117, 103, 85, 73, 72, 97, 110,
				100, 108, 101, 114, 67, 111, 108, 111, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 122,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				68, 101, 98, 117, 103, 103, 105, 110, 103, 92,
				80, 114, 101, 102, 97, 98, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				67, 111, 110, 116, 97, 105, 110, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 122,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				68, 101, 98, 117, 103, 103, 105, 110, 103, 92,
				80, 114, 101, 102, 97, 98, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				69, 110, 117, 109, 70, 105, 101, 108, 100, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 124,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				68, 101, 98, 117, 103, 103, 105, 110, 103, 92,
				80, 114, 101, 102, 97, 98, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				69, 110, 117, 109, 72, 105, 115, 116, 111, 114,
				121, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 118, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 68, 101, 98, 117, 103, 103, 105, 110,
				103, 92, 80, 114, 101, 102, 97, 98, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 68, 101,
				98, 117, 103, 85, 73, 72, 97, 110, 100, 108,
				101, 114, 70, 105, 101, 108, 100, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 123, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 68, 101,
				98, 117, 103, 103, 105, 110, 103, 92, 80, 114,
				101, 102, 97, 98, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 68, 101, 98, 117, 103, 85,
				73, 72, 97, 110, 100, 108, 101, 114, 70, 108,
				111, 97, 116, 70, 105, 101, 108, 100, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 120, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 68,
				101, 98, 117, 103, 103, 105, 110, 103, 92, 80,
				114, 101, 102, 97, 98, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 68, 101, 98, 117, 103,
				85, 73, 72, 97, 110, 100, 108, 101, 114, 70,
				111, 108, 100, 111, 117, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 118, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 68, 101, 98,
				117, 103, 103, 105, 110, 103, 92, 80, 114, 101,
				102, 97, 98, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 101, 98, 117, 103, 85, 73,
				72, 97, 110, 100, 108, 101, 114, 71, 114, 111,
				117, 112, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 117, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 68, 101, 98, 117, 103, 103, 105,
				110, 103, 92, 80, 114, 101, 102, 97, 98, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 68,
				101, 98, 117, 103, 85, 73, 72, 97, 110, 100,
				108, 101, 114, 72, 66, 111, 120, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 131, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 68, 101,
				98, 117, 103, 103, 105, 110, 103, 92, 80, 114,
				101, 102, 97, 98, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 68, 101, 98, 117, 103, 85,
				73, 72, 97, 110, 100, 108, 101, 114, 73, 110,
				100, 105, 114, 101, 99, 116, 70, 108, 111, 97,
				116, 70, 105, 101, 108, 100, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 127, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 68, 101, 98,
				117, 103, 103, 105, 110, 103, 92, 80, 114, 101,
				102, 97, 98, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 101, 98, 117, 103, 85, 73,
				72, 97, 110, 100, 108, 101, 114, 73, 110, 100,
				105, 114, 101, 99, 116, 84, 111, 103, 103, 108,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 121, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 68, 101, 98, 117, 103, 103, 105, 110,
				103, 92, 80, 114, 101, 102, 97, 98, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 68, 101,
				98, 117, 103, 85, 73, 72, 97, 110, 100, 108,
				101, 114, 73, 110, 116, 70, 105, 101, 108, 100,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				123, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 68, 101, 98, 117, 103, 103, 105, 110, 103,
				92, 80, 114, 101, 102, 97, 98, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 68, 101, 98,
				117, 103, 85, 73, 72, 97, 110, 100, 108, 101,
				114, 77, 101, 115, 115, 97, 103, 101, 66, 111,
				120, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 119, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 68, 101, 98, 117, 103, 103, 105, 110,
				103, 92, 80, 114, 101, 102, 97, 98, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 68, 101,
				98, 117, 103, 85, 73, 72, 97, 110, 100, 108,
				101, 114, 79, 98, 106, 101, 99, 116, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 123, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 68,
				101, 98, 117, 103, 103, 105, 110, 103, 92, 80,
				114, 101, 102, 97, 98, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 68, 101, 98, 117, 103,
				85, 73, 72, 97, 110, 100, 108, 101, 114, 79,
				98, 106, 101, 99, 116, 76, 105, 115, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 129,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				68, 101, 98, 117, 103, 103, 105, 110, 103, 92,
				80, 114, 101, 102, 97, 98, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				79, 98, 106, 101, 99, 116, 80, 111, 112, 117,
				112, 70, 105, 101, 108, 100, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 118, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 68, 101, 98,
				117, 103, 103, 105, 110, 103, 92, 80, 114, 101,
				102, 97, 98, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 101, 98, 117, 103, 85, 73,
				72, 97, 110, 100, 108, 101, 114, 80, 97, 110,
				101, 108, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 129, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 68, 101, 98, 117, 103, 103, 105,
				110, 103, 92, 80, 114, 101, 102, 97, 98, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 68,
				101, 98, 117, 103, 85, 73, 72, 97, 110, 100,
				108, 101, 114, 80, 101, 114, 115, 105, 115, 116,
				101, 110, 116, 67, 97, 110, 118, 97, 115, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 124,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				68, 101, 98, 117, 103, 103, 105, 110, 103, 92,
				80, 114, 101, 102, 97, 98, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				80, 114, 111, 103, 114, 101, 115, 115, 66, 97,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 116, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 68, 101, 98, 117, 103, 103, 105, 110,
				103, 92, 80, 114, 101, 102, 97, 98, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 68, 101,
				98, 117, 103, 85, 73, 72, 97, 110, 100, 108,
				101, 114, 82, 111, 119, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 119, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 68, 101, 98, 117,
				103, 103, 105, 110, 103, 92, 80, 114, 101, 102,
				97, 98, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 68, 101, 98, 117, 103, 85, 73, 72,
				97, 110, 100, 108, 101, 114, 84, 111, 103, 103,
				108, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 126, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 68, 101, 98, 117, 103, 103, 105,
				110, 103, 92, 80, 114, 101, 102, 97, 98, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 68,
				101, 98, 117, 103, 85, 73, 72, 97, 110, 100,
				108, 101, 114, 84, 111, 103, 103, 108, 101, 72,
				105, 115, 116, 111, 114, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 122, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 68, 101, 98,
				117, 103, 103, 105, 110, 103, 92, 80, 114, 101,
				102, 97, 98, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 101, 98, 117, 103, 85, 73,
				72, 97, 110, 100, 108, 101, 114, 85, 73, 110,
				116, 70, 105, 101, 108, 100, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 118, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 68, 101, 98,
				117, 103, 103, 105, 110, 103, 92, 80, 114, 101,
				102, 97, 98, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 101, 98, 117, 103, 85, 73,
				72, 97, 110, 100, 108, 101, 114, 86, 97, 108,
				117, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 123, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 68, 101, 98, 117, 103, 103, 105,
				110, 103, 92, 80, 114, 101, 102, 97, 98, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 68,
				101, 98, 117, 103, 85, 73, 72, 97, 110, 100,
				108, 101, 114, 86, 97, 108, 117, 101, 84, 117,
				112, 108, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 117, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 68, 101, 98, 117, 103, 103,
				105, 110, 103, 92, 80, 114, 101, 102, 97, 98,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				68, 101, 98, 117, 103, 85, 73, 72, 97, 110,
				100, 108, 101, 114, 86, 66, 111, 120, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 120, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 68,
				101, 98, 117, 103, 103, 105, 110, 103, 92, 80,
				114, 101, 102, 97, 98, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 68, 101, 98, 117, 103,
				85, 73, 72, 97, 110, 100, 108, 101, 114, 86,
				101, 99, 116, 111, 114, 50, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 120, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 68, 101, 98,
				117, 103, 103, 105, 110, 103, 92, 80, 114, 101,
				102, 97, 98, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 101, 98, 117, 103, 85, 73,
				72, 97, 110, 100, 108, 101, 114, 86, 101, 99,
				116, 111, 114, 51, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 120, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 68, 101, 98, 117, 103,
				103, 105, 110, 103, 92, 80, 114, 101, 102, 97,
				98, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 68, 101, 98, 117, 103, 85, 73, 72, 97,
				110, 100, 108, 101, 114, 86, 101, 99, 116, 111,
				114, 52, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 119, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 68, 101, 98, 117, 103, 103, 105,
				110, 103, 92, 80, 114, 101, 102, 97, 98, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 68,
				101, 98, 117, 103, 85, 73, 72, 97, 110, 100,
				108, 101, 114, 87, 105, 100, 103, 101, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 108,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				68, 101, 98, 117, 103, 103, 105, 110, 103, 92,
				80, 114, 101, 102, 97, 98, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 70, 111,
				108, 100, 111, 117, 116, 46, 99, 115, 0, 0,
				0, 4, 0, 0, 0, 97, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 68, 101, 98, 117,
				103, 103, 105, 110, 103, 92, 80, 114, 111, 102,
				105, 108, 105, 110, 103, 83, 99, 111, 112, 101,
				46, 99, 115, 0, 0, 0, 4, 0, 0, 0,
				106, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 68, 101, 98, 117, 103, 103, 105, 110, 103,
				92, 83, 104, 97, 100, 101, 114, 68, 101, 98,
				117, 103, 80, 114, 105, 110, 116, 77, 97, 110,
				97, 103, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 102, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 68, 101, 98, 117, 103,
				103, 105, 110, 103, 92, 86, 111, 108, 117, 109,
				101, 68, 101, 98, 117, 103, 83, 101, 116, 116,
				105, 110, 103, 115, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 83, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 68, 101, 112, 114, 101,
				99, 97, 116, 101, 100, 46, 99, 115, 0, 0,
				0, 3, 0, 0, 0, 86, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 68, 111, 99, 117,
				109, 101, 110, 116, 97, 116, 105, 111, 110, 46,
				99, 115, 0, 0, 0, 6, 0, 0, 0, 109,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				76, 105, 103, 104, 116, 105, 110, 103, 92, 80,
				114, 111, 98, 101, 86, 111, 108, 117, 109, 101,
				92, 80, 114, 111, 98, 101, 66, 114, 105, 99,
				107, 73, 110, 100, 101, 120, 46, 99, 115, 0,
				0, 0, 4, 0, 0, 0, 108, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 76, 105, 103,
				104, 116, 105, 110, 103, 92, 80, 114, 111, 98,
				101, 86, 111, 108, 117, 109, 101, 92, 80, 114,
				111, 98, 101, 66, 114, 105, 99, 107, 80, 111,
				111, 108, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 113, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 76, 105, 103, 104, 116, 105, 110,
				103, 92, 80, 114, 111, 98, 101, 86, 111, 108,
				117, 109, 101, 92, 80, 114, 111, 98, 101, 73,
				110, 100, 101, 120, 79, 102, 73, 110, 100, 105,
				99, 101, 115, 46, 99, 115, 0, 0, 0, 12,
				0, 0, 0, 114, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 76, 105, 103, 104, 116, 105,
				110, 103, 92, 80, 114, 111, 98, 101, 86, 111,
				108, 117, 109, 101, 92, 80, 114, 111, 98, 101,
				82, 101, 102, 101, 114, 101, 110, 99, 101, 86,
				111, 108, 117, 109, 101, 46, 99, 115, 0, 0,
				0, 3, 0, 0, 0, 120, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 76, 105, 103, 104,
				116, 105, 110, 103, 92, 80, 114, 111, 98, 101,
				86, 111, 108, 117, 109, 101, 92, 80, 114, 111,
				98, 101, 82, 101, 102, 101, 114, 101, 110, 99,
				101, 86, 111, 108, 117, 109, 101, 46, 68, 101,
				98, 117, 103, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 124, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 76, 105, 103, 104, 116, 105,
				110, 103, 92, 80, 114, 111, 98, 101, 86, 111,
				108, 117, 109, 101, 92, 80, 114, 111, 98, 101,
				82, 101, 102, 101, 114, 101, 110, 99, 101, 86,
				111, 108, 117, 109, 101, 46, 83, 116, 114, 101,
				97, 109, 105, 110, 103, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 121, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 76, 105, 103, 104,
				116, 105, 110, 103, 92, 80, 114, 111, 98, 101,
				86, 111, 108, 117, 109, 101, 92, 80, 114, 111,
				98, 101, 82, 101, 102, 101, 114, 101, 110, 99,
				101, 86, 111, 108, 117, 109, 101, 80, 114, 111,
				102, 105, 108, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 112, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 76, 105, 103, 104, 116,
				105, 110, 103, 92, 80, 114, 111, 98, 101, 86,
				111, 108, 117, 109, 101, 92, 80, 114, 111, 98,
				101, 84, 111, 117, 99, 104, 117, 112, 86, 111,
				108, 117, 109, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 105, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 76, 105, 103, 104, 116,
				105, 110, 103, 92, 80, 114, 111, 98, 101, 86,
				111, 108, 117, 109, 101, 92, 80, 114, 111, 98,
				101, 86, 111, 108, 117, 109, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 115, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 76, 105,
				103, 104, 116, 105, 110, 103, 92, 80, 114, 111,
				98, 101, 86, 111, 108, 117, 109, 101, 92, 80,
				114, 111, 98, 101, 86, 111, 108, 117, 109, 101,
				46, 77, 105, 103, 114, 97, 116, 105, 111, 110,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				110, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 76, 105, 103, 104, 116, 105, 110, 103, 92,
				80, 114, 111, 98, 101, 86, 111, 108, 117, 109,
				101, 92, 80, 114, 111, 98, 101, 86, 111, 108,
				117, 109, 101, 65, 115, 115, 101, 116, 46, 99,
				115, 0, 0, 0, 3, 0, 0, 0, 126, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 76,
				105, 103, 104, 116, 105, 110, 103, 92, 80, 114,
				111, 98, 101, 86, 111, 108, 117, 109, 101, 92,
				80, 114, 111, 98, 101, 86, 111, 108, 117, 109,
				101, 66, 97, 107, 105, 110, 103, 80, 114, 111,
				99, 101, 115, 115, 83, 101, 116, 116, 105, 110,
				103, 115, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 118, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 76, 105, 103, 104, 116, 105, 110,
				103, 92, 80, 114, 111, 98, 101, 86, 111, 108,
				117, 109, 101, 92, 80, 114, 111, 98, 101, 86,
				111, 108, 117, 109, 101, 71, 73, 67, 111, 110,
				116, 114, 105, 98, 117, 116, 111, 114, 46, 99,
				115, 0, 0, 0, 3, 0, 0, 0, 117, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 76,
				105, 103, 104, 116, 105, 110, 103, 92, 80, 114,
				111, 98, 101, 86, 111, 108, 117, 109, 101, 92,
				80, 114, 111, 98, 101, 86, 111, 108, 117, 109,
				101, 80, 101, 114, 83, 99, 101, 110, 101, 68,
				97, 116, 97, 46, 99, 115, 0, 0, 0, 6,
				0, 0, 0, 114, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 76, 105, 103, 104, 116, 105,
				110, 103, 92, 80, 114, 111, 98, 101, 86, 111,
				108, 117, 109, 101, 92, 80, 114, 111, 98, 101,
				86, 111, 108, 117, 109, 101, 83, 99, 101, 110,
				101, 68, 97, 116, 97, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 121, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 76, 105, 103, 104,
				116, 105, 110, 103, 92, 80, 114, 111, 98, 101,
				86, 111, 108, 117, 109, 101, 92, 83, 104, 97,
				100, 101, 114, 86, 97, 114, 105, 97, 98, 108,
				101, 115, 80, 114, 111, 98, 101, 86, 111, 108,
				117, 109, 101, 115, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 100, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 76, 105, 103, 104, 116,
				105, 110, 103, 92, 83, 112, 104, 101, 114, 105,
				99, 97, 108, 72, 97, 114, 109, 111, 110, 105,
				99, 115, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 91, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 76, 105, 103, 104, 116, 115, 92,
				76, 105, 103, 104, 116, 65, 110, 99, 104, 111,
				114, 46, 99, 115, 0, 0, 0, 3, 0, 0,
				0, 94, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 76, 111, 111, 107, 68, 101, 118, 92,
				73, 68, 97, 116, 97, 80, 114, 111, 118, 105,
				100, 101, 114, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 106, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 80, 111, 115, 116, 80, 114,
				111, 99, 101, 115, 115, 105, 110, 103, 92, 76,
				101, 110, 115, 70, 108, 97, 114, 101, 67, 111,
				109, 109, 111, 110, 83, 82, 80, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 109, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 80, 111,
				115, 116, 80, 114, 111, 99, 101, 115, 115, 105,
				110, 103, 92, 76, 101, 110, 115, 70, 108, 97,
				114, 101, 67, 111, 109, 112, 111, 110, 101, 110,
				116, 83, 82, 80, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 104, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 80, 111, 115, 116, 80,
				114, 111, 99, 101, 115, 115, 105, 110, 103, 92,
				76, 101, 110, 115, 70, 108, 97, 114, 101, 68,
				97, 116, 97, 83, 82, 80, 46, 99, 115, 0,
				0, 0, 13, 0, 0, 0, 96, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 82, 101, 110,
				100, 101, 114, 71, 114, 97, 112, 104, 92, 82,
				101, 110, 100, 101, 114, 71, 114, 97, 112, 104,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				103, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 92, 82, 101, 110, 100, 101, 114, 71,
				114, 97, 112, 104, 66, 117, 105, 108, 100, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 112, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 82, 101, 110, 100, 101, 114, 71, 114,
				97, 112, 104, 92, 82, 101, 110, 100, 101, 114,
				71, 114, 97, 112, 104, 68, 101, 102, 97, 117,
				108, 116, 82, 101, 115, 111, 117, 114, 99, 101,
				115, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 102, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 82, 101, 110, 100, 101, 114, 71, 114,
				97, 112, 104, 92, 82, 101, 110, 100, 101, 114,
				71, 114, 97, 112, 104, 76, 111, 103, 103, 101,
				114, 46, 99, 115, 0, 0, 0, 3, 0, 0,
				0, 106, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 82, 101, 110, 100, 101, 114, 71, 114,
				97, 112, 104, 92, 82, 101, 110, 100, 101, 114,
				71, 114, 97, 112, 104, 79, 98, 106, 101, 99,
				116, 80, 111, 111, 108, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 100, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 82, 101, 110, 100,
				101, 114, 71, 114, 97, 112, 104, 92, 82, 101,
				110, 100, 101, 114, 71, 114, 97, 112, 104, 80,
				97, 115, 115, 46, 99, 115, 0, 0, 0, 4,
				0, 0, 0, 117, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 82, 101, 110, 100, 101, 114,
				71, 114, 97, 112, 104, 92, 82, 101, 110, 100,
				101, 114, 71, 114, 97, 112, 104, 82, 101, 115,
				111, 117, 114, 99, 101, 67, 111, 109, 112, 117,
				116, 101, 66, 117, 102, 102, 101, 114, 46, 99,
				115, 0, 0, 0, 3, 0, 0, 0, 108, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 82,
				101, 110, 100, 101, 114, 71, 114, 97, 112, 104,
				92, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 82, 101, 115, 111, 117, 114, 99, 101,
				80, 111, 111, 108, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 112, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 82, 101, 110, 100, 101,
				114, 71, 114, 97, 112, 104, 92, 82, 101, 110,
				100, 101, 114, 71, 114, 97, 112, 104, 82, 101,
				115, 111, 117, 114, 99, 101, 82, 101, 103, 105,
				115, 116, 114, 121, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 116, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 82, 101, 110, 100, 101,
				114, 71, 114, 97, 112, 104, 92, 82, 101, 110,
				100, 101, 114, 71, 114, 97, 112, 104, 82, 101,
				115, 111, 117, 114, 99, 101, 82, 101, 110, 100,
				101, 114, 101, 114, 76, 105, 115, 116, 46, 99,
				115, 0, 0, 0, 3, 0, 0, 0, 105, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 82,
				101, 110, 100, 101, 114, 71, 114, 97, 112, 104,
				92, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 82, 101, 115, 111, 117, 114, 99, 101,
				115, 46, 99, 115, 0, 0, 0, 5, 0, 0,
				0, 111, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 82, 101, 110, 100, 101, 114, 71, 114,
				97, 112, 104, 92, 82, 101, 110, 100, 101, 114,
				71, 114, 97, 112, 104, 82, 101, 115, 111, 117,
				114, 99, 101, 84, 101, 120, 116, 117, 114, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				104, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 82, 101, 110, 100, 101, 114, 80, 105, 112,
				101, 108, 105, 110, 101, 92, 73, 67, 108, 111,
				117, 100, 66, 97, 99, 107, 103, 114, 111, 117,
				110, 100, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 110, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 92, 73, 83,
				104, 97, 100, 101, 114, 86, 97, 114, 105, 97,
				110, 116, 83, 101, 116, 116, 105, 110, 103, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				104, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 82, 101, 110, 100, 101, 114, 80, 105, 112,
				101, 108, 105, 110, 101, 92, 73, 86, 111, 108,
				117, 109, 101, 116, 114, 105, 99, 67, 108, 111,
				117, 100, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 111, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 92, 82, 101,
				110, 100, 101, 114, 80, 105, 112, 101, 108, 105,
				110, 101, 82, 101, 115, 111, 117, 114, 99, 101,
				115, 46, 99, 115, 0, 0, 0, 5, 0, 0,
				0, 114, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 83, 104, 97, 100, 101, 114, 71, 101,
				110, 101, 114, 97, 116, 111, 114, 92, 83, 104,
				97, 100, 101, 114, 71, 101, 110, 101, 114, 97,
				116, 111, 114, 65, 116, 116, 114, 105, 98, 117,
				116, 101, 115, 46, 99, 115, 0, 0, 0, 5,
				0, 0, 0, 106, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 83, 104, 97, 100, 101, 114,
				76, 105, 98, 114, 97, 114, 121, 92, 83, 97,
				109, 112, 108, 105, 110, 103, 92, 72, 97, 109,
				109, 101, 114, 115, 108, 101, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 104, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 84, 101,
				120, 116, 117, 114, 101, 115, 92, 66, 117, 102,
				102, 101, 114, 101, 100, 82, 84, 72, 97, 110,
				100, 108, 101, 83, 121, 115, 116, 101, 109, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 104,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				84, 101, 120, 116, 117, 114, 101, 115, 92, 80,
				111, 119, 101, 114, 79, 102, 84, 119, 111, 84,
				101, 120, 116, 117, 114, 101, 65, 116, 108, 97,
				115, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 90, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 84, 101, 120, 116, 117, 114, 101, 115,
				92, 82, 84, 72, 97, 110, 100, 108, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 91,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				84, 101, 120, 116, 117, 114, 101, 115, 92, 82,
				84, 72, 97, 110, 100, 108, 101, 115, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 96, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 84,
				101, 120, 116, 117, 114, 101, 115, 92, 82, 84,
				72, 97, 110, 100, 108, 101, 83, 121, 115, 116,
				101, 109, 46, 99, 115, 0, 0, 0, 3, 0,
				0, 0, 96, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 84, 101, 120, 116, 117, 114, 101,
				115, 92, 84, 101, 120, 116, 117, 114, 101, 50,
				68, 65, 116, 108, 97, 115, 46, 99, 115, 0,
				0, 0, 4, 0, 0, 0, 103, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 84, 101, 120,
				116, 117, 114, 101, 115, 92, 84, 101, 120, 116,
				117, 114, 101, 50, 68, 65, 116, 108, 97, 115,
				68, 121, 110, 97, 109, 105, 99, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 91, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 84, 101,
				120, 116, 117, 114, 101, 115, 92, 84, 101, 120,
				116, 117, 114, 101, 88, 82, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 98, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 85, 116, 105,
				108, 105, 116, 105, 101, 115, 92, 65, 114, 114,
				97, 121, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 108, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 85, 116, 105, 108, 105, 116, 105,
				101, 115, 92, 66, 97, 116, 99, 104, 82, 101,
				110, 100, 101, 114, 101, 114, 71, 114, 111, 117,
				112, 71, 108, 111, 98, 97, 108, 115, 46, 99,
				115, 0, 0, 0, 8, 0, 0, 0, 91, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 85,
				116, 105, 108, 105, 116, 105, 101, 115, 92, 66,
				105, 116, 65, 114, 114, 97, 121, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 90, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 92, 66, 108,
				105, 116, 116, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 102, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 85, 116, 105, 108,
				105, 116, 105, 101, 115, 92, 67, 97, 109, 101,
				114, 97, 67, 97, 112, 116, 117, 114, 101, 66,
				114, 105, 100, 103, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 98, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 114, 101,
				110, 100, 101, 114, 45, 112, 105, 112, 101, 108,
				105, 110, 101, 115, 46, 99, 111, 114, 101, 64,
				49, 52, 46, 48, 46, 49, 49, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 85, 116, 105, 108,
				105, 116, 105, 101, 115, 92, 67, 111, 108, 111,
				114, 83, 112, 97, 99, 101, 85, 116, 105, 108,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 93, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 85, 116, 105, 108, 105, 116, 105, 101,
				115, 92, 67, 111, 108, 111, 114, 85, 116, 105,
				108, 115, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 98, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 85, 116, 105, 108, 105, 116, 105,
				101, 115, 92, 67, 111, 114, 101, 77, 97, 116,
				114, 105, 120, 85, 116, 105, 108, 115, 46, 99,
				115, 0, 0, 0, 3, 0, 0, 0, 92, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 85,
				116, 105, 108, 105, 116, 105, 101, 115, 92, 67,
				111, 114, 101, 85, 116, 105, 108, 115, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 98, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 85,
				116, 105, 108, 105, 116, 105, 101, 115, 92, 68,
				101, 108, 101, 103, 97, 116, 101, 85, 116, 105,
				108, 105, 116, 121, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 91, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 92, 70, 83, 82, 85, 116,
				105, 108, 115, 46, 99, 115, 0, 0, 0, 4,
				0, 0, 0, 93, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 85, 116, 105, 108, 105, 116,
				105, 101, 115, 92, 72, 97, 98, 108, 101, 67,
				117, 114, 118, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 97, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 92, 72, 97, 108, 116, 111,
				110, 83, 101, 113, 117, 101, 110, 99, 101, 46,
				99, 115, 0, 0, 0, 4, 0, 0, 0, 97,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				85, 116, 105, 108, 105, 116, 105, 101, 115, 92,
				72, 68, 82, 79, 117, 116, 112, 117, 116, 85,
				116, 105, 108, 115, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 98, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 92, 77, 97, 116, 101, 114,
				105, 97, 108, 81, 117, 97, 108, 105, 116, 121,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				92, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 85, 116, 105, 108, 105, 116, 105, 101, 115,
				92, 77, 101, 115, 104, 71, 105, 122, 109, 111,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				99, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 85, 116, 105, 108, 105, 116, 105, 101, 115,
				92, 82, 101, 115, 111, 117, 114, 99, 101, 82,
				101, 108, 111, 97, 100, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 102, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 92, 83, 99,
				101, 110, 101, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 95, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 92, 84, 101,
				120, 116, 117, 114, 101, 67, 117, 114, 118, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				98, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 85, 116, 105, 108, 105, 116, 105, 101, 115,
				92, 84, 105, 108, 101, 76, 97, 121, 111, 117,
				116, 85, 116, 105, 108, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 90, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 85, 116, 105,
				108, 105, 116, 105, 101, 115, 92, 88, 82, 85,
				116, 105, 108, 115, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 87, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 86, 111, 108, 117, 109,
				101, 92, 73, 86, 111, 108, 117, 109, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 95,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				86, 111, 108, 117, 109, 101, 92, 75, 101, 121,
				102, 114, 97, 109, 101, 85, 116, 105, 108, 105,
				116, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 86, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 114, 101, 110, 100, 101,
				114, 45, 112, 105, 112, 101, 108, 105, 110, 101,
				115, 46, 99, 111, 114, 101, 64, 49, 52, 46,
				48, 46, 49, 49, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 86, 111, 108, 117, 109, 101, 92,
				86, 111, 108, 117, 109, 101, 46, 99, 115, 0,
				0, 0, 5, 0, 0, 0, 95, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 86, 111, 108,
				117, 109, 101, 92, 86, 111, 108, 117, 109, 101,
				67, 111, 109, 112, 111, 110, 101, 110, 116, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 93,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				86, 111, 108, 117, 109, 101, 92, 86, 111, 108,
				117, 109, 101, 77, 97, 110, 97, 103, 101, 114,
				46, 99, 115, 0, 0, 0, 41, 0, 0, 0,
				95, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 114, 101, 110, 100, 101, 114, 45,
				112, 105, 112, 101, 108, 105, 110, 101, 115, 46,
				99, 111, 114, 101, 64, 49, 52, 46, 48, 46,
				49, 49, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 86, 111, 108, 117, 109, 101, 92, 86, 111,
				108, 117, 109, 101, 80, 97, 114, 97, 109, 101,
				116, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 93, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 86, 111, 108, 117, 109, 101,
				92, 86, 111, 108, 117, 109, 101, 80, 114, 111,
				102, 105, 108, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 91, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 114, 101, 110,
				100, 101, 114, 45, 112, 105, 112, 101, 108, 105,
				110, 101, 115, 46, 99, 111, 114, 101, 64, 49,
				52, 46, 48, 46, 49, 49, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 86, 111, 108, 117, 109,
				101, 92, 86, 111, 108, 117, 109, 101, 83, 116,
				97, 99, 107, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 100, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 114, 101, 110, 100,
				101, 114, 45, 112, 105, 112, 101, 108, 105, 110,
				101, 115, 46, 99, 111, 114, 101, 64, 49, 52,
				46, 48, 46, 49, 49, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 88, 82, 92, 88, 82, 66,
				117, 105, 108, 116, 105, 110, 83, 104, 97, 100,
				101, 114, 67, 111, 110, 115, 116, 97, 110, 116,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 100, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 88, 82, 92, 88, 82, 71, 114, 97,
				112, 104, 105, 99, 115, 65, 117, 116, 111, 109,
				97, 116, 101, 100, 84, 101, 115, 116, 115, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 84,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 114, 101, 110, 100, 101, 114, 45, 112,
				105, 112, 101, 108, 105, 110, 101, 115, 46, 99,
				111, 114, 101, 64, 49, 52, 46, 48, 46, 49,
				49, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				88, 82, 92, 88, 82, 76, 97, 121, 111, 117,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 88, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 114, 101, 110, 100, 101, 114,
				45, 112, 105, 112, 101, 108, 105, 110, 101, 115,
				46, 99, 111, 114, 101, 64, 49, 52, 46, 48,
				46, 49, 49, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 88, 82, 92, 88, 82, 77, 105, 114,
				114, 111, 114, 86, 105, 101, 119, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 91, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				114, 101, 110, 100, 101, 114, 45, 112, 105, 112,
				101, 108, 105, 110, 101, 115, 46, 99, 111, 114,
				101, 64, 49, 52, 46, 48, 46, 49, 49, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 88, 82,
				92, 88, 82, 79, 99, 99, 108, 117, 115, 105,
				111, 110, 77, 101, 115, 104, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 82, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 88, 82, 92,
				88, 82, 80, 97, 115, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 84, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 114,
				101, 110, 100, 101, 114, 45, 112, 105, 112, 101,
				108, 105, 110, 101, 115, 46, 99, 111, 114, 101,
				64, 49, 52, 46, 48, 46, 49, 49, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 88, 82, 92,
				88, 82, 83, 121, 115, 116, 101, 109, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 82, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 114, 101, 110, 100, 101, 114, 45, 112, 105,
				112, 101, 108, 105, 110, 101, 115, 46, 99, 111,
				114, 101, 64, 49, 52, 46, 48, 46, 49, 49,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 88,
				82, 92, 88, 82, 86, 105, 101, 119, 46, 99,
				115
			},
			TypesData = new byte[20132]
			{
				0, 0, 0, 0, 36, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 67, 97, 109,
				101, 114, 97, 83, 119, 105, 116, 99, 104, 101,
				114, 0, 0, 0, 0, 32, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 70, 114,
				101, 101, 67, 97, 109, 101, 114, 97, 0, 0,
				0, 0, 39, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 67, 111, 109, 109, 97,
				110, 100, 66, 117, 102, 102, 101, 114, 80, 111,
				111, 108, 0, 0, 0, 0, 40, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 67,
				111, 109, 112, 111, 110, 101, 110, 116, 83, 105,
				110, 103, 108, 101, 116, 111, 110, 1, 0, 0,
				0, 36, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 67, 111, 110, 115, 116, 97,
				110, 116, 66, 117, 102, 102, 101, 114, 0, 0,
				0, 0, 40, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 67, 111, 110, 115, 116,
				97, 110, 116, 66, 117, 102, 102, 101, 114, 66,
				97, 115, 101, 1, 0, 0, 0, 36, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				67, 111, 110, 115, 116, 97, 110, 116, 66, 117,
				102, 102, 101, 114, 0, 0, 0, 0, 45, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 67, 111, 110, 115, 116, 97, 110, 116, 66,
				117, 102, 102, 101, 114, 83, 105, 110, 103, 108,
				101, 116, 111, 110, 0, 0, 0, 0, 42, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 68, 105, 115, 112, 108, 97, 121, 73, 110,
				102, 111, 65, 116, 116, 114, 105, 98, 117, 116,
				101, 0, 0, 0, 0, 49, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 65, 100,
				100, 105, 116, 105, 111, 110, 97, 108, 80, 114,
				111, 112, 101, 114, 116, 121, 65, 116, 116, 114,
				105, 98, 117, 116, 101, 0, 0, 0, 0, 37,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 67, 111, 114, 101, 85, 110, 115, 97,
				102, 101, 85, 116, 105, 108, 115, 0, 0, 0,
				0, 60, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 67, 111, 114, 101, 85, 110,
				115, 97, 102, 101, 85, 116, 105, 108, 115, 124,
				70, 105, 120, 101, 100, 66, 117, 102, 102, 101,
				114, 83, 116, 114, 105, 110, 103, 81, 117, 101,
				117, 101, 0, 0, 0, 0, 48, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 67,
				111, 114, 101, 85, 110, 115, 97, 102, 101, 85,
				116, 105, 108, 115, 124, 73, 75, 101, 121, 71,
				101, 116, 116, 101, 114, 0, 0, 0, 0, 54,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 67, 111, 114, 101, 85, 110, 115, 97,
				102, 101, 85, 116, 105, 108, 115, 124, 68, 101,
				102, 97, 117, 108, 116, 75, 101, 121, 71, 101,
				116, 116, 101, 114, 0, 0, 0, 0, 51, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 67, 111, 114, 101, 85, 110, 115, 97, 102,
				101, 85, 116, 105, 108, 115, 124, 85, 105, 110,
				116, 75, 101, 121, 71, 101, 116, 116, 101, 114,
				0, 0, 0, 0, 34, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 68, 121, 110,
				97, 109, 105, 99, 65, 114, 114, 97, 121, 0,
				0, 0, 0, 43, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 68, 121, 110, 97,
				109, 105, 99, 65, 114, 114, 97, 121, 124, 73,
				116, 101, 114, 97, 116, 111, 114, 0, 0, 0,
				0, 50, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 68, 121, 110, 97, 109, 105,
				99, 65, 114, 114, 97, 121, 124, 82, 97, 110,
				103, 101, 69, 110, 117, 109, 101, 114, 97, 98,
				108, 101, 0, 0, 0, 0, 49, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 68,
				121, 110, 97, 109, 105, 99, 65, 114, 114, 97,
				121, 43, 124, 82, 97, 110, 103, 101, 73, 116,
				101, 114, 97, 116, 111, 114, 0, 0, 0, 0,
				44, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 68, 121, 110, 97, 109, 105, 99,
				65, 114, 114, 97, 121, 69, 120, 116, 101, 110,
				115, 105, 111, 110, 115, 0, 0, 0, 0, 46,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 68, 121, 110, 97, 109, 105, 99, 82,
				101, 115, 111, 108, 117, 116, 105, 111, 110, 72,
				97, 110, 100, 108, 101, 114, 0, 0, 0, 0,
				62, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 68, 121, 110, 97, 109, 105, 99,
				82, 101, 115, 111, 108, 117, 116, 105, 111, 110,
				72, 97, 110, 100, 108, 101, 114, 124, 83, 99,
				97, 108, 101, 114, 67, 111, 110, 116, 97, 105,
				110, 101, 114, 0, 0, 0, 0, 53, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				71, 108, 111, 98, 97, 108, 68, 121, 110, 97,
				109, 105, 99, 82, 101, 115, 111, 108, 117, 116,
				105, 111, 110, 83, 101, 116, 116, 105, 110, 103,
				115, 0, 0, 0, 0, 37, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 73, 65,
				100, 100, 105, 116, 105, 111, 110, 97, 108, 68,
				97, 116, 97, 0, 0, 0, 0, 60, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				73, 86, 105, 114, 116, 117, 97, 108, 84, 101,
				120, 116, 117, 114, 105, 110, 103, 69, 110, 97,
				98, 108, 101, 100, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 0, 0,
				0, 0, 32, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 76, 105, 115, 116, 66,
				117, 102, 102, 101, 114, 0, 0, 0, 0, 42,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 76, 105, 115, 116, 66, 117, 102, 102,
				101, 114, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 0, 0, 0, 0, 32, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 79,
				98, 106, 101, 99, 116, 80, 111, 111, 108, 0,
				0, 0, 0, 45, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 79, 98, 106, 101,
				99, 116, 80, 111, 111, 108, 124, 80, 111, 111,
				108, 101, 100, 79, 98, 106, 101, 99, 116, 0,
				0, 0, 0, 33, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 71, 101, 110, 101,
				114, 105, 99, 80, 111, 111, 108, 0, 0, 0,
				0, 39, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 85, 110, 115, 97, 102, 101,
				71, 101, 110, 101, 114, 105, 99, 80, 111, 111,
				108, 0, 0, 0, 0, 30, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 76, 105,
				115, 116, 80, 111, 111, 108, 0, 0, 0, 0,
				33, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 72, 97, 115, 104, 83, 101, 116,
				80, 111, 111, 108, 0, 0, 0, 0, 36, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 68, 105, 99, 116, 105, 111, 110, 97, 114,
				121, 80, 111, 111, 108, 0, 0, 0, 0, 42,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 76, 105, 115, 116, 67, 104, 97, 110,
				103, 101, 100, 69, 118, 101, 110, 116, 65, 114,
				103, 115, 0, 0, 0, 0, 36, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 79,
				98, 115, 101, 114, 118, 97, 98, 108, 101, 76,
				105, 115, 116, 0, 0, 0, 0, 43, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				82, 101, 109, 111, 118, 101, 82, 97, 110, 103,
				101, 69, 120, 116, 101, 110, 115, 105, 111, 110,
				115, 0, 0, 0, 0, 38, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 83, 101,
				114, 105, 97, 108, 105, 122, 97, 98, 108, 101,
				69, 110, 117, 109, 1, 0, 0, 0, 42, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 83, 101, 114, 105, 97, 108, 105, 122, 101,
				100, 68, 105, 99, 116, 105, 111, 110, 97, 114,
				121, 1, 0, 0, 0, 42, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 83, 101,
				114, 105, 97, 108, 105, 122, 101, 100, 68, 105,
				99, 116, 105, 111, 110, 97, 114, 121, 0, 0,
				0, 0, 46, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 83, 119, 97, 112, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 69,
				120, 116, 101, 110, 115, 105, 111, 110, 115, 0,
				0, 0, 0, 32, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 88, 82, 71, 114,
				97, 112, 104, 105, 99, 115, 0, 0, 0, 0,
				42, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 68, 101, 98, 117, 103, 68, 105,
				115, 112, 108, 97, 121, 83, 101, 116, 116, 105,
				110, 103, 115, 1, 0, 0, 0, 47, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				68, 101, 98, 117, 103, 68, 105, 115, 112, 108,
				97, 121, 83, 101, 116, 116, 105, 110, 103, 115,
				80, 97, 110, 101, 108, 1, 0, 0, 0, 47,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 68, 101, 98, 117, 103, 68, 105, 115,
				112, 108, 97, 121, 83, 101, 116, 116, 105, 110,
				103, 115, 80, 97, 110, 101, 108, 0, 0, 0,
				0, 44, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 68, 101, 98, 117, 103, 68,
				105, 115, 112, 108, 97, 121, 83, 101, 116, 116,
				105, 110, 103, 115, 85, 73, 0, 0, 0, 0,
				48, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 68, 101, 98, 117, 103, 68, 105,
				115, 112, 108, 97, 121, 83, 101, 116, 116, 105,
				110, 103, 115, 86, 111, 108, 117, 109, 101, 0,
				0, 0, 0, 55, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 68, 101, 98, 117,
				103, 68, 105, 115, 112, 108, 97, 121, 83, 101,
				116, 116, 105, 110, 103, 115, 86, 111, 108, 117,
				109, 101, 124, 83, 116, 121, 108, 101, 115, 0,
				0, 0, 0, 56, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 68, 101, 98, 117,
				103, 68, 105, 115, 112, 108, 97, 121, 83, 101,
				116, 116, 105, 110, 103, 115, 86, 111, 108, 117,
				109, 101, 124, 83, 116, 114, 105, 110, 103, 115,
				0, 0, 0, 0, 62, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 68, 101, 98,
				117, 103, 68, 105, 115, 112, 108, 97, 121, 83,
				101, 116, 116, 105, 110, 103, 115, 86, 111, 108,
				117, 109, 101, 124, 87, 105, 100, 103, 101, 116,
				70, 97, 99, 116, 111, 114, 121, 0, 0, 0,
				0, 62, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 68, 101, 98, 117, 103, 68,
				105, 115, 112, 108, 97, 121, 83, 101, 116, 116,
				105, 110, 103, 115, 86, 111, 108, 117, 109, 101,
				124, 83, 101, 116, 116, 105, 110, 103, 115, 80,
				97, 110, 101, 108, 0, 0, 0, 0, 38, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 68, 101, 98, 117, 103, 70, 114, 97, 109,
				101, 84, 105, 109, 105, 110, 103, 1, 0, 0,
				0, 34, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 68, 101, 98, 117, 103, 77,
				97, 110, 97, 103, 101, 114, 0, 0, 0, 0,
				37, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 68, 101, 98, 117, 103, 65, 99,
				116, 105, 111, 110, 68, 101, 115, 99, 0, 0,
				0, 0, 38, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 68, 101, 98, 117, 103,
				65, 99, 116, 105, 111, 110, 83, 116, 97, 116,
				101, 0, 0, 0, 0, 32, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 73, 68,
				101, 98, 117, 103, 68, 97, 116, 97, 1, 0,
				0, 0, 34, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 68, 101, 98, 117, 103,
				77, 97, 110, 97, 103, 101, 114, 1, 0, 0,
				0, 34, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 68, 101, 98, 117, 103, 77,
				97, 110, 97, 103, 101, 114, 0, 0, 0, 0,
				42, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 68, 101, 98, 117, 103, 77, 97,
				110, 97, 103, 101, 114, 124, 85, 73, 83, 116,
				97, 116, 101, 0, 0, 0, 0, 33, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				68, 101, 98, 117, 103, 83, 104, 97, 112, 101,
				115, 1, 0, 0, 0, 29, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 68, 101,
				98, 117, 103, 85, 73, 0, 0, 0, 0, 39,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 68, 101, 98, 117, 103, 85, 73, 124,
				67, 111, 110, 116, 97, 105, 110, 101, 114, 0,
				0, 0, 0, 37, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 68, 101, 98, 117,
				103, 85, 73, 124, 70, 111, 108, 100, 111, 117,
				116, 0, 0, 0, 0, 53, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 68, 101,
				98, 117, 103, 85, 73, 43, 70, 111, 108, 100,
				111, 117, 116, 124, 67, 111, 110, 116, 101, 120,
				116, 77, 101, 110, 117, 73, 116, 101, 109, 0,
				0, 0, 0, 34, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 68, 101, 98, 117,
				103, 85, 73, 124, 72, 66, 111, 120, 0, 0,
				0, 0, 34, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 68, 101, 98, 117, 103,
				85, 73, 124, 86, 66, 111, 120, 0, 0, 0,
				0, 35, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 68, 101, 98, 117, 103, 85,
				73, 124, 84, 97, 98, 108, 101, 0, 0, 0,
				0, 39, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 68, 101, 98, 117, 103, 85,
				73, 43, 84, 97, 98, 108, 101, 124, 82, 111,
				119, 1, 0, 0, 0, 29, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 68, 101,
				98, 117, 103, 85, 73, 0, 0, 0, 0, 36,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 68, 101, 98, 117, 103, 85, 73, 124,
				87, 105, 100, 103, 101, 116, 0, 0, 0, 0,
				51, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 68, 101, 98, 117, 103, 85, 73,
				43, 87, 105, 100, 103, 101, 116, 124, 78, 97,
				109, 101, 65, 110, 100, 84, 111, 111, 108, 116,
				105, 112, 0, 0, 0, 0, 40, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 68,
				101, 98, 117, 103, 85, 73, 124, 73, 67, 111,
				110, 116, 97, 105, 110, 101, 114, 0, 0, 0,
				0, 41, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 68, 101, 98, 117, 103, 85,
				73, 124, 73, 86, 97, 108, 117, 101, 70, 105,
				101, 108, 100, 0, 0, 0, 0, 36, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 46,
				68, 101, 98, 117, 103, 85, 73, 124, 66, 117,
				116, 116, 111, 110, 0, 0, 0, 0, 35, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 68, 101, 98, 117, 103, 85, 73, 124, 86,
				97, 108, 117, 101, 0, 0, 0, 0, 46, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 68, 101, 98, 117, 103, 85, 73, 124, 80,
				114, 111, 103, 114, 101, 115, 115, 66, 97, 114,
				86, 97, 108, 117, 101, 0, 0, 0, 0, 40,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 68, 101, 98, 117, 103, 85, 73, 124,
				86, 97, 108, 117, 101, 84, 117, 112, 108, 101,
				1, 0, 0, 0, 29, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 68, 101, 98,
				117, 103, 85, 73, 0, 0, 0, 0, 35, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 68, 101, 98, 117, 103, 85, 73, 124, 70,
				105, 101, 108, 100, 0, 0, 0, 0, 39, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 68, 101, 98, 117, 103, 85, 73, 124, 66,
				111, 111, 108, 70, 105, 101, 108, 100, 0, 0,
				0, 0, 46, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 68, 101, 98, 117, 103,
				85, 73, 124, 72, 105, 115, 116, 111, 114, 121,
				66, 111, 111, 108, 70, 105, 101, 108, 100, 0,
				0, 0, 0, 38, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 68, 101, 98, 117,
				103, 85, 73, 124, 73, 110, 116, 70, 105, 101,
				108, 100, 0, 0, 0, 0, 39, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 68,
				101, 98, 117, 103, 85, 73, 124, 85, 73, 110,
				116, 70, 105, 101, 108, 100, 0, 0, 0, 0,
				40, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 68, 101, 98, 117, 103, 85, 73,
				124, 70, 108, 111, 97, 116, 70, 105, 101, 108,
				100, 1, 0, 0, 0, 39, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 68, 101,
				98, 117, 103, 85, 73, 124, 69, 110, 117, 109,
				70, 105, 101, 108, 100, 1, 0, 0, 0, 39,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 68, 101, 98, 117, 103, 85, 73, 124,
				69, 110, 117, 109, 70, 105, 101, 108, 100, 0,
				0, 0, 0, 46, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 68, 101, 98, 117,
				103, 85, 73, 124, 79, 98, 106, 101, 99, 116,
				80, 111, 112, 117, 112, 70, 105, 101, 108, 100,
				0, 0, 0, 0, 46, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 68, 101, 98,
				117, 103, 85, 73, 124, 72, 105, 115, 116, 111,
				114, 121, 69, 110, 117, 109, 70, 105, 101, 108,
				100, 0, 0, 0, 0, 38, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 68, 101,
				98, 117, 103, 85, 73, 124, 66, 105, 116, 70,
				105, 101, 108, 100, 0, 0, 0, 0, 40, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 68, 101, 98, 117, 103, 85, 73, 124, 67,
				111, 108, 111, 114, 70, 105, 101, 108, 100, 0,
				0, 0, 0, 42, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 68, 101, 98, 117,
				103, 85, 73, 124, 86, 101, 99, 116, 111, 114,
				50, 70, 105, 101, 108, 100, 0, 0, 0, 0,
				42, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 68, 101, 98, 117, 103, 85, 73,
				124, 86, 101, 99, 116, 111, 114, 51, 70, 105,
				101, 108, 100, 0, 0, 0, 0, 42, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 46,
				68, 101, 98, 117, 103, 85, 73, 124, 86, 101,
				99, 116, 111, 114, 52, 70, 105, 101, 108, 100,
				0, 0, 0, 0, 41, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 68, 101, 98,
				117, 103, 85, 73, 124, 79, 98, 106, 101, 99,
				116, 70, 105, 101, 108, 100, 0, 0, 0, 0,
				45, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 68, 101, 98, 117, 103, 85, 73,
				124, 79, 98, 106, 101, 99, 116, 76, 105, 115,
				116, 70, 105, 101, 108, 100, 0, 0, 0, 0,
				40, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 68, 101, 98, 117, 103, 85, 73,
				124, 77, 101, 115, 115, 97, 103, 101, 66, 111,
				120, 1, 0, 0, 0, 29, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 68, 101,
				98, 117, 103, 85, 73, 0, 0, 0, 0, 35,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 68, 101, 98, 117, 103, 85, 73, 124,
				80, 97, 110, 101, 108, 0, 0, 0, 0, 34,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 68, 101, 98, 117, 103, 85, 112, 100,
				97, 116, 101, 114, 0, 0, 0, 0, 41, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 66, 111, 116, 116, 108, 101, 110, 101, 99,
				107, 72, 105, 115, 116, 111, 103, 114, 97, 109,
				0, 0, 0, 0, 39, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 66, 111, 116,
				116, 108, 101, 110, 101, 99, 107, 72, 105, 115,
				116, 111, 114, 121, 0, 0, 0, 0, 37, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 70, 114, 97, 109, 101, 84, 105, 109, 101,
				83, 97, 109, 112, 108, 101, 0, 0, 0, 0,
				44, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 70, 114, 97, 109, 101, 84, 105,
				109, 101, 83, 97, 109, 112, 108, 101, 72, 105,
				115, 116, 111, 114, 121, 0, 0, 0, 0, 43,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 73, 68, 101, 98, 117, 103, 68, 105,
				115, 112, 108, 97, 121, 83, 101, 116, 116, 105,
				110, 103, 115, 0, 0, 0, 0, 47, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				73, 68, 101, 98, 117, 103, 68, 105, 115, 112,
				108, 97, 121, 83, 101, 116, 116, 105, 110, 103,
				115, 68, 97, 116, 97, 0, 0, 0, 0, 48,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 73, 68, 101, 98, 117, 103, 68, 105,
				115, 112, 108, 97, 121, 83, 101, 116, 116, 105,
				110, 103, 115, 80, 97, 110, 101, 108, 0, 0,
				0, 0, 58, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 73, 68, 101, 98, 117,
				103, 68, 105, 115, 112, 108, 97, 121, 83, 101,
				116, 116, 105, 110, 103, 115, 80, 97, 110, 101,
				108, 68, 105, 115, 112, 111, 115, 97, 98, 108,
				101, 0, 0, 0, 0, 48, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 73, 68,
				101, 98, 117, 103, 68, 105, 115, 112, 108, 97,
				121, 83, 101, 116, 116, 105, 110, 103, 115, 81,
				117, 101, 114, 121, 0, 0, 0, 0, 42, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 73, 86, 111, 108, 117, 109, 101, 68, 101,
				98, 117, 103, 83, 101, 116, 116, 105, 110, 103,
				115, 0, 0, 0, 0, 43, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 73, 86,
				111, 108, 117, 109, 101, 68, 101, 98, 117, 103,
				83, 101, 116, 116, 105, 110, 103, 115, 50, 0,
				0, 0, 0, 40, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 77, 111, 117, 115,
				101, 80, 111, 115, 105, 116, 105, 111, 110, 68,
				101, 98, 117, 103, 0, 0, 0, 0, 47, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 85, 73, 124, 68, 101, 98, 117, 103, 85,
				73, 72, 97, 110, 100, 108, 101, 114, 66, 105,
				116, 70, 105, 101, 108, 100, 0, 0, 0, 0,
				45, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 85, 73, 124, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				66, 117, 116, 116, 111, 110, 0, 0, 0, 0,
				44, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 85, 73, 124, 68, 101, 98, 117,
				103, 85, 73, 80, 114, 101, 102, 97, 98, 66,
				117, 110, 100, 108, 101, 0, 0, 0, 0, 45,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 85, 73, 124, 68, 101, 98, 117, 103,
				85, 73, 72, 97, 110, 100, 108, 101, 114, 67,
				97, 110, 118, 97, 115, 0, 0, 0, 0, 44,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 85, 73, 124, 68, 101, 98, 117, 103,
				85, 73, 72, 97, 110, 100, 108, 101, 114, 67,
				111, 108, 111, 114, 0, 0, 0, 0, 48, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 85, 73, 124, 68, 101, 98, 117, 103, 85,
				73, 72, 97, 110, 100, 108, 101, 114, 67, 111,
				110, 116, 97, 105, 110, 101, 114, 0, 0, 0,
				0, 48, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 85, 73, 124, 68, 101, 98,
				117, 103, 85, 73, 72, 97, 110, 100, 108, 101,
				114, 69, 110, 117, 109, 70, 105, 101, 108, 100,
				0, 0, 0, 0, 50, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 85, 73, 124,
				68, 101, 98, 117, 103, 85, 73, 72, 97, 110,
				100, 108, 101, 114, 69, 110, 117, 109, 72, 105,
				115, 116, 111, 114, 121, 0, 0, 0, 0, 44,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 85, 73, 124, 68, 101, 98, 117, 103,
				85, 73, 72, 97, 110, 100, 108, 101, 114, 70,
				105, 101, 108, 100, 0, 0, 0, 0, 49, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 85, 73, 124, 68, 101, 98, 117, 103, 85,
				73, 72, 97, 110, 100, 108, 101, 114, 70, 108,
				111, 97, 116, 70, 105, 101, 108, 100, 0, 0,
				0, 0, 46, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 85, 73, 124, 68, 101,
				98, 117, 103, 85, 73, 72, 97, 110, 100, 108,
				101, 114, 70, 111, 108, 100, 111, 117, 116, 0,
				0, 0, 0, 44, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 85, 73, 124, 68,
				101, 98, 117, 103, 85, 73, 72, 97, 110, 100,
				108, 101, 114, 71, 114, 111, 117, 112, 0, 0,
				0, 0, 43, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 85, 73, 124, 68, 101,
				98, 117, 103, 85, 73, 72, 97, 110, 100, 108,
				101, 114, 72, 66, 111, 120, 0, 0, 0, 0,
				57, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 85, 73, 124, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				73, 110, 100, 105, 114, 101, 99, 116, 70, 108,
				111, 97, 116, 70, 105, 101, 108, 100, 0, 0,
				0, 0, 53, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 85, 73, 124, 68, 101,
				98, 117, 103, 85, 73, 72, 97, 110, 100, 108,
				101, 114, 73, 110, 100, 105, 114, 101, 99, 116,
				84, 111, 103, 103, 108, 101, 0, 0, 0, 0,
				47, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 85, 73, 124, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				73, 110, 116, 70, 105, 101, 108, 100, 0, 0,
				0, 0, 49, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 85, 73, 124, 68, 101,
				98, 117, 103, 85, 73, 72, 97, 110, 100, 108,
				101, 114, 77, 101, 115, 115, 97, 103, 101, 66,
				111, 120, 0, 0, 0, 0, 45, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 85,
				73, 124, 68, 101, 98, 117, 103, 85, 73, 72,
				97, 110, 100, 108, 101, 114, 79, 98, 106, 101,
				99, 116, 0, 0, 0, 0, 49, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 85,
				73, 124, 68, 101, 98, 117, 103, 85, 73, 72,
				97, 110, 100, 108, 101, 114, 79, 98, 106, 101,
				99, 116, 76, 105, 115, 116, 0, 0, 0, 0,
				55, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 85, 73, 124, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				79, 98, 106, 101, 99, 116, 80, 111, 112, 117,
				112, 70, 105, 101, 108, 100, 0, 0, 0, 0,
				44, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 85, 73, 124, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				80, 97, 110, 101, 108, 0, 0, 0, 0, 55,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 85, 73, 124, 68, 101, 98, 117, 103,
				85, 73, 72, 97, 110, 100, 108, 101, 114, 80,
				101, 114, 115, 105, 115, 116, 101, 110, 116, 67,
				97, 110, 118, 97, 115, 0, 0, 0, 0, 50,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 85, 73, 124, 68, 101, 98, 117, 103,
				85, 73, 72, 97, 110, 100, 108, 101, 114, 80,
				114, 111, 103, 114, 101, 115, 115, 66, 97, 114,
				0, 0, 0, 0, 42, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 85, 73, 124,
				68, 101, 98, 117, 103, 85, 73, 72, 97, 110,
				100, 108, 101, 114, 82, 111, 119, 0, 0, 0,
				0, 45, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 85, 73, 124, 68, 101, 98,
				117, 103, 85, 73, 72, 97, 110, 100, 108, 101,
				114, 84, 111, 103, 103, 108, 101, 0, 0, 0,
				0, 52, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 85, 73, 124, 68, 101, 98,
				117, 103, 85, 73, 72, 97, 110, 100, 108, 101,
				114, 84, 111, 103, 103, 108, 101, 72, 105, 115,
				116, 111, 114, 121, 0, 0, 0, 0, 48, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 85, 73, 124, 68, 101, 98, 117, 103, 85,
				73, 72, 97, 110, 100, 108, 101, 114, 85, 73,
				110, 116, 70, 105, 101, 108, 100, 0, 0, 0,
				0, 44, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 85, 73, 124, 68, 101, 98,
				117, 103, 85, 73, 72, 97, 110, 100, 108, 101,
				114, 86, 97, 108, 117, 101, 0, 0, 0, 0,
				49, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 85, 73, 124, 68, 101, 98, 117,
				103, 85, 73, 72, 97, 110, 100, 108, 101, 114,
				86, 97, 108, 117, 101, 84, 117, 112, 108, 101,
				0, 0, 0, 0, 43, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 85, 73, 124,
				68, 101, 98, 117, 103, 85, 73, 72, 97, 110,
				100, 108, 101, 114, 86, 66, 111, 120, 0, 0,
				0, 0, 46, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 85, 73, 124, 68, 101,
				98, 117, 103, 85, 73, 72, 97, 110, 100, 108,
				101, 114, 86, 101, 99, 116, 111, 114, 50, 0,
				0, 0, 0, 46, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 85, 73, 124, 68,
				101, 98, 117, 103, 85, 73, 72, 97, 110, 100,
				108, 101, 114, 86, 101, 99, 116, 111, 114, 51,
				0, 0, 0, 0, 46, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 85, 73, 124,
				68, 101, 98, 117, 103, 85, 73, 72, 97, 110,
				100, 108, 101, 114, 86, 101, 99, 116, 111, 114,
				52, 0, 0, 0, 0, 45, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 85, 73,
				124, 68, 101, 98, 117, 103, 85, 73, 72, 97,
				110, 100, 108, 101, 114, 87, 105, 100, 103, 101,
				116, 0, 0, 0, 0, 34, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 85, 73,
				124, 85, 73, 70, 111, 108, 100, 111, 117, 116,
				0, 0, 0, 0, 39, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 84, 80, 114,
				111, 102, 105, 108, 105, 110, 103, 83, 97, 109,
				112, 108, 101, 114, 0, 0, 0, 0, 38, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 80, 114, 111, 102, 105, 108, 105, 110, 103,
				83, 97, 109, 112, 108, 101, 114, 0, 0, 0,
				0, 36, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 80, 114, 111, 102, 105, 108,
				105, 110, 103, 83, 99, 111, 112, 101, 0, 0,
				0, 0, 37, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 80, 114, 111, 102, 105,
				108, 105, 110, 103, 83, 97, 109, 112, 108, 101,
				0, 0, 0, 0, 45, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 83, 104, 97,
				100, 101, 114, 68, 101, 98, 117, 103, 80, 114,
				105, 110, 116, 77, 97, 110, 97, 103, 101, 114,
				0, 0, 0, 0, 55, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 83, 104, 97,
				100, 101, 114, 68, 101, 98, 117, 103, 80, 114,
				105, 110, 116, 77, 97, 110, 97, 103, 101, 114,
				124, 80, 114, 111, 102, 105, 108, 105, 110, 103,
				0, 0, 0, 0, 43, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 83, 104, 97,
				100, 101, 114, 68, 101, 98, 117, 103, 80, 114,
				105, 110, 116, 73, 110, 112, 117, 116, 0, 0,
				0, 0, 51, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 83, 104, 97, 100, 101,
				114, 68, 101, 98, 117, 103, 80, 114, 105, 110,
				116, 73, 110, 112, 117, 116, 80, 114, 111, 100,
				117, 99, 101, 114, 1, 0, 0, 0, 41, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 86, 111, 108, 117, 109, 101, 68, 101, 98,
				117, 103, 83, 101, 116, 116, 105, 110, 103, 115,
				1, 0, 0, 0, 41, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 86, 111, 108,
				117, 109, 101, 68, 101, 98, 117, 103, 83, 101,
				116, 116, 105, 110, 103, 115, 1, 0, 0, 0,
				34, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 68, 101, 98, 117, 103, 77, 97,
				110, 97, 103, 101, 114, 0, 0, 0, 0, 44,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 67, 111, 114, 101, 82, 80, 72, 101,
				108, 112, 85, 82, 76, 65, 116, 116, 114, 105,
				98, 117, 116, 101, 0, 0, 0, 0, 39, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 68, 111, 99, 117, 109, 101, 110, 116, 97,
				116, 105, 111, 110, 73, 110, 102, 111, 0, 0,
				0, 0, 40, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 68, 111, 99, 117, 109,
				101, 110, 116, 97, 116, 105, 111, 110, 85, 116,
				105, 108, 115, 0, 0, 0, 0, 37, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				80, 114, 111, 98, 101, 66, 114, 105, 99, 107,
				73, 110, 100, 101, 120, 0, 0, 0, 0, 43,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 80, 114, 111, 98, 101, 66, 114, 105,
				99, 107, 73, 110, 100, 101, 120, 124, 66, 114,
				105, 99, 107, 0, 0, 0, 0, 51, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 46,
				80, 114, 111, 98, 101, 66, 114, 105, 99, 107,
				73, 110, 100, 101, 120, 124, 82, 101, 115, 101,
				114, 118, 101, 100, 66, 114, 105, 99, 107, 0,
				0, 0, 0, 47, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 80, 114, 111, 98,
				101, 66, 114, 105, 99, 107, 73, 110, 100, 101,
				120, 124, 86, 111, 120, 101, 108, 77, 101, 116,
				97, 0, 0, 0, 0, 47, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 80, 114,
				111, 98, 101, 66, 114, 105, 99, 107, 73, 110,
				100, 101, 120, 124, 66, 114, 105, 99, 107, 77,
				101, 116, 97, 0, 0, 0, 0, 57, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 46,
				80, 114, 111, 98, 101, 66, 114, 105, 99, 107,
				73, 110, 100, 101, 120, 124, 67, 101, 108, 108,
				73, 110, 100, 101, 120, 85, 112, 100, 97, 116,
				101, 73, 110, 102, 111, 0, 0, 0, 0, 36,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 80, 114, 111, 98, 101, 66, 114, 105,
				99, 107, 80, 111, 111, 108, 0, 0, 0, 0,
				52, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 80, 114, 111, 98, 101, 66, 114,
				105, 99, 107, 80, 111, 111, 108, 124, 66, 114,
				105, 99, 107, 67, 104, 117, 110, 107, 65, 108,
				108, 111, 99, 0, 0, 0, 0, 49, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 46,
				80, 114, 111, 98, 101, 66, 114, 105, 99, 107,
				80, 111, 111, 108, 124, 68, 97, 116, 97, 76,
				111, 99, 97, 116, 105, 111, 110, 0, 0, 0,
				0, 44, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 80, 114, 111, 98, 101, 66,
				114, 105, 99, 107, 66, 108, 101, 110, 100, 105,
				110, 103, 80, 111, 111, 108, 0, 0, 0, 0,
				38, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 80, 114, 111, 98, 101, 67, 101,
				108, 108, 73, 110, 100, 105, 99, 101, 115, 0,
				0, 0, 0, 52, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 80, 114, 111, 98,
				101, 67, 101, 108, 108, 73, 110, 100, 105, 99,
				101, 115, 124, 73, 110, 100, 101, 120, 77, 101,
				116, 97, 68, 97, 116, 97, 0, 0, 0, 0,
				49, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 80, 114, 111, 98, 101, 86, 111,
				108, 117, 109, 101, 83, 121, 115, 116, 101, 109,
				80, 97, 114, 97, 109, 101, 116, 101, 114, 115,
				0, 0, 0, 0, 50, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 80, 114, 111,
				98, 101, 86, 111, 108, 117, 109, 101, 83, 104,
				97, 100, 105, 110, 103, 80, 97, 114, 97, 109,
				101, 116, 101, 114, 115, 1, 0, 0, 0, 42,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 80, 114, 111, 98, 101, 82, 101, 102,
				101, 114, 101, 110, 99, 101, 86, 111, 108, 117,
				109, 101, 0, 0, 0, 0, 47, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 80,
				114, 111, 98, 101, 82, 101, 102, 101, 114, 101,
				110, 99, 101, 86, 111, 108, 117, 109, 101, 124,
				67, 101, 108, 108, 0, 0, 0, 0, 63, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 80, 114, 111, 98, 101, 82, 101, 102, 101,
				114, 101, 110, 99, 101, 86, 111, 108, 117, 109,
				101, 43, 67, 101, 108, 108, 124, 80, 101, 114,
				83, 99, 101, 110, 97, 114, 105, 111, 68, 97,
				116, 97, 0, 0, 0, 0, 51, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 80,
				114, 111, 98, 101, 82, 101, 102, 101, 114, 101,
				110, 99, 101, 86, 111, 108, 117, 109, 101, 124,
				67, 101, 108, 108, 73, 110, 102, 111, 0, 0,
				0, 0, 59, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 80, 114, 111, 98, 101,
				82, 101, 102, 101, 114, 101, 110, 99, 101, 86,
				111, 108, 117, 109, 101, 124, 66, 108, 101, 110,
				100, 105, 110, 103, 67, 101, 108, 108, 73, 110,
				102, 111, 0, 0, 0, 0, 49, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 80,
				114, 111, 98, 101, 82, 101, 102, 101, 114, 101,
				110, 99, 101, 86, 111, 108, 117, 109, 101, 124,
				86, 111, 108, 117, 109, 101, 0, 0, 0, 0,
				58, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 80, 114, 111, 98, 101, 82, 101,
				102, 101, 114, 101, 110, 99, 101, 86, 111, 108,
				117, 109, 101, 124, 82, 101, 102, 86, 111, 108,
				84, 114, 97, 110, 115, 102, 111, 114, 109, 0,
				0, 0, 0, 59, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 80, 114, 111, 98,
				101, 82, 101, 102, 101, 114, 101, 110, 99, 101,
				86, 111, 108, 117, 109, 101, 124, 82, 117, 110,
				116, 105, 109, 101, 82, 101, 115, 111, 117, 114,
				99, 101, 115, 0, 0, 0, 0, 63, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 46,
				80, 114, 111, 98, 101, 82, 101, 102, 101, 114,
				101, 110, 99, 101, 86, 111, 108, 117, 109, 101,
				124, 69, 120, 116, 114, 97, 68, 97, 116, 97,
				65, 99, 116, 105, 111, 110, 73, 110, 112, 117,
				116, 0, 0, 0, 0, 51, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 80, 114,
				111, 98, 101, 82, 101, 102, 101, 114, 101, 110,
				99, 101, 86, 111, 108, 117, 109, 101, 124, 73,
				110, 105, 116, 73, 110, 102, 111, 0, 0, 0,
				0, 38, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 80, 114, 111, 98, 101, 86,
				111, 108, 117, 109, 101, 68, 101, 98, 117, 103,
				1, 0, 0, 0, 42, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 80, 114, 111,
				98, 101, 82, 101, 102, 101, 114, 101, 110, 99,
				101, 86, 111, 108, 117, 109, 101, 0, 0, 0,
				0, 67, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 80, 114, 111, 98, 101, 82,
				101, 102, 101, 114, 101, 110, 99, 101, 86, 111,
				108, 117, 109, 101, 124, 67, 101, 108, 108, 73,
				110, 115, 116, 97, 110, 99, 101, 100, 68, 101,
				98, 117, 103, 80, 114, 111, 98, 101, 115, 1,
				0, 0, 0, 42, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 80, 114, 111, 98,
				101, 82, 101, 102, 101, 114, 101, 110, 99, 101,
				86, 111, 108, 117, 109, 101, 0, 0, 0, 0,
				49, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 80, 114, 111, 98, 101, 82, 101,
				102, 101, 114, 101, 110, 99, 101, 86, 111, 108,
				117, 109, 101, 80, 114, 111, 102, 105, 108, 101,
				0, 0, 0, 0, 40, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 80, 114, 111,
				98, 101, 84, 111, 117, 99, 104, 117, 112, 86,
				111, 108, 117, 109, 101, 1, 0, 0, 0, 33,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 80, 114, 111, 98, 101, 86, 111, 108,
				117, 109, 101, 1, 0, 0, 0, 33, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				80, 114, 111, 98, 101, 86, 111, 108, 117, 109,
				101, 0, 0, 0, 0, 38, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 80, 114,
				111, 98, 101, 86, 111, 108, 117, 109, 101, 65,
				115, 115, 101, 116, 0, 0, 0, 0, 49, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 80, 114, 111, 98, 101, 86, 111, 108, 117,
				109, 101, 65, 115, 115, 101, 116, 124, 67, 101,
				108, 108, 67, 111, 117, 110, 116, 115, 0, 0,
				0, 0, 43, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 80, 114, 111, 98, 101,
				68, 105, 108, 97, 116, 105, 111, 110, 83, 101,
				116, 116, 105, 110, 103, 115, 0, 0, 0, 0,
				43, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 86, 105, 114, 116, 117, 97, 108,
				79, 102, 102, 115, 101, 116, 83, 101, 116, 116,
				105, 110, 103, 115, 0, 0, 0, 0, 54, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 80, 114, 111, 98, 101, 86, 111, 108, 117,
				109, 101, 66, 97, 107, 105, 110, 103, 80, 114,
				111, 99, 101, 115, 115, 83, 101, 116, 116, 105,
				110, 103, 115, 0, 0, 0, 0, 36, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				71, 73, 67, 111, 110, 116, 114, 105, 98, 117,
				116, 111, 114, 115, 0, 0, 0, 0, 45, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 80, 114, 111, 98, 101, 86, 111, 108, 117,
				109, 101, 80, 101, 114, 83, 99, 101, 110, 101,
				68, 97, 116, 97, 0, 0, 0, 0, 61, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 80, 114, 111, 98, 101, 86, 111, 108, 117,
				109, 101, 80, 101, 114, 83, 99, 101, 110, 101,
				68, 97, 116, 97, 124, 80, 101, 114, 83, 99,
				101, 110, 97, 114, 105, 111, 68, 97, 116, 97,
				0, 0, 0, 0, 77, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 80, 114, 111,
				98, 101, 86, 111, 108, 117, 109, 101, 80, 101,
				114, 83, 99, 101, 110, 101, 68, 97, 116, 97,
				124, 83, 101, 114, 105, 97, 108, 105, 122, 97,
				98, 108, 101, 80, 101, 114, 83, 99, 101, 110,
				97, 114, 105, 111, 68, 97, 116, 97, 73, 116,
				101, 109, 0, 0, 0, 0, 42, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 80,
				114, 111, 98, 101, 86, 111, 108, 117, 109, 101,
				83, 99, 101, 110, 101, 68, 97, 116, 97, 0,
				0, 0, 0, 64, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 80, 114, 111, 98,
				101, 86, 111, 108, 117, 109, 101, 83, 99, 101,
				110, 101, 68, 97, 116, 97, 124, 83, 101, 114,
				105, 97, 108, 105, 122, 97, 98, 108, 101, 66,
				111, 117, 110, 100, 73, 116, 101, 109, 0, 0,
				0, 0, 64, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 80, 114, 111, 98, 101,
				86, 111, 108, 117, 109, 101, 83, 99, 101, 110,
				101, 68, 97, 116, 97, 124, 83, 101, 114, 105,
				97, 108, 105, 122, 97, 98, 108, 101, 72, 97,
				115, 80, 86, 73, 116, 101, 109, 0, 0, 0,
				0, 64, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 80, 114, 111, 98, 101, 86,
				111, 108, 117, 109, 101, 83, 99, 101, 110, 101,
				68, 97, 116, 97, 124, 83, 101, 114, 105, 97,
				108, 105, 122, 97, 98, 108, 101, 80, 86, 80,
				114, 111, 102, 105, 108, 101, 0, 0, 0, 0,
				69, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 80, 114, 111, 98, 101, 86, 111,
				108, 117, 109, 101, 83, 99, 101, 110, 101, 68,
				97, 116, 97, 124, 83, 101, 114, 105, 97, 108,
				105, 122, 97, 98, 108, 101, 80, 86, 66, 97,
				107, 101, 83, 101, 116, 116, 105, 110, 103, 115,
				0, 0, 0, 0, 52, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 80, 114, 111,
				98, 101, 86, 111, 108, 117, 109, 101, 83, 99,
				101, 110, 101, 68, 97, 116, 97, 124, 66, 97,
				107, 105, 110, 103, 83, 101, 116, 0, 0, 0,
				0, 49, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 83, 104, 97, 100, 101, 114,
				86, 97, 114, 105, 97, 98, 108, 101, 115, 80,
				114, 111, 98, 101, 86, 111, 108, 117, 109, 101,
				115, 0, 0, 0, 0, 42, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 83, 112,
				104, 101, 114, 105, 99, 97, 108, 72, 97, 114,
				109, 111, 110, 105, 99, 115, 76, 49, 0, 0,
				0, 0, 47, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 83, 112, 104, 101, 114,
				105, 99, 97, 108, 72, 97, 114, 109, 111, 110,
				105, 99, 115, 76, 50, 85, 116, 105, 108, 115,
				0, 0, 0, 0, 23, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 124, 76, 105, 103,
				104, 116, 65, 110, 99, 104, 111, 114, 0, 0,
				0, 0, 28, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 76, 105, 103, 104, 116,
				65, 110, 99, 104, 111, 114, 124, 65, 120, 101,
				115, 0, 0, 0, 0, 43, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 76, 111,
				111, 107, 68, 101, 118, 124, 73, 68, 97, 116,
				97, 80, 114, 111, 118, 105, 100, 101, 114, 0,
				0, 0, 0, 33, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 76, 111, 111, 107,
				68, 101, 118, 124, 83, 107, 121, 0, 0, 0,
				0, 51, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 76, 111, 111, 107, 68, 101,
				118, 124, 83, 116, 97, 103, 101, 82, 117, 110,
				116, 105, 109, 101, 73, 110, 116, 101, 114, 102,
				97, 99, 101, 0, 0, 0, 0, 40, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				76, 101, 110, 115, 70, 108, 97, 114, 101, 67,
				111, 109, 109, 111, 110, 83, 82, 80, 0, 0,
				0, 0, 58, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 76, 101, 110, 115, 70,
				108, 97, 114, 101, 67, 111, 109, 109, 111, 110,
				83, 82, 80, 124, 76, 101, 110, 115, 70, 108,
				97, 114, 101, 67, 111, 109, 112, 73, 110, 102,
				111, 0, 0, 0, 0, 43, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 76, 101,
				110, 115, 70, 108, 97, 114, 101, 67, 111, 109,
				112, 111, 110, 101, 110, 116, 83, 82, 80, 0,
				0, 0, 0, 45, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 76, 101, 110, 115,
				70, 108, 97, 114, 101, 68, 97, 116, 97, 69,
				108, 101, 109, 101, 110, 116, 83, 82, 80, 0,
				0, 0, 0, 38, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 76, 101, 110, 115,
				70, 108, 97, 114, 101, 68, 97, 116, 97, 83,
				82, 80, 0, 0, 0, 0, 71, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 69,
				120, 112, 101, 114, 105, 109, 101, 110, 116, 97,
				108, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 82, 101, 110, 100, 101, 114, 71, 114,
				97, 112, 104, 77, 111, 100, 117, 108, 101, 124,
				82, 101, 110, 100, 101, 114, 71, 114, 97, 112,
				104, 67, 111, 110, 116, 101, 120, 116, 0, 0,
				0, 0, 74, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 120, 112, 101, 114,
				105, 109, 101, 110, 116, 97, 108, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 82, 101,
				110, 100, 101, 114, 71, 114, 97, 112, 104, 77,
				111, 100, 117, 108, 101, 124, 82, 101, 110, 100,
				101, 114, 71, 114, 97, 112, 104, 80, 97, 114,
				97, 109, 101, 116, 101, 114, 115, 0, 0, 0,
				0, 73, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 69, 120, 112, 101, 114, 105,
				109, 101, 110, 116, 97, 108, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 82, 101, 110,
				100, 101, 114, 71, 114, 97, 112, 104, 77, 111,
				100, 117, 108, 101, 124, 82, 101, 110, 100, 101,
				114, 71, 114, 97, 112, 104, 69, 120, 101, 99,
				117, 116, 105, 111, 110, 0, 0, 0, 0, 75,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 69, 120, 112, 101, 114, 105, 109, 101,
				110, 116, 97, 108, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 82, 101, 110, 100, 101,
				114, 71, 114, 97, 112, 104, 77, 111, 100, 117,
				108, 101, 124, 82, 101, 110, 100, 101, 114, 71,
				114, 97, 112, 104, 68, 101, 98, 117, 103, 80,
				97, 114, 97, 109, 115, 0, 0, 0, 0, 83,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 69, 120, 112, 101, 114, 105, 109, 101,
				110, 116, 97, 108, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 82, 101, 110, 100, 101,
				114, 71, 114, 97, 112, 104, 77, 111, 100, 117,
				108, 101, 46, 82, 101, 110, 100, 101, 114, 71,
				114, 97, 112, 104, 68, 101, 98, 117, 103, 80,
				97, 114, 97, 109, 115, 124, 83, 116, 114, 105,
				110, 103, 115, 0, 0, 0, 0, 73, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				69, 120, 112, 101, 114, 105, 109, 101, 110, 116,
				97, 108, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 82, 101, 110, 100, 101, 114, 71,
				114, 97, 112, 104, 77, 111, 100, 117, 108, 101,
				124, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 68, 101, 98, 117, 103, 68, 97, 116,
				97, 0, 0, 0, 0, 87, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 69, 120,
				112, 101, 114, 105, 109, 101, 110, 116, 97, 108,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 77, 111, 100, 117, 108, 101, 46, 82,
				101, 110, 100, 101, 114, 71, 114, 97, 112, 104,
				68, 101, 98, 117, 103, 68, 97, 116, 97, 124,
				80, 97, 115, 115, 68, 101, 98, 117, 103, 68,
				97, 116, 97, 0, 0, 0, 0, 91, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				69, 120, 112, 101, 114, 105, 109, 101, 110, 116,
				97, 108, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 82, 101, 110, 100, 101, 114, 71,
				114, 97, 112, 104, 77, 111, 100, 117, 108, 101,
				46, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 68, 101, 98, 117, 103, 68, 97, 116,
				97, 124, 82, 101, 115, 111, 117, 114, 99, 101,
				68, 101, 98, 117, 103, 68, 97, 116, 97, 0,
				0, 0, 0, 64, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 69, 120, 112, 101,
				114, 105, 109, 101, 110, 116, 97, 108, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 82,
				101, 110, 100, 101, 114, 71, 114, 97, 112, 104,
				77, 111, 100, 117, 108, 101, 124, 82, 101, 110,
				100, 101, 114, 71, 114, 97, 112, 104, 0, 0,
				0, 0, 85, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 120, 112, 101, 114,
				105, 109, 101, 110, 116, 97, 108, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 82, 101,
				110, 100, 101, 114, 71, 114, 97, 112, 104, 77,
				111, 100, 117, 108, 101, 46, 82, 101, 110, 100,
				101, 114, 71, 114, 97, 112, 104, 124, 67, 111,
				109, 112, 105, 108, 101, 100, 82, 101, 115, 111,
				117, 114, 99, 101, 73, 110, 102, 111, 0, 0,
				0, 0, 81, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 120, 112, 101, 114,
				105, 109, 101, 110, 116, 97, 108, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 82, 101,
				110, 100, 101, 114, 71, 114, 97, 112, 104, 77,
				111, 100, 117, 108, 101, 46, 82, 101, 110, 100,
				101, 114, 71, 114, 97, 112, 104, 124, 67, 111,
				109, 112, 105, 108, 101, 100, 80, 97, 115, 115,
				73, 110, 102, 111, 0, 0, 0, 0, 87, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 69, 120, 112, 101, 114, 105, 109, 101, 110,
				116, 97, 108, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 82, 101, 110, 100, 101, 114,
				71, 114, 97, 112, 104, 77, 111, 100, 117, 108,
				101, 46, 82, 101, 110, 100, 101, 114, 71, 114,
				97, 112, 104, 124, 80, 114, 111, 102, 105, 108,
				105, 110, 103, 83, 99, 111, 112, 101, 80, 97,
				115, 115, 68, 97, 116, 97, 0, 0, 0, 0,
				78, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 120, 112, 101, 114, 105, 109,
				101, 110, 116, 97, 108, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 82, 101, 110, 100,
				101, 114, 71, 114, 97, 112, 104, 77, 111, 100,
				117, 108, 101, 124, 82, 101, 110, 100, 101, 114,
				71, 114, 97, 112, 104, 80, 114, 111, 102, 105,
				108, 105, 110, 103, 83, 99, 111, 112, 101, 0,
				0, 0, 0, 71, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 69, 120, 112, 101,
				114, 105, 109, 101, 110, 116, 97, 108, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 82,
				101, 110, 100, 101, 114, 71, 114, 97, 112, 104,
				77, 111, 100, 117, 108, 101, 124, 82, 101, 110,
				100, 101, 114, 71, 114, 97, 112, 104, 66, 117,
				105, 108, 100, 101, 114, 0, 0, 0, 0, 80,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 69, 120, 112, 101, 114, 105, 109, 101,
				110, 116, 97, 108, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 82, 101, 110, 100, 101,
				114, 71, 114, 97, 112, 104, 77, 111, 100, 117,
				108, 101, 124, 82, 101, 110, 100, 101, 114, 71,
				114, 97, 112, 104, 68, 101, 102, 97, 117, 108,
				116, 82, 101, 115, 111, 117, 114, 99, 101, 115,
				0, 0, 0, 0, 73, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 69, 120, 112,
				101, 114, 105, 109, 101, 110, 116, 97, 108, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 46,
				82, 101, 110, 100, 101, 114, 71, 114, 97, 112,
				104, 77, 111, 100, 117, 108, 101, 124, 82, 101,
				110, 100, 101, 114, 71, 114, 97, 112, 104, 76,
				111, 103, 73, 110, 100, 101, 110, 116, 0, 0,
				0, 0, 70, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 120, 112, 101, 114,
				105, 109, 101, 110, 116, 97, 108, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 82, 101,
				110, 100, 101, 114, 71, 114, 97, 112, 104, 77,
				111, 100, 117, 108, 101, 124, 82, 101, 110, 100,
				101, 114, 71, 114, 97, 112, 104, 76, 111, 103,
				103, 101, 114, 0, 0, 0, 0, 74, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				69, 120, 112, 101, 114, 105, 109, 101, 110, 116,
				97, 108, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 82, 101, 110, 100, 101, 114, 71,
				114, 97, 112, 104, 77, 111, 100, 117, 108, 101,
				124, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 79, 98, 106, 101, 99, 116, 80, 111,
				111, 108, 0, 0, 0, 0, 95, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 69,
				120, 112, 101, 114, 105, 109, 101, 110, 116, 97,
				108, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 82, 101, 110, 100, 101, 114, 71, 114,
				97, 112, 104, 77, 111, 100, 117, 108, 101, 46,
				82, 101, 110, 100, 101, 114, 71, 114, 97, 112,
				104, 79, 98, 106, 101, 99, 116, 80, 111, 111,
				108, 124, 83, 104, 97, 114, 101, 100, 79, 98,
				106, 101, 99, 116, 80, 111, 111, 108, 66, 97,
				115, 101, 0, 0, 0, 0, 91, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 69,
				120, 112, 101, 114, 105, 109, 101, 110, 116, 97,
				108, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 82, 101, 110, 100, 101, 114, 71, 114,
				97, 112, 104, 77, 111, 100, 117, 108, 101, 46,
				82, 101, 110, 100, 101, 114, 71, 114, 97, 112,
				104, 79, 98, 106, 101, 99, 116, 80, 111, 111,
				108, 124, 83, 104, 97, 114, 101, 100, 79, 98,
				106, 101, 99, 116, 80, 111, 111, 108, 1, 0,
				0, 0, 68, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 120, 112, 101, 114,
				105, 109, 101, 110, 116, 97, 108, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 82, 101,
				110, 100, 101, 114, 71, 114, 97, 112, 104, 77,
				111, 100, 117, 108, 101, 124, 82, 101, 110, 100,
				101, 114, 71, 114, 97, 112, 104, 80, 97, 115,
				115, 1, 0, 0, 0, 68, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 69, 120,
				112, 101, 114, 105, 109, 101, 110, 116, 97, 108,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 77, 111, 100, 117, 108, 101, 124, 82,
				101, 110, 100, 101, 114, 71, 114, 97, 112, 104,
				80, 97, 115, 115, 0, 0, 0, 0, 72, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 69, 120, 112, 101, 114, 105, 109, 101, 110,
				116, 97, 108, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 46, 82, 101, 110, 100, 101, 114,
				71, 114, 97, 112, 104, 77, 111, 100, 117, 108,
				101, 124, 67, 111, 109, 112, 117, 116, 101, 66,
				117, 102, 102, 101, 114, 72, 97, 110, 100, 108,
				101, 0, 0, 0, 0, 70, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 69, 120,
				112, 101, 114, 105, 109, 101, 110, 116, 97, 108,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 77, 111, 100, 117, 108, 101, 124, 67,
				111, 109, 112, 117, 116, 101, 66, 117, 102, 102,
				101, 114, 68, 101, 115, 99, 0, 0, 0, 0,
				74, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 120, 112, 101, 114, 105, 109,
				101, 110, 116, 97, 108, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 82, 101, 110, 100,
				101, 114, 71, 114, 97, 112, 104, 77, 111, 100,
				117, 108, 101, 124, 67, 111, 109, 112, 117, 116,
				101, 66, 117, 102, 102, 101, 114, 82, 101, 115,
				111, 117, 114, 99, 101, 0, 0, 0, 0, 70,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 69, 120, 112, 101, 114, 105, 109, 101,
				110, 116, 97, 108, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 82, 101, 110, 100, 101,
				114, 71, 114, 97, 112, 104, 77, 111, 100, 117,
				108, 101, 124, 67, 111, 109, 112, 117, 116, 101,
				66, 117, 102, 102, 101, 114, 80, 111, 111, 108,
				0, 0, 0, 0, 77, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 69, 120, 112,
				101, 114, 105, 109, 101, 110, 116, 97, 108, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 46,
				82, 101, 110, 100, 101, 114, 71, 114, 97, 112,
				104, 77, 111, 100, 117, 108, 101, 124, 73, 82,
				101, 110, 100, 101, 114, 71, 114, 97, 112, 104,
				82, 101, 115, 111, 117, 114, 99, 101, 80, 111,
				111, 108, 0, 0, 0, 0, 76, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 69,
				120, 112, 101, 114, 105, 109, 101, 110, 116, 97,
				108, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 82, 101, 110, 100, 101, 114, 71, 114,
				97, 112, 104, 77, 111, 100, 117, 108, 101, 124,
				82, 101, 110, 100, 101, 114, 71, 114, 97, 112,
				104, 82, 101, 115, 111, 117, 114, 99, 101, 80,
				111, 111, 108, 0, 0, 0, 0, 92, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				69, 120, 112, 101, 114, 105, 109, 101, 110, 116,
				97, 108, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 82, 101, 110, 100, 101, 114, 71,
				114, 97, 112, 104, 77, 111, 100, 117, 108, 101,
				46, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 82, 101, 115, 111, 117, 114, 99, 101,
				80, 111, 111, 108, 124, 82, 101, 115, 111, 117,
				114, 99, 101, 76, 111, 103, 73, 110, 102, 111,
				0, 0, 0, 0, 80, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 69, 120, 112,
				101, 114, 105, 109, 101, 110, 116, 97, 108, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 46,
				82, 101, 110, 100, 101, 114, 71, 114, 97, 112,
				104, 77, 111, 100, 117, 108, 101, 124, 82, 101,
				110, 100, 101, 114, 71, 114, 97, 112, 104, 82,
				101, 115, 111, 117, 114, 99, 101, 82, 101, 103,
				105, 115, 116, 114, 121, 0, 0, 0, 0, 105,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 69, 120, 112, 101, 114, 105, 109, 101,
				110, 116, 97, 108, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 82, 101, 110, 100, 101,
				114, 71, 114, 97, 112, 104, 77, 111, 100, 117,
				108, 101, 46, 82, 101, 110, 100, 101, 114, 71,
				114, 97, 112, 104, 82, 101, 115, 111, 117, 114,
				99, 101, 82, 101, 103, 105, 115, 116, 114, 121,
				124, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 82, 101, 115, 111, 117, 114, 99, 101,
				115, 68, 97, 116, 97, 0, 0, 0, 0, 71,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 69, 120, 112, 101, 114, 105, 109, 101,
				110, 116, 97, 108, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 82, 101, 110, 100, 101,
				114, 71, 114, 97, 112, 104, 77, 111, 100, 117,
				108, 101, 124, 82, 101, 110, 100, 101, 114, 101,
				114, 76, 105, 115, 116, 72, 97, 110, 100, 108,
				101, 0, 0, 0, 0, 73, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 69, 120,
				112, 101, 114, 105, 109, 101, 110, 116, 97, 108,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 77, 111, 100, 117, 108, 101, 124, 82,
				101, 110, 100, 101, 114, 101, 114, 76, 105, 115,
				116, 82, 101, 115, 111, 117, 114, 99, 101, 0,
				0, 0, 0, 67, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 69, 120, 112, 101,
				114, 105, 109, 101, 110, 116, 97, 108, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 82,
				101, 110, 100, 101, 114, 71, 114, 97, 112, 104,
				77, 111, 100, 117, 108, 101, 124, 82, 101, 115,
				111, 117, 114, 99, 101, 72, 97, 110, 100, 108,
				101, 0, 0, 0, 0, 73, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 69, 120,
				112, 101, 114, 105, 109, 101, 110, 116, 97, 108,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 77, 111, 100, 117, 108, 101, 124, 73,
				82, 101, 110, 100, 101, 114, 71, 114, 97, 112,
				104, 82, 101, 115, 111, 117, 114, 99, 101, 0,
				0, 0, 0, 72, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 69, 120, 112, 101,
				114, 105, 109, 101, 110, 116, 97, 108, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 82,
				101, 110, 100, 101, 114, 71, 114, 97, 112, 104,
				77, 111, 100, 117, 108, 101, 124, 82, 101, 110,
				100, 101, 114, 71, 114, 97, 112, 104, 82, 101,
				115, 111, 117, 114, 99, 101, 0, 0, 0, 0,
				66, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 120, 112, 101, 114, 105, 109,
				101, 110, 116, 97, 108, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 82, 101, 110, 100,
				101, 114, 71, 114, 97, 112, 104, 77, 111, 100,
				117, 108, 101, 124, 84, 101, 120, 116, 117, 114,
				101, 72, 97, 110, 100, 108, 101, 0, 0, 0,
				0, 67, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 69, 120, 112, 101, 114, 105,
				109, 101, 110, 116, 97, 108, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 82, 101, 110,
				100, 101, 114, 71, 114, 97, 112, 104, 77, 111,
				100, 117, 108, 101, 124, 70, 97, 115, 116, 77,
				101, 109, 111, 114, 121, 68, 101, 115, 99, 0,
				0, 0, 0, 64, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 69, 120, 112, 101,
				114, 105, 109, 101, 110, 116, 97, 108, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 46, 82,
				101, 110, 100, 101, 114, 71, 114, 97, 112, 104,
				77, 111, 100, 117, 108, 101, 124, 84, 101, 120,
				116, 117, 114, 101, 68, 101, 115, 99, 0, 0,
				0, 0, 68, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 120, 112, 101, 114,
				105, 109, 101, 110, 116, 97, 108, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 82, 101,
				110, 100, 101, 114, 71, 114, 97, 112, 104, 77,
				111, 100, 117, 108, 101, 124, 84, 101, 120, 116,
				117, 114, 101, 82, 101, 115, 111, 117, 114, 99,
				101, 0, 0, 0, 0, 64, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 69, 120,
				112, 101, 114, 105, 109, 101, 110, 116, 97, 108,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 82, 101, 110, 100, 101, 114, 71, 114, 97,
				112, 104, 77, 111, 100, 117, 108, 101, 124, 84,
				101, 120, 116, 117, 114, 101, 80, 111, 111, 108,
				0, 0, 0, 0, 38, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 73, 67, 108,
				111, 117, 100, 66, 97, 99, 107, 103, 114, 111,
				117, 110, 100, 0, 0, 0, 0, 44, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				73, 83, 104, 97, 100, 101, 114, 86, 97, 114,
				105, 97, 110, 116, 83, 101, 116, 116, 105, 110,
				103, 115, 0, 0, 0, 0, 38, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 73,
				86, 111, 108, 117, 109, 101, 116, 114, 105, 99,
				67, 108, 111, 117, 100, 0, 0, 0, 0, 45,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 82, 101, 115, 111,
				117, 114, 99, 101, 115, 0, 0, 0, 0, 34,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 71, 101, 110, 101, 114, 97, 116, 101,
				72, 76, 83, 76, 0, 0, 0, 0, 43, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 83, 117, 114, 102, 97, 99, 101, 68, 97,
				116, 97, 65, 116, 116, 114, 105, 98, 117, 116,
				101, 115, 0, 0, 0, 0, 31, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 72,
				76, 83, 76, 65, 114, 114, 97, 121, 0, 0,
				0, 0, 38, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 80, 97, 99, 107, 105,
				110, 103, 65, 116, 116, 114, 105, 98, 117, 116,
				101, 0, 0, 0, 0, 36, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 83, 104,
				97, 100, 101, 114, 71, 101, 110, 85, 73, 110,
				116, 52, 0, 0, 0, 0, 32, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 72,
				97, 109, 109, 101, 114, 115, 108, 101, 121, 0,
				0, 0, 0, 50, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 72, 97, 109, 109,
				101, 114, 115, 108, 101, 121, 124, 72, 97, 109,
				109, 101, 114, 115, 108, 101, 121, 50, 100, 83,
				101, 113, 49, 54, 0, 0, 0, 0, 50, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 72, 97, 109, 109, 101, 114, 115, 108, 101,
				121, 124, 72, 97, 109, 109, 101, 114, 115, 108,
				101, 121, 50, 100, 83, 101, 113, 51, 50, 0,
				0, 0, 0, 50, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 46, 72, 97, 109, 109,
				101, 114, 115, 108, 101, 121, 124, 72, 97, 109,
				109, 101, 114, 115, 108, 101, 121, 50, 100, 83,
				101, 113, 54, 52, 0, 0, 0, 0, 51, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 72, 97, 109, 109, 101, 114, 115, 108, 101,
				121, 124, 72, 97, 109, 109, 101, 114, 115, 108,
				101, 121, 50, 100, 83, 101, 113, 50, 53, 54,
				0, 0, 0, 0, 44, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 66, 117, 102,
				102, 101, 114, 101, 100, 82, 84, 72, 97, 110,
				100, 108, 101, 83, 121, 115, 116, 101, 109, 0,
				0, 0, 0, 44, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 80, 111, 119, 101,
				114, 79, 102, 84, 119, 111, 84, 101, 120, 116,
				117, 114, 101, 65, 116, 108, 97, 115, 0, 0,
				0, 0, 43, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 82, 84, 72, 97, 110,
				100, 108, 101, 83, 116, 97, 116, 105, 99, 72,
				101, 108, 112, 101, 114, 115, 0, 0, 0, 0,
				30, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 82, 84, 72, 97, 110, 100, 108,
				101, 0, 0, 0, 0, 31, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 82, 84,
				72, 97, 110, 100, 108, 101, 115, 0, 0, 0,
				0, 40, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 82, 84, 72, 97, 110, 100,
				108, 101, 80, 114, 111, 112, 101, 114, 116, 105,
				101, 115, 0, 0, 0, 0, 36, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 82,
				84, 72, 97, 110, 100, 108, 101, 83, 121, 115,
				116, 101, 109, 0, 0, 0, 0, 36, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				65, 116, 108, 97, 115, 65, 108, 108, 111, 99,
				97, 116, 111, 114, 0, 0, 0, 0, 46, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 65, 116, 108, 97, 115, 65, 108, 108, 111,
				99, 97, 116, 111, 114, 124, 65, 116, 108, 97,
				115, 78, 111, 100, 101, 0, 0, 0, 0, 36,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 84, 101, 120, 116, 117, 114, 101, 50,
				68, 65, 116, 108, 97, 115, 0, 0, 0, 0,
				43, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 65, 116, 108, 97, 115, 65, 108,
				108, 111, 99, 97, 116, 111, 114, 68, 121, 110,
				97, 109, 105, 99, 0, 0, 0, 0, 57, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 65, 116, 108, 97, 115, 65, 108, 108, 111,
				99, 97, 116, 111, 114, 68, 121, 110, 97, 109,
				105, 99, 124, 65, 116, 108, 97, 115, 78, 111,
				100, 101, 80, 111, 111, 108, 0, 0, 0, 0,
				53, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 65, 116, 108, 97, 115, 65, 108,
				108, 111, 99, 97, 116, 111, 114, 68, 121, 110,
				97, 109, 105, 99, 124, 65, 116, 108, 97, 115,
				78, 111, 100, 101, 0, 0, 0, 0, 43, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 84, 101, 120, 116, 117, 114, 101, 50, 68,
				65, 116, 108, 97, 115, 68, 121, 110, 97, 109,
				105, 99, 0, 0, 0, 0, 31, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 84,
				101, 120, 116, 117, 114, 101, 88, 82, 0, 0,
				0, 0, 37, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 65, 114, 114, 97, 121,
				69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
				0, 0, 0, 0, 36, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 83, 72, 67,
				111, 101, 102, 102, 105, 99, 105, 101, 110, 116,
				115, 0, 0, 0, 0, 47, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 66, 97,
				116, 99, 104, 82, 101, 110, 100, 101, 114, 101,
				114, 71, 114, 111, 117, 112, 71, 108, 111, 98,
				97, 108, 115, 0, 0, 0, 0, 31, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				73, 66, 105, 116, 65, 114, 114, 97, 121, 0,
				0, 0, 0, 31, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 66, 105, 116, 65,
				114, 114, 97, 121, 56, 0, 0, 0, 0, 32,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 66, 105, 116, 65, 114, 114, 97, 121,
				49, 54, 0, 0, 0, 0, 32, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 66,
				105, 116, 65, 114, 114, 97, 121, 51, 50, 0,
				0, 0, 0, 32, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 66, 105, 116, 65,
				114, 114, 97, 121, 54, 52, 0, 0, 0, 0,
				33, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 66, 105, 116, 65, 114, 114, 97,
				121, 49, 50, 56, 0, 0, 0, 0, 33, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 66, 105, 116, 65, 114, 114, 97, 121, 50,
				53, 54, 0, 0, 0, 0, 39, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 66,
				105, 116, 65, 114, 114, 97, 121, 85, 116, 105,
				108, 105, 116, 105, 101, 115, 0, 0, 0, 0,
				29, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 66, 108, 105, 116, 116, 101, 114,
				0, 0, 0, 0, 43, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 66, 108, 105,
				116, 116, 101, 114, 124, 66, 108, 105, 116, 83,
				104, 97, 100, 101, 114, 73, 68, 115, 0, 0,
				0, 0, 41, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 67, 97, 109, 101, 114,
				97, 67, 97, 112, 116, 117, 114, 101, 66, 114,
				105, 100, 103, 101, 0, 0, 0, 0, 37, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 67, 111, 108, 111, 114, 83, 112, 97, 99,
				101, 85, 116, 105, 108, 115, 0, 0, 0, 0,
				32, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 67, 111, 108, 111, 114, 85, 116,
				105, 108, 115, 0, 0, 0, 0, 37, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				67, 111, 114, 101, 77, 97, 116, 114, 105, 120,
				85, 116, 105, 108, 115, 0, 0, 0, 0, 31,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 67, 111, 114, 101, 85, 116, 105, 108,
				115, 0, 0, 0, 0, 40, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 67, 111,
				114, 101, 85, 116, 105, 108, 115, 124, 83, 101,
				99, 116, 105, 111, 110, 115, 0, 0, 0, 0,
				42, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 46, 67, 111, 114, 101, 85, 116, 105,
				108, 115, 124, 80, 114, 105, 111, 114, 105, 116,
				105, 101, 115, 0, 0, 0, 0, 37, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				68, 101, 108, 101, 103, 97, 116, 101, 85, 116,
				105, 108, 105, 116, 121, 0, 0, 0, 0, 30,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 70, 83, 82, 85, 116, 105, 108, 115,
				0, 0, 0, 0, 46, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 70, 83, 82,
				85, 116, 105, 108, 115, 124, 83, 104, 97, 100,
				101, 114, 67, 111, 110, 115, 116, 97, 110, 116,
				115, 0, 0, 0, 0, 32, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 72, 97,
				98, 108, 101, 67, 117, 114, 118, 101, 0, 0,
				0, 0, 40, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 46, 72, 97, 98, 108, 101,
				67, 117, 114, 118, 101, 124, 83, 101, 103, 109,
				101, 110, 116, 0, 0, 0, 0, 45, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 46,
				72, 97, 98, 108, 101, 67, 117, 114, 118, 101,
				124, 68, 105, 114, 101, 99, 116, 80, 97, 114,
				97, 109, 115, 0, 0, 0, 0, 41, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 46,
				72, 97, 98, 108, 101, 67, 117, 114, 118, 101,
				124, 85, 110, 105, 102, 111, 114, 109, 115, 0,
				0, 0, 0, 36, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 72, 97, 108, 116,
				111, 110, 83, 101, 113, 117, 101, 110, 99, 101,
				0, 0, 0, 0, 36, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 72, 68, 82,
				79, 117, 116, 112, 117, 116, 85, 116, 105, 108,
				115, 0, 0, 0, 0, 58, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 46, 72, 68,
				82, 79, 117, 116, 112, 117, 116, 85, 116, 105,
				108, 115, 124, 72, 68, 82, 68, 105, 115, 112,
				108, 97, 121, 73, 110, 102, 111, 114, 109, 97,
				116, 105, 111, 110, 0, 0, 0, 0, 51, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				46, 72, 68, 82, 79, 117, 116, 112, 117, 116,
				85, 116, 105, 108, 115, 124, 83, 104, 97, 100,
				101, 114, 75, 101, 121, 119, 111, 114, 100, 115,
				0, 0, 0, 0, 53, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 46, 72, 68, 82,
				79, 117, 116, 112, 117, 116, 85, 116, 105, 108,
				115, 124, 83, 104, 97, 100, 101, 114, 80, 114,
				111, 112, 101, 114, 116, 121, 73, 100, 0, 0,
				0, 0, 46, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 77, 97, 116, 101, 114,
				105, 97, 108, 81, 117, 97, 108, 105, 116, 121,
				85, 116, 105, 108, 105, 116, 105, 101, 115, 0,
				0, 0, 0, 31, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 77, 101, 115, 104,
				71, 105, 122, 109, 111, 0, 0, 0, 0, 37,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 82, 101, 108, 111, 97, 100, 65, 116,
				116, 114, 105, 98, 117, 116, 101, 0, 0, 0,
				0, 42, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 82, 101, 108, 111, 97, 100,
				71, 114, 111, 117, 112, 65, 116, 116, 114, 105,
				98, 117, 116, 101, 0, 0, 0, 0, 41, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 83, 99, 101, 110, 101, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				0, 0, 0, 0, 34, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 84, 101, 120,
				116, 117, 114, 101, 67, 117, 114, 118, 101, 0,
				0, 0, 0, 43, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 84, 101, 120, 116,
				117, 114, 101, 67, 117, 114, 118, 101, 80, 97,
				114, 97, 109, 101, 116, 101, 114, 0, 0, 0,
				0, 37, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 84, 105, 108, 101, 76, 97,
				121, 111, 117, 116, 85, 116, 105, 108, 115, 0,
				0, 0, 0, 29, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 88, 82, 85, 116,
				105, 108, 115, 0, 0, 0, 0, 29, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				73, 86, 111, 108, 117, 109, 101, 0, 0, 0,
				0, 37, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 75, 101, 121, 102, 114, 97,
				109, 101, 85, 116, 105, 108, 105, 116, 121, 0,
				0, 0, 0, 28, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 86, 111, 108, 117,
				109, 101, 0, 0, 0, 0, 41, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 86,
				111, 108, 117, 109, 101, 67, 111, 109, 112, 111,
				110, 101, 110, 116, 77, 101, 110, 117, 0, 0,
				0, 0, 58, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 86, 111, 108, 117, 109,
				101, 67, 111, 109, 112, 111, 110, 101, 110, 116,
				77, 101, 110, 117, 70, 111, 114, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 0, 0, 0, 0, 47, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 86, 111,
				108, 117, 109, 101, 67, 111, 109, 112, 111, 110,
				101, 110, 116, 68, 101, 112, 114, 101, 99, 97,
				116, 101, 100, 0, 0, 0, 0, 37, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				86, 111, 108, 117, 109, 101, 67, 111, 109, 112,
				111, 110, 101, 110, 116, 0, 0, 0, 0, 44,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 46, 86, 111, 108, 117, 109, 101, 67, 111,
				109, 112, 111, 110, 101, 110, 116, 124, 73, 110,
				100, 101, 110, 116, 0, 0, 0, 0, 35, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 86, 111, 108, 117, 109, 101, 77, 97, 110,
				97, 103, 101, 114, 0, 0, 0, 0, 42, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 86, 111, 108, 117, 109, 101, 73, 115, 111,
				108, 97, 116, 105, 111, 110, 83, 99, 111, 112,
				101, 1, 0, 0, 0, 37, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 86, 111,
				108, 117, 109, 101, 80, 97, 114, 97, 109, 101,
				116, 101, 114, 1, 0, 0, 0, 37, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				86, 111, 108, 117, 109, 101, 80, 97, 114, 97,
				109, 101, 116, 101, 114, 0, 0, 0, 0, 35,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 66, 111, 111, 108, 80, 97, 114, 97,
				109, 101, 116, 101, 114, 0, 0, 0, 0, 40,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 76, 97, 121, 101, 114, 77, 97, 115,
				107, 80, 97, 114, 97, 109, 101, 116, 101, 114,
				0, 0, 0, 0, 34, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 73, 110, 116,
				80, 97, 114, 97, 109, 101, 116, 101, 114, 0,
				0, 0, 0, 42, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 78, 111, 73, 110,
				116, 101, 114, 112, 73, 110, 116, 80, 97, 114,
				97, 109, 101, 116, 101, 114, 0, 0, 0, 0,
				37, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 77, 105, 110, 73, 110, 116, 80,
				97, 114, 97, 109, 101, 116, 101, 114, 0, 0,
				0, 0, 45, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 78, 111, 73, 110, 116,
				101, 114, 112, 77, 105, 110, 73, 110, 116, 80,
				97, 114, 97, 109, 101, 116, 101, 114, 0, 0,
				0, 0, 37, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 77, 97, 120, 73, 110,
				116, 80, 97, 114, 97, 109, 101, 116, 101, 114,
				0, 0, 0, 0, 45, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 78, 111, 73,
				110, 116, 101, 114, 112, 77, 97, 120, 73, 110,
				116, 80, 97, 114, 97, 109, 101, 116, 101, 114,
				0, 0, 0, 0, 41, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 67, 108, 97,
				109, 112, 101, 100, 73, 110, 116, 80, 97, 114,
				97, 109, 101, 116, 101, 114, 0, 0, 0, 0,
				49, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 78, 111, 73, 110, 116, 101, 114,
				112, 67, 108, 97, 109, 112, 101, 100, 73, 110,
				116, 80, 97, 114, 97, 109, 101, 116, 101, 114,
				0, 0, 0, 0, 36, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 70, 108, 111,
				97, 116, 80, 97, 114, 97, 109, 101, 116, 101,
				114, 0, 0, 0, 0, 44, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 78, 111,
				73, 110, 116, 101, 114, 112, 70, 108, 111, 97,
				116, 80, 97, 114, 97, 109, 101, 116, 101, 114,
				0, 0, 0, 0, 39, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 77, 105, 110,
				70, 108, 111, 97, 116, 80, 97, 114, 97, 109,
				101, 116, 101, 114, 0, 0, 0, 0, 47, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 78, 111, 73, 110, 116, 101, 114, 112, 77,
				105, 110, 70, 108, 111, 97, 116, 80, 97, 114,
				97, 109, 101, 116, 101, 114, 0, 0, 0, 0,
				39, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 77, 97, 120, 70, 108, 111, 97,
				116, 80, 97, 114, 97, 109, 101, 116, 101, 114,
				0, 0, 0, 0, 47, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 78, 111, 73,
				110, 116, 101, 114, 112, 77, 97, 120, 70, 108,
				111, 97, 116, 80, 97, 114, 97, 109, 101, 116,
				101, 114, 0, 0, 0, 0, 43, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 67,
				108, 97, 109, 112, 101, 100, 70, 108, 111, 97,
				116, 80, 97, 114, 97, 109, 101, 116, 101, 114,
				0, 0, 0, 0, 51, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 78, 111, 73,
				110, 116, 101, 114, 112, 67, 108, 97, 109, 112,
				101, 100, 70, 108, 111, 97, 116, 80, 97, 114,
				97, 109, 101, 116, 101, 114, 0, 0, 0, 0,
				41, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 70, 108, 111, 97, 116, 82, 97,
				110, 103, 101, 80, 97, 114, 97, 109, 101, 116,
				101, 114, 0, 0, 0, 0, 49, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 78,
				111, 73, 110, 116, 101, 114, 112, 70, 108, 111,
				97, 116, 82, 97, 110, 103, 101, 80, 97, 114,
				97, 109, 101, 116, 101, 114, 0, 0, 0, 0,
				36, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 67, 111, 108, 111, 114, 80, 97,
				114, 97, 109, 101, 116, 101, 114, 0, 0, 0,
				0, 44, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 78, 111, 73, 110, 116, 101,
				114, 112, 67, 111, 108, 111, 114, 80, 97, 114,
				97, 109, 101, 116, 101, 114, 0, 0, 0, 0,
				38, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 124, 86, 101, 99, 116, 111, 114, 50,
				80, 97, 114, 97, 109, 101, 116, 101, 114, 0,
				0, 0, 0, 46, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 78, 111, 73, 110,
				116, 101, 114, 112, 86, 101, 99, 116, 111, 114,
				50, 80, 97, 114, 97, 109, 101, 116, 101, 114,
				0, 0, 0, 0, 38, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 86, 101, 99,
				116, 111, 114, 51, 80, 97, 114, 97, 109, 101,
				116, 101, 114, 0, 0, 0, 0, 46, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				82, 101, 110, 100, 101, 114, 105, 110, 103, 124,
				78, 111, 73, 110, 116, 101, 114, 112, 86, 101,
				99, 116, 111, 114, 51, 80, 97, 114, 97, 109,
				101, 116, 101, 114, 0, 0, 0, 0, 38, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 86, 101, 99, 116, 111, 114, 52, 80, 97,
				114, 97, 109, 101, 116, 101, 114, 0, 0, 0,
				0, 46, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 78, 111, 73, 110, 116, 101,
				114, 112, 86, 101, 99, 116, 111, 114, 52, 80,
				97, 114, 97, 109, 101, 116, 101, 114, 0, 0,
				0, 0, 38, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 84, 101, 120, 116, 117,
				114, 101, 80, 97, 114, 97, 109, 101, 116, 101,
				114, 0, 0, 0, 0, 46, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 78, 111,
				73, 110, 116, 101, 114, 112, 84, 101, 120, 116,
				117, 114, 101, 80, 97, 114, 97, 109, 101, 116,
				101, 114, 0, 0, 0, 0, 40, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 84,
				101, 120, 116, 117, 114, 101, 50, 68, 80, 97,
				114, 97, 109, 101, 116, 101, 114, 0, 0, 0,
				0, 40, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 82, 101, 110, 100, 101, 114,
				105, 110, 103, 124, 84, 101, 120, 116, 117, 114,
				101, 51, 68, 80, 97, 114, 97, 109, 101, 116,
				101, 114, 0, 0, 0, 0, 44, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 82,
				101, 110, 100, 101, 114, 84, 101, 120, 116, 117,
				114, 101, 80, 97, 114, 97, 109, 101, 116, 101,
				114, 0, 0, 0, 0, 52, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 78, 111,
				73, 110, 116, 101, 114, 112, 82, 101, 110, 100,
				101, 114, 84, 101, 120, 116, 117, 114, 101, 80,
				97, 114, 97, 109, 101, 116, 101, 114, 0, 0,
				0, 0, 38, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 67, 117, 98, 101, 109,
				97, 112, 80, 97, 114, 97, 109, 101, 116, 101,
				114, 0, 0, 0, 0, 46, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 78, 111,
				73, 110, 116, 101, 114, 112, 67, 117, 98, 101,
				109, 97, 112, 80, 97, 114, 97, 109, 101, 116,
				101, 114, 0, 0, 0, 0, 37, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 79,
				98, 106, 101, 99, 116, 80, 97, 114, 97, 109,
				101, 116, 101, 114, 0, 0, 0, 0, 45, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 65, 110, 105, 109, 97, 116, 105, 111, 110,
				67, 117, 114, 118, 101, 80, 97, 114, 97, 109,
				101, 116, 101, 114, 0, 0, 0, 0, 39, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 77, 97, 116, 101, 114, 105, 97, 108, 80,
				97, 114, 97, 109, 101, 116, 101, 114, 0, 0,
				0, 0, 35, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 86, 111, 108, 117, 109,
				101, 80, 114, 111, 102, 105, 108, 101, 0, 0,
				0, 0, 33, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 124, 86, 111, 108, 117, 109,
				101, 83, 116, 97, 99, 107, 0, 0, 0, 0,
				59, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 120, 112, 101, 114, 105, 109,
				101, 110, 116, 97, 108, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 88, 82, 66, 117,
				105, 108, 116, 105, 110, 83, 104, 97, 100, 101,
				114, 67, 111, 110, 115, 116, 97, 110, 116, 115,
				0, 0, 0, 0, 46, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 124, 88, 82, 71,
				114, 97, 112, 104, 105, 99, 115, 65, 117, 116,
				111, 109, 97, 116, 101, 100, 84, 101, 115, 116,
				115, 0, 0, 0, 0, 43, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 69, 120,
				112, 101, 114, 105, 109, 101, 110, 116, 97, 108,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 88, 82, 76, 97, 121, 111, 117, 116, 0,
				0, 0, 0, 47, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 69, 120, 112, 101,
				114, 105, 109, 101, 110, 116, 97, 108, 46, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 124, 88,
				82, 77, 105, 114, 114, 111, 114, 86, 105, 101,
				119, 0, 0, 0, 0, 50, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 69, 120,
				112, 101, 114, 105, 109, 101, 110, 116, 97, 108,
				46, 82, 101, 110, 100, 101, 114, 105, 110, 103,
				124, 88, 82, 79, 99, 99, 108, 117, 115, 105,
				111, 110, 77, 101, 115, 104, 0, 0, 0, 0,
				51, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 120, 112, 101, 114, 105, 109,
				101, 110, 116, 97, 108, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 88, 82, 80, 97,
				115, 115, 67, 114, 101, 97, 116, 101, 73, 110,
				102, 111, 0, 0, 0, 0, 41, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 69,
				120, 112, 101, 114, 105, 109, 101, 110, 116, 97,
				108, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 124, 88, 82, 80, 97, 115, 115, 0, 0,
				0, 0, 43, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 120, 112, 101, 114,
				105, 109, 101, 110, 116, 97, 108, 46, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 124, 88, 82,
				83, 121, 115, 116, 101, 109, 0, 0, 0, 0,
				41, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 120, 112, 101, 114, 105, 109,
				101, 110, 116, 97, 108, 46, 82, 101, 110, 100,
				101, 114, 105, 110, 103, 124, 88, 82, 86, 105,
				101, 119
			},
			TotalFiles = 166,
			TotalTypes = 393,
			IsEditorOnly = false
		};
	}
}
namespace UnityEngine
{
	[AddComponentMenu("Rendering/Light Anchor")]
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	public class LightAnchor : MonoBehaviour
	{
		public enum UpDirection
		{
			World,
			Local
		}

		private struct Axes
		{
			public Vector3 up;

			public Vector3 right;

			public Vector3 forward;
		}

		private const float k_ArcRadius = 5f;

		private const float k_AxisLength = 10f;

		internal const float k_MaxDistance = 10000f;

		[SerializeField]
		[Min(0f)]
		private float m_Distance;

		[SerializeField]
		private UpDirection m_FrameSpace;

		[SerializeField]
		private Transform m_AnchorPositionOverride;

		[SerializeField]
		private Vector3 m_AnchorPositionOffset;

		[SerializeField]
		private float m_Yaw;

		[SerializeField]
		private float m_Pitch;

		[SerializeField]
		private float m_Roll;

		public float yaw
		{
			get
			{
				return m_Yaw;
			}
			set
			{
				m_Yaw = NormalizeAngleDegree(value);
			}
		}

		public float pitch
		{
			get
			{
				return m_Pitch;
			}
			set
			{
				m_Pitch = NormalizeAngleDegree(value);
			}
		}

		public float roll
		{
			get
			{
				return m_Roll;
			}
			set
			{
				m_Roll = NormalizeAngleDegree(value);
			}
		}

		public float distance
		{
			get
			{
				return m_Distance;
			}
			set
			{
				m_Distance = Mathf.Clamp(value, 0f, 10000f);
			}
		}

		public UpDirection frameSpace
		{
			get
			{
				return m_FrameSpace;
			}
			set
			{
				m_FrameSpace = value;
			}
		}

		public Vector3 anchorPosition
		{
			get
			{
				if (anchorPositionOverride != null)
				{
					return anchorPositionOverride.position + anchorPositionOverride.TransformDirection(anchorPositionOffset);
				}
				return base.transform.position + base.transform.forward * distance;
			}
		}

		public Transform anchorPositionOverride
		{
			get
			{
				return m_AnchorPositionOverride;
			}
			set
			{
				m_AnchorPositionOverride = value;
			}
		}

		public Vector3 anchorPositionOffset
		{
			get
			{
				return m_AnchorPositionOffset;
			}
			set
			{
				m_AnchorPositionOffset = value;
			}
		}

		public static float NormalizeAngleDegree(float angle)
		{
			float num = angle - -180f;
			return num - Mathf.Floor(num / 360f) * 360f + -180f;
		}

		public void SynchronizeOnTransform(Camera camera)
		{
			Axes worldSpaceAxes = GetWorldSpaceAxes(camera, anchorPosition);
			Vector3 vector = base.transform.position - anchorPosition;
			if (vector.magnitude == 0f)
			{
				vector = -base.transform.forward;
			}
			Vector3 vector2 = Vector3.ProjectOnPlane(vector, worldSpaceAxes.up);
			if (vector2.magnitude < 0.0001f)
			{
				vector2 = Vector3.ProjectOnPlane(vector, worldSpaceAxes.up + worldSpaceAxes.right * 0.0001f);
			}
			vector2.Normalize();
			float angle = Vector3.SignedAngle(worldSpaceAxes.forward, vector2, worldSpaceAxes.up);
			Vector3 axis = Quaternion.AngleAxis(angle, worldSpaceAxes.up) * worldSpaceAxes.right;
			float num = Vector3.SignedAngle(vector2, vector, axis);
			yaw = angle;
			pitch = num;
			roll = base.transform.rotation.eulerAngles.z;
		}

		public void UpdateTransform(Camera camera, Vector3 anchor)
		{
			Axes worldSpaceAxes = GetWorldSpaceAxes(camera, anchor);
			UpdateTransform(worldSpaceAxes.up, worldSpaceAxes.right, worldSpaceAxes.forward, anchor);
		}

		private Axes GetWorldSpaceAxes(Camera camera, Vector3 anchor)
		{
			if (base.transform.IsChildOf(camera.transform))
			{
				return new Axes
				{
					up = Vector3.up,
					right = Vector3.right,
					forward = Vector3.forward
				};
			}
			Matrix4x4 matrix4x = camera.cameraToWorldMatrix;
			if (m_FrameSpace == UpDirection.Local)
			{
				Vector3 up = Camera.main.transform.up;
				matrix4x = (Matrix4x4.Scale(new Vector3(1f, 1f, -1f)) * Matrix4x4.LookAt(camera.transform.position, anchor, up).inverse).inverse;
			}
			else if (!camera.orthographic && camera.transform.position != anchor)
			{
				Quaternion q = Quaternion.LookRotation((anchor - camera.transform.position).normalized);
				matrix4x = (Matrix4x4.Scale(new Vector3(1f, 1f, -1f)) * Matrix4x4.TRS(camera.transform.position, q, Vector3.one).inverse).inverse;
			}
			Vector3 up2 = (matrix4x * Vector3.up).normalized;
			Vector3 right = (matrix4x * Vector3.right).normalized;
			Vector3 forward = (matrix4x * Vector3.forward).normalized;
			return new Axes
			{
				up = up2,
				right = right,
				forward = forward
			};
		}

		private void Update()
		{
			if (!(anchorPositionOverride == null) && !(Camera.main == null) && (anchorPositionOverride.hasChanged || Camera.main.transform.hasChanged))
			{
				UpdateTransform(Camera.main, anchorPosition);
			}
		}

		private void OnDrawGizmosSelected()
		{
			Camera main = Camera.main;
			if (!(main == null))
			{
				Vector3 vector = anchorPosition;
				Axes worldSpaceAxes = GetWorldSpaceAxes(main, vector);
				Vector3.ProjectOnPlane(base.transform.position - vector, worldSpaceAxes.up);
				Mathf.Min(distance * 0.25f, 5f);
				Mathf.Min(distance * 0.5f, 10f);
			}
		}

		private void UpdateTransform(Vector3 up, Vector3 right, Vector3 forward, Vector3 anchor)
		{
			Quaternion quaternion = Quaternion.AngleAxis(m_Yaw, up);
			Quaternion quaternion2 = Quaternion.AngleAxis(m_Pitch, right);
			Vector3 position = anchor + quaternion * quaternion2 * forward * distance;
			base.transform.position = position;
			Vector3 eulerAngles = Quaternion.LookRotation(-(quaternion * quaternion2 * forward).normalized, up).eulerAngles;
			eulerAngles.z = m_Roll;
			base.transform.eulerAngles = eulerAngles;
		}
	}
}
namespace UnityEngine.Experimental.Rendering
{
	public static class XRBuiltinShaderConstants
	{
		public static readonly int unity_StereoCameraProjection = Shader.PropertyToID("unity_StereoCameraProjection");

		public static readonly int unity_StereoCameraInvProjection = Shader.PropertyToID("unity_StereoCameraInvProjection");

		public static readonly int unity_StereoMatrixV = Shader.PropertyToID("unity_StereoMatrixV");

		public static readonly int unity_StereoMatrixInvV = Shader.PropertyToID("unity_StereoMatrixInvV");

		public static readonly int unity_StereoMatrixP = Shader.PropertyToID("unity_StereoMatrixP");

		public static readonly int unity_StereoMatrixInvP = Shader.PropertyToID("unity_StereoMatrixInvP");

		public static readonly int unity_StereoMatrixVP = Shader.PropertyToID("unity_StereoMatrixVP");

		public static readonly int unity_StereoMatrixInvVP = Shader.PropertyToID("unity_StereoMatrixInvVP");

		public static readonly int unity_StereoWorldSpaceCameraPos = Shader.PropertyToID("unity_StereoWorldSpaceCameraPos");

		private static Matrix4x4[] s_cameraProjMatrix = new Matrix4x4[2];

		private static Matrix4x4[] s_invCameraProjMatrix = new Matrix4x4[2];

		private static Matrix4x4[] s_viewMatrix = new Matrix4x4[2];

		private static Matrix4x4[] s_invViewMatrix = new Matrix4x4[2];

		private static Matrix4x4[] s_projMatrix = new Matrix4x4[2];

		private static Matrix4x4[] s_invProjMatrix = new Matrix4x4[2];

		private static Matrix4x4[] s_viewProjMatrix = new Matrix4x4[2];

		private static Matrix4x4[] s_invViewProjMatrix = new Matrix4x4[2];

		private static Vector4[] s_worldSpaceCameraPos = new Vector4[2];

		public static void UpdateBuiltinShaderConstants(Matrix4x4 viewMatrix, Matrix4x4 projMatrix, bool renderIntoTexture, int viewIndex)
		{
		}

		public static void SetBuiltinShaderConstants(CommandBuffer cmd)
		{
		}

		public static void Update(XRPass xrPass, CommandBuffer cmd, bool renderIntoTexture)
		{
		}
	}
	public class XRLayout
	{
		private readonly List<(Camera, XRPass)> m_ActivePasses = new List<(Camera, XRPass)>();

		public void AddCamera(Camera camera, bool enableXR)
		{
			if (!(camera == null))
			{
				bool flag = (camera.cameraType == CameraType.Game || camera.cameraType == CameraType.VR) && camera.targetTexture == null && enableXR;
				if (XRSystem.displayActive && flag)
				{
					XRSystem.SetDisplayZRange(camera.nearClipPlane, camera.farClipPlane);
					XRSystem.CreateDefaultLayout(camera);
				}
				else
				{
					AddPass(camera, XRSystem.emptyPass);
				}
			}
		}

		public void ReconfigurePass(XRPass xrPass, Camera camera)
		{
			if (xrPass.enabled)
			{
				XRSystem.ReconfigurePass(xrPass, camera);
				xrPass.UpdateCombinedOcclusionMesh();
			}
		}

		public List<(Camera, XRPass)> GetActivePasses()
		{
			return m_ActivePasses;
		}

		internal void AddPass(Camera camera, XRPass xrPass)
		{
			xrPass.UpdateCombinedOcclusionMesh();
			m_ActivePasses.Add((camera, xrPass));
		}

		internal void Clear()
		{
			for (int i = 0; i < m_ActivePasses.Count; i++)
			{
				XRPass item = m_ActivePasses[m_ActivePasses.Count - i - 1].Item2;
				if (item != XRSystem.emptyPass)
				{
					item.Release();
				}
			}
			m_ActivePasses.Clear();
		}

		internal void LogDebugInfo()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendFormat("XRSystem setup for frame {0}, active: {1}", Time.frameCount, XRSystem.displayActive);
			stringBuilder.AppendLine();
			for (int i = 0; i < m_ActivePasses.Count; i++)
			{
				XRPass item = m_ActivePasses[i].Item2;
				for (int j = 0; j < item.viewCount; j++)
				{
					Rect viewport = item.GetViewport(j);
					stringBuilder.AppendFormat("XR Pass {0} Cull {1} View {2} Slice {3} : {4} x {5}", item.multipassId, item.cullingPassId, j, item.GetTextureArraySlice(j), viewport.width, viewport.height);
					stringBuilder.AppendLine();
				}
			}
			Debug.Log(stringBuilder);
		}
	}
	internal static class XRMirrorView
	{
		private static readonly MaterialPropertyBlock s_MirrorViewMaterialProperty = new MaterialPropertyBlock();

		private static readonly ProfilingSampler k_MirrorViewProfilingSampler = new ProfilingSampler("XR Mirror View");

		private static readonly int k_SourceTex = Shader.PropertyToID("_SourceTex");

		private static readonly int k_SourceTexArraySlice = Shader.PropertyToID("_SourceTexArraySlice");

		private static readonly int k_ScaleBias = Shader.PropertyToID("_ScaleBias");

		private static readonly int k_ScaleBiasRt = Shader.PropertyToID("_ScaleBiasRt");

		private static readonly int k_SRGBRead = Shader.PropertyToID("_SRGBRead");

		private static readonly int k_SRGBWrite = Shader.PropertyToID("_SRGBWrite");

		private static readonly int k_MaxNits = Shader.PropertyToID("_MaxNits");

		private static readonly int k_SourceMaxNits = Shader.PropertyToID("_SourceMaxNits");

		private static readonly int k_SourceHDREncoding = Shader.PropertyToID("_SourceHDREncoding");

		private static readonly int k_ColorTransform = Shader.PropertyToID("_ColorTransform");
	}
	internal class XROcclusionMesh
	{
		private XRPass m_Pass;

		private Mesh m_CombinedMesh;

		private Material m_Material;

		private int m_CombinedMeshHashCode;

		private static readonly ProfilingSampler k_OcclusionMeshProfilingSampler = new ProfilingSampler("XR Occlusion Mesh");

		internal bool hasValidOcclusionMesh
		{
			get
			{
				if (IsOcclusionMeshSupported())
				{
					if (m_Pass.singlePassEnabled)
					{
						return m_CombinedMesh != null;
					}
					return m_Pass.GetOcclusionMesh() != null;
				}
				return false;
			}
		}

		internal XROcclusionMesh(XRPass xrPass)
		{
			m_Pass = xrPass;
		}

		internal void SetMaterial(Material mat)
		{
			m_Material = mat;
		}

		internal void RenderOcclusionMesh(CommandBuffer cmd, float occlusionMeshScale, bool yFlip = false)
		{
			if (!IsOcclusionMeshSupported())
			{
				return;
			}
			using (new ProfilingScope(cmd, k_OcclusionMeshProfilingSampler))
			{
				if (m_Pass.singlePassEnabled)
				{
					if (m_CombinedMesh != null && SystemInfo.supportsMultiview)
					{
						cmd.EnableShaderKeyword("XR_OCCLUSION_MESH_COMBINED");
						Vector3 vector = new Vector3(occlusionMeshScale, yFlip ? occlusionMeshScale : (0f - occlusionMeshScale), 1f);
						cmd.DrawMesh(m_CombinedMesh, Matrix4x4.Scale(vector), m_Material);
						cmd.DisableShaderKeyword("XR_OCCLUSION_MESH_COMBINED");
					}
					else if (m_CombinedMesh != null && SystemInfo.supportsRenderTargetArrayIndexFromVertexShader)
					{
						m_Pass.StopSinglePass(cmd);
						cmd.EnableShaderKeyword("XR_OCCLUSION_MESH_COMBINED");
						Vector3 vector2 = new Vector3(occlusionMeshScale, yFlip ? occlusionMeshScale : (0f - occlusionMeshScale), 1f);
						cmd.DrawMesh(m_CombinedMesh, Matrix4x4.Scale(vector2), m_Material);
						cmd.DisableShaderKeyword("XR_OCCLUSION_MESH_COMBINED");
						m_Pass.StartSinglePass(cmd);
					}
				}
				else
				{
					Mesh occlusionMesh = m_Pass.GetOcclusionMesh();
					if (occlusionMesh != null)
					{
						cmd.DrawMesh(occlusionMesh, Matrix4x4.identity, m_Material);
					}
				}
			}
		}

		internal void UpdateCombinedMesh()
		{
			if (IsOcclusionMeshSupported() && m_Pass.singlePassEnabled && TryGetOcclusionMeshCombinedHashCode(out var hashCode))
			{
				if (m_CombinedMesh == null || hashCode != m_CombinedMeshHashCode)
				{
					CreateOcclusionMeshCombined();
					m_CombinedMeshHashCode = hashCode;
				}
			}
			else
			{
				m_CombinedMesh = null;
				m_CombinedMeshHashCode = 0;
			}
		}

		private bool IsOcclusionMeshSupported()
		{
			if (m_Pass.enabled)
			{
				return m_Material != null;
			}
			return false;
		}

		private bool TryGetOcclusionMeshCombinedHashCode(out int hashCode)
		{
			hashCode = 17;
			for (int i = 0; i < m_Pass.viewCount; i++)
			{
				Mesh occlusionMesh = m_Pass.GetOcclusionMesh(i);
				if (occlusionMesh != null)
				{
					hashCode = hashCode * 23 + occlusionMesh.GetHashCode();
					continue;
				}
				hashCode = 0;
				return false;
			}
			return true;
		}

		private void CreateOcclusionMeshCombined()
		{
			CoreUtils.Destroy(m_CombinedMesh);
			m_CombinedMesh = new Mesh();
			m_CombinedMesh.indexFormat = IndexFormat.UInt16;
			int num = 0;
			uint num2 = 0u;
			for (int i = 0; i < m_Pass.viewCount; i++)
			{
				Mesh occlusionMesh = m_Pass.GetOcclusionMesh(i);
				Debug.Assert(occlusionMesh != null);
				Debug.Assert(occlusionMesh.subMeshCount == 1);
				Debug.Assert(occlusionMesh.indexFormat == IndexFormat.UInt16);
				num += occlusionMesh.vertexCount;
				num2 += occlusionMesh.GetIndexCount(0);
			}
			Vector3[] array = new Vector3[num];
			ushort[] array2 = new ushort[num2];
			int num3 = 0;
			int num4 = 0;
			for (int j = 0; j < m_Pass.viewCount; j++)
			{
				Mesh occlusionMesh2 = m_Pass.GetOcclusionMesh(j);
				int[] indices = occlusionMesh2.GetIndices(0);
				occlusionMesh2.vertices.CopyTo(array, num3);
				for (int k = 0; k < occlusionMesh2.vertices.Length; k++)
				{
					array[num3 + k].z = j;
				}
				for (int l = 0; l < indices.Length; l++)
				{
					int num5 = num3 + indices[l];
					Debug.Assert(indices[l] < 65535);
					array2[num4 + l] = (ushort)num5;
				}
				num3 += occlusionMesh2.vertexCount;
				num4 += indices.Length;
			}
			m_CombinedMesh.vertices = array;
			m_CombinedMesh.SetIndices(array2, MeshTopology.Triangles, 0);
		}
	}
	public struct XRPassCreateInfo
	{
		internal RenderTargetIdentifier renderTarget;

		internal RenderTextureDescriptor renderTargetDesc;

		internal ScriptableCullingParameters cullingParameters;

		internal Material occlusionMeshMaterial;

		internal float occlusionMeshScale;

		internal IntPtr foveatedRenderingInfo;

		internal int multipassId;

		internal int cullingPassId;

		internal bool copyDepth;
	}
	public class XRPass
	{
		private readonly List<XRView> m_Views;

		private readonly XROcclusionMesh m_OcclusionMesh;

		public bool enabled => false;

		public bool supportsFoveatedRendering => false;

		public bool copyDepth { get; private set; }

		public int multipassId { get; private set; }

		public int cullingPassId { get; private set; }

		public RenderTargetIdentifier renderTarget { get; private set; }

		public RenderTextureDescriptor renderTargetDesc { get; private set; }

		public ScriptableCullingParameters cullingParams { get; private set; }

		public int viewCount => m_Views.Count;

		public bool singlePassEnabled => viewCount > 1;

		public IntPtr foveatedRenderingInfo { get; private set; }

		public bool isHDRDisplayOutputActive => false;

		public ColorGamut hdrDisplayOutputColorGamut => ColorGamut.sRGB;

		public HDROutputUtils.HDRDisplayInformation hdrDisplayOutputInformation => new HDROutputUtils.HDRDisplayInformation(-1, -1, -1, 160f);

		public float occlusionMeshScale { get; private set; }

		public bool hasValidOcclusionMesh => m_OcclusionMesh.hasValidOcclusionMesh;

		public XRPass()
		{
			m_Views = new List<XRView>(2);
			m_OcclusionMesh = new XROcclusionMesh(this);
		}

		public static XRPass CreateDefault(XRPassCreateInfo createInfo)
		{
			XRPass xRPass = GenericPool<XRPass>.Get();
			xRPass.InitBase(createInfo);
			return xRPass;
		}

		public virtual void Release()
		{
			GenericPool<XRPass>.Release(this);
		}

		public Matrix4x4 GetProjMatrix(int viewIndex = 0)
		{
			return m_Views[viewIndex].projMatrix;
		}

		public Matrix4x4 GetViewMatrix(int viewIndex = 0)
		{
			return m_Views[viewIndex].viewMatrix;
		}

		public Rect GetViewport(int viewIndex = 0)
		{
			return m_Views[viewIndex].viewport;
		}

		public Mesh GetOcclusionMesh(int viewIndex = 0)
		{
			return m_Views[viewIndex].occlusionMesh;
		}

		public int GetTextureArraySlice(int viewIndex = 0)
		{
			return m_Views[viewIndex].textureArraySlice;
		}

		public void StartSinglePass(CommandBuffer cmd)
		{
			if (enabled && singlePassEnabled)
			{
				if (viewCount > TextureXR.slices)
				{
					throw new NotImplementedException($"Invalid XR setup for single-pass, trying to render too many views! Max supported: {TextureXR.slices}");
				}
				if (SystemInfo.supportsMultiview)
				{
					cmd.EnableShaderKeyword("STEREO_MULTIVIEW_ON");
					return;
				}
				cmd.EnableShaderKeyword("STEREO_INSTANCING_ON");
				cmd.SetInstanceMultiplier((uint)viewCount);
			}
		}

		public void StopSinglePass(CommandBuffer cmd)
		{
			if (enabled && singlePassEnabled)
			{
				if (SystemInfo.supportsMultiview)
				{
					cmd.DisableShaderKeyword("STEREO_MULTIVIEW_ON");
					return;
				}
				cmd.DisableShaderKeyword("STEREO_INSTANCING_ON");
				cmd.SetInstanceMultiplier(1u);
			}
		}

		public void RenderOcclusionMesh(CommandBuffer cmd, bool renderIntoTexture = false)
		{
			if (occlusionMeshScale > 0f)
			{
				m_OcclusionMesh.RenderOcclusionMesh(cmd, occlusionMeshScale, renderIntoTexture);
			}
		}

		public Vector4 ApplyXRViewCenterOffset(Vector2 center)
		{
			Vector4 zero = Vector4.zero;
			float num = 0.5f - center.x;
			float num2 = 0.5f - center.y;
			zero.x = m_Views[0].eyeCenterUV.x - num;
			zero.y = m_Views[0].eyeCenterUV.y - num2;
			if (singlePassEnabled)
			{
				zero.z = m_Views[1].eyeCenterUV.x - num;
				zero.w = m_Views[1].eyeCenterUV.y - num2;
			}
			return zero;
		}

		internal void AssignView(int viewId, XRView xrView)
		{
			if (viewId < 0 || viewId >= m_Views.Count)
			{
				throw new ArgumentOutOfRangeException("viewId");
			}
			m_Views[viewId] = xrView;
		}

		internal void AssignCullingParams(int cullingPassId, ScriptableCullingParameters cullingParams)
		{
			cullingParams.cullingOptions &= ~CullingOptions.Stereo;
			this.cullingPassId = cullingPassId;
			this.cullingParams = cullingParams;
		}

		internal void UpdateCombinedOcclusionMesh()
		{
			m_OcclusionMesh.UpdateCombinedMesh();
		}

		public void InitBase(XRPassCreateInfo createInfo)
		{
			m_Views.Clear();
			copyDepth = createInfo.copyDepth;
			multipassId = createInfo.multipassId;
			AssignCullingParams(createInfo.cullingPassId, createInfo.cullingParameters);
			renderTarget = new RenderTargetIdentifier(createInfo.renderTarget, 0, CubemapFace.Unknown, -1);
			renderTargetDesc = createInfo.renderTargetDesc;
			m_OcclusionMesh.SetMaterial(createInfo.occlusionMeshMaterial);
			occlusionMeshScale = createInfo.occlusionMeshScale;
			foveatedRenderingInfo = createInfo.foveatedRenderingInfo;
		}

		internal void AddView(XRView xrView)
		{
			if (m_Views.Count < TextureXR.slices)
			{
				m_Views.Add(xrView);
				return;
			}
			throw new NotImplementedException($"Invalid XR setup for single-pass, trying to add too many views! Max supported: {TextureXR.slices}");
		}
	}
	public static class XRSystem
	{
		private static XRLayout s_Layout = new XRLayout();

		private static Func<XRPassCreateInfo, XRPass> s_PassAllocator = null;

		private static MSAASamples s_MSAASamples = MSAASamples.None;

		private static Material s_OcclusionMeshMaterial;

		private static Material s_MirrorViewMaterial;

		private static Action<XRLayout, Camera> s_LayoutOverride = null;

		public static readonly XRPass emptyPass = new XRPass();

		public static bool displayActive => false;

		public static bool isHDRDisplayOutputActive => false;

		public static bool singlePassAllowed { get; set; } = true;

		public static FoveatedRenderingCaps foveatedRenderingCaps { get; set; }

		public static bool dumpDebugInfo { get; set; } = false;

		public static void Initialize(Func<XRPassCreateInfo, XRPass> passAllocator, Shader occlusionMeshPS, Shader mirrorViewPS)
		{
			if (passAllocator == null)
			{
				throw new ArgumentNullException("passCreator");
			}
			s_PassAllocator = passAllocator;
			RefreshDeviceInfo();
			foveatedRenderingCaps = SystemInfo.foveatedRenderingCaps;
			if (occlusionMeshPS != null && s_OcclusionMeshMaterial == null)
			{
				s_OcclusionMeshMaterial = CoreUtils.CreateEngineMaterial(occlusionMeshPS);
			}
			if (mirrorViewPS != null && s_MirrorViewMaterial == null)
			{
				s_MirrorViewMaterial = CoreUtils.CreateEngineMaterial(mirrorViewPS);
			}
			if (XRGraphicsAutomatedTests.enabled)
			{
				SetLayoutOverride(XRGraphicsAutomatedTests.OverrideLayout);
			}
		}

		public static void SetDisplayMSAASamples(MSAASamples msaaSamples)
		{
			if (s_MSAASamples != msaaSamples)
			{
				s_MSAASamples = msaaSamples;
			}
		}

		public static MSAASamples GetDisplayMSAASamples()
		{
			return s_MSAASamples;
		}

		public static void SetRenderScale(float renderScale)
		{
		}

		public static XRLayout NewLayout()
		{
			RefreshDeviceInfo();
			if (s_Layout.GetActivePasses().Count > 0)
			{
				Debug.LogWarning("Render Pipeline error : the XR layout still contains active passes. Executing XRSystem.EndLayout() right now.");
				EndLayout();
			}
			return s_Layout;
		}

		public static void EndLayout()
		{
			if (dumpDebugInfo)
			{
				s_Layout.LogDebugInfo();
			}
			s_Layout.Clear();
		}

		public static void RenderMirrorView(CommandBuffer cmd, Camera camera)
		{
		}

		public static void Dispose()
		{
			if (s_OcclusionMeshMaterial != null)
			{
				CoreUtils.Destroy(s_OcclusionMeshMaterial);
				s_OcclusionMeshMaterial = null;
			}
			if (s_MirrorViewMaterial != null)
			{
				CoreUtils.Destroy(s_MirrorViewMaterial);
				s_MirrorViewMaterial = null;
			}
		}

		internal static void SetDisplayZRange(float zNear, float zFar)
		{
		}

		private static void SetLayoutOverride(Action<XRLayout, Camera> action)
		{
			s_LayoutOverride = action;
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSplashScreen)]
		private static void XRSystemInit()
		{
			if (GraphicsSettings.currentRenderPipeline != null)
			{
				RefreshDeviceInfo();
			}
		}

		private static void RefreshDeviceInfo()
		{
		}

		internal static void CreateDefaultLayout(Camera camera)
		{
		}

		internal static void ReconfigurePass(XRPass xrPass, Camera camera)
		{
		}
	}
	internal readonly struct XRView
	{
		internal readonly Matrix4x4 projMatrix;

		internal readonly Matrix4x4 viewMatrix;

		internal readonly Rect viewport;

		internal readonly Mesh occlusionMesh;

		internal readonly int textureArraySlice;

		internal readonly Vector2 eyeCenterUV;

		internal XRView(Matrix4x4 projMatrix, Matrix4x4 viewMatrix, Rect viewport, Mesh occlusionMesh, int textureArraySlice)
		{
			this.projMatrix = projMatrix;
			this.viewMatrix = viewMatrix;
			this.viewport = viewport;
			this.occlusionMesh = occlusionMesh;
			this.textureArraySlice = textureArraySlice;
			eyeCenterUV = ComputeEyeCenterUV(projMatrix);
		}

		private static Vector2 ComputeEyeCenterUV(Matrix4x4 proj)
		{
			FrustumPlanes decomposeProjection = proj.decomposeProjection;
			float num = Math.Abs(decomposeProjection.left);
			float num2 = Math.Abs(decomposeProjection.right);
			float num3 = Math.Abs(decomposeProjection.top);
			float num4 = Math.Abs(decomposeProjection.bottom);
			return new Vector2(num / (num2 + num), num3 / (num3 + num4));
		}
	}
}
namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
	[Flags]
	public enum DepthAccess
	{
		Read = 1,
		Write = 2,
		ReadWrite = 3
	}
	public class RenderGraphContext
	{
		public ScriptableRenderContext renderContext;

		public CommandBuffer cmd;

		public RenderGraphObjectPool renderGraphPool;

		public RenderGraphDefaultResources defaultResources;
	}
	public struct RenderGraphParameters
	{
		public string executionName;

		public int currentFrameIndex;

		public bool rendererListCulling;

		public ScriptableRenderContext scriptableRenderContext;

		public CommandBuffer commandBuffer;
	}
	public struct RenderGraphExecution : IDisposable
	{
		private RenderGraph renderGraph;

		internal RenderGraphExecution(RenderGraph renderGraph)
		{
			this.renderGraph = renderGraph;
		}

		public void Dispose()
		{
			renderGraph.Execute();
		}
	}
	internal class RenderGraphDebugParams
	{
		private static class Strings
		{
			public static readonly DebugUI.Widget.NameAndTooltip ClearRenderTargetsAtCreation = new DebugUI.Widget.NameAndTooltip
			{
				name = "Clear Render Targets At Creation",
				tooltip = "Enable to clear all render textures before any rendergraph passes to check if some clears are missing."
			};

			public static readonly DebugUI.Widget.NameAndTooltip DisablePassCulling = new DebugUI.Widget.NameAndTooltip
			{
				name = "Disable Pass Culling",
				tooltip = "Enable to temporarily disable culling to asses if a pass is culled."
			};

			public static readonly DebugUI.Widget.NameAndTooltip ImmediateMode = new DebugUI.Widget.NameAndTooltip
			{
				name = "Immediate Mode",
				tooltip = "Enable to force render graph to execute all passes in the order you registered them."
			};

			public static readonly DebugUI.Widget.NameAndTooltip EnableLogging = new DebugUI.Widget.NameAndTooltip
			{
				name = "Enable Logging",
				tooltip = "Enable to allow HDRP to capture information in the log."
			};

			public static readonly DebugUI.Widget.NameAndTooltip LogFrameInformation = new DebugUI.Widget.NameAndTooltip
			{
				name = "Log Frame Information",
				tooltip = "Enable to log information output from each frame."
			};

			public static readonly DebugUI.Widget.NameAndTooltip LogResources = new DebugUI.Widget.NameAndTooltip
			{
				name = "Log Resources",
				tooltip = "Enable to log the current render graph's global resource usage."
			};
		}

		private DebugUI.Widget[] m_DebugItems;

		private DebugUI.Panel m_DebugPanel;

		public bool clearRenderTargetsAtCreation;

		public bool clearRenderTargetsAtRelease;

		public bool disablePassCulling;

		public bool immediateMode;

		public bool enableLogging;

		public bool logFrameInformation;

		public bool logResources;

		public void RegisterDebug(string name, DebugUI.Panel debugPanel = null)
		{
			List<DebugUI.Widget> list = new List<DebugUI.Widget>();
			list.Add(new DebugUI.Container
			{
				displayName = name + " Render Graph",
				children = 
				{
					(DebugUI.Widget)new DebugUI.BoolField
					{
						nameAndTooltip = Strings.ClearRenderTargetsAtCreation,
						getter = () => clearRenderTargetsAtCreation,
						setter = delegate(bool value)
						{
							clearRenderTargetsAtCreation = value;
						}
					},
					(DebugUI.Widget)new DebugUI.BoolField
					{
						nameAndTooltip = Strings.DisablePassCulling,
						getter = () => disablePassCulling,
						setter = delegate(bool value)
						{
							disablePassCulling = value;
						}
					},
					(DebugUI.Widget)new DebugUI.BoolField
					{
						nameAndTooltip = Strings.ImmediateMode,
						getter = () => immediateMode,
						setter = delegate(bool value)
						{
							immediateMode = value;
						}
					},
					(DebugUI.Widget)new DebugUI.BoolField
					{
						nameAndTooltip = Strings.EnableLogging,
						getter = () => enableLogging,
						setter = delegate(bool value)
						{
							enableLogging = value;
						}
					},
					(DebugUI.Widget)new DebugUI.Button
					{
						nameAndTooltip = Strings.LogFrameInformation,
						action = delegate
						{
							if (!enableLogging)
							{
								Debug.Log("You must first enable logging before this logging frame information.");
							}
							logFrameInformation = true;
						}
					},
					(DebugUI.Widget)new DebugUI.Button
					{
						nameAndTooltip = Strings.LogResources,
						action = delegate
						{
							if (!enableLogging)
							{
								Debug.Log("You must first enable logging before this logging resources.");
							}
							logResources = true;
						}
					}
				}
			});
			m_DebugItems = list.ToArray();
			m_DebugPanel = ((debugPanel != null) ? debugPanel : DebugManager.instance.GetPanel((name.Length == 0) ? "Render Graph" : name, createIfNull: true));
			m_DebugPanel.children.Add(m_DebugItems);
		}

		public void UnRegisterDebug(string name)
		{
			m_DebugPanel.children.Remove(m_DebugItems);
			m_DebugPanel = null;
			m_DebugItems = null;
		}
	}
	public delegate void RenderFunc<PassData>(PassData data, RenderGraphContext renderGraphContext) where PassData : class, new();
	internal class RenderGraphDebugData
	{
		[DebuggerDisplay("PassDebug: {name}")]
		public struct PassDebugData
		{
			public string name;

			public List<int>[] resourceReadLists;

			public List<int>[] resourceWriteLists;

			public bool culled;

			public bool async;

			public int syncToPassIndex;

			public int syncFromPassIndex;

			public bool generateDebugData;
		}

		[DebuggerDisplay("ResourceDebug: {name} [{creationPassIndex}:{releasePassIndex}]")]
		public struct ResourceDebugData
		{
			public string name;

			public bool imported;

			public int creationPassIndex;

			public int releasePassIndex;

			public List<int> consumerList;

			public List<int> producerList;
		}

		public List<PassDebugData> passList = new List<PassDebugData>();

		public List<ResourceDebugData>[] resourceLists = new List<ResourceDebugData>[2];

		public void Clear()
		{
			passList.Clear();
			if (resourceLists[0] == null)
			{
				for (int i = 0; i < 2; i++)
				{
					resourceLists[i] = new List<ResourceDebugData>();
				}
			}
			for (int j = 0; j < 2; j++)
			{
				resourceLists[j].Clear();
			}
		}
	}
	public class RenderGraph
	{
		internal struct CompiledResourceInfo
		{
			public List<int> producers;

			public List<int> consumers;

			public int refCount;

			public bool imported;

			public void Reset()
			{
				if (producers == null)
				{
					producers = new List<int>();
				}
				if (consumers == null)
				{
					consumers = new List<int>();
				}
				producers.Clear();
				consumers.Clear();
				refCount = 0;
				imported = false;
			}
		}

		[DebuggerDisplay("RenderPass: {pass.name} (Index:{pass.index} Async:{enableAsyncCompute})")]
		internal struct CompiledPassInfo
		{
			public RenderGraphPass pass;

			public List<int>[] resourceCreateList;

			public List<int>[] resourceReleaseList;

			public int refCount;

			public bool culled;

			public bool culledByRendererList;

			public bool hasSideEffect;

			public int syncToPassIndex;

			public int syncFromPassIndex;

			public bool needGraphicsFence;

			public GraphicsFence fence;

			public bool enableAsyncCompute;

			public bool allowPassCulling => pass.allowPassCulling;

			public void Reset(RenderGraphPass pass)
			{
				this.pass = pass;
				enableAsyncCompute = pass.enableAsyncCompute;
				if (resourceCreateList == null)
				{
					resourceCreateList = new List<int>[2];
					resourceReleaseList = new List<int>[2];
					for (int i = 0; i < 2; i++)
					{
						resourceCreateList[i] = new List<int>();
						resourceReleaseList[i] = new List<int>();
					}
				}
				for (int j = 0; j < 2; j++)
				{
					resourceCreateList[j].Clear();
					resourceReleaseList[j].Clear();
				}
				refCount = 0;
				culled = false;
				culledByRendererList = false;
				hasSideEffect = false;
				syncToPassIndex = -1;
				syncFromPassIndex = -1;
				needGraphicsFence = false;
			}
		}

		private class ProfilingScopePassData
		{
			public ProfilingSampler sampler;
		}

		internal delegate void OnGraphRegisteredDelegate(RenderGraph graph);

		internal delegate void OnExecutionRegisteredDelegate(RenderGraph graph, string executionName);

		public static readonly int kMaxMRTCount = 8;

		private RenderGraphResourceRegistry m_Resources;

		private RenderGraphObjectPool m_RenderGraphPool = new RenderGraphObjectPool();

		private List<RenderGraphPass> m_RenderPasses = new List<RenderGraphPass>(64);

		private List<RendererListHandle> m_RendererLists = new List<RendererListHandle>(32);

		private RenderGraphDebugParams m_DebugParameters = new RenderGraphDebugParams();

		private RenderGraphLogger m_FrameInformationLogger = new RenderGraphLogger();

		private RenderGraphDefaultResources m_DefaultResources = new RenderGraphDefaultResources();

		private Dictionary<int, ProfilingSampler> m_DefaultProfilingSamplers = new Dictionary<int, ProfilingSampler>();

		private bool m_ExecutionExceptionWasRaised;

		private RenderGraphContext m_RenderGraphContext = new RenderGraphContext();

		private CommandBuffer m_PreviousCommandBuffer;

		private int m_CurrentImmediatePassIndex;

		private List<int>[] m_ImmediateModeResourceList = new List<int>[2];

		private DynamicArray<CompiledResourceInfo>[] m_CompiledResourcesInfos = new DynamicArray<CompiledResourceInfo>[2];

		private DynamicArray<CompiledPassInfo> m_CompiledPassInfos = new DynamicArray<CompiledPassInfo>();

		private Stack<int> m_CullingStack = new Stack<int>();

		private int m_ExecutionCount;

		private int m_CurrentFrameIndex;

		private bool m_HasRenderGraphBegun;

		private string m_CurrentExecutionName;

		private bool m_RendererListCulling;

		private Dictionary<string, RenderGraphDebugData> m_DebugData = new Dictionary<string, RenderGraphDebugData>();

		private static List<RenderGraph> s_RegisteredGraphs = new List<RenderGraph>();

		public string name { get; private set; } = "RenderGraph";

		internal static bool requireDebugData { get; set; } = false;

		public RenderGraphDefaultResources defaultResources => m_DefaultResources;

		internal static event OnGraphRegisteredDelegate onGraphRegistered;

		internal static event OnGraphRegisteredDelegate onGraphUnregistered;

		internal static event OnExecutionRegisteredDelegate onExecutionRegistered;

		internal static event OnExecutionRegisteredDelegate onExecutionUnregistered;

		public RenderGraph(string name = "RenderGraph")
		{
			this.name = name;
			m_Resources = new RenderGraphResourceRegistry(m_DebugParameters, m_FrameInformationLogger);
			for (int i = 0; i < 2; i++)
			{
				m_CompiledResourcesInfos[i] = new DynamicArray<CompiledResourceInfo>();
			}
			s_RegisteredGraphs.Add(this);
			RenderGraph.onGraphRegistered?.Invoke(this);
		}

		public void Cleanup()
		{
			m_Resources.Cleanup();
			m_DefaultResources.Cleanup();
			m_RenderGraphPool.Cleanup();
			s_RegisteredGraphs.Remove(this);
			RenderGraph.onGraphUnregistered?.Invoke(this);
		}

		public void RegisterDebug(DebugUI.Panel panel = null)
		{
			m_DebugParameters.RegisterDebug(name, panel);
		}

		public void UnRegisterDebug()
		{
			m_DebugParameters.UnRegisterDebug(name);
		}

		public static List<RenderGraph> GetRegisteredRenderGraphs()
		{
			return s_RegisteredGraphs;
		}

		internal RenderGraphDebugData GetDebugData(string executionName)
		{
			if (m_DebugData.TryGetValue(executionName, out var value))
			{
				return value;
			}
			return null;
		}

		public void EndFrame()
		{
			m_Resources.PurgeUnusedGraphicsResources();
			if (m_DebugParameters.logFrameInformation)
			{
				Debug.Log(m_FrameInformationLogger.GetAllLogs());
				m_DebugParameters.logFrameInformation = false;
			}
			if (m_DebugParameters.logResources)
			{
				m_Resources.FlushLogs();
				m_DebugParameters.logResources = false;
			}
		}

		public TextureHandle ImportTexture(RTHandle rt)
		{
			return m_Resources.ImportTexture(rt);
		}

		public TextureHandle ImportBackbuffer(RenderTargetIdentifier rt)
		{
			return m_Resources.ImportBackbuffer(rt);
		}

		public TextureHandle CreateTexture(in TextureDesc desc)
		{
			return m_Resources.CreateTexture(in desc);
		}

		public TextureHandle CreateSharedTexture(in TextureDesc desc, bool explicitRelease = false)
		{
			if (m_HasRenderGraphBegun)
			{
				throw new InvalidOperationException("A shared texture can only be created outside of render graph execution.");
			}
			return m_Resources.CreateSharedTexture(in desc, explicitRelease);
		}

		public void RefreshSharedTextureDesc(TextureHandle handle, in TextureDesc desc)
		{
			m_Resources.RefreshSharedTextureDesc(handle, in desc);
		}

		public void ReleaseSharedTexture(TextureHandle texture)
		{
			if (m_HasRenderGraphBegun)
			{
				throw new InvalidOperationException("A shared texture can only be release outside of render graph execution.");
			}
			m_Resources.ReleaseSharedTexture(texture);
		}

		public TextureHandle CreateTexture(TextureHandle texture)
		{
			return m_Resources.CreateTexture(m_Resources.GetTextureResourceDesc(in texture.handle));
		}

		public void CreateTextureIfInvalid(in TextureDesc desc, ref TextureHandle texture)
		{
			if (!texture.IsValid())
			{
				texture = m_Resources.CreateTexture(in desc);
			}
		}

		public TextureDesc GetTextureDesc(TextureHandle texture)
		{
			return m_Resources.GetTextureResourceDesc(in texture.handle);
		}

		public RendererListHandle CreateRendererList(in RendererListDesc desc)
		{
			return m_Resources.CreateRendererList(in desc);
		}

		public ComputeBufferHandle ImportComputeBuffer(ComputeBuffer computeBuffer)
		{
			return m_Resources.ImportComputeBuffer(computeBuffer);
		}

		public ComputeBufferHandle CreateComputeBuffer(in ComputeBufferDesc desc)
		{
			return m_Resources.CreateComputeBuffer(in desc);
		}

		public ComputeBufferHandle CreateComputeBuffer(in ComputeBufferHandle computeBuffer)
		{
			return m_Resources.CreateComputeBuffer(m_Resources.GetComputeBufferResourceDesc(in computeBuffer.handle));
		}

		public ComputeBufferDesc GetComputeBufferDesc(in ComputeBufferHandle computeBuffer)
		{
			return m_Resources.GetComputeBufferResourceDesc(in computeBuffer.handle);
		}

		public RenderGraphBuilder AddRenderPass<PassData>(string passName, out PassData passData, ProfilingSampler sampler) where PassData : class, new()
		{
			RenderGraphPass<PassData> renderGraphPass = m_RenderGraphPool.Get<RenderGraphPass<PassData>>();
			renderGraphPass.Initialize(m_RenderPasses.Count, m_RenderGraphPool.Get<PassData>(), passName, sampler);
			passData = renderGraphPass.data;
			m_RenderPasses.Add(renderGraphPass);
			return new RenderGraphBuilder(renderGraphPass, m_Resources, this);
		}

		public RenderGraphBuilder AddRenderPass<PassData>(string passName, out PassData passData) where PassData : class, new()
		{
			return AddRenderPass<PassData>(passName, out passData, GetDefaultProfilingSampler(passName));
		}

		public RenderGraphExecution RecordAndExecute(in RenderGraphParameters parameters)
		{
			m_CurrentFrameIndex = parameters.currentFrameIndex;
			m_CurrentExecutionName = ((parameters.executionName != null) ? parameters.executionName : "RenderGraphExecution");
			m_HasRenderGraphBegun = true;
			m_RendererListCulling = parameters.rendererListCulling;
			m_Resources.BeginRenderGraph(m_ExecutionCount++);
			if (m_DebugParameters.enableLogging)
			{
				m_FrameInformationLogger.Initialize(m_CurrentExecutionName);
			}
			m_DefaultResources.InitializeForRendering(this);
			m_RenderGraphContext.cmd = parameters.commandBuffer;
			m_RenderGraphContext.renderContext = parameters.scriptableRenderContext;
			m_RenderGraphContext.renderGraphPool = m_RenderGraphPool;
			m_RenderGraphContext.defaultResources = m_DefaultResources;
			if (m_DebugParameters.immediateMode)
			{
				LogFrameInformation();
				m_CompiledPassInfos.Resize(m_CompiledPassInfos.capacity);
				m_CurrentImmediatePassIndex = 0;
				for (int i = 0; i < 2; i++)
				{
					if (m_ImmediateModeResourceList[i] == null)
					{
						m_ImmediateModeResourceList[i] = new List<int>();
					}
					m_ImmediateModeResourceList[i].Clear();
				}
				m_Resources.BeginExecute(m_CurrentFrameIndex);
			}
			return new RenderGraphExecution(this);
		}

		internal void Execute()
		{
			m_ExecutionExceptionWasRaised = false;
			try
			{
				if (m_RenderGraphContext.cmd == null)
				{
					throw new InvalidOperationException("RenderGraph.RecordAndExecute was not called before executing the render graph.");
				}
				if (!m_DebugParameters.immediateMode)
				{
					LogFrameInformation();
					CompileRenderGraph();
					m_Resources.BeginExecute(m_CurrentFrameIndex);
					ExecuteRenderGraph();
				}
			}
			catch (Exception exception)
			{
				Debug.LogError("Render Graph Execution error");
				if (!m_ExecutionExceptionWasRaised)
				{
					Debug.LogException(exception);
				}
				m_ExecutionExceptionWasRaised = true;
			}
			finally
			{
				GenerateDebugData();
				if (m_DebugParameters.immediateMode)
				{
					ReleaseImmediateModeResources();
				}
				ClearCompiledGraph();
				m_Resources.EndExecute();
				InvalidateContext();
				m_HasRenderGraphBegun = false;
			}
		}

		public void BeginProfilingSampler(ProfilingSampler sampler)
		{
			ProfilingScopePassData passData;
			using RenderGraphBuilder renderGraphBuilder = AddRenderPass<ProfilingScopePassData>("BeginProfile", out passData, null);
			passData.sampler = sampler;
			renderGraphBuilder.AllowPassCulling(value: false);
			renderGraphBuilder.GenerateDebugData(value: false);
			renderGraphBuilder.SetRenderFunc(delegate(ProfilingScopePassData data, RenderGraphContext ctx)
			{
				data.sampler.Begin(ctx.cmd);
			});
		}

		public void EndProfilingSampler(ProfilingSampler sampler)
		{
			ProfilingScopePassData passData;
			using RenderGraphBuilder renderGraphBuilder = AddRenderPass<ProfilingScopePassData>("EndProfile", out passData, null);
			passData.sampler = sampler;
			renderGraphBuilder.AllowPassCulling(value: false);
			renderGraphBuilder.GenerateDebugData(value: false);
			renderGraphBuilder.SetRenderFunc(delegate(ProfilingScopePassData data, RenderGraphContext ctx)
			{
				data.sampler.End(ctx.cmd);
			});
		}

		internal DynamicArray<CompiledPassInfo> GetCompiledPassInfos()
		{
			return m_CompiledPassInfos;
		}

		internal void ClearCompiledGraph()
		{
			ClearRenderPasses();
			m_Resources.Clear(m_ExecutionExceptionWasRaised);
			m_RendererLists.Clear();
			for (int i = 0; i < 2; i++)
			{
				m_CompiledResourcesInfos[i].Clear();
			}
			m_CompiledPassInfos.Clear();
		}

		private void InvalidateContext()
		{
			m_RenderGraphContext.cmd = null;
			m_RenderGraphContext.renderGraphPool = null;
			m_RenderGraphContext.defaultResources = null;
		}

		internal void OnPassAdded(RenderGraphPass pass)
		{
			if (m_DebugParameters.immediateMode)
			{
				ExecutePassImmediatly(pass);
			}
		}

		private void InitResourceInfosData(DynamicArray<CompiledResourceInfo> resourceInfos, int count)
		{
			resourceInfos.Resize(count);
			for (int i = 0; i < resourceInfos.size; i++)
			{
				resourceInfos[i].Reset();
			}
		}

		private void InitializeCompilationData()
		{
			InitResourceInfosData(m_CompiledResourcesInfos[0], m_Resources.GetTextureResourceCount());
			InitResourceInfosData(m_CompiledResourcesInfos[1], m_Resources.GetComputeBufferResourceCount());
			m_CompiledPassInfos.Resize(m_RenderPasses.Count);
			for (int i = 0; i < m_CompiledPassInfos.size; i++)
			{
				m_CompiledPassInfos[i].Reset(m_RenderPasses[i]);
			}
		}

		private void CountReferences()
		{
			for (int i = 0; i < m_CompiledPassInfos.size; i++)
			{
				ref CompiledPassInfo reference = ref m_CompiledPassInfos[i];
				for (int j = 0; j < 2; j++)
				{
					foreach (ResourceHandle item in reference.pass.resourceReadLists[j])
					{
						ResourceHandle res = item;
						ref CompiledResourceInfo reference2 = ref m_CompiledResourcesInfos[j][res];
						reference2.imported = m_Resources.IsRenderGraphResourceImported(in res);
						reference2.consumers.Add(i);
						reference2.refCount++;
					}
					foreach (ResourceHandle item2 in reference.pass.resourceWriteLists[j])
					{
						ResourceHandle res2 = item2;
						ref CompiledResourceInfo reference3 = ref m_CompiledResourcesInfos[j][res2];
						reference3.imported = m_Resources.IsRenderGraphResourceImported(in res2);
						reference3.producers.Add(i);
						reference.hasSideEffect = reference3.imported;
						reference.refCount++;
					}
					foreach (ResourceHandle item3 in reference.pass.transientResourceList[j])
					{
						int index = item3;
						ref CompiledResourceInfo reference4 = ref m_CompiledResourcesInfos[j][index];
						reference4.refCount++;
						reference4.consumers.Add(i);
						reference4.producers.Add(i);
					}
				}
			}
		}

		private void CullUnusedPasses()
		{
			if (m_DebugParameters.disablePassCulling)
			{
				if (m_DebugParameters.enableLogging)
				{
					m_FrameInformationLogger.LogLine("- Pass Culling Disabled -\n");
				}
				return;
			}
			for (int i = 0; i < 2; i++)
			{
				DynamicArray<CompiledResourceInfo> dynamicArray = m_CompiledResourcesInfos[i];
				m_CullingStack.Clear();
				for (int j = 0; j < dynamicArray.size; j++)
				{
					if (dynamicArray[j].refCount == 0)
					{
						m_CullingStack.Push(j);
					}
				}
				while (m_CullingStack.Count != 0)
				{
					foreach (int producer in dynamicArray[m_CullingStack.Pop()].producers)
					{
						ref CompiledPassInfo reference = ref m_CompiledPassInfos[producer];
						reference.refCount--;
						if (reference.refCount != 0 || reference.hasSideEffect || !reference.allowPassCulling)
						{
							continue;
						}
						reference.culled = true;
						foreach (ResourceHandle item in reference.pass.resourceReadLists[i])
						{
							ref CompiledResourceInfo reference2 = ref dynamicArray[item];
							reference2.refCount--;
							if (reference2.refCount == 0)
							{
								m_CullingStack.Push(item);
							}
						}
					}
				}
			}
			LogCulledPasses();
		}

		private void UpdatePassSynchronization(ref CompiledPassInfo currentPassInfo, ref CompiledPassInfo producerPassInfo, int currentPassIndex, int lastProducer, ref int intLastSyncIndex)
		{
			currentPassInfo.syncToPassIndex = lastProducer;
			intLastSyncIndex = lastProducer;
			producerPassInfo.needGraphicsFence = true;
			if (producerPassInfo.syncFromPassIndex == -1)
			{
				producerPassInfo.syncFromPassIndex = currentPassIndex;
			}
		}

		private void UpdateResourceSynchronization(ref int lastGraphicsPipeSync, ref int lastComputePipeSync, int currentPassIndex, in CompiledResourceInfo resource)
		{
			int latestProducerIndex = GetLatestProducerIndex(currentPassIndex, in resource);
			if (latestProducerIndex == -1)
			{
				return;
			}
			ref CompiledPassInfo reference = ref m_CompiledPassInfos[currentPassIndex];
			if (m_CompiledPassInfos[latestProducerIndex].enableAsyncCompute == reference.enableAsyncCompute)
			{
				return;
			}
			if (reference.enableAsyncCompute)
			{
				if (latestProducerIndex > lastGraphicsPipeSync)
				{
					UpdatePassSynchronization(ref reference, ref m_CompiledPassInfos[latestProducerIndex], currentPassIndex, latestProducerIndex, ref lastGraphicsPipeSync);
				}
			}
			else if (latestProducerIndex > lastComputePipeSync)
			{
				UpdatePassSynchronization(ref reference, ref m_CompiledPassInfos[latestProducerIndex], currentPassIndex, latestProducerIndex, ref lastComputePipeSync);
			}
		}

		private int GetFirstValidConsumerIndex(int passIndex, in CompiledResourceInfo info)
		{
			foreach (int consumer in info.consumers)
			{
				if (consumer > passIndex && !m_CompiledPassInfos[consumer].culled)
				{
					return consumer;
				}
			}
			return -1;
		}

		private int FindTextureProducer(int consumerPass, in CompiledResourceInfo info, out int index)
		{
			int result = 0;
			for (index = 0; index < info.producers.Count; index++)
			{
				int num = info.producers[index];
				if (!m_CompiledPassInfos[num].culled)
				{
					return num;
				}
				if (num >= consumerPass)
				{
					return result;
				}
				result = num;
			}
			return result;
		}

		private int GetLatestProducerIndex(int passIndex, in CompiledResourceInfo info)
		{
			int result = -1;
			foreach (int producer in info.producers)
			{
				CompiledPassInfo compiledPassInfo = m_CompiledPassInfos[producer];
				if (producer < passIndex && !compiledPassInfo.culled && !compiledPassInfo.culledByRendererList)
				{
					result = producer;
					continue;
				}
				return result;
			}
			return result;
		}

		private int GetLatestValidReadIndex(in CompiledResourceInfo info)
		{
			if (info.consumers.Count == 0)
			{
				return -1;
			}
			List<int> consumers = info.consumers;
			for (int num = consumers.Count - 1; num >= 0; num--)
			{
				if (!m_CompiledPassInfos[consumers[num]].culled)
				{
					return consumers[num];
				}
			}
			return -1;
		}

		private int GetFirstValidWriteIndex(in CompiledResourceInfo info)
		{
			if (info.producers.Count == 0)
			{
				return -1;
			}
			List<int> producers = info.producers;
			for (int i = 0; i < producers.Count; i++)
			{
				if (!m_CompiledPassInfos[producers[i]].culled)
				{
					return producers[i];
				}
			}
			return -1;
		}

		private int GetLatestValidWriteIndex(in CompiledResourceInfo info)
		{
			if (info.producers.Count == 0)
			{
				return -1;
			}
			List<int> producers = info.producers;
			for (int num = producers.Count - 1; num >= 0; num--)
			{
				if (!m_CompiledPassInfos[producers[num]].culled)
				{
					return producers[num];
				}
			}
			return -1;
		}

		private void CreateRendererLists()
		{
			for (int i = 0; i < m_CompiledPassInfos.size; i++)
			{
				ref CompiledPassInfo reference = ref m_CompiledPassInfos[i];
				if (!reference.culled)
				{
					m_RendererLists.AddRange(reference.pass.usedRendererListList);
				}
			}
			m_Resources.CreateRendererLists(m_RendererLists, m_RenderGraphContext.renderContext, m_RendererListCulling);
		}

		internal bool GetImportedFallback(TextureDesc desc, out TextureHandle fallback)
		{
			fallback = TextureHandle.nullHandle;
			if (!desc.bindTextureMS)
			{
				if (desc.depthBufferBits != DepthBits.None)
				{
					fallback = defaultResources.whiteTexture;
				}
				else if (desc.clearColor == Color.black || desc.clearColor == default(Color))
				{
					if (desc.dimension == TextureXR.dimension)
					{
						fallback = defaultResources.blackTextureXR;
					}
					else if (desc.dimension == TextureDimension.Tex3D)
					{
						fallback = defaultResources.blackTexture3DXR;
					}
					else if (desc.dimension == TextureDimension.Tex2D)
					{
						fallback = defaultResources.blackTexture;
					}
				}
				else if (desc.clearColor == Color.white)
				{
					if (desc.dimension == TextureXR.dimension)
					{
						fallback = defaultResources.whiteTextureXR;
					}
					else if (desc.dimension == TextureDimension.Tex2D)
					{
						fallback = defaultResources.whiteTexture;
					}
				}
			}
			return fallback.IsValid();
		}

		private void AllocateCulledPassResources(ref CompiledPassInfo passInfo, int passIndex)
		{
			for (int i = 0; i < 2; i++)
			{
				DynamicArray<CompiledResourceInfo> dynamicArray = m_CompiledResourcesInfos[i];
				foreach (ResourceHandle item in passInfo.pass.resourceWriteLists[i])
				{
					ResourceHandle handle = item;
					ref CompiledResourceInfo reference = ref dynamicArray[handle];
					int firstValidConsumerIndex = GetFirstValidConsumerIndex(passIndex, in reference);
					int index;
					int num = FindTextureProducer(firstValidConsumerIndex, in reference, out index);
					if (firstValidConsumerIndex == -1 || passIndex != num)
					{
						continue;
					}
					if (i == 0)
					{
						TextureResource textureResource = m_Resources.GetTextureResource(in handle);
						if (!textureResource.desc.disableFallBackToImportedTexture && GetImportedFallback(textureResource.desc, out var fallback))
						{
							reference.imported = true;
							textureResource.imported = true;
							textureResource.graphicsResource = m_Resources.GetTexture(in fallback);
							continue;
						}
						textureResource.desc.sizeMode = TextureSizeMode.Explicit;
						textureResource.desc.width = 1;
						textureResource.desc.height = 1;
						textureResource.desc.clearBuffer = true;
					}
					reference.producers[index - 1] = firstValidConsumerIndex;
				}
			}
		}

		private void UpdateResourceAllocationAndSynchronization()
		{
			int lastGraphicsPipeSync = -1;
			int lastComputePipeSync = -1;
			for (int i = 0; i < m_CompiledPassInfos.size; i++)
			{
				ref CompiledPassInfo reference = ref m_CompiledPassInfos[i];
				if (reference.culledByRendererList)
				{
					AllocateCulledPassResources(ref reference, i);
				}
				if (reference.culled)
				{
					continue;
				}
				for (int j = 0; j < 2; j++)
				{
					DynamicArray<CompiledResourceInfo> dynamicArray = m_CompiledResourcesInfos[j];
					foreach (ResourceHandle item in reference.pass.resourceReadLists[j])
					{
						int index = item;
						UpdateResourceSynchronization(ref lastGraphicsPipeSync, ref lastComputePipeSync, i, in dynamicArray[index]);
					}
					foreach (ResourceHandle item2 in reference.pass.resourceWriteLists[j])
					{
						int index2 = item2;
						UpdateResourceSynchronization(ref lastGraphicsPipeSync, ref lastComputePipeSync, i, in dynamicArray[index2]);
					}
				}
			}
			for (int k = 0; k < 2; k++)
			{
				DynamicArray<CompiledResourceInfo> dynamicArray2 = m_CompiledResourcesInfos[k];
				for (int l = 0; l < dynamicArray2.size; l++)
				{
					CompiledResourceInfo info = dynamicArray2[l];
					bool flag = m_Resources.IsRenderGraphResourceShared((RenderGraphResourceType)k, l);
					if (info.imported && !flag)
					{
						continue;
					}
					int firstValidWriteIndex = GetFirstValidWriteIndex(in info);
					if (firstValidWriteIndex != -1)
					{
						m_CompiledPassInfos[firstValidWriteIndex].resourceCreateList[k].Add(l);
					}
					int latestValidReadIndex = GetLatestValidReadIndex(in info);
					int latestValidWriteIndex = GetLatestValidWriteIndex(in info);
					int num = ((firstValidWriteIndex != -1 || info.imported) ? Math.Max(latestValidWriteIndex, latestValidReadIndex) : (-1));
					if (num != -1)
					{
						if (m_CompiledPassInfos[num].enableAsyncCompute)
						{
							int num2 = num;
							int num3 = m_CompiledPassInfos[num2].syncFromPassIndex;
							while (num3 == -1 && num2++ < m_CompiledPassInfos.size - 1)
							{
								if (m_CompiledPassInfos[num2].enableAsyncCompute)
								{
									num3 = m_CompiledPassInfos[num2].syncFromPassIndex;
								}
							}
							if (num2 == m_CompiledPassInfos.size)
							{
								if (!m_CompiledPassInfos[num].hasSideEffect)
								{
									RenderGraphPass renderGraphPass = m_RenderPasses[num];
									string arg = "<unknown>";
									throw new InvalidOperationException($"{(RenderGraphResourceType)k} resource '{arg}' in asynchronous pass '{renderGraphPass.name}' is missing synchronization on the graphics pipeline.");
								}
								num3 = num2;
							}
							int num4 = Math.Max(0, num3 - 1);
							while (m_CompiledPassInfos[num4].culled)
							{
								num4 = Math.Max(0, num4 - 1);
							}
							m_CompiledPassInfos[num4].resourceReleaseList[k].Add(l);
						}
						else
						{
							m_CompiledPassInfos[num].resourceReleaseList[k].Add(l);
						}
					}
					if (flag && (firstValidWriteIndex != -1 || num != -1))
					{
						m_Resources.UpdateSharedResourceLastFrameIndex(k, l);
					}
				}
			}
		}

		private bool AreRendererListsEmpty(List<RendererListHandle> rendererLists)
		{
			foreach (RendererListHandle rendererList2 in rendererLists)
			{
				RendererListHandle handle = rendererList2;
				RendererList rendererList = m_Resources.GetRendererList(in handle);
				if (m_RenderGraphContext.renderContext.QueryRendererListStatus(rendererList) == RendererListStatus.kRendererListPopulated)
				{
					return false;
				}
			}
			if (rendererLists.Count <= 0)
			{
				return false;
			}
			return true;
		}

		private void TryCullPassAtIndex(int passIndex)
		{
			RenderGraphPass pass = m_CompiledPassInfos[passIndex].pass;
			if (!m_CompiledPassInfos[passIndex].culled && pass.allowPassCulling && pass.allowRendererListCulling && !m_CompiledPassInfos[passIndex].hasSideEffect && AreRendererListsEmpty(pass.usedRendererListList))
			{
				m_CompiledPassInfos[passIndex].culled = (m_CompiledPassInfos[passIndex].culledByRendererList = true);
			}
		}

		private void CullRendererLists()
		{
			for (int i = 0; i < m_CompiledPassInfos.size; i++)
			{
				if (!m_CompiledPassInfos[i].culled && !m_CompiledPassInfos[i].hasSideEffect && m_CompiledPassInfos[i].pass.usedRendererListList.Count > 0)
				{
					TryCullPassAtIndex(i);
				}
			}
		}

		internal void CompileRenderGraph()
		{
			using (new ProfilingScope(m_RenderGraphContext.cmd, ProfilingSampler.Get(RenderGraphProfileId.CompileRenderGraph)))
			{
				InitializeCompilationData();
				CountReferences();
				CullUnusedPasses();
				CreateRendererLists();
				if (m_RendererListCulling)
				{
					CullRendererLists();
				}
				UpdateResourceAllocationAndSynchronization();
				LogRendererListsCreation();
			}
		}

		private ref CompiledPassInfo CompilePassImmediatly(RenderGraphPass pass)
		{
			if (m_CurrentImmediatePassIndex >= m_CompiledPassInfos.size)
			{
				m_CompiledPassInfos.Resize(m_CompiledPassInfos.size * 2);
			}
			ref CompiledPassInfo reference = ref m_CompiledPassInfos[m_CurrentImmediatePassIndex++];
			reference.Reset(pass);
			reference.enableAsyncCompute = false;
			for (int i = 0; i < 2; i++)
			{
				foreach (ResourceHandle item in pass.transientResourceList[i])
				{
					reference.resourceCreateList[i].Add(item);
					reference.resourceReleaseList[i].Add(item);
				}
				foreach (ResourceHandle item2 in pass.resourceWriteLists[i])
				{
					ResourceHandle res = item2;
					if (!pass.transientResourceList[i].Contains(res) && !m_Resources.IsGraphicsResourceCreated(in res))
					{
						reference.resourceCreateList[i].Add(res);
						m_ImmediateModeResourceList[i].Add(res);
					}
				}
				foreach (ResourceHandle item3 in pass.resourceReadLists[i])
				{
					_ = item3;
				}
			}
			foreach (RendererListHandle usedRendererList in pass.usedRendererListList)
			{
				RendererListHandle res2 = usedRendererList;
				if (!m_Resources.IsRendererListCreated(in res2))
				{
					m_RendererLists.Add(res2);
				}
			}
			m_Resources.CreateRendererLists(m_RendererLists, m_RenderGraphContext.renderContext);
			m_RendererLists.Clear();
			return ref reference;
		}

		private void ExecutePassImmediatly(RenderGraphPass pass)
		{
			ExecuteCompiledPass(ref CompilePassImmediatly(pass), m_CurrentImmediatePassIndex - 1);
		}

		private void ExecuteCompiledPass(ref CompiledPassInfo passInfo, int passIndex)
		{
			if (passInfo.culled)
			{
				return;
			}
			if (!passInfo.pass.HasRenderFunc())
			{
				throw new InvalidOperationException($"RenderPass {passInfo.pass.name} was not provided with an execute function.");
			}
			try
			{
				using (new ProfilingScope(m_RenderGraphContext.cmd, passInfo.pass.customSampler))
				{
					LogRenderPassBegin(in passInfo);
					using (new RenderGraphLogIndent(m_FrameInformationLogger))
					{
						PreRenderPassExecute(in passInfo, m_RenderGraphContext);
						passInfo.pass.Execute(m_RenderGraphContext);
						PostRenderPassExecute(ref passInfo, m_RenderGraphContext);
					}
				}
			}
			catch (Exception exception)
			{
				m_ExecutionExceptionWasRaised = true;
				Debug.LogError($"Render Graph Execution error at pass {passInfo.pass.name} ({passIndex})");
				Debug.LogException(exception);
				throw;
			}
		}

		private void ExecuteRenderGraph()
		{
			using (new ProfilingScope(m_RenderGraphContext.cmd, ProfilingSampler.Get(RenderGraphProfileId.ExecuteRenderGraph)))
			{
				for (int i = 0; i < m_CompiledPassInfos.size; i++)
				{
					ExecuteCompiledPass(ref m_CompiledPassInfos[i], i);
				}
			}
		}

		private void PreRenderPassSetRenderTargets(in CompiledPassInfo passInfo, RenderGraphContext rgContext)
		{
			RenderGraphPass pass = passInfo.pass;
			if (!pass.depthBuffer.IsValid() && pass.colorBufferMaxIndex == -1)
			{
				return;
			}
			RenderTargetIdentifier[] tempArray = rgContext.renderGraphPool.GetTempArray<RenderTargetIdentifier>(pass.colorBufferMaxIndex + 1);
			TextureHandle[] colorBuffers = pass.colorBuffers;
			if (pass.colorBufferMaxIndex > 0)
			{
				for (int i = 0; i <= pass.colorBufferMaxIndex; i++)
				{
					if (!colorBuffers[i].IsValid())
					{
						throw new InvalidOperationException("MRT setup is invalid. Some indices are not used.");
					}
					tempArray[i] = m_Resources.GetTexture(in colorBuffers[i]);
				}
				if (!pass.depthBuffer.IsValid())
				{
					throw new InvalidOperationException("Setting MRTs without a depth buffer is not supported.");
				}
				CoreUtils.SetRenderTarget(rgContext.cmd, tempArray, m_Resources.GetTexture(pass.depthBuffer));
			}
			else if (pass.depthBuffer.IsValid())
			{
				if (pass.colorBufferMaxIndex > -1)
				{
					CoreUtils.SetRenderTarget(rgContext.cmd, m_Resources.GetTexture(in pass.colorBuffers[0]), m_Resources.GetTexture(pass.depthBuffer));
				}
				else
				{
					CoreUtils.SetRenderTarget(rgContext.cmd, m_Resources.GetTexture(pass.depthBuffer));
				}
			}
			else
			{
				CoreUtils.SetRenderTarget(rgContext.cmd, m_Resources.GetTexture(in pass.colorBuffers[0]));
			}
		}

		private void PreRenderPassExecute(in CompiledPassInfo passInfo, RenderGraphContext rgContext)
		{
			RenderGraphPass pass = passInfo.pass;
			m_PreviousCommandBuffer = rgContext.cmd;
			bool flag = false;
			for (int i = 0; i < 2; i++)
			{
				foreach (int item in passInfo.resourceCreateList[i])
				{
					flag |= m_Resources.CreatePooledResource(rgContext, i, item);
				}
			}
			PreRenderPassSetRenderTargets(in passInfo, rgContext);
			if (passInfo.enableAsyncCompute)
			{
				GraphicsFence fence = default(GraphicsFence);
				if (flag)
				{
					fence = rgContext.cmd.CreateGraphicsFence(GraphicsFenceType.AsyncQueueSynchronisation, SynchronisationStageFlags.AllGPUOperations);
				}
				rgContext.renderContext.ExecuteCommandBuffer(rgContext.cmd);
				rgContext.cmd.Clear();
				CommandBuffer commandBuffer = CommandBufferPool.Get(pass.name);
				commandBuffer.SetExecutionFlags(CommandBufferExecutionFlags.AsyncCompute);
				rgContext.cmd = commandBuffer;
				if (flag)
				{
					rgContext.cmd.WaitOnAsyncGraphicsFence(fence);
				}
			}
			if (passInfo.syncToPassIndex != -1)
			{
				rgContext.cmd.WaitOnAsyncGraphicsFence(m_CompiledPassInfos[passInfo.syncToPassIndex].fence);
			}
		}

		private void PostRenderPassExecute(ref CompiledPassInfo passInfo, RenderGraphContext rgContext)
		{
			if (passInfo.needGraphicsFence)
			{
				passInfo.fence = rgContext.cmd.CreateAsyncGraphicsFence();
			}
			if (passInfo.enableAsyncCompute)
			{
				rgContext.renderContext.ExecuteCommandBufferAsync(rgContext.cmd, ComputeQueueType.Background);
				CommandBufferPool.Release(rgContext.cmd);
				rgContext.cmd = m_PreviousCommandBuffer;
			}
			m_RenderGraphPool.ReleaseAllTempAlloc();
			for (int i = 0; i < 2; i++)
			{
				foreach (int item in passInfo.resourceReleaseList[i])
				{
					m_Resources.ReleasePooledResource(rgContext, i, item);
				}
			}
		}

		private void ClearRenderPasses()
		{
			foreach (RenderGraphPass renderPass in m_RenderPasses)
			{
				renderPass.Release(m_RenderGraphPool);
			}
			m_RenderPasses.Clear();
		}

		private void ReleaseImmediateModeResources()
		{
			for (int i = 0; i < 2; i++)
			{
				foreach (int item in m_ImmediateModeResourceList[i])
				{
					m_Resources.ReleasePooledResource(m_RenderGraphContext, i, item);
				}
			}
		}

		private void LogFrameInformation()
		{
			if (m_DebugParameters.enableLogging)
			{
				m_FrameInformationLogger.LogLine("==== Staring render graph frame for: " + m_CurrentExecutionName + " ====");
				if (!m_DebugParameters.immediateMode)
				{
					m_FrameInformationLogger.LogLine("Number of passes declared: {0}\n", m_RenderPasses.Count);
				}
			}
		}

		private void LogRendererListsCreation()
		{
			if (m_DebugParameters.enableLogging)
			{
				m_FrameInformationLogger.LogLine("Number of renderer lists created: {0}\n", m_RendererLists.Count);
			}
		}

		private void LogRenderPassBegin(in CompiledPassInfo passInfo)
		{
			if (!m_DebugParameters.enableLogging)
			{
				return;
			}
			RenderGraphPass pass = passInfo.pass;
			m_FrameInformationLogger.LogLine("[{0}][{1}] \"{2}\"", pass.index, pass.enableAsyncCompute ? "Compute" : "Graphics", pass.name);
			using (new RenderGraphLogIndent(m_FrameInformationLogger))
			{
				if (passInfo.syncToPassIndex != -1)
				{
					m_FrameInformationLogger.LogLine("Synchronize with [{0}]", passInfo.syncToPassIndex);
				}
			}
		}

		private void LogCulledPasses()
		{
			if (!m_DebugParameters.enableLogging)
			{
				return;
			}
			m_FrameInformationLogger.LogLine("Pass Culling Report:");
			using (new RenderGraphLogIndent(m_FrameInformationLogger))
			{
				for (int i = 0; i < m_CompiledPassInfos.size; i++)
				{
					if (m_CompiledPassInfos[i].culled)
					{
						RenderGraphPass renderGraphPass = m_RenderPasses[i];
						m_FrameInformationLogger.LogLine("[{0}] {1}", renderGraphPass.index, renderGraphPass.name);
					}
				}
				m_FrameInformationLogger.LogLine("\n");
			}
		}

		private ProfilingSampler GetDefaultProfilingSampler(string name)
		{
			int hashCode = name.GetHashCode();
			if (!m_DefaultProfilingSamplers.TryGetValue(hashCode, out var value))
			{
				value = new ProfilingSampler(name);
				m_DefaultProfilingSamplers.Add(hashCode, value);
			}
			return value;
		}

		private void UpdateImportedResourceLifeTime(ref RenderGraphDebugData.ResourceDebugData data, List<int> passList)
		{
			foreach (int pass in passList)
			{
				if (data.creationPassIndex == -1)
				{
					data.creationPassIndex = pass;
				}
				else
				{
					data.creationPassIndex = Math.Min(data.creationPassIndex, pass);
				}
				if (data.releasePassIndex == -1)
				{
					data.releasePassIndex = pass;
				}
				else
				{
					data.releasePassIndex = Math.Max(data.releasePassIndex, pass);
				}
			}
		}

		private void GenerateDebugData()
		{
			if (m_ExecutionExceptionWasRaised)
			{
				return;
			}
			if (!requireDebugData)
			{
				CleanupDebugData();
				return;
			}
			if (!m_DebugData.TryGetValue(m_CurrentExecutionName, out var value))
			{
				RenderGraph.onExecutionRegistered?.Invoke(this, m_CurrentExecutionName);
				value = new RenderGraphDebugData();
				m_DebugData.Add(m_CurrentExecutionName, value);
			}
			value.Clear();
			for (int i = 0; i < 2; i++)
			{
				for (int j = 0; j < m_CompiledResourcesInfos[i].size; j++)
				{
					ref CompiledResourceInfo reference = ref m_CompiledResourcesInfos[i][j];
					RenderGraphDebugData.ResourceDebugData data = new RenderGraphDebugData.ResourceDebugData
					{
						name = m_Resources.GetRenderGraphResourceName((RenderGraphResourceType)i, j),
						imported = m_Resources.IsRenderGraphResourceImported((RenderGraphResourceType)i, j),
						creationPassIndex = -1,
						releasePassIndex = -1,
						consumerList = new List<int>(reference.consumers),
						producerList = new List<int>(reference.producers)
					};
					if (data.imported)
					{
						UpdateImportedResourceLifeTime(ref data, data.consumerList);
						UpdateImportedResourceLifeTime(ref data, data.producerList);
					}
					value.resourceLists[i].Add(data);
				}
			}
			for (int k = 0; k < m_CompiledPassInfos.size; k++)
			{
				ref CompiledPassInfo reference2 = ref m_CompiledPassInfos[k];
				RenderGraphDebugData.PassDebugData item = new RenderGraphDebugData.PassDebugData
				{
					name = reference2.pass.name,
					culled = reference2.culled,
					async = reference2.enableAsyncCompute,
					generateDebugData = reference2.pass.generateDebugData,
					resourceReadLists = new List<int>[2],
					resourceWriteLists = new List<int>[2],
					syncFromPassIndex = reference2.syncFromPassIndex,
					syncToPassIndex = reference2.syncToPassIndex
				};
				for (int l = 0; l < 2; l++)
				{
					item.resourceReadLists[l] = new List<int>();
					item.resourceWriteLists[l] = new List<int>();
					foreach (ResourceHandle item2 in reference2.pass.resourceReadLists[l])
					{
						item.resourceReadLists[l].Add(item2);
					}
					foreach (ResourceHandle item3 in reference2.pass.resourceWriteLists[l])
					{
						item.resourceWriteLists[l].Add(item3);
					}
					foreach (int item4 in reference2.resourceCreateList[l])
					{
						RenderGraphDebugData.ResourceDebugData value2 = value.resourceLists[l][item4];
						if (!value2.imported)
						{
							value2.creationPassIndex = k;
							value.resourceLists[l][item4] = value2;
						}
					}
					foreach (int item5 in reference2.resourceReleaseList[l])
					{
						RenderGraphDebugData.ResourceDebugData value3 = value.resourceLists[l][item5];
						if (!value3.imported)
						{
							value3.releasePassIndex = k;
							value.resourceLists[l][item5] = value3;
						}
					}
				}
				value.passList.Add(item);
			}
		}

		private void CleanupDebugData()
		{
			foreach (KeyValuePair<string, RenderGraphDebugData> debugDatum in m_DebugData)
			{
				RenderGraph.onExecutionUnregistered?.Invoke(this, debugDatum.Key);
			}
			m_DebugData.Clear();
		}
	}
	public struct RenderGraphProfilingScope : IDisposable
	{
		private bool m_Disposed;

		private ProfilingSampler m_Sampler;

		private RenderGraph m_RenderGraph;

		public RenderGraphProfilingScope(RenderGraph renderGraph, ProfilingSampler sampler)
		{
			m_RenderGraph = renderGraph;
			m_Sampler = sampler;
			m_Disposed = false;
			renderGraph.BeginProfilingSampler(sampler);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (!m_Disposed)
			{
				if (disposing)
				{
					m_RenderGraph.EndProfilingSampler(m_Sampler);
				}
				m_Disposed = true;
			}
		}
	}
	public struct RenderGraphBuilder : IDisposable
	{
		private RenderGraphPass m_RenderPass;

		private RenderGraphResourceRegistry m_Resources;

		private RenderGraph m_RenderGraph;

		private bool m_Disposed;

		public TextureHandle UseColorBuffer(in TextureHandle input, int index)
		{
			CheckResource(in input.handle, dontCheckTransientReadWrite: true);
			m_Resources.IncrementWriteCount(in input.handle);
			m_RenderPass.SetColorBuffer(input, index);
			return input;
		}

		public TextureHandle UseDepthBuffer(in TextureHandle input, DepthAccess flags)
		{
			CheckResource(in input.handle, dontCheckTransientReadWrite: true);
			if ((flags & DepthAccess.Write) != 0)
			{
				m_Resources.IncrementWriteCount(in input.handle);
			}
			if ((flags & DepthAccess.Read) != 0 && !m_Resources.IsRenderGraphResourceImported(in input.handle) && m_Resources.TextureNeedsFallback(in input))
			{
				WriteTexture(in input);
			}
			m_RenderPass.SetDepthBuffer(input, flags);
			return input;
		}

		public TextureHandle ReadTexture(in TextureHandle input)
		{
			CheckResource(in input.handle);
			if (!m_Resources.IsRenderGraphResourceImported(in input.handle) && m_Resources.TextureNeedsFallback(in input))
			{
				TextureResource textureResource = m_Resources.GetTextureResource(in input.handle);
				textureResource.desc.clearBuffer = true;
				textureResource.desc.clearColor = Color.black;
				if (m_RenderGraph.GetImportedFallback(textureResource.desc, out var fallback))
				{
					return fallback;
				}
				WriteTexture(in input);
			}
			m_RenderPass.AddResourceRead(in input.handle);
			return input;
		}

		public TextureHandle WriteTexture(in TextureHandle input)
		{
			CheckResource(in input.handle);
			m_Resources.IncrementWriteCount(in input.handle);
			m_RenderPass.AddResourceWrite(in input.handle);
			return input;
		}

		public TextureHandle ReadWriteTexture(in TextureHandle input)
		{
			CheckResource(in input.handle);
			m_Resources.IncrementWriteCount(in input.handle);
			m_RenderPass.AddResourceWrite(in input.handle);
			m_RenderPass.AddResourceRead(in input.handle);
			return input;
		}

		public TextureHandle CreateTransientTexture(in TextureDesc desc)
		{
			TextureHandle result = m_Resources.CreateTexture(in desc, m_RenderPass.index);
			m_RenderPass.AddTransientResource(in result.handle);
			return result;
		}

		public TextureHandle CreateTransientTexture(in TextureHandle texture)
		{
			TextureDesc desc = m_Resources.GetTextureResourceDesc(in texture.handle);
			TextureHandle result = m_Resources.CreateTexture(in desc, m_RenderPass.index);
			m_RenderPass.AddTransientResource(in result.handle);
			return result;
		}

		public RendererListHandle UseRendererList(in RendererListHandle input)
		{
			m_RenderPass.UseRendererList(input);
			return input;
		}

		public ComputeBufferHandle ReadComputeBuffer(in ComputeBufferHandle input)
		{
			CheckResource(in input.handle);
			m_RenderPass.AddResourceRead(in input.handle);
			return input;
		}

		public ComputeBufferHandle WriteComputeBuffer(in ComputeBufferHandle input)
		{
			CheckResource(in input.handle);
			m_RenderPass.AddResourceWrite(in input.handle);
			m_Resources.IncrementWriteCount(in input.handle);
			return input;
		}

		public ComputeBufferHandle CreateTransientComputeBuffer(in ComputeBufferDesc desc)
		{
			ComputeBufferHandle result = m_Resources.CreateComputeBuffer(in desc, m_RenderPass.index);
			m_RenderPass.AddTransientResource(in result.handle);
			return result;
		}

		public ComputeBufferHandle CreateTransientComputeBuffer(in ComputeBufferHandle computebuffer)
		{
			ComputeBufferDesc desc = m_Resources.GetComputeBufferResourceDesc(in computebuffer.handle);
			ComputeBufferHandle result = m_Resources.CreateComputeBuffer(in desc, m_RenderPass.index);
			m_RenderPass.AddTransientResource(in result.handle);
			return result;
		}

		public void SetRenderFunc<PassData>(RenderFunc<PassData> renderFunc) where PassData : class, new()
		{
			((RenderGraphPass<PassData>)m_RenderPass).renderFunc = renderFunc;
		}

		public void EnableAsyncCompute(bool value)
		{
			m_RenderPass.EnableAsyncCompute(value);
		}

		public void AllowPassCulling(bool value)
		{
			m_RenderPass.AllowPassCulling(value);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		public void AllowRendererListCulling(bool value)
		{
			m_RenderPass.AllowRendererListCulling(value);
		}

		public RendererListHandle DependsOn(in RendererListHandle input)
		{
			m_RenderPass.UseRendererList(input);
			return input;
		}

		internal RenderGraphBuilder(RenderGraphPass renderPass, RenderGraphResourceRegistry resources, RenderGraph renderGraph)
		{
			m_RenderPass = renderPass;
			m_Resources = resources;
			m_RenderGraph = renderGraph;
			m_Disposed = false;
		}

		private void Dispose(bool disposing)
		{
			if (!m_Disposed)
			{
				m_RenderGraph.OnPassAdded(m_RenderPass);
				m_Disposed = true;
			}
		}

		private void CheckResource(in ResourceHandle res, bool dontCheckTransientReadWrite = false)
		{
		}

		internal void GenerateDebugData(bool value)
		{
			m_RenderPass.GenerateDebugData(value);
		}
	}
	public class RenderGraphDefaultResources
	{
		private bool m_IsValid;

		private RTHandle m_BlackTexture2D;

		private RTHandle m_WhiteTexture2D;

		private RTHandle m_ShadowTexture2D;

		public TextureHandle blackTexture { get; private set; }

		public TextureHandle whiteTexture { get; private set; }

		public TextureHandle clearTextureXR { get; private set; }

		public TextureHandle magentaTextureXR { get; private set; }

		public TextureHandle blackTextureXR { get; private set; }

		public TextureHandle blackTextureArrayXR { get; private set; }

		public TextureHandle blackUIntTextureXR { get; private set; }

		public TextureHandle blackTexture3DXR { get; private set; }

		public TextureHandle whiteTextureXR { get; private set; }

		public TextureHandle defaultShadowTexture { get; private set; }

		internal RenderGraphDefaultResources()
		{
			m_BlackTexture2D = RTHandles.Alloc(Texture2D.blackTexture);
			m_WhiteTexture2D = RTHandles.Alloc(Texture2D.whiteTexture);
			m_ShadowTexture2D = RTHandles.Alloc(1, 1, 1, DepthBits.Depth32, GraphicsFormat.R8G8B8A8_SRGB, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2D, enableRandomWrite: false, useMipMap: false, autoGenerateMips: true, isShadowMap: true);
		}

		internal void Cleanup()
		{
			m_BlackTexture2D.Release();
			m_WhiteTexture2D.Release();
			m_ShadowTexture2D.Release();
		}

		internal void InitializeForRendering(RenderGraph renderGraph)
		{
			blackTexture = renderGraph.ImportTexture(m_BlackTexture2D);
			whiteTexture = renderGraph.ImportTexture(m_WhiteTexture2D);
			defaultShadowTexture = renderGraph.ImportTexture(m_ShadowTexture2D);
			clearTextureXR = renderGraph.ImportTexture(TextureXR.GetClearTexture());
			magentaTextureXR = renderGraph.ImportTexture(TextureXR.GetMagentaTexture());
			blackTextureXR = renderGraph.ImportTexture(TextureXR.GetBlackTexture());
			blackTextureArrayXR = renderGraph.ImportTexture(TextureXR.GetBlackTextureArray());
			blackUIntTextureXR = renderGraph.ImportTexture(TextureXR.GetBlackUIntTexture());
			blackTexture3DXR = renderGraph.ImportTexture(TextureXR.GetBlackTexture3D());
			whiteTextureXR = renderGraph.ImportTexture(TextureXR.GetWhiteTexture());
		}
	}
	internal struct RenderGraphLogIndent : IDisposable
	{
		private int m_Indentation;

		private RenderGraphLogger m_Logger;

		private bool m_Disposed;

		public RenderGraphLogIndent(RenderGraphLogger logger, int indentation = 1)
		{
			m_Disposed = false;
			m_Indentation = indentation;
			m_Logger = logger;
			m_Logger.IncrementIndentation(m_Indentation);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			Debug.Assert(m_Logger != null, "RenderGraphLogIndent: logger parameter should not be null.");
			if (!m_Disposed)
			{
				if (disposing && m_Logger != null)
				{
					m_Logger.DecrementIndentation(m_Indentation);
				}
				m_Disposed = true;
			}
		}
	}
	internal class RenderGraphLogger
	{
		private Dictionary<string, StringBuilder> m_LogMap = new Dictionary<string, StringBuilder>();

		private StringBuilder m_CurrentBuilder;

		private int m_CurrentIndentation;

		public void Initialize(string logName)
		{
			if (!m_LogMap.TryGetValue(logName, out var value))
			{
				value = new StringBuilder();
				m_LogMap.Add(logName, value);
			}
			m_CurrentBuilder = value;
			m_CurrentBuilder.Clear();
			m_CurrentIndentation = 0;
		}

		public void IncrementIndentation(int value)
		{
			m_CurrentIndentation += Math.Abs(value);
		}

		public void DecrementIndentation(int value)
		{
			m_CurrentIndentation = Math.Max(0, m_CurrentIndentation - Math.Abs(value));
		}

		public void LogLine(string format, params object[] args)
		{
			for (int i = 0; i < m_CurrentIndentation; i++)
			{
				m_CurrentBuilder.Append('\t');
			}
			m_CurrentBuilder.AppendFormat(format, args);
			m_CurrentBuilder.AppendLine();
		}

		public string GetLog(string logName)
		{
			if (m_LogMap.TryGetValue(logName, out var value))
			{
				return value.ToString();
			}
			return "";
		}

		public string GetAllLogs()
		{
			string text = "";
			foreach (KeyValuePair<string, StringBuilder> item in m_LogMap)
			{
				StringBuilder value = item.Value;
				value.AppendLine();
				text += value.ToString();
			}
			return text;
		}
	}
	public sealed class RenderGraphObjectPool
	{
		private abstract class SharedObjectPoolBase
		{
			protected static List<SharedObjectPoolBase> s_AllocatedPools = new List<SharedObjectPoolBase>();

			protected abstract void Clear();

			public static void ClearAll()
			{
				foreach (SharedObjectPoolBase s_AllocatedPool in s_AllocatedPools)
				{
					s_AllocatedPool.Clear();
				}
			}
		}

		private class SharedObjectPool<T> : SharedObjectPoolBase where T : new()
		{
			private Stack<T> m_Pool = new Stack<T>();

			private static readonly Lazy<SharedObjectPool<T>> s_Instance = new Lazy<SharedObjectPool<T>>(AllocatePool);

			public static SharedObjectPool<T> sharedPool => s_Instance.Value;

			public T Get()
			{
				if (m_Pool.Count != 0)
				{
					return m_Pool.Pop();
				}
				return new T();
			}

			public void Release(T value)
			{
				m_Pool.Push(value);
			}

			private static SharedObjectPool<T> AllocatePool()
			{
				SharedObjectPool<T> sharedObjectPool = new SharedObjectPool<T>();
				SharedObjectPoolBase.s_AllocatedPools.Add(sharedObjectPool);
				return sharedObjectPool;
			}

			protected override void Clear()
			{
				m_Pool.Clear();
			}
		}

		private Dictionary<(Type, int), Stack<object>> m_ArrayPool = new Dictionary<(Type, int), Stack<object>>();

		private List<(object, (Type, int))> m_AllocatedArrays = new List<(object, (Type, int))>();

		private List<MaterialPropertyBlock> m_AllocatedMaterialPropertyBlocks = new List<MaterialPropertyBlock>();

		internal RenderGraphObjectPool()
		{
		}

		public T[] GetTempArray<T>(int size)
		{
			if (!m_ArrayPool.TryGetValue((typeof(T), size), out var value))
			{
				value = new Stack<object>();
				m_ArrayPool.Add((typeof(T), size), value);
			}
			T[] array = ((value.Count > 0) ? ((T[])value.Pop()) : new T[size]);
			m_AllocatedArrays.Add((array, (typeof(T), size)));
			return array;
		}

		public MaterialPropertyBlock GetTempMaterialPropertyBlock()
		{
			MaterialPropertyBlock materialPropertyBlock = SharedObjectPool<MaterialPropertyBlock>.sharedPool.Get();
			materialPropertyBlock.Clear();
			m_AllocatedMaterialPropertyBlocks.Add(materialPropertyBlock);
			return materialPropertyBlock;
		}

		internal void ReleaseAllTempAlloc()
		{
			foreach (var allocatedArray in m_AllocatedArrays)
			{
				Debug.Assert(m_ArrayPool.TryGetValue(allocatedArray.Item2, out var value), "Correct stack type should always be allocated.");
				value.Push(allocatedArray.Item1);
			}
			m_AllocatedArrays.Clear();
			foreach (MaterialPropertyBlock allocatedMaterialPropertyBlock in m_AllocatedMaterialPropertyBlocks)
			{
				SharedObjectPool<MaterialPropertyBlock>.sharedPool.Release(allocatedMaterialPropertyBlock);
			}
			m_AllocatedMaterialPropertyBlocks.Clear();
		}

		internal T Get<T>() where T : new()
		{
			return SharedObjectPool<T>.sharedPool.Get();
		}

		internal void Release<T>(T value) where T : new()
		{
			SharedObjectPool<T>.sharedPool.Release(value);
		}

		internal void Cleanup()
		{
			m_AllocatedArrays.Clear();
			m_AllocatedMaterialPropertyBlocks.Clear();
			m_ArrayPool.Clear();
			SharedObjectPoolBase.ClearAll();
		}
	}
	[DebuggerDisplay("RenderPass: {name} (Index:{index} Async:{enableAsyncCompute})")]
	internal abstract class RenderGraphPass
	{
		public List<ResourceHandle>[] resourceReadLists = new List<ResourceHandle>[2];

		public List<ResourceHandle>[] resourceWriteLists = new List<ResourceHandle>[2];

		public List<ResourceHandle>[] transientResourceList = new List<ResourceHandle>[2];

		public List<RendererListHandle> usedRendererListList = new List<RendererListHandle>();

		public string name { get; protected set; }

		public int index { get; protected set; }

		public ProfilingSampler customSampler { get; protected set; }

		public bool enableAsyncCompute { get; protected set; }

		public bool allowPassCulling { get; protected set; }

		public TextureHandle depthBuffer { get; protected set; }

		public TextureHandle[] colorBuffers { get; protected set; } = new TextureHandle[RenderGraph.kMaxMRTCount];

		public int colorBufferMaxIndex { get; protected set; } = -1;

		public int refCount { get; protected set; }

		public bool generateDebugData { get; protected set; }

		public bool allowRendererListCulling { get; protected set; }

		public RenderFunc<PassData> GetExecuteDelegate<PassData>() where PassData : class, new()
		{
			return ((RenderGraphPass<PassData>)this).renderFunc;
		}

		public abstract void Execute(RenderGraphContext renderGraphContext);

		public abstract void Release(RenderGraphObjectPool pool);

		public abstract bool HasRenderFunc();

		public RenderGraphPass()
		{
			for (int i = 0; i < 2; i++)
			{
				resourceReadLists[i] = new List<ResourceHandle>();
				resourceWriteLists[i] = new List<ResourceHandle>();
				transientResourceList[i] = new List<ResourceHandle>();
			}
		}

		public void Clear()
		{
			name = "";
			index = -1;
			customSampler = null;
			for (int i = 0; i < 2; i++)
			{
				resourceReadLists[i].Clear();
				resourceWriteLists[i].Clear();
				transientResourceList[i].Clear();
			}
			usedRendererListList.Clear();
			enableAsyncCompute = false;
			allowPassCulling = true;
			allowRendererListCulling = true;
			generateDebugData = true;
			refCount = 0;
			colorBufferMaxIndex = -1;
			depthBuffer = TextureHandle.nullHandle;
			for (int j = 0; j < RenderGraph.kMaxMRTCount; j++)
			{
				colorBuffers[j] = TextureHandle.nullHandle;
			}
		}

		public void AddResourceWrite(in ResourceHandle res)
		{
			resourceWriteLists[res.iType].Add(res);
		}

		public void AddResourceRead(in ResourceHandle res)
		{
			resourceReadLists[res.iType].Add(res);
		}

		public void AddTransientResource(in ResourceHandle res)
		{
			transientResourceList[res.iType].Add(res);
		}

		public void UseRendererList(RendererListHandle rendererList)
		{
			usedRendererListList.Add(rendererList);
		}

		public void EnableAsyncCompute(bool value)
		{
			enableAsyncCompute = value;
		}

		public void AllowPassCulling(bool value)
		{
			allowPassCulling = value;
		}

		public void AllowRendererListCulling(bool value)
		{
			allowRendererListCulling = value;
		}

		public void GenerateDebugData(bool value)
		{
			generateDebugData = value;
		}

		public void SetColorBuffer(TextureHandle resource, int index)
		{
			Debug.Assert(index < RenderGraph.kMaxMRTCount && index >= 0);
			colorBufferMaxIndex = Math.Max(colorBufferMaxIndex, index);
			colorBuffers[index] = resource;
			AddResourceWrite(in resource.handle);
		}

		public void SetDepthBuffer(TextureHandle resource, DepthAccess flags)
		{
			depthBuffer = resource;
			if ((flags & DepthAccess.Read) != 0)
			{
				AddResourceRead(in resource.handle);
			}
			if ((flags & DepthAccess.Write) != 0)
			{
				AddResourceWrite(in resource.handle);
			}
		}
	}
	[DebuggerDisplay("RenderPass: {name} (Index:{index} Async:{enableAsyncCompute})")]
	internal sealed class RenderGraphPass<PassData> : RenderGraphPass where PassData : class, new()
	{
		internal PassData data;

		internal RenderFunc<PassData> renderFunc;

		public override void Execute(RenderGraphContext renderGraphContext)
		{
			GetExecuteDelegate<PassData>()(data, renderGraphContext);
		}

		public void Initialize(int passIndex, PassData passData, string passName, ProfilingSampler sampler)
		{
			Clear();
			base.index = passIndex;
			data = passData;
			base.name = passName;
			base.customSampler = sampler;
		}

		public override void Release(RenderGraphObjectPool pool)
		{
			Clear();
			pool.Release(data);
			data = null;
			renderFunc = null;
			pool.Release(this);
		}

		public override bool HasRenderFunc()
		{
			return renderFunc != null;
		}
	}
	internal enum RenderGraphProfileId
	{
		CompileRenderGraph,
		ExecuteRenderGraph,
		RenderGraphClear,
		RenderGraphClearDebug
	}
	[DebuggerDisplay("ComputeBuffer ({handle.index})")]
	public struct ComputeBufferHandle
	{
		private static ComputeBufferHandle s_NullHandle;

		internal ResourceHandle handle;

		public static ComputeBufferHandle nullHandle => s_NullHandle;

		internal ComputeBufferHandle(int handle, bool shared = false)
		{
			this.handle = new ResourceHandle(handle, RenderGraphResourceType.ComputeBuffer, shared);
		}

		public static implicit operator ComputeBuffer(ComputeBufferHandle buffer)
		{
			if (!buffer.IsValid())
			{
				return null;
			}
			return RenderGraphResourceRegistry.current.GetComputeBuffer(in buffer);
		}

		public bool IsValid()
		{
			return handle.IsValid();
		}
	}
	public struct ComputeBufferDesc
	{
		public int count;

		public int stride;

		public ComputeBufferType type;

		public string name;

		public ComputeBufferDesc(int count, int stride)
		{
			this = default(ComputeBufferDesc);
			this.count = count;
			this.stride = stride;
			type = ComputeBufferType.Default;
		}

		public ComputeBufferDesc(int count, int stride, ComputeBufferType type)
		{
			this = default(ComputeBufferDesc);
			this.count = count;
			this.stride = stride;
			this.type = type;
		}

		public override int GetHashCode()
		{
			return (int)(((17 * 23 + count) * 23 + stride) * 23 + type);
		}
	}
	[DebuggerDisplay("ComputeBufferResource ({desc.name})")]
	internal class ComputeBufferResource : RenderGraphResource<ComputeBufferDesc, ComputeBuffer>
	{
		public override string GetName()
		{
			if (imported)
			{
				return "ImportedComputeBuffer";
			}
			return desc.name;
		}

		public override void CreatePooledGraphicsResource()
		{
			Debug.Assert(m_Pool != null, "ComputeBufferResource: CreatePooledGraphicsResource should only be called for regular pooled resources");
			int hashCode = desc.GetHashCode();
			if (graphicsResource != null)
			{
				throw new InvalidOperationException($"ComputeBufferResource: Trying to create an already created resource ({GetName()}). Resource was probably declared for writing more than once in the same pass.");
			}
			ComputeBufferPool obj = m_Pool as ComputeBufferPool;
			if (!obj.TryGetResource(hashCode, out graphicsResource))
			{
				CreateGraphicsResource(desc.name);
			}
			cachedHash = hashCode;
			obj.RegisterFrameAllocation(cachedHash, graphicsResource);
			graphicsResource.name = desc.name;
		}

		public override void ReleasePooledGraphicsResource(int frameIndex)
		{
			if (graphicsResource == null)
			{
				throw new InvalidOperationException("ComputeBufferResource: Tried to release a resource (" + GetName() + ") that was never created. Check that there is at least one pass writing to it first.");
			}
			if (m_Pool is ComputeBufferPool computeBufferPool)
			{
				computeBufferPool.ReleaseResource(cachedHash, graphicsResource, frameIndex);
				computeBufferPool.UnregisterFrameAllocation(cachedHash, graphicsResource);
			}
			Reset(null);
		}

		public override void CreateGraphicsResource(string name = "")
		{
			graphicsResource = new ComputeBuffer(desc.count, desc.stride, desc.type);
			graphicsResource.name = ((name == "") ? $"RenderGraphComputeBuffer_{desc.count}_{desc.stride}_{desc.type}" : name);
		}

		public override void ReleaseGraphicsResource()
		{
			if (graphicsResource != null)
			{
				graphicsResource.Release();
			}
			base.ReleaseGraphicsResource();
		}

		public override void LogCreation(RenderGraphLogger logger)
		{
			logger.LogLine("Created ComputeBuffer: " + desc.name);
		}

		public override void LogRelease(RenderGraphLogger logger)
		{
			logger.LogLine("Released ComputeBuffer: " + desc.name);
		}
	}
	internal class ComputeBufferPool : RenderGraphResourcePool<ComputeBuffer>
	{
		protected override void ReleaseInternalResource(ComputeBuffer res)
		{
			res.Release();
		}

		protected override string GetResourceName(ComputeBuffer res)
		{
			return "ComputeBufferNameNotAvailable";
		}

		protected override long GetResourceSize(ComputeBuffer res)
		{
			return res.count * res.stride;
		}

		protected override string GetResourceTypeName()
		{
			return "ComputeBuffer";
		}

		protected override int GetSortIndex(ComputeBuffer res)
		{
			return res.GetHashCode();
		}

		public override void PurgeUnusedResources(int currentFrameIndex)
		{
			RenderGraphResourcePool<ComputeBuffer>.s_CurrentFrameIndex = currentFrameIndex;
			m_RemoveList.Clear();
			foreach (KeyValuePair<int, SortedList<int, (ComputeBuffer, int)>> item in m_ResourcePool)
			{
				SortedList<int, (ComputeBuffer, int)> value = item.Value;
				IList<int> keys = value.Keys;
				IList<(ComputeBuffer, int)> values = value.Values;
				for (int i = 0; i < value.Count; i++)
				{
					(ComputeBuffer, int) tuple = values[i];
					if (RenderGraphResourcePool<ComputeBuffer>.ShouldReleaseResource(tuple.Item2, RenderGraphResourcePool<ComputeBuffer>.s_CurrentFrameIndex))
					{
						tuple.Item1.Release();
						m_RemoveList.Add(keys[i]);
					}
				}
				foreach (int remove in m_RemoveList)
				{
					value.Remove(remove);
				}
			}
		}
	}
	internal abstract class IRenderGraphResourcePool
	{
		public abstract void PurgeUnusedResources(int currentFrameIndex);

		public abstract void Cleanup();

		public abstract void CheckFrameAllocation(bool onException, int frameIndex);

		public abstract void LogResources(RenderGraphLogger logger);
	}
	internal abstract class RenderGraphResourcePool<Type> : IRenderGraphResourcePool where Type : class
	{
		private struct ResourceLogInfo
		{
			public string name;

			public long size;
		}

		protected Dictionary<int, SortedList<int, (Type resource, int frameIndex)>> m_ResourcePool = new Dictionary<int, SortedList<int, (Type, int)>>();

		protected List<int> m_RemoveList = new List<int>(32);

		private List<(int, Type)> m_FrameAllocatedResources = new List<(int, Type)>();

		protected static int s_CurrentFrameIndex;

		private const int kStaleResourceLifetime = 10;

		protected abstract void ReleaseInternalResource(Type res);

		protected abstract string GetResourceName(Type res);

		protected abstract long GetResourceSize(Type res);

		protected abstract string GetResourceTypeName();

		protected abstract int GetSortIndex(Type res);

		public void ReleaseResource(int hash, Type resource, int currentFrameIndex)
		{
			if (!m_ResourcePool.TryGetValue(hash, out SortedList<int, (Type, int)> value))
			{
				value = new SortedList<int, (Type, int)>();
				m_ResourcePool.Add(hash, value);
			}
			value.Add(GetSortIndex(resource), (resource, currentFrameIndex));
		}

		public bool TryGetResource(int hashCode, out Type resource)
		{
			if (m_ResourcePool.TryGetValue(hashCode, out SortedList<int, (Type, int)> value) && value.Count > 0)
			{
				resource = value.Values[value.Count - 1].Item1;
				value.RemoveAt(value.Count - 1);
				return true;
			}
			resource = null;
			return false;
		}

		public override void Cleanup()
		{
			foreach (KeyValuePair<int, SortedList<int, (Type, int)>> item in m_ResourcePool)
			{
				foreach (KeyValuePair<int, (Type, int)> item2 in item.Value)
				{
					ReleaseInternalResource(item2.Value.Item1);
				}
			}
		}

		public void RegisterFrameAllocation(int hash, Type value)
		{
			if (hash != -1)
			{
				m_FrameAllocatedResources.Add((hash, value));
			}
		}

		public void UnregisterFrameAllocation(int hash, Type value)
		{
			if (hash != -1)
			{
				m_FrameAllocatedResources.Remove((hash, value));
			}
		}

		public override void CheckFrameAllocation(bool onException, int frameIndex)
		{
			if (m_FrameAllocatedResources.Count != 0)
			{
				string text = "";
				if (!onException)
				{
					text = "RenderGraph: Not all resources of type " + GetResourceTypeName() + " were released. This can be caused by a resources being allocated but never read by any pass.";
				}
				foreach (var frameAllocatedResource in m_FrameAllocatedResources)
				{
					if (!onException)
					{
						text = text + "\n\t" + GetResourceName(frameAllocatedResource.Item2);
					}
					ReleaseResource(frameAllocatedResource.Item1, frameAllocatedResource.Item2, frameIndex);
				}
				Debug.LogWarning(text);
			}
			m_FrameAllocatedResources.Clear();
		}

		public override void LogResources(RenderGraphLogger logger)
		{
			List<ResourceLogInfo> list = new List<ResourceLogInfo>();
			foreach (KeyValuePair<int, SortedList<int, (Type, int)>> item in m_ResourcePool)
			{
				foreach (KeyValuePair<int, (Type, int)> item2 in item.Value)
				{
					list.Add(new ResourceLogInfo
					{
						name = GetResourceName(item2.Value.Item1),
						size = GetResourceSize(item2.Value.Item1)
					});
				}
			}
			logger.LogLine("== " + GetResourceTypeName() + " Resources ==");
			list.Sort((ResourceLogInfo a, ResourceLogInfo b) => (a.size < b.size) ? 1 : (-1));
			int num = 0;
			float num2 = 0f;
			foreach (ResourceLogInfo item3 in list)
			{
				float num3 = (float)item3.size / 1048576f;
				num2 += num3;
				logger.LogLine($"[{num++:D2}]\t[{num3:0.00} MB]\t{item3.name}");
			}
			logger.LogLine($"\nTotal Size [{num2:0.00}]");
		}

		protected static bool ShouldReleaseResource(int lastUsedFrameIndex, int currentFrameIndex)
		{
			return lastUsedFrameIndex + 10 < currentFrameIndex;
		}
	}
	internal class RenderGraphResourceRegistry
	{
		private delegate bool ResourceCreateCallback(RenderGraphContext rgContext, IRenderGraphResource res);

		private delegate void ResourceCallback(RenderGraphContext rgContext, IRenderGraphResource res);

		private class RenderGraphResourcesData
		{
			public DynamicArray<IRenderGraphResource> resourceArray = new DynamicArray<IRenderGraphResource>();

			public int sharedResourcesCount;

			public IRenderGraphResourcePool pool;

			public ResourceCreateCallback createResourceCallback;

			public ResourceCallback releaseResourceCallback;

			public void Clear(bool onException, int frameIndex)
			{
				resourceArray.Resize(sharedResourcesCount);
				pool.CheckFrameAllocation(onException, frameIndex);
			}

			public void Cleanup()
			{
				for (int i = 0; i < sharedResourcesCount; i++)
				{
					resourceArray[i]?.ReleaseGraphicsResource();
				}
				pool.Cleanup();
			}

			public void PurgeUnusedGraphicsResources(int frameIndex)
			{
				pool.PurgeUnusedResources(frameIndex);
			}

			public int AddNewRenderGraphResource<ResType>(out ResType outRes, bool pooledResource = true) where ResType : IRenderGraphResource, new()
			{
				int size = resourceArray.size;
				resourceArray.Resize(resourceArray.size + 1, keepContent: true);
				if (resourceArray[size] == null)
				{
					resourceArray[size] = new ResType();
				}
				outRes = resourceArray[size] as ResType;
				IRenderGraphResourcePool obj = (pooledResource ? pool : null);
				outRes.Reset(obj);
				return size;
			}
		}

		private const int kSharedResourceLifetime = 30;

		private static RenderGraphResourceRegistry m_CurrentRegistry;

		private RenderGraphResourcesData[] m_RenderGraphResources = new RenderGraphResourcesData[2];

		private DynamicArray<RendererListResource> m_RendererListResources = new DynamicArray<RendererListResource>();

		private RenderGraphDebugParams m_RenderGraphDebug;

		private RenderGraphLogger m_ResourceLogger = new RenderGraphLogger();

		private RenderGraphLogger m_FrameInformationLogger;

		private int m_CurrentFrameIndex;

		private int m_ExecutionCount;

		private RTHandle m_CurrentBackbuffer;

		private const int kInitialRendererListCount = 256;

		private List<RendererList> m_ActiveRendererLists = new List<RendererList>(256);

		internal static RenderGraphResourceRegistry current
		{
			get
			{
				return m_CurrentRegistry;
			}
			set
			{
				m_CurrentRegistry = value;
			}
		}

		internal RTHandle GetTexture(in TextureHandle handle)
		{
			if (!handle.IsValid())
			{
				return null;
			}
			TextureResource textureResource = GetTextureResource(in handle.handle);
			RTHandle graphicsResource = textureResource.graphicsResource;
			if (graphicsResource == null && !textureResource.imported)
			{
				throw new InvalidOperationException("Trying to use a texture (" + textureResource.GetName() + ") that was already released or not yet created. Make sure you declare it for reading in your pass or you don't read it before it's been written to at least once.");
			}
			return graphicsResource;
		}

		internal bool TextureNeedsFallback(in TextureHandle handle)
		{
			if (!handle.IsValid())
			{
				return false;
			}
			return GetTextureResource(in handle.handle).NeedsFallBack();
		}

		internal RendererList GetRendererList(in RendererListHandle handle)
		{
			if (!handle.IsValid() || (int)handle >= m_RendererListResources.size)
			{
				return RendererList.nullRendererList;
			}
			return m_RendererListResources[handle].rendererList;
		}

		internal ComputeBuffer GetComputeBuffer(in ComputeBufferHandle handle)
		{
			if (!handle.IsValid())
			{
				return null;
			}
			return GetComputeBufferResource(in handle.handle).graphicsResource ?? throw new InvalidOperationException("Trying to use a compute buffer ({bufferResource.GetName()}) that was already released or not yet created. Make sure you declare it for reading in your pass or you don't read it before it's been written to at least once.");
		}

		private RenderGraphResourceRegistry()
		{
		}

		internal RenderGraphResourceRegistry(RenderGraphDebugParams renderGraphDebug, RenderGraphLogger frameInformationLogger)
		{
			m_RenderGraphDebug = renderGraphDebug;
			m_FrameInformationLogger = frameInformationLogger;
			for (int i = 0; i < 2; i++)
			{
				m_RenderGraphResources[i] = new RenderGraphResourcesData();
			}
			m_RenderGraphResources[0].createResourceCallback = CreateTextureCallback;
			m_RenderGraphResources[0].releaseResourceCallback = ReleaseTextureCallback;
			m_RenderGraphResources[0].pool = new TexturePool();
			m_RenderGraphResources[1].pool = new ComputeBufferPool();
		}

		internal void BeginRenderGraph(int executionCount)
		{
			m_ExecutionCount = executionCount;
			ResourceHandle.NewFrame(executionCount);
			if (m_RenderGraphDebug.enableLogging)
			{
				m_ResourceLogger.Initialize("RenderGraph Resources");
			}
		}

		internal void BeginExecute(int currentFrameIndex)
		{
			m_CurrentFrameIndex = currentFrameIndex;
			ManageSharedRenderGraphResources();
			current = this;
		}

		internal void EndExecute()
		{
			current = null;
		}

		private void CheckHandleValidity(in ResourceHandle res)
		{
			CheckHandleValidity(res.type, res.index);
		}

		private void CheckHandleValidity(RenderGraphResourceType type, int index)
		{
			DynamicArray<IRenderGraphResource> resourceArray = m_RenderGraphResources[(int)type].resourceArray;
			if (index >= resourceArray.size)
			{
				throw new ArgumentException($"Trying to access resource of type {type} with an invalid resource index {index}");
			}
		}

		internal void IncrementWriteCount(in ResourceHandle res)
		{
			CheckHandleValidity(in res);
			m_RenderGraphResources[res.iType].resourceArray[res.index].IncrementWriteCount();
		}

		internal string GetRenderGraphResourceName(in ResourceHandle res)
		{
			CheckHandleValidity(in res);
			return m_RenderGraphResources[res.iType].resourceArray[res.index].GetName();
		}

		internal string GetRenderGraphResourceName(RenderGraphResourceType type, int index)
		{
			CheckHandleValidity(type, index);
			return m_RenderGraphResources[(int)type].resourceArray[index].GetName();
		}

		internal bool IsRenderGraphResourceImported(in ResourceHandle res)
		{
			CheckHandleValidity(in res);
			return m_RenderGraphResources[res.iType].resourceArray[res.index].imported;
		}

		internal bool IsRenderGraphResourceShared(RenderGraphResourceType type, int index)
		{
			CheckHandleValidity(type, index);
			return index < m_RenderGraphResources[(int)type].sharedResourcesCount;
		}

		internal bool IsGraphicsResourceCreated(in ResourceHandle res)
		{
			CheckHandleValidity(in res);
			return m_RenderGraphResources[res.iType].resourceArray[res.index].IsCreated();
		}

		internal bool IsRendererListCreated(in RendererListHandle res)
		{
			return m_RendererListResources[res].rendererList.isValid;
		}

		internal bool IsRenderGraphResourceImported(RenderGraphResourceType type, int index)
		{
			CheckHandleValidity(type, index);
			return m_RenderGraphResources[(int)type].resourceArray[index].imported;
		}

		internal int GetRenderGraphResourceTransientIndex(in ResourceHandle res)
		{
			CheckHandleValidity(in res);
			return m_RenderGraphResources[res.iType].resourceArray[res.index].transientPassIndex;
		}

		internal TextureHandle ImportTexture(RTHandle rt)
		{
			TextureResource outRes;
			int handle = m_RenderGraphResources[0].AddNewRenderGraphResource<TextureResource>(out outRes);
			outRes.graphicsResource = rt;
			outRes.imported = true;
			return new TextureHandle(handle);
		}

		internal TextureHandle CreateSharedTexture(in TextureDesc desc, bool explicitRelease)
		{
			RenderGraphResourcesData renderGraphResourcesData = m_RenderGraphResources[0];
			int sharedResourcesCount = renderGraphResourcesData.sharedResourcesCount;
			Debug.Assert(renderGraphResourcesData.resourceArray.size <= sharedResourcesCount);
			TextureResource outRes = null;
			int handle = -1;
			for (int i = 0; i < sharedResourcesCount; i++)
			{
				if (!renderGraphResourcesData.resourceArray[i].shared)
				{
					outRes = (TextureResource)renderGraphResourcesData.resourceArray[i];
					handle = i;
					break;
				}
			}
			if (outRes == null)
			{
				handle = m_RenderGraphResources[0].AddNewRenderGraphResource<TextureResource>(out outRes, pooledResource: false);
				renderGraphResourcesData.sharedResourcesCount++;
			}
			outRes.imported = true;
			outRes.shared = true;
			outRes.sharedExplicitRelease = explicitRelease;
			outRes.desc = desc;
			return new TextureHandle(handle, shared: true);
		}

		internal void RefreshSharedTextureDesc(TextureHandle texture, in TextureDesc desc)
		{
			if (!IsRenderGraphResourceShared(RenderGraphResourceType.Texture, texture.handle))
			{
				throw new InvalidOperationException($"Trying to refresh texture {texture} that is not a shared resource.");
			}
			TextureResource textureResource = GetTextureResource(in texture.handle);
			textureResource.ReleaseGraphicsResource();
			textureResource.desc = desc;
		}

		internal void ReleaseSharedTexture(TextureHandle texture)
		{
			RenderGraphResourcesData renderGraphResourcesData = m_RenderGraphResources[0];
			if ((int)texture.handle >= renderGraphResourcesData.sharedResourcesCount)
			{
				throw new InvalidOperationException("Tried to release a non shared texture.");
			}
			if ((int)texture.handle == renderGraphResourcesData.sharedResourcesCount - 1)
			{
				renderGraphResourcesData.sharedResourcesCount--;
			}
			TextureResource textureResource = GetTextureResource(in texture.handle);
			textureResource.ReleaseGraphicsResource();
			textureResource.Reset(null);
		}

		internal TextureHandle ImportBackbuffer(RenderTargetIdentifier rt)
		{
			if (m_CurrentBackbuffer != null)
			{
				m_CurrentBackbuffer.SetTexture(rt);
			}
			else
			{
				m_CurrentBackbuffer = RTHandles.Alloc(rt, "Backbuffer");
			}
			TextureResource outRes;
			int handle = m_RenderGraphResources[0].AddNewRenderGraphResource<TextureResource>(out outRes);
			outRes.graphicsResource = m_CurrentBackbuffer;
			outRes.imported = true;
			return new TextureHandle(handle);
		}

		internal TextureHandle CreateTexture(in TextureDesc desc, int transientPassIndex = -1)
		{
			ValidateTextureDesc(in desc);
			TextureResource outRes;
			int handle = m_RenderGraphResources[0].AddNewRenderGraphResource<TextureResource>(out outRes);
			outRes.desc = desc;
			outRes.transientPassIndex = transientPassIndex;
			outRes.requestFallBack = desc.fallBackToBlackTexture;
			return new TextureHandle(handle);
		}

		internal int GetResourceCount(RenderGraphResourceType type)
		{
			return m_RenderGraphResources[(int)type].resourceArray.size;
		}

		internal int GetTextureResourceCount()
		{
			return GetResourceCount(RenderGraphResourceType.Texture);
		}

		internal TextureResource GetTextureResource(in ResourceHandle handle)
		{
			return m_RenderGraphResources[0].resourceArray[handle] as TextureResource;
		}

		internal TextureDesc GetTextureResourceDesc(in ResourceHandle handle)
		{
			return (m_RenderGraphResources[0].resourceArray[handle] as TextureResource).desc;
		}

		internal RendererListHandle CreateRendererList(in RendererListDesc desc)
		{
			ValidateRendererListDesc(in desc);
			return new RendererListHandle(m_RendererListResources.Add(new RendererListResource(in desc)));
		}

		internal ComputeBufferHandle ImportComputeBuffer(ComputeBuffer computeBuffer)
		{
			ComputeBufferResource outRes;
			int handle = m_RenderGraphResources[1].AddNewRenderGraphResource<ComputeBufferResource>(out outRes);
			outRes.graphicsResource = computeBuffer;
			outRes.imported = true;
			return new ComputeBufferHandle(handle);
		}

		internal ComputeBufferHandle CreateComputeBuffer(in ComputeBufferDesc desc, int transientPassIndex = -1)
		{
			ValidateComputeBufferDesc(in desc);
			ComputeBufferResource outRes;
			int handle = m_RenderGraphResources[1].AddNewRenderGraphResource<ComputeBufferResource>(out outRes);
			outRes.desc = desc;
			outRes.transientPassIndex = transientPassIndex;
			return new ComputeBufferHandle(handle);
		}

		internal ComputeBufferDesc GetComputeBufferResourceDesc(in ResourceHandle handle)
		{
			return (m_RenderGraphResources[1].resourceArray[handle] as ComputeBufferResource).desc;
		}

		internal int GetComputeBufferResourceCount()
		{
			return GetResourceCount(RenderGraphResourceType.ComputeBuffer);
		}

		private ComputeBufferResource GetComputeBufferResource(in ResourceHandle handle)
		{
			return m_RenderGraphResources[1].resourceArray[handle] as ComputeBufferResource;
		}

		internal void UpdateSharedResourceLastFrameIndex(int type, int index)
		{
			m_RenderGraphResources[type].resourceArray[index].sharedResourceLastFrameUsed = m_ExecutionCount;
		}

		private void ManageSharedRenderGraphResources()
		{
			for (int i = 0; i < 2; i++)
			{
				RenderGraphResourcesData renderGraphResourcesData = m_RenderGraphResources[i];
				for (int j = 0; j < renderGraphResourcesData.sharedResourcesCount; j++)
				{
					IRenderGraphResource renderGraphResource = m_RenderGraphResources[i].resourceArray[j];
					bool flag = renderGraphResource.IsCreated();
					if (renderGraphResource.sharedResourceLastFrameUsed == m_ExecutionCount && !flag)
					{
						renderGraphResource.CreateGraphicsResource(renderGraphResource.GetName());
					}
					else if (flag && !renderGraphResource.sharedExplicitRelease && renderGraphResource.sharedResourceLastFrameUsed + 30 < m_ExecutionCount)
					{
						renderGraphResource.ReleaseGraphicsResource();
					}
				}
			}
		}

		internal bool CreatePooledResource(RenderGraphContext rgContext, int type, int index)
		{
			bool? flag = false;
			IRenderGraphResource renderGraphResource = m_RenderGraphResources[type].resourceArray[index];
			if (!renderGraphResource.imported)
			{
				renderGraphResource.CreatePooledGraphicsResource();
				if (m_RenderGraphDebug.enableLogging)
				{
					renderGraphResource.LogCreation(m_FrameInformationLogger);
				}
				flag = m_RenderGraphResources[type].createResourceCallback?.Invoke(rgContext, renderGraphResource);
			}
			return flag == true;
		}

		internal bool CreatePooledResource(RenderGraphContext rgContext, ResourceHandle handle)
		{
			return CreatePooledResource(rgContext, handle.iType, handle.index);
		}

		private bool CreateTextureCallback(RenderGraphContext rgContext, IRenderGraphResource res)
		{
			TextureResource textureResource = res as TextureResource;
			FastMemoryDesc fastMemoryDesc = textureResource.desc.fastMemoryDesc;
			if (fastMemoryDesc.inFastMemory)
			{
				textureResource.graphicsResource.SwitchToFastMemory(rgContext.cmd, fastMemoryDesc.residencyFraction, fastMemoryDesc.flags);
			}
			bool result = false;
			if (textureResource.desc.clearBuffer || m_RenderGraphDebug.clearRenderTargetsAtCreation)
			{
				bool flag = m_RenderGraphDebug.clearRenderTargetsAtCreation && !textureResource.desc.clearBuffer;
				using (new ProfilingScope(rgContext.cmd, ProfilingSampler.Get(flag ? RenderGraphProfileId.RenderGraphClearDebug : RenderGraphProfileId.RenderGraphClear)))
				{
					ClearFlag clearFlag = ((textureResource.desc.depthBufferBits == DepthBits.None) ? ClearFlag.Color : ClearFlag.DepthStencil);
					Color clearColor = (flag ? Color.magenta : textureResource.desc.clearColor);
					CoreUtils.SetRenderTarget(rgContext.cmd, textureResource.graphicsResource, clearFlag, clearColor);
				}
				result = true;
			}
			return result;
		}

		internal void ReleasePooledResource(RenderGraphContext rgContext, int type, int index)
		{
			IRenderGraphResource renderGraphResource = m_RenderGraphResources[type].resourceArray[index];
			if (!renderGraphResource.imported)
			{
				m_RenderGraphResources[type].releaseResourceCallback?.Invoke(rgContext, renderGraphResource);
				if (m_RenderGraphDebug.enableLogging)
				{
					renderGraphResource.LogRelease(m_FrameInformationLogger);
				}
				renderGraphResource.ReleasePooledGraphicsResource(m_CurrentFrameIndex);
			}
		}

		internal void ReleasePooledResource(RenderGraphContext rgContext, ResourceHandle handle)
		{
			ReleasePooledResource(rgContext, handle.iType, handle.index);
		}

		private void ReleaseTextureCallback(RenderGraphContext rgContext, IRenderGraphResource res)
		{
			TextureResource textureResource = res as TextureResource;
			if (m_RenderGraphDebug.clearRenderTargetsAtRelease)
			{
				using (new ProfilingScope(rgContext.cmd, ProfilingSampler.Get(RenderGraphProfileId.RenderGraphClearDebug)))
				{
					ClearFlag clearFlag = ((textureResource.desc.depthBufferBits == DepthBits.None) ? ClearFlag.Color : ClearFlag.DepthStencil);
					CoreUtils.SetRenderTarget(rgContext.cmd, textureResource.graphicsResource, clearFlag, Color.magenta);
				}
			}
		}

		private void ValidateTextureDesc(in TextureDesc desc)
		{
		}

		private void ValidateRendererListDesc(in RendererListDesc desc)
		{
		}

		private void ValidateComputeBufferDesc(in ComputeBufferDesc desc)
		{
		}

		internal void CreateRendererLists(List<RendererListHandle> rendererLists, ScriptableRenderContext context, bool manualDispatch = false)
		{
			m_ActiveRendererLists.Clear();
			foreach (RendererListHandle rendererList in rendererLists)
			{
				ref RendererListResource reference = ref m_RendererListResources[rendererList];
				reference.rendererList = context.CreateRendererList(reference.desc);
				m_ActiveRendererLists.Add(reference.rendererList);
			}
			if (manualDispatch)
			{
				context.PrepareRendererListsAsync(m_ActiveRendererLists);
			}
		}

		internal void Clear(bool onException)
		{
			LogResources();
			for (int i = 0; i < 2; i++)
			{
				m_RenderGraphResources[i].Clear(onException, m_CurrentFrameIndex);
			}
			m_RendererListResources.Clear();
			m_ActiveRendererLists.Clear();
		}

		internal void PurgeUnusedGraphicsResources()
		{
			for (int i = 0; i < 2; i++)
			{
				m_RenderGraphResources[i].PurgeUnusedGraphicsResources(m_CurrentFrameIndex);
			}
		}

		internal void Cleanup()
		{
			for (int i = 0; i < 2; i++)
			{
				m_RenderGraphResources[i].Cleanup();
			}
			RTHandles.Release(m_CurrentBackbuffer);
		}

		internal void FlushLogs()
		{
			Debug.Log(m_ResourceLogger.GetAllLogs());
		}

		private void LogResources()
		{
			if (m_RenderGraphDebug.enableLogging)
			{
				m_ResourceLogger.LogLine("==== Allocated Resources ====\n");
				for (int i = 0; i < 2; i++)
				{
					m_RenderGraphResources[i].pool.LogResources(m_ResourceLogger);
					m_ResourceLogger.LogLine("");
				}
			}
		}
	}
	[DebuggerDisplay("RendererList ({handle})")]
	public struct RendererListHandle
	{
		private bool m_IsValid;

		internal int handle { get; private set; }

		internal RendererListHandle(int handle)
		{
			this.handle = handle;
			m_IsValid = true;
		}

		public static implicit operator int(RendererListHandle handle)
		{
			return handle.handle;
		}

		public static implicit operator RendererList(RendererListHandle rendererList)
		{
			if (!rendererList.IsValid())
			{
				return RendererList.nullRendererList;
			}
			return RenderGraphResourceRegistry.current.GetRendererList(in rendererList);
		}

		public bool IsValid()
		{
			return m_IsValid;
		}
	}
	internal struct RendererListResource
	{
		public RendererListDesc desc;

		public RendererList rendererList;

		internal RendererListResource(in RendererListDesc desc)
		{
			this.desc = desc;
			rendererList = default(RendererList);
		}
	}
	internal enum RenderGraphResourceType
	{
		Texture,
		ComputeBuffer,
		Count
	}
	internal struct ResourceHandle
	{
		private const uint kValidityMask = 4294901760u;

		private const uint kIndexMask = 65535u;

		private uint m_Value;

		private static uint s_CurrentValidBit = 65536u;

		private static uint s_SharedResourceValidBit = 2147418112u;

		public int index => (int)(m_Value & 0xFFFF);

		public RenderGraphResourceType type { get; private set; }

		public int iType => (int)type;

		internal ResourceHandle(int value, RenderGraphResourceType type, bool shared)
		{
			Debug.Assert(value <= 65535);
			m_Value = (uint)(value & 0xFFFF) | (shared ? s_SharedResourceValidBit : s_CurrentValidBit);
			this.type = type;
		}

		public static implicit operator int(ResourceHandle handle)
		{
			return handle.index;
		}

		public bool IsValid()
		{
			uint num = m_Value & 0xFFFF0000u;
			if (num != 0)
			{
				if (num != s_CurrentValidBit)
				{
					return num == s_SharedResourceValidBit;
				}
				return true;
			}
			return false;
		}

		public static void NewFrame(int executionIndex)
		{
			uint num = s_CurrentValidBit;
			s_CurrentValidBit = (uint)(((executionIndex >> 16) ^ ((executionIndex & 0xFFFF) * 58546883)) << 16);
			if (s_CurrentValidBit == 0 || s_CurrentValidBit == s_SharedResourceValidBit)
			{
				uint num2;
				for (num2 = 1u; num == num2 << 16; num2++)
				{
				}
				s_CurrentValidBit = num2 << 16;
			}
		}
	}
	internal class IRenderGraphResource
	{
		public bool imported;

		public bool shared;

		public bool sharedExplicitRelease;

		public bool requestFallBack;

		public uint writeCount;

		public int cachedHash;

		public int transientPassIndex;

		public int sharedResourceLastFrameUsed;

		protected IRenderGraphResourcePool m_Pool;

		public virtual void Reset(IRenderGraphResourcePool pool)
		{
			imported = false;
			shared = false;
			sharedExplicitRelease = false;
			cachedHash = -1;
			transientPassIndex = -1;
			sharedResourceLastFrameUsed = -1;
			requestFallBack = false;
			writeCount = 0u;
			m_Pool = pool;
		}

		public virtual string GetName()
		{
			return "";
		}

		public virtual bool IsCreated()
		{
			return false;
		}

		public virtual void IncrementWriteCount()
		{
			writeCount++;
		}

		public virtual bool NeedsFallBack()
		{
			if (requestFallBack)
			{
				return writeCount == 0;
			}
			return false;
		}

		public virtual void CreatePooledGraphicsResource()
		{
		}

		public virtual void CreateGraphicsResource(string name = "")
		{
		}

		public virtual void ReleasePooledGraphicsResource(int frameIndex)
		{
		}

		public virtual void ReleaseGraphicsResource()
		{
		}

		public virtual void LogCreation(RenderGraphLogger logger)
		{
		}

		public virtual void LogRelease(RenderGraphLogger logger)
		{
		}

		public virtual int GetSortIndex()
		{
			return 0;
		}
	}
	[DebuggerDisplay("Resource ({GetType().Name}:{GetName()})")]
	internal abstract class RenderGraphResource<DescType, ResType> : IRenderGraphResource where DescType : struct where ResType : class
	{
		public DescType desc;

		public ResType graphicsResource;

		public override void Reset(IRenderGraphResourcePool pool)
		{
			base.Reset(pool);
			graphicsResource = null;
		}

		public override bool IsCreated()
		{
			return graphicsResource != null;
		}

		public override void ReleaseGraphicsResource()
		{
			graphicsResource = null;
		}
	}
	[DebuggerDisplay("Texture ({handle.index})")]
	public struct TextureHandle
	{
		private static TextureHandle s_NullHandle;

		internal ResourceHandle handle;

		public static TextureHandle nullHandle => s_NullHandle;

		internal TextureHandle(int handle, bool shared = false)
		{
			this.handle = new ResourceHandle(handle, RenderGraphResourceType.Texture, shared);
		}

		public static implicit operator RenderTargetIdentifier(TextureHandle texture)
		{
			if (!texture.IsValid())
			{
				return default(RenderTargetIdentifier);
			}
			return RenderGraphResourceRegistry.current.GetTexture(in texture);
		}

		public static implicit operator Texture(TextureHandle texture)
		{
			return texture.IsValid() ? RenderGraphResourceRegistry.current.GetTexture(in texture) : null;
		}

		public static implicit operator RenderTexture(TextureHandle texture)
		{
			return texture.IsValid() ? RenderGraphResourceRegistry.current.GetTexture(in texture) : null;
		}

		public static implicit operator RTHandle(TextureHandle texture)
		{
			if (!texture.IsValid())
			{
				return null;
			}
			return RenderGraphResourceRegistry.current.GetTexture(in texture);
		}

		public bool IsValid()
		{
			return handle.IsValid();
		}
	}
	public enum TextureSizeMode
	{
		Explicit,
		Scale,
		Functor
	}
	public struct FastMemoryDesc
	{
		public bool inFastMemory;

		public FastMemoryFlags flags;

		public float residencyFraction;
	}
	public struct TextureDesc
	{
		public TextureSizeMode sizeMode;

		public int width;

		public int height;

		public int slices;

		public Vector2 scale;

		public ScaleFunc func;

		public DepthBits depthBufferBits;

		public GraphicsFormat colorFormat;

		public FilterMode filterMode;

		public TextureWrapMode wrapMode;

		public TextureDimension dimension;

		public bool enableRandomWrite;

		public bool useMipMap;

		public bool autoGenerateMips;

		public bool isShadowMap;

		public int anisoLevel;

		public float mipMapBias;

		public MSAASamples msaaSamples;

		public bool bindTextureMS;

		public bool useDynamicScale;

		public RenderTextureMemoryless memoryless;

		public VRTextureUsage vrUsage;

		public string name;

		public FastMemoryDesc fastMemoryDesc;

		public bool fallBackToBlackTexture;

		public bool disableFallBackToImportedTexture;

		public bool clearBuffer;

		public Color clearColor;

		private void InitDefaultValues(bool dynamicResolution, bool xrReady)
		{
			useDynamicScale = dynamicResolution;
			vrUsage = VRTextureUsage.None;
			if (xrReady)
			{
				slices = TextureXR.slices;
				dimension = TextureXR.dimension;
			}
			else
			{
				slices = 1;
				dimension = TextureDimension.Tex2D;
			}
		}

		public TextureDesc(int width, int height, bool dynamicResolution = false, bool xrReady = false)
		{
			this = default(TextureDesc);
			sizeMode = TextureSizeMode.Explicit;
			this.width = width;
			this.height = height;
			msaaSamples = MSAASamples.None;
			InitDefaultValues(dynamicResolution, xrReady);
		}

		public TextureDesc(Vector2 scale, bool dynamicResolution = false, bool xrReady = false)
		{
			this = default(TextureDesc);
			sizeMode = TextureSizeMode.Scale;
			this.scale = scale;
			msaaSamples = MSAASamples.None;
			dimension = TextureDimension.Tex2D;
			InitDefaultValues(dynamicResolution, xrReady);
		}

		public TextureDesc(ScaleFunc func, bool dynamicResolution = false, bool xrReady = false)
		{
			this = default(TextureDesc);
			sizeMode = TextureSizeMode.Functor;
			this.func = func;
			msaaSamples = MSAASamples.None;
			dimension = TextureDimension.Tex2D;
			InitDefaultValues(dynamicResolution, xrReady);
		}

		public TextureDesc(TextureDesc input)
		{
			this = input;
		}

		public override int GetHashCode()
		{
			int num = 17;
			switch (sizeMode)
			{
			case TextureSizeMode.Explicit:
				num = num * 23 + width;
				num = num * 23 + height;
				break;
			case TextureSizeMode.Functor:
				if (func != null)
				{
					num = num * 23 + func.GetHashCode();
				}
				break;
			case TextureSizeMode.Scale:
				num = num * 23 + scale.x.GetHashCode();
				num = num * 23 + scale.y.GetHashCode();
				break;
			}
			num = num * 23 + mipMapBias.GetHashCode();
			num = num * 23 + slices;
			num = (int)(num * 23 + depthBufferBits);
			num = (int)(num * 23 + colorFormat);
			num = (int)(num * 23 + filterMode);
			num = (int)(num * 23 + wrapMode);
			num = (int)(num * 23 + dimension);
			num = (int)(num * 23 + memoryless);
			num = (int)(num * 23 + vrUsage);
			num = num * 23 + anisoLevel;
			num = num * 23 + (enableRandomWrite ? 1 : 0);
			num = num * 23 + (useMipMap ? 1 : 0);
			num = num * 23 + (autoGenerateMips ? 1 : 0);
			num = num * 23 + (isShadowMap ? 1 : 0);
			num = num * 23 + (bindTextureMS ? 1 : 0);
			num = num * 23 + (useDynamicScale ? 1 : 0);
			num = (int)(num * 23 + msaaSamples);
			return num * 23 + (fastMemoryDesc.inFastMemory ? 1 : 0);
		}
	}
	[DebuggerDisplay("TextureResource ({desc.name})")]
	internal class TextureResource : RenderGraphResource<TextureDesc, RTHandle>
	{
		private static int m_TextureCreationIndex;

		public override string GetName()
		{
			if (imported && !shared)
			{
				if (graphicsResource == null)
				{
					return "null resource";
				}
				return graphicsResource.name;
			}
			return desc.name;
		}

		public override void CreatePooledGraphicsResource()
		{
			Debug.Assert(m_Pool != null, "TextureResource: CreatePooledGraphicsResource should only be called for regular pooled resources");
			int hashCode = desc.GetHashCode();
			if (graphicsResource != null)
			{
				throw new InvalidOperationException($"TextureResource: Trying to create an already created resource ({GetName()}). Resource was probably declared for writing more than once in the same pass.");
			}
			TexturePool obj = m_Pool as TexturePool;
			if (!obj.TryGetResource(hashCode, out graphicsResource))
			{
				CreateGraphicsResource(desc.name);
			}
			cachedHash = hashCode;
			obj.RegisterFrameAllocation(cachedHash, graphicsResource);
			graphicsResource.m_Name = desc.name;
		}

		public override void ReleasePooledGraphicsResource(int frameIndex)
		{
			if (graphicsResource == null)
			{
				throw new InvalidOperationException("TextureResource: Tried to release a resource (" + GetName() + ") that was never created. Check that there is at least one pass writing to it first.");
			}
			if (m_Pool is TexturePool texturePool)
			{
				texturePool.ReleaseResource(cachedHash, graphicsResource, frameIndex);
				texturePool.UnregisterFrameAllocation(cachedHash, graphicsResource);
			}
			Reset(null);
		}

		public override void CreateGraphicsResource(string name = "")
		{
			if (name == "")
			{
				name = $"RenderGraphTexture_{m_TextureCreationIndex++}";
			}
			switch (desc.sizeMode)
			{
			case TextureSizeMode.Explicit:
				graphicsResource = RTHandles.Alloc(desc.width, desc.height, desc.slices, desc.depthBufferBits, desc.colorFormat, desc.filterMode, desc.wrapMode, desc.dimension, desc.enableRandomWrite, desc.useMipMap, desc.autoGenerateMips, desc.isShadowMap, desc.anisoLevel, desc.mipMapBias, desc.msaaSamples, desc.bindTextureMS, desc.useDynamicScale, desc.memoryless, desc.vrUsage, name);
				break;
			case TextureSizeMode.Scale:
				graphicsResource = RTHandles.Alloc(desc.scale, desc.slices, desc.depthBufferBits, desc.colorFormat, desc.filterMode, desc.wrapMode, desc.dimension, desc.enableRandomWrite, desc.useMipMap, desc.autoGenerateMips, desc.isShadowMap, desc.anisoLevel, desc.mipMapBias, desc.msaaSamples, desc.bindTextureMS, desc.useDynamicScale, desc.memoryless, desc.vrUsage, name);
				break;
			case TextureSizeMode.Functor:
				graphicsResource = RTHandles.Alloc(desc.func, desc.slices, desc.depthBufferBits, desc.colorFormat, desc.filterMode, desc.wrapMode, desc.dimension, desc.enableRandomWrite, desc.useMipMap, desc.autoGenerateMips, desc.isShadowMap, desc.anisoLevel, desc.mipMapBias, desc.msaaSamples, desc.bindTextureMS, desc.useDynamicScale, desc.memoryless, desc.vrUsage, name);
				break;
			}
		}

		public override void ReleaseGraphicsResource()
		{
			if (graphicsResource != null)
			{
				graphicsResource.Release();
			}
			base.ReleaseGraphicsResource();
		}

		public override void LogCreation(RenderGraphLogger logger)
		{
			logger.LogLine($"Created Texture: {desc.name} (Cleared: {desc.clearBuffer})");
		}

		public override void LogRelease(RenderGraphLogger logger)
		{
			logger.LogLine("Released Texture: " + desc.name);
		}
	}
	internal class TexturePool : RenderGraphResourcePool<RTHandle>
	{
		protected override void ReleaseInternalResource(RTHandle res)
		{
			res.Release();
		}

		protected override string GetResourceName(RTHandle res)
		{
			return res.rt.name;
		}

		protected override long GetResourceSize(RTHandle res)
		{
			return Profiler.GetRuntimeMemorySizeLong(res.rt);
		}

		protected override string GetResourceTypeName()
		{
			return "Texture";
		}

		protected override int GetSortIndex(RTHandle res)
		{
			return res.GetInstanceID();
		}

		public override void PurgeUnusedResources(int currentFrameIndex)
		{
			RenderGraphResourcePool<RTHandle>.s_CurrentFrameIndex = currentFrameIndex;
			m_RemoveList.Clear();
			foreach (KeyValuePair<int, SortedList<int, (RTHandle, int)>> item in m_ResourcePool)
			{
				SortedList<int, (RTHandle, int)> value = item.Value;
				IList<int> keys = value.Keys;
				IList<(RTHandle, int)> values = value.Values;
				for (int i = 0; i < value.Count; i++)
				{
					(RTHandle, int) tuple = values[i];
					if (RenderGraphResourcePool<RTHandle>.ShouldReleaseResource(tuple.Item2, RenderGraphResourcePool<RTHandle>.s_CurrentFrameIndex))
					{
						tuple.Item1.Release();
						m_RemoveList.Add(keys[i]);
					}
				}
				foreach (int remove in m_RemoveList)
				{
					value.Remove(remove);
				}
			}
		}
	}
}
namespace UnityEngine.Rendering
{
	public class CameraSwitcher : MonoBehaviour
	{
		public Camera[] m_Cameras;

		private int m_CurrentCameraIndex = -1;

		private Camera m_OriginalCamera;

		private Vector3 m_OriginalCameraPosition;

		private Quaternion m_OriginalCameraRotation;

		private Camera m_CurrentCamera;

		private GUIContent[] m_CameraNames;

		private int[] m_CameraIndices;

		private DebugUI.EnumField m_DebugEntry;

		private int m_DebugEntryEnumIndex;

		private void OnEnable()
		{
			m_OriginalCamera = GetComponent<Camera>();
			m_CurrentCamera = m_OriginalCamera;
			if (m_OriginalCamera == null)
			{
				Debug.LogError("Camera Switcher needs a Camera component attached");
				return;
			}
			m_CurrentCameraIndex = GetCameraCount() - 1;
			m_CameraNames = new GUIContent[GetCameraCount()];
			m_CameraIndices = new int[GetCameraCount()];
			for (int i = 0; i < m_Cameras.Length; i++)
			{
				Camera camera = m_Cameras[i];
				if (camera != null)
				{
					m_CameraNames[i] = new GUIContent(camera.name);
				}
				else
				{
					m_CameraNames[i] = new GUIContent("null");
				}
				m_CameraIndices[i] = i;
			}
			m_CameraNames[GetCameraCount() - 1] = new GUIContent("Original Camera");
			m_CameraIndices[GetCameraCount() - 1] = GetCameraCount() - 1;
			m_DebugEntry = new DebugUI.EnumField
			{
				displayName = "Camera Switcher",
				getter = () => m_CurrentCameraIndex,
				setter = delegate(int value)
				{
					SetCameraIndex(value);
				},
				enumNames = m_CameraNames,
				enumValues = m_CameraIndices,
				getIndex = () => m_DebugEntryEnumIndex,
				setIndex = delegate(int value)
				{
					m_DebugEntryEnumIndex = value;
				}
			};
			DebugManager.instance.GetPanel("Camera", createIfNull: true).children.Add(m_DebugEntry);
		}

		private void OnDisable()
		{
			if (m_DebugEntry != null && m_DebugEntry.panel != null)
			{
				m_DebugEntry.panel.children.Remove(m_DebugEntry);
			}
		}

		private int GetCameraCount()
		{
			return m_Cameras.Length + 1;
		}

		private Camera GetNextCamera()
		{
			if (m_CurrentCameraIndex == m_Cameras.Length)
			{
				return m_OriginalCamera;
			}
			return m_Cameras[m_CurrentCameraIndex];
		}

		private void SetCameraIndex(int index)
		{
			if (index <= 0 || index >= GetCameraCount())
			{
				return;
			}
			m_CurrentCameraIndex = index;
			if (m_CurrentCamera == m_OriginalCamera)
			{
				m_OriginalCameraPosition = m_OriginalCamera.transform.position;
				m_OriginalCameraRotation = m_OriginalCamera.transform.rotation;
			}
			m_CurrentCamera = GetNextCamera();
			if (m_CurrentCamera != null)
			{
				if (m_CurrentCamera == m_OriginalCamera)
				{
					m_OriginalCamera.transform.position = m_OriginalCameraPosition;
					m_OriginalCamera.transform.rotation = m_OriginalCameraRotation;
				}
				base.transform.position = m_CurrentCamera.transform.position;
				base.transform.rotation = m_CurrentCamera.transform.rotation;
			}
		}
	}
	public class FreeCamera : MonoBehaviour
	{
		private const float k_MouseSensitivityMultiplier = 0.01f;

		public float m_LookSpeedController = 120f;

		public float m_LookSpeedMouse = 4f;

		public float m_MoveSpeed = 10f;

		public float m_MoveSpeedIncrement = 2.5f;

		public float m_Turbo = 10f;

		private static string kMouseX = "Mouse X";

		private static string kMouseY = "Mouse Y";

		private static string kRightStickX = "Controller Right Stick X";

		private static string kRightStickY = "Controller Right Stick Y";

		private static string kVertical = "Vertical";

		private static string kHorizontal = "Horizontal";

		private static string kYAxis = "YAxis";

		private static string kSpeedAxis = "Speed Axis";

		private float inputRotateAxisX;

		private float inputRotateAxisY;

		private float inputChangeSpeed;

		private float inputVertical;

		private float inputHorizontal;

		private float inputYAxis;

		private bool leftShiftBoost;

		private bool leftShift;

		private bool fire1;

		private void OnEnable()
		{
			RegisterInputs();
		}

		private void RegisterInputs()
		{
		}

		private void UpdateInputs()
		{
			inputRotateAxisX = 0f;
			inputRotateAxisY = 0f;
			leftShiftBoost = false;
			fire1 = false;
			if (Input.GetMouseButton(1))
			{
				leftShiftBoost = true;
				inputRotateAxisX = Input.GetAxis(kMouseX) * m_LookSpeedMouse;
				inputRotateAxisY = Input.GetAxis(kMouseY) * m_LookSpeedMouse;
			}
			inputRotateAxisX += Input.GetAxis(kRightStickX) * m_LookSpeedController * 0.01f;
			inputRotateAxisY += Input.GetAxis(kRightStickY) * m_LookSpeedController * 0.01f;
			leftShift = Input.GetKey(KeyCode.LeftShift);
			fire1 = Input.GetAxis("Fire1") > 0f;
			inputChangeSpeed = Input.GetAxis(kSpeedAxis);
			inputVertical = Input.GetAxis(kVertical);
			inputHorizontal = Input.GetAxis(kHorizontal);
			inputYAxis = Input.GetAxis(kYAxis);
		}

		private void Update()
		{
			if (DebugManager.instance.displayRuntimeUI)
			{
				return;
			}
			UpdateInputs();
			if (inputChangeSpeed != 0f)
			{
				m_MoveSpeed += inputChangeSpeed * m_MoveSpeedIncrement;
				if (m_MoveSpeed < m_MoveSpeedIncrement)
				{
					m_MoveSpeed = m_MoveSpeedIncrement;
				}
			}
			if (inputRotateAxisX != 0f || inputRotateAxisY != 0f || inputVertical != 0f || inputHorizontal != 0f || inputYAxis != 0f)
			{
				float x = base.transform.localEulerAngles.x;
				float y = base.transform.localEulerAngles.y + inputRotateAxisX;
				float num = x - inputRotateAxisY;
				if (x <= 90f && num >= 0f)
				{
					num = Mathf.Clamp(num, 0f, 90f);
				}
				if (x >= 270f)
				{
					num = Mathf.Clamp(num, 270f, 360f);
				}
				base.transform.localRotation = Quaternion.Euler(num, y, base.transform.localEulerAngles.z);
				float num2 = Time.deltaTime * m_MoveSpeed;
				if (fire1 || (leftShiftBoost && leftShift))
				{
					num2 *= m_Turbo;
				}
				base.transform.position += base.transform.forward * num2 * inputVertical;
				base.transform.position += base.transform.right * num2 * inputHorizontal;
				base.transform.position += Vector3.up * num2 * inputYAxis;
			}
		}
	}
	public static class CommandBufferPool
	{
		private static ObjectPool<CommandBuffer> s_BufferPool = new ObjectPool<CommandBuffer>(null, delegate(CommandBuffer x)
		{
			x.Clear();
		});

		public static CommandBuffer Get()
		{
			CommandBuffer commandBuffer = s_BufferPool.Get();
			commandBuffer.name = "";
			return commandBuffer;
		}

		public static CommandBuffer Get(string name)
		{
			CommandBuffer commandBuffer = s_BufferPool.Get();
			commandBuffer.name = name;
			return commandBuffer;
		}

		public static void Release(CommandBuffer buffer)
		{
			s_BufferPool.Release(buffer);
		}
	}
	[Flags]
	public enum ClearFlag
	{
		None = 0,
		Color = 1,
		Depth = 2,
		Stencil = 4,
		DepthStencil = 6,
		ColorStencil = 5,
		All = 7
	}
	public static class ComponentSingleton<TType> where TType : Component
	{
		private static TType s_Instance;

		public static TType instance
		{
			get
			{
				if (s_Instance == null)
				{
					GameObject obj = new GameObject("Default " + typeof(TType).Name)
					{
						hideFlags = HideFlags.HideAndDontSave
					};
					Object.DontDestroyOnLoad(obj);
					obj.SetActive(value: false);
					s_Instance = obj.AddComponent<TType>();
				}
				return s_Instance;
			}
		}

		public static void Release()
		{
			if (s_Instance != null)
			{
				CoreUtils.Destroy(s_Instance.gameObject);
				s_Instance = null;
			}
		}
	}
	public class ConstantBuffer
	{
		private static List<ConstantBufferBase> m_RegisteredConstantBuffers = new List<ConstantBufferBase>();

		public static void PushGlobal<CBType>(CommandBuffer cmd, in CBType data, int shaderId) where CBType : struct
		{
			ConstantBufferSingleton<CBType> instance = ConstantBufferSingleton<CBType>.instance;
			instance.UpdateData(cmd, in data);
			instance.SetGlobal(cmd, shaderId);
		}

		public static void PushGlobal<CBType>(in CBType data, int shaderId) where CBType : struct
		{
			ConstantBufferSingleton<CBType> instance = ConstantBufferSingleton<CBType>.instance;
			instance.UpdateData(in data);
			instance.SetGlobal(shaderId);
		}

		public static void Push<CBType>(CommandBuffer cmd, in CBType data, ComputeShader cs, int shaderId) where CBType : struct
		{
			ConstantBufferSingleton<CBType> instance = ConstantBufferSingleton<CBType>.instance;
			instance.UpdateData(cmd, in data);
			instance.Set(cmd, cs, shaderId);
		}

		public static void Push<CBType>(in CBType data, ComputeShader cs, int shaderId) where CBType : struct
		{
			ConstantBufferSingleton<CBType> instance = ConstantBufferSingleton<CBType>.instance;
			instance.UpdateData(in data);
			instance.Set(cs, shaderId);
		}

		public static void Push<CBType>(CommandBuffer cmd, in CBType data, Material mat, int shaderId) where CBType : struct
		{
			ConstantBufferSingleton<CBType> instance = ConstantBufferSingleton<CBType>.instance;
			instance.UpdateData(cmd, in data);
			instance.Set(mat, shaderId);
		}

		public static void Push<CBType>(in CBType data, Material mat, int shaderId) where CBType : struct
		{
			ConstantBufferSingleton<CBType> instance = ConstantBufferSingleton<CBType>.instance;
			instance.UpdateData(in data);
			instance.Set(mat, shaderId);
		}

		public static void UpdateData<CBType>(CommandBuffer cmd, in CBType data) where CBType : struct
		{
			ConstantBufferSingleton<CBType>.instance.UpdateData(cmd, in data);
		}

		public static void UpdateData<CBType>(in CBType data) where CBType : struct
		{
			ConstantBufferSingleton<CBType>.instance.UpdateData(in data);
		}

		public static void SetGlobal<CBType>(CommandBuffer cmd, int shaderId) where CBType : struct
		{
			ConstantBufferSingleton<CBType>.instance.SetGlobal(cmd, shaderId);
		}

		public static void SetGlobal<CBType>(int shaderId) where CBType : struct
		{
			ConstantBufferSingleton<CBType>.instance.SetGlobal(shaderId);
		}

		public static void Set<CBType>(CommandBuffer cmd, ComputeShader cs, int shaderId) where CBType : struct
		{
			ConstantBufferSingleton<CBType>.instance.Set(cmd, cs, shaderId);
		}

		public static void Set<CBType>(ComputeShader cs, int shaderId) where CBType : struct
		{
			ConstantBufferSingleton<CBType>.instance.Set(cs, shaderId);
		}

		public static void Set<CBType>(Material mat, int shaderId) where CBType : struct
		{
			ConstantBufferSingleton<CBType>.instance.Set(mat, shaderId);
		}

		public static void ReleaseAll()
		{
			foreach (ConstantBufferBase registeredConstantBuffer in m_RegisteredConstantBuffers)
			{
				registeredConstantBuffer.Release();
			}
			m_RegisteredConstantBuffers.Clear();
		}

		internal static void Register(ConstantBufferBase cb)
		{
			m_RegisteredConstantBuffers.Add(cb);
		}
	}
	public abstract class ConstantBufferBase
	{
		public abstract void Release();
	}
	public class ConstantBuffer<CBType> : ConstantBufferBase where CBType : struct
	{
		private HashSet<int> m_GlobalBindings = new HashSet<int>();

		private CBType[] m_Data = new CBType[1];

		private ComputeBuffer m_GPUConstantBuffer;

		public ConstantBuffer()
		{
			m_GPUConstantBuffer = new ComputeBuffer(1, UnsafeUtility.SizeOf<CBType>(), ComputeBufferType.Constant);
		}

		public void UpdateData(CommandBuffer cmd, in CBType data)
		{
			m_Data[0] = data;
			cmd.SetBufferData(m_GPUConstantBuffer, m_Data);
		}

		public void UpdateData(in CBType data)
		{
			m_Data[0] = data;
			m_GPUConstantBuffer.SetData(m_Data);
		}

		public void SetGlobal(CommandBuffer cmd, int shaderId)
		{
			m_GlobalBindings.Add(shaderId);
			cmd.SetGlobalConstantBuffer(m_GPUConstantBuffer, shaderId, 0, m_GPUConstantBuffer.stride);
		}

		public void SetGlobal(int shaderId)
		{
			m_GlobalBindings.Add(shaderId);
			Shader.SetGlobalConstantBuffer(shaderId, m_GPUConstantBuffer, 0, m_GPUConstantBuffer.stride);
		}

		public void Set(CommandBuffer cmd, ComputeShader cs, int shaderId)
		{
			cmd.SetComputeConstantBufferParam(cs, shaderId, m_GPUConstantBuffer, 0, m_GPUConstantBuffer.stride);
		}

		public void Set(ComputeShader cs, int shaderId)
		{
			cs.SetConstantBuffer(shaderId, m_GPUConstantBuffer, 0, m_GPUConstantBuffer.stride);
		}

		public void Set(Material mat, int shaderId)
		{
			mat.SetConstantBuffer(shaderId, m_GPUConstantBuffer, 0, m_GPUConstantBuffer.stride);
		}

		public void PushGlobal(CommandBuffer cmd, in CBType data, int shaderId)
		{
			UpdateData(cmd, in data);
			SetGlobal(cmd, shaderId);
		}

		public void PushGlobal(in CBType data, int shaderId)
		{
			UpdateData(in data);
			SetGlobal(shaderId);
		}

		public override void Release()
		{
			foreach (int globalBinding in m_GlobalBindings)
			{
				Shader.SetGlobalConstantBuffer(globalBinding, (ComputeBuffer)null, 0, 0);
			}
			m_GlobalBindings.Clear();
			CoreUtils.SafeRelease(m_GPUConstantBuffer);
		}
	}
	internal class ConstantBufferSingleton<CBType> : ConstantBuffer<CBType> where CBType : struct
	{
		private static ConstantBufferSingleton<CBType> s_Instance;

		internal static ConstantBufferSingleton<CBType> instance
		{
			get
			{
				if (s_Instance == null)
				{
					s_Instance = new ConstantBufferSingleton<CBType>();
					ConstantBuffer.Register(s_Instance);
				}
				return s_Instance;
			}
			set
			{
				s_Instance = value;
			}
		}

		public override void Release()
		{
			base.Release();
			s_Instance = null;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, AllowMultiple = false)]
	public class DisplayInfoAttribute : Attribute
	{
		public string name;

		public int order;
	}
	[AttributeUsage(AttributeTargets.Field)]
	public class AdditionalPropertyAttribute : Attribute
	{
	}
	internal enum CoreProfileId
	{
		BlitTextureInPotAtlas,
		APVCellStreamingUpdate,
		APVScenarioBlendingUpdate
	}
	public static class CoreUnsafeUtils
	{
		public struct FixedBufferStringQueue
		{
			private unsafe byte* m_ReadCursor;

			private unsafe byte* m_WriteCursor;

			private unsafe readonly byte* m_BufferEnd;

			private unsafe readonly byte* m_BufferStart;

			private readonly int m_BufferLength;

			public int Count { get; private set; }

			public unsafe FixedBufferStringQueue(byte* ptr, int length)
			{
				m_BufferStart = ptr;
				m_BufferLength = length;
				m_BufferEnd = m_BufferStart + m_BufferLength;
				m_ReadCursor = m_BufferStart;
				m_WriteCursor = m_BufferStart;
				Count = 0;
				Clear();
			}

			public unsafe bool TryPush(string v)
			{
				int num = v.Length * 2 + 4;
				if (m_WriteCursor + num >= m_BufferEnd)
				{
					return false;
				}
				*(int*)m_WriteCursor = v.Length;
				m_WriteCursor += 4;
				char* ptr = (char*)m_WriteCursor;
				int num2 = 0;
				while (num2 < v.Length)
				{
					*ptr = v[num2];
					num2++;
					ptr++;
				}
				m_WriteCursor += 2 * v.Length;
				int count = Count + 1;
				Count = count;
				return true;
			}

			public unsafe bool TryPop(out string v)
			{
				int readCursor = *(int*)m_ReadCursor;
				if (readCursor != 0)
				{
					m_ReadCursor += 4;
					v = new string((char*)m_ReadCursor, 0, readCursor);
					m_ReadCursor += readCursor * 2;
					return true;
				}
				v = null;
				return false;
			}

			public unsafe void Clear()
			{
				m_WriteCursor = m_BufferStart;
				m_ReadCursor = m_BufferStart;
				Count = 0;
				UnsafeUtility.MemClear(m_BufferStart, m_BufferLength);
			}
		}

		public interface IKeyGetter<TValue, TKey>
		{
			TKey Get(ref TValue v);
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		internal struct DefaultKeyGetter<T> : IKeyGetter<T, T>
		{
			public T Get(ref T v)
			{
				return v;
			}
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		internal struct UintKeyGetter : IKeyGetter<uint, uint>
		{
			public uint Get(ref uint v)
			{
				return v;
			}
		}

		public unsafe static void CopyTo<T>(this List<T> list, void* dest, int count) where T : struct
		{
			int num = Mathf.Min(count, list.Count);
			for (int i = 0; i < num; i++)
			{
				UnsafeUtility.WriteArrayElement(dest, i, list[i]);
			}
		}

		public unsafe static void CopyTo<T>(this T[] list, void* dest, int count) where T : struct
		{
			int num = Mathf.Min(count, list.Length);
			for (int i = 0; i < num; i++)
			{
				UnsafeUtility.WriteArrayElement(dest, i, list[i]);
			}
		}

		private static void CalculateRadixParams(int radixBits, out int bitStates)
		{
			if (radixBits != 2 && radixBits != 4 && radixBits != 8)
			{
				throw new Exception("Radix bits must be 2, 4 or 8 for uint radix sort.");
			}
			bitStates = 1 << radixBits;
		}

		private static int CalculateRadixSupportSize(int bitStates, int arrayLength)
		{
			return bitStates * 3 + arrayLength;
		}

		private unsafe static void CalculateRadixSortSupportArrays(int bitStates, int arrayLength, uint* supportArray, out uint* bucketIndices, out uint* bucketSizes, out uint* bucketPrefix, out uint* arrayOutput)
		{
			bucketIndices = supportArray;
			bucketSizes = bucketIndices + bitStates;
			bucketPrefix = bucketSizes + bitStates;
			arrayOutput = bucketPrefix + bitStates;
		}

		private unsafe static void MergeSort(uint* array, uint* support, int length)
		{
			for (int num = 1; num < length; num *= 2)
			{
				for (int i = 0; i + num < length; i += num * 2)
				{
					int num2 = i + num;
					int num3 = num2 + num;
					if (num3 > length)
					{
						num3 = length;
					}
					int num4 = i;
					int num5 = i;
					int num6 = num2;
					while (num5 < num2 && num6 < num3)
					{
						if (array[num5] <= array[num6])
						{
							support[num4] = array[num5++];
						}
						else
						{
							support[num4] = array[num6++];
						}
						num4++;
					}
					while (num5 < num2)
					{
						support[num4] = array[num5++];
						num4++;
					}
					while (num6 < num3)
					{
						support[num4] = array[num6++];
						num4++;
					}
					for (num4 = i; num4 < num3; num4++)
					{
						array[num4] = support[num4];
					}
				}
			}
		}

		public unsafe static void MergeSort(uint[] arr, int sortSize, ref uint[] supportArray)
		{
			sortSize = Math.Min(sortSize, arr.Length);
			if (arr == null || sortSize == 0)
			{
				return;
			}
			if (supportArray == null || supportArray.Length < sortSize)
			{
				supportArray = new uint[sortSize];
			}
			fixed (uint* array = arr)
			{
				fixed (uint* support = supportArray)
				{
					MergeSort(array, support, sortSize);
				}
			}
		}

		public unsafe static void MergeSort(NativeArray<uint> arr, int sortSize, ref NativeArray<uint> supportArray)
		{
			sortSize = Math.Min(sortSize, arr.Length);
			if (arr.IsCreated && sortSize != 0)
			{
				if (!supportArray.IsCreated || supportArray.Length < sortSize)
				{
					ArrayExtensions.ResizeArray(ref supportArray, arr.Length);
				}
				MergeSort((uint*)arr.GetUnsafePtr(), (uint*)supportArray.GetUnsafePtr(), sortSize);
			}
		}

		private unsafe static void InsertionSort(uint* arr, int length)
		{
			for (int i = 0; i < length; i++)
			{
				int num = i;
				while (num >= 1 && arr[num] < arr[num - 1])
				{
					uint num2 = arr[num];
					arr[num] = arr[num - 1];
					arr[num - 1] = num2;
					num--;
				}
			}
		}

		public unsafe static void InsertionSort(uint[] arr, int sortSize)
		{
			sortSize = Math.Min(arr.Length, sortSize);
			if (arr != null && sortSize != 0)
			{
				fixed (uint* arr2 = arr)
				{
					InsertionSort(arr2, sortSize);
				}
			}
		}

		public unsafe static void InsertionSort(NativeArray<uint> arr, int sortSize)
		{
			sortSize = Math.Min(arr.Length, sortSize);
			if (arr.IsCreated && sortSize != 0)
			{
				InsertionSort((uint*)arr.GetUnsafePtr(), sortSize);
			}
		}

		private unsafe static void RadixSort(uint* array, uint* support, int radixBits, int bitStates, int length)
		{
			uint num = (uint)(bitStates - 1);
			CalculateRadixSortSupportArrays(bitStates, length, support, out var bucketIndices, out var bucketSizes, out var bucketPrefix, out var arrayOutput);
			int num2 = 32 / radixBits;
			uint* ptr = arrayOutput;
			uint* ptr2 = array;
			for (int i = 0; i < num2; i++)
			{
				int num3 = i * radixBits;
				for (int j = 0; j < 3 * bitStates; j++)
				{
					bucketIndices[j] = 0u;
				}
				for (int k = 0; k < length; k++)
				{
					bucketSizes[(ptr2[k] >> num3) & num]++;
				}
				for (int l = 1; l < bitStates; l++)
				{
					bucketPrefix[l] = bucketPrefix[l - 1] + bucketSizes[l - 1];
				}
				for (int m = 0; m < length; m++)
				{
					uint num4 = ptr2[m];
					uint num5 = (num4 >> num3) & num;
					ptr[bucketPrefix[num5] + bucketIndices[num5]++] = num4;
				}
				uint* intPtr = ptr2;
				ptr2 = ptr;
				ptr = intPtr;
			}
		}

		public unsafe static void RadixSort(uint[] arr, int sortSize, ref uint[] supportArray, int radixBits = 8)
		{
			sortSize = Math.Min(sortSize, arr.Length);
			CalculateRadixParams(radixBits, out var bitStates);
			if (arr == null || sortSize == 0)
			{
				return;
			}
			int num = CalculateRadixSupportSize(bitStates, sortSize);
			if (supportArray == null || supportArray.Length < num)
			{
				supportArray = new uint[num];
			}
			fixed (uint* array = arr)
			{
				fixed (uint* support = supportArray)
				{
					RadixSort(array, support, radixBits, bitStates, sortSize);
				}
			}
		}

		public unsafe static void RadixSort(NativeArray<uint> array, int sortSize, ref NativeArray<uint> supportArray, int radixBits = 8)
		{
			sortSize = Math.Min(sortSize, array.Length);
			CalculateRadixParams(radixBits, out var bitStates);
			if (array.IsCreated && sortSize != 0)
			{
				int num = CalculateRadixSupportSize(bitStates, sortSize);
				if (!supportArray.IsCreated || supportArray.Length < num)
				{
					ArrayExtensions.ResizeArray(ref supportArray, num);
				}
				RadixSort((uint*)array.GetUnsafePtr(), (uint*)supportArray.GetUnsafePtr(), radixBits, bitStates, sortSize);
			}
		}

		public unsafe static void QuickSort(uint[] arr, int left, int right)
		{
			fixed (uint* data = arr)
			{
				QuickSort<uint, uint, UintKeyGetter>(data, left, right);
			}
		}

		public unsafe static void QuickSort<T>(int count, void* data) where T : struct, IComparable<T>
		{
			QuickSort<T, T, DefaultKeyGetter<T>>(data, 0, count - 1);
		}

		public unsafe static void QuickSort<TValue, TKey, TGetter>(int count, void* data) where TValue : struct where TKey : struct, IComparable<TKey> where TGetter : struct, IKeyGetter<TValue, TKey>
		{
			QuickSort<TValue, TKey, TGetter>(data, 0, count - 1);
		}

		public unsafe static void QuickSort<TValue, TKey, TGetter>(void* data, int left, int right) where TValue : struct where TKey : struct, IComparable<TKey> where TGetter : struct, IKeyGetter<TValue, TKey>
		{
			if (left < right)
			{
				int num = Partition<TValue, TKey, TGetter>(data, left, right);
				if (num >= 1)
				{
					QuickSort<TValue, TKey, TGetter>(data, left, num);
				}
				if (num + 1 < right)
				{
					QuickSort<TValue, TKey, TGetter>(data, num + 1, right);
				}
			}
		}

		public unsafe static int IndexOf<T>(void* data, int count, T v) where T : struct, IEquatable<T>
		{
			for (int i = 0; i < count; i++)
			{
				if (UnsafeUtility.ReadArrayElement<T>(data, i).Equals(v))
				{
					return i;
				}
			}
			return -1;
		}

		public unsafe static int CompareHashes<TOldValue, TOldGetter, TNewValue, TNewGetter>(int oldHashCount, void* oldHashes, int newHashCount, void* newHashes, int* addIndices, int* removeIndices, out int addCount, out int remCount) where TOldValue : struct where TOldGetter : struct, IKeyGetter<TOldValue, Hash128> where TNewValue : struct where TNewGetter : struct, IKeyGetter<TNewValue, Hash128>
		{
			TOldGetter val = new TOldGetter();
			TNewGetter val2 = new TNewGetter();
			addCount = 0;
			remCount = 0;
			if (oldHashCount == newHashCount)
			{
				Hash128 hash = default(Hash128);
				Hash128 hash2 = default(Hash128);
				CombineHashes<TOldValue, TOldGetter>(oldHashCount, oldHashes, &hash);
				CombineHashes<TNewValue, TNewGetter>(newHashCount, newHashes, &hash2);
				if (hash == hash2)
				{
					return 0;
				}
			}
			int num = 0;
			int i = 0;
			int j = 0;
			while (i < oldHashCount || j < newHashCount)
			{
				if (i == oldHashCount)
				{
					for (; j < newHashCount; j++)
					{
						addIndices[addCount++] = j;
						num++;
					}
					continue;
				}
				if (j == newHashCount)
				{
					for (; i < oldHashCount; i++)
					{
						removeIndices[remCount++] = i;
						num++;
					}
					continue;
				}
				TNewValue v = UnsafeUtility.ReadArrayElement<TNewValue>(newHashes, j);
				TOldValue v2 = UnsafeUtility.ReadArrayElement<TOldValue>(oldHashes, i);
				Hash128 hash3 = val2.Get(ref v);
				Hash128 hash4 = val.Get(ref v2);
				if (hash3 == hash4)
				{
					j++;
					i++;
					continue;
				}
				if (hash3 < hash4)
				{
					while (j < newHashCount && hash3 < hash4)
					{
						addIndices[addCount++] = j;
						j++;
						num++;
						v = UnsafeUtility.ReadArrayElement<TNewValue>(newHashes, j);
						hash3 = val2.Get(ref v);
					}
					continue;
				}
				for (; i < oldHashCount; i++)
				{
					if (!(hash4 < hash3))
					{
						break;
					}
					removeIndices[remCount++] = i;
					num++;
				}
			}
			return num;
		}

		public unsafe static int CompareHashes(int oldHashCount, Hash128* oldHashes, int newHashCount, Hash128* newHashes, int* addIndices, int* removeIndices, out int addCount, out int remCount)
		{
			return CompareHashes<Hash128, DefaultKeyGetter<Hash128>, Hash128, DefaultKeyGetter<Hash128>>(oldHashCount, oldHashes, newHashCount, newHashes, addIndices, removeIndices, out addCount, out remCount);
		}

		public unsafe static void CombineHashes<TValue, TGetter>(int count, void* hashes, Hash128* outHash) where TValue : struct where TGetter : struct, IKeyGetter<TValue, Hash128>
		{
			TGetter val = new TGetter();
			for (int i = 0; i < count; i++)
			{
				TValue v = UnsafeUtility.ReadArrayElement<TValue>(hashes, i);
				Hash128 inHash = val.Get(ref v);
				HashUtilities.AppendHash(ref inHash, ref *outHash);
			}
		}

		public unsafe static void CombineHashes(int count, Hash128* hashes, Hash128* outHash)
		{
			CombineHashes<Hash128, DefaultKeyGetter<Hash128>>(count, hashes, outHash);
		}

		private unsafe static int Partition<TValue, TKey, TGetter>(void* data, int left, int right) where TValue : struct where TKey : struct, IComparable<TKey> where TGetter : struct, IKeyGetter<TValue, TKey>
		{
			TGetter val = default(TGetter);
			TValue v = UnsafeUtility.ReadArrayElement<TValue>(data, left);
			TKey other = val.Get(ref v);
			left--;
			right++;
			while (true)
			{
				int num = 0;
				TValue val2 = default(TValue);
				TKey val3 = default(TKey);
				do
				{
					left++;
					val2 = UnsafeUtility.ReadArrayElement<TValue>(data, left);
					num = val.Get(ref val2).CompareTo(other);
				}
				while (num < 0);
				TValue val4 = default(TValue);
				TKey val5 = default(TKey);
				do
				{
					right--;
					val4 = UnsafeUtility.ReadArrayElement<TValue>(data, right);
					num = val.Get(ref val4).CompareTo(other);
				}
				while (num > 0);
				if (left >= right)
				{
					break;
				}
				UnsafeUtility.WriteArrayElement(data, right, val2);
				UnsafeUtility.WriteArrayElement(data, left, val4);
			}
			return right;
		}

		public unsafe static bool HaveDuplicates(int[] arr)
		{
			int* ptr = stackalloc int[arr.Length];
			arr.CopyTo(ptr, arr.Length);
			QuickSort<int>(arr.Length, ptr);
			for (int num = arr.Length - 1; num > 0; num--)
			{
				if (UnsafeUtility.ReadArrayElement<int>(ptr, num).CompareTo(UnsafeUtility.ReadArrayElement<int>(ptr, num - 1)) == 0)
				{
					return true;
				}
			}
			return false;
		}
	}
	[DebuggerDisplay("Size = {size} Capacity = {capacity}")]
	public class DynamicArray<T> where T : new()
	{
		public struct Iterator
		{
			private readonly DynamicArray<T> owner;

			private int index;

			public ref T Current => ref owner[index];

			public Iterator(DynamicArray<T> setOwner)
			{
				owner = setOwner;
				index = -1;
			}

			public bool MoveNext()
			{
				index++;
				return index < owner.size;
			}

			public void Reset()
			{
				index = -1;
			}
		}

		public struct RangeEnumerable
		{
			public struct RangeIterator
			{
				private readonly DynamicArray<T> owner;

				private int index;

				private int first;

				private int last;

				public ref T Current => ref owner[index];

				public RangeIterator(DynamicArray<T> setOwner, int first, int numItems)
				{
					owner = setOwner;
					this.first = first;
					index = first - 1;
					last = first + numItems;
				}

				public bool MoveNext()
				{
					index++;
					return index < last;
				}

				public void Reset()
				{
					index = first - 1;
				}
			}

			public RangeIterator iterator;

			public RangeIterator GetEnumerator()
			{
				return iterator;
			}
		}

		private T[] m_Array;

		public int size { get; private set; }

		public int capacity => m_Array.Length;

		public ref T this[int index] => ref m_Array[index];

		public DynamicArray()
		{
			m_Array = new T[32];
			size = 0;
		}

		public DynamicArray(int size)
		{
			m_Array = new T[size];
			this.size = size;
		}

		public void Clear()
		{
			size = 0;
		}

		public bool Contains(T item)
		{
			return IndexOf(item) != -1;
		}

		public int Add(in T value)
		{
			int num = size;
			if (num >= m_Array.Length)
			{
				T[] array = new T[m_Array.Length * 2];
				Array.Copy(m_Array, array, m_Array.Length);
				m_Array = array;
			}
			m_Array[num] = value;
			size++;
			BumpVersion();
			return num;
		}

		public void AddRange(DynamicArray<T> array)
		{
			Reserve(size + array.size, keepContent: true);
			for (int i = 0; i < array.size; i++)
			{
				m_Array[size++] = array[i];
			}
			BumpVersion();
		}

		public bool Remove(T item)
		{
			int num = IndexOf(item);
			if (num != -1)
			{
				RemoveAt(num);
				return true;
			}
			return false;
		}

		public void RemoveAt(int index)
		{
			if (index < 0 || index >= size)
			{
				throw new IndexOutOfRangeException();
			}
			if (index != size - 1)
			{
				Array.Copy(m_Array, index + 1, m_Array, index, size - index - 1);
			}
			size--;
			BumpVersion();
		}

		public void RemoveRange(int index, int count)
		{
			if (count != 0)
			{
				if (index < 0 || index >= size || count < 0 || index + count > size)
				{
					throw new ArgumentOutOfRangeException();
				}
				Array.Copy(m_Array, index + count, m_Array, index, size - index - count);
				size -= count;
				BumpVersion();
			}
		}

		public int FindIndex(int startIndex, int count, Predicate<T> match)
		{
			for (int i = startIndex; i < size; i++)
			{
				if (match(m_Array[i]))
				{
					return i;
				}
			}
			return -1;
		}

		public int IndexOf(T item, int index, int count)
		{
			int num = index;
			while (num < size && count > 0)
			{
				ref readonly T reference = ref m_Array[num];
				object obj = item;
				if (reference.Equals(obj))
				{
					return num;
				}
				num++;
				count--;
			}
			return -1;
		}

		public int IndexOf(T item, int index)
		{
			for (int i = index; i < size; i++)
			{
				ref readonly T reference = ref m_Array[i];
				object obj = item;
				if (reference.Equals(obj))
				{
					return i;
				}
			}
			return -1;
		}

		public int IndexOf(T item)
		{
			return IndexOf(item, 0);
		}

		public void Resize(int newSize, bool keepContent = false)
		{
			Reserve(newSize, keepContent);
			size = newSize;
			BumpVersion();
		}

		public void Reserve(int newCapacity, bool keepContent = false)
		{
			if (newCapacity > m_Array.Length)
			{
				if (keepContent)
				{
					T[] array = new T[newCapacity];
					Array.Copy(m_Array, array, m_Array.Length);
					m_Array = array;
				}
				else
				{
					m_Array = new T[newCapacity];
				}
			}
		}

		public static implicit operator T[](DynamicArray<T> array)
		{
			return array.m_Array;
		}

		public Iterator GetEnumerator()
		{
			return new Iterator(this);
		}

		public RangeEnumerable SubRange(int first, int numItems)
		{
			return new RangeEnumerable
			{
				iterator = new RangeEnumerable.RangeIterator(this, first, numItems)
			};
		}

		internal void BumpVersion()
		{
		}
	}
	public static class DynamicArrayExtensions
	{
		private static int Partition<T>(T[] data, int left, int right) where T : IComparable<T>, new()
		{
			T other = data[left];
			left--;
			right++;
			while (true)
			{
				int num = 0;
				T val = default(T);
				do
				{
					left++;
					val = data[left];
					num = val.CompareTo(other);
				}
				while (num < 0);
				T val2 = default(T);
				do
				{
					right--;
					val2 = data[right];
					num = val2.CompareTo(other);
				}
				while (num > 0);
				if (left >= right)
				{
					break;
				}
				data[right] = val;
				data[left] = val2;
			}
			return right;
		}

		private static void QuickSort<T>(T[] data, int left, int right) where T : IComparable<T>, new()
		{
			if (left < right)
			{
				int num = Partition(data, left, right);
				if (num >= 1)
				{
					QuickSort(data, left, num);
				}
				if (num + 1 < right)
				{
					QuickSort(data, num + 1, right);
				}
			}
		}

		public static void QuickSort<T>(this DynamicArray<T> array) where T : IComparable<T>, new()
		{
			QuickSort<T>(array, 0, array.size - 1);
			array.BumpVersion();
		}
	}
	public delegate float PerformDynamicRes();
	public enum DynamicResScalePolicyType
	{
		ReturnsPercentage,
		ReturnsMinMaxLerpFactor
	}
	public enum DynamicResScalerSlot
	{
		User,
		System,
		Count
	}
	public class DynamicResolutionHandler
	{
		private struct ScalerContainer
		{
			public DynamicResScalePolicyType type;

			public PerformDynamicRes method;
		}

		public enum UpsamplerScheduleType
		{
			BeforePost,
			AfterDepthOfField,
			AfterPost
		}

		private bool m_Enabled;

		private bool m_UseMipBias;

		private float m_MinScreenFraction;

		private float m_MaxScreenFraction;

		private float m_CurrentFraction;

		private bool m_ForcingRes;

		private bool m_CurrentCameraRequest;

		private float m_PrevFraction;

		private bool m_ForceSoftwareFallback;

		private bool m_RunUpscalerFilterOnFullResolution;

		private float m_PrevHWScaleWidth;

		private float m_PrevHWScaleHeight;

		private Vector2Int m_LastScaledSize;

		private static DynamicResScalerSlot s_ActiveScalerSlot = DynamicResScalerSlot.User;

		private static ScalerContainer[] s_ScalerContainers = new ScalerContainer[2]
		{
			new ScalerContainer
			{
				type = DynamicResScalePolicyType.ReturnsMinMaxLerpFactor,
				method = DefaultDynamicResMethod
			},
			new ScalerContainer
			{
				type = DynamicResScalePolicyType.ReturnsMinMaxLerpFactor,
				method = DefaultDynamicResMethod
			}
		};

		private Vector2Int cachedOriginalSize;

		private static Dictionary<int, DynamicResUpscaleFilter> s_CameraUpscaleFilters = new Dictionary<int, DynamicResUpscaleFilter>();

		private DynamicResolutionType type;

		private GlobalDynamicResolutionSettings m_CachedSettings = GlobalDynamicResolutionSettings.NewDefault();

		private const int CameraDictionaryMaxcCapacity = 32;

		private WeakReference m_OwnerCameraWeakRef;

		private static Dictionary<int, DynamicResolutionHandler> s_CameraInstances = new Dictionary<int, DynamicResolutionHandler>(32);

		private static DynamicResolutionHandler s_DefaultInstance = new DynamicResolutionHandler();

		private static int s_ActiveCameraId = 0;

		private static DynamicResolutionHandler s_ActiveInstance = s_DefaultInstance;

		private static bool s_ActiveInstanceDirty = true;

		private static float s_GlobalHwFraction = 1f;

		private static bool s_GlobalHwUpresActive = false;

		private UpsamplerScheduleType m_UpsamplerSchedule = UpsamplerScheduleType.AfterPost;

		public DynamicResUpscaleFilter filter { get; private set; }

		public Vector2Int finalViewport { get; set; }

		public bool runUpscalerFilterOnFullResolution
		{
			get
			{
				if (!m_RunUpscalerFilterOnFullResolution)
				{
					return filter == DynamicResUpscaleFilter.EdgeAdaptiveScalingUpres;
				}
				return true;
			}
			set
			{
				m_RunUpscalerFilterOnFullResolution = value;
			}
		}

		public UpsamplerScheduleType upsamplerSchedule
		{
			get
			{
				return m_UpsamplerSchedule;
			}
			set
			{
				m_UpsamplerSchedule = value;
			}
		}

		public static DynamicResolutionHandler instance => s_ActiveInstance;

		private void Reset()
		{
			m_Enabled = false;
			m_UseMipBias = false;
			m_MinScreenFraction = 1f;
			m_MaxScreenFraction = 1f;
			m_CurrentFraction = 1f;
			m_ForcingRes = false;
			m_CurrentCameraRequest = true;
			m_PrevFraction = -1f;
			m_ForceSoftwareFallback = false;
			m_RunUpscalerFilterOnFullResolution = false;
			m_PrevHWScaleWidth = 1f;
			m_PrevHWScaleHeight = 1f;
			m_LastScaledSize = new Vector2Int(0, 0);
			filter = DynamicResUpscaleFilter.CatmullRom;
		}

		private bool FlushScalableBufferManagerState()
		{
			if (s_GlobalHwUpresActive == HardwareDynamicResIsEnabled() && s_GlobalHwFraction == m_CurrentFraction)
			{
				return false;
			}
			s_GlobalHwUpresActive = HardwareDynamicResIsEnabled();
			s_GlobalHwFraction = m_CurrentFraction;
			float num = (s_GlobalHwUpresActive ? s_GlobalHwFraction : 1f);
			ScalableBufferManager.ResizeBuffers(num, num);
			return true;
		}

		private static DynamicResolutionHandler GetOrCreateDrsInstanceHandler(Camera camera)
		{
			if (camera == null)
			{
				return null;
			}
			DynamicResolutionHandler value = null;
			int instanceID = camera.GetInstanceID();
			if (!s_CameraInstances.TryGetValue(instanceID, out value))
			{
				if (s_CameraInstances.Count >= 32)
				{
					int key = 0;
					DynamicResolutionHandler dynamicResolutionHandler = null;
					foreach (KeyValuePair<int, DynamicResolutionHandler> s_CameraInstance in s_CameraInstances)
					{
						if (s_CameraInstance.Value.m_OwnerCameraWeakRef == null || !s_CameraInstance.Value.m_OwnerCameraWeakRef.IsAlive)
						{
							dynamicResolutionHandler = s_CameraInstance.Value;
							key = s_CameraInstance.Key;
							break;
						}
					}
					if (dynamicResolutionHandler != null)
					{
						value = dynamicResolutionHandler;
						s_CameraInstances.Remove(key);
						s_CameraUpscaleFilters.Remove(key);
					}
				}
				if (value == null)
				{
					value = new DynamicResolutionHandler();
					value.m_OwnerCameraWeakRef = new WeakReference(camera);
				}
				else
				{
					value.Reset();
					value.m_OwnerCameraWeakRef.Target = camera;
				}
				s_CameraInstances.Add(instanceID, value);
			}
			return value;
		}

		private DynamicResolutionHandler()
		{
			Reset();
		}

		private static float DefaultDynamicResMethod()
		{
			return 1f;
		}

		private void ProcessSettings(GlobalDynamicResolutionSettings settings)
		{
			m_Enabled = settings.enabled && (Application.isPlaying || settings.forceResolution);
			if (!m_Enabled)
			{
				m_CurrentFraction = 1f;
			}
			else
			{
				type = settings.dynResType;
				m_UseMipBias = settings.useMipBias;
				float minScreenFraction = Mathf.Clamp(settings.minPercentage / 100f, 0.1f, 1f);
				m_MinScreenFraction = minScreenFraction;
				float maxScreenFraction = Mathf.Clamp(settings.maxPercentage / 100f, m_MinScreenFraction, 3f);
				m_MaxScreenFraction = maxScreenFraction;
				DynamicResUpscaleFilter value;
				bool flag = s_CameraUpscaleFilters.TryGetValue(s_ActiveCameraId, out value);
				filter = (flag ? value : settings.upsampleFilter);
				m_ForcingRes = settings.forceResolution;
				if (m_ForcingRes)
				{
					float currentFraction = Mathf.Clamp(settings.forcedPercentage / 100f, 0.1f, 1.5f);
					m_CurrentFraction = currentFraction;
				}
			}
			m_CachedSettings = settings;
		}

		public Vector2 GetResolvedScale()
		{
			if (!m_Enabled || !m_CurrentCameraRequest)
			{
				return new Vector2(1f, 1f);
			}
			float x = m_CurrentFraction;
			float y = m_CurrentFraction;
			if (!m_ForceSoftwareFallback && type == DynamicResolutionType.Hardware)
			{
				x = ScalableBufferManager.widthScaleFactor;
				y = ScalableBufferManager.heightScaleFactor;
			}
			return new Vector2(x, y);
		}

		public float CalculateMipBias(Vector2Int inputResolution, Vector2Int outputResolution, bool forceApply = false)
		{
			if (!m_UseMipBias && !forceApply)
			{
				return 0f;
			}
			return (float)Math.Log((double)inputResolution.x / (double)outputResolution.x, 2.0);
		}

		public static void SetDynamicResScaler(PerformDynamicRes scaler, DynamicResScalePolicyType scalerType = DynamicResScalePolicyType.ReturnsMinMaxLerpFactor)
		{
			s_ScalerContainers[0] = new ScalerContainer
			{
				type = scalerType,
				method = scaler
			};
		}

		public static void SetSystemDynamicResScaler(PerformDynamicRes scaler, DynamicResScalePolicyType scalerType = DynamicResScalePolicyType.ReturnsMinMaxLerpFactor)
		{
			s_ScalerContainers[1] = new ScalerContainer
			{
				type = scalerType,
				method = scaler
			};
		}

		public static void SetActiveDynamicScalerSlot(DynamicResScalerSlot slot)
		{
			s_ActiveScalerSlot = slot;
		}

		public static void ClearSelectedCamera()
		{
			s_ActiveInstance = s_DefaultInstance;
			s_ActiveCameraId = 0;
			s_ActiveInstanceDirty = true;
		}

		public static void SetUpscaleFilter(Camera camera, DynamicResUpscaleFilter filter)
		{
			int instanceID = camera.GetInstanceID();
			if (s_CameraUpscaleFilters.ContainsKey(instanceID))
			{
				s_CameraUpscaleFilters[instanceID] = filter;
			}
			else
			{
				s_CameraUpscaleFilters.Add(instanceID, filter);
			}
		}

		public void SetCurrentCameraRequest(bool cameraRequest)
		{
			m_CurrentCameraRequest = cameraRequest;
		}

		public static void UpdateAndUseCamera(Camera camera, GlobalDynamicResolutionSettings? settings = null, Action OnResolutionChange = null)
		{
			int num;
			if (camera == null)
			{
				s_ActiveInstance = s_DefaultInstance;
				num = 0;
			}
			else
			{
				s_ActiveInstance = GetOrCreateDrsInstanceHandler(camera);
				num = camera.GetInstanceID();
			}
			s_ActiveInstanceDirty = num != s_ActiveCameraId;
			s_ActiveCameraId = num;
			s_ActiveInstance.Update(settings.HasValue ? settings.Value : s_ActiveInstance.m_CachedSettings, OnResolutionChange);
		}

		public void Update(GlobalDynamicResolutionSettings settings, Action OnResolutionChange = null)
		{
			ProcessSettings(settings);
			if (!m_Enabled || !s_ActiveInstanceDirty)
			{
				FlushScalableBufferManagerState();
				s_ActiveInstanceDirty = false;
				return;
			}
			if (!m_ForcingRes)
			{
				ref ScalerContainer reference = ref s_ScalerContainers[(int)s_ActiveScalerSlot];
				if (reference.type == DynamicResScalePolicyType.ReturnsMinMaxLerpFactor)
				{
					float t = Mathf.Clamp(reference.method(), 0f, 1f);
					m_CurrentFraction = Mathf.Lerp(m_MinScreenFraction, m_MaxScreenFraction, t);
				}
				else if (reference.type == DynamicResScalePolicyType.ReturnsPercentage)
				{
					float num = Mathf.Max(reference.method(), 5f);
					m_CurrentFraction = Mathf.Clamp(num / 100f, m_MinScreenFraction, m_MaxScreenFraction);
				}
			}
			bool flag = false;
			bool num2 = m_CurrentFraction != m_PrevFraction;
			m_PrevFraction = m_CurrentFraction;
			if (!m_ForceSoftwareFallback && type == DynamicResolutionType.Hardware)
			{
				flag = FlushScalableBufferManagerState();
				if (ScalableBufferManager.widthScaleFactor != m_PrevHWScaleWidth || ScalableBufferManager.heightScaleFactor != m_PrevHWScaleHeight)
				{
					flag = true;
				}
			}
			if (num2 || flag)
			{
				OnResolutionChange?.Invoke();
			}
			s_ActiveInstanceDirty = false;
			m_PrevHWScaleWidth = ScalableBufferManager.widthScaleFactor;
			m_PrevHWScaleHeight = ScalableBufferManager.heightScaleFactor;
		}

		public bool SoftwareDynamicResIsEnabled()
		{
			if (m_CurrentCameraRequest && m_Enabled && (m_CurrentFraction != 1f || runUpscalerFilterOnFullResolution))
			{
				if (!m_ForceSoftwareFallback)
				{
					return type == DynamicResolutionType.Software;
				}
				return true;
			}
			return false;
		}

		public bool HardwareDynamicResIsEnabled()
		{
			if (!m_ForceSoftwareFallback && m_CurrentCameraRequest && m_Enabled)
			{
				return type == DynamicResolutionType.Hardware;
			}
			return false;
		}

		public bool RequestsHardwareDynamicResolution()
		{
			if (m_ForceSoftwareFallback)
			{
				return false;
			}
			return type == DynamicResolutionType.Hardware;
		}

		public bool DynamicResolutionEnabled()
		{
			if (m_CurrentCameraRequest && m_Enabled)
			{
				if (m_CurrentFraction == 1f)
				{
					return runUpscalerFilterOnFullResolution;
				}
				return true;
			}
			return false;
		}

		public void ForceSoftwareFallback()
		{
			m_ForceSoftwareFallback = true;
		}

		public Vector2Int GetScaledSize(Vector2Int size)
		{
			cachedOriginalSize = size;
			if (!m_Enabled || !m_CurrentCameraRequest)
			{
				return size;
			}
			return m_LastScaledSize = ApplyScalesOnSize(size);
		}

		public Vector2Int ApplyScalesOnSize(Vector2Int size)
		{
			return ApplyScalesOnSize(size, GetResolvedScale());
		}

		internal Vector2Int ApplyScalesOnSize(Vector2Int size, Vector2 scales)
		{
			Vector2Int result = new Vector2Int(Mathf.CeilToInt((float)size.x * scales.x), Mathf.CeilToInt((float)size.y * scales.y));
			if (m_ForceSoftwareFallback || type != DynamicResolutionType.Hardware)
			{
				result.x += 1 & result.x;
				result.y += 1 & result.y;
			}
			result.x = Math.Min(result.x, size.x);
			result.y = Math.Min(result.y, size.y);
			return result;
		}

		public float GetCurrentScale()
		{
			if (!m_Enabled || !m_CurrentCameraRequest)
			{
				return 1f;
			}
			return m_CurrentFraction;
		}

		public Vector2Int GetLastScaledSize()
		{
			return m_LastScaledSize;
		}

		public float GetLowResMultiplier(float targetLowRes)
		{
			return GetLowResMultiplier(targetLowRes, m_CachedSettings.lowResTransparencyMinimumThreshold);
		}

		public float GetLowResMultiplier(float targetLowRes, float minimumThreshold)
		{
			if (!m_Enabled)
			{
				return targetLowRes;
			}
			float num = Math.Min(minimumThreshold / 100f, targetLowRes);
			if (targetLowRes * m_CurrentFraction >= num)
			{
				return targetLowRes;
			}
			return Mathf.Clamp(num / m_CurrentFraction, 0f, 1f);
		}
	}
	public enum DynamicResolutionType : byte
	{
		Software,
		Hardware
	}
	public enum DynamicResUpscaleFilter : byte
	{
		[Obsolete("Bilinear upscale filter is considered obsolete and is not supported anymore, please use CatmullRom for a very cheap, but blurry filter.", false)]
		Bilinear,
		CatmullRom,
		[Obsolete("Lanczos upscale filter is considered obsolete and is not supported anymore, please use Contrast Adaptive Sharpening for very sharp filter or FidelityFX Super Resolution 1.0.", false)]
		Lanczos,
		ContrastAdaptiveSharpen,
		[InspectorName("FidelityFX Super Resolution 1.0")]
		EdgeAdaptiveScalingUpres,
		[InspectorName("TAA Upscale")]
		TAAU
	}
	[Serializable]
	public struct GlobalDynamicResolutionSettings
	{
		public bool enabled;

		public bool useMipBias;

		public bool enableDLSS;

		public uint DLSSPerfQualitySetting;

		public DynamicResolutionHandler.UpsamplerScheduleType DLSSInjectionPoint;

		public bool DLSSUseOptimalSettings;

		[Range(0f, 1f)]
		public float DLSSSharpness;

		public bool fsrOverrideSharpness;

		[Range(0f, 1f)]
		public float fsrSharpness;

		public float maxPercentage;

		public float minPercentage;

		public DynamicResolutionType dynResType;

		public DynamicResUpscaleFilter upsampleFilter;

		public bool forceResolution;

		public float forcedPercentage;

		public float lowResTransparencyMinimumThreshold;

		public float rayTracingHalfResThreshold;

		public float lowResSSGIMinimumThreshold;

		public float lowResVolumetricCloudsMinimumThreshold;

		public static GlobalDynamicResolutionSettings NewDefault()
		{
			return new GlobalDynamicResolutionSettings
			{
				useMipBias = false,
				maxPercentage = 100f,
				minPercentage = 100f,
				dynResType = DynamicResolutionType.Hardware,
				upsampleFilter = DynamicResUpscaleFilter.CatmullRom,
				forcedPercentage = 100f,
				lowResTransparencyMinimumThreshold = 0f,
				lowResVolumetricCloudsMinimumThreshold = 50f,
				rayTracingHalfResThreshold = 50f,
				enableDLSS = false,
				DLSSUseOptimalSettings = true,
				DLSSPerfQualitySetting = 0u,
				DLSSSharpness = 0.5f,
				DLSSInjectionPoint = DynamicResolutionHandler.UpsamplerScheduleType.BeforePost,
				fsrOverrideSharpness = false,
				fsrSharpness = 0.92f
			};
		}
	}
	public interface IAdditionalData
	{
	}
	public interface IVirtualTexturingEnabledRenderPipeline
	{
		bool virtualTexturingEnabled { get; }
	}
	public struct ListBuffer<T> where T : unmanaged
	{
		private unsafe T* m_BufferPtr;

		private int m_Capacity;

		private unsafe int* m_CountPtr;

		internal unsafe T* BufferPtr => m_BufferPtr;

		public unsafe int Count => *m_CountPtr;

		public int Capacity => m_Capacity;

		public unsafe ref T this[in int index]
		{
			get
			{
				if (index < 0 || index >= Count)
				{
					throw new IndexOutOfRangeException($"Expected a value between 0 and {Count}, but received {index}.");
				}
				return ref m_BufferPtr[index];
			}
		}

		public unsafe ListBuffer(T* bufferPtr, int* countPtr, int capacity)
		{
			m_BufferPtr = bufferPtr;
			m_Capacity = capacity;
			m_CountPtr = countPtr;
		}

		public unsafe ref T GetUnchecked(in int index)
		{
			return ref m_BufferPtr[index];
		}

		public unsafe bool TryAdd(in T value)
		{
			if (Count >= m_Capacity)
			{
				return false;
			}
			m_BufferPtr[Count] = value;
			(*m_CountPtr)++;
			return true;
		}

		public unsafe void CopyTo(T* dstBuffer, int startDstIndex, int copyCount)
		{
			UnsafeUtility.MemCpy(dstBuffer + startDstIndex, m_BufferPtr, UnsafeUtility.SizeOf<T>() * copyCount);
		}

		public unsafe bool TryCopyTo(ListBuffer<T> other)
		{
			if (other.Count + Count >= other.m_Capacity)
			{
				return false;
			}
			UnsafeUtility.MemCpy(other.m_BufferPtr + other.Count, m_BufferPtr, UnsafeUtility.SizeOf<T>() * Count);
			*other.m_CountPtr += Count;
			return true;
		}

		public unsafe bool TryCopyFrom(T* srcPtr, int count)
		{
			if (count + Count > m_Capacity)
			{
				return false;
			}
			UnsafeUtility.MemCpy(m_BufferPtr + Count, srcPtr, UnsafeUtility.SizeOf<T>() * count);
			*m_CountPtr += count;
			return true;
		}
	}
	public static class ListBufferExtensions
	{
		public unsafe static void QuickSort<T>(this ListBuffer<T> self) where T : unmanaged, IComparable<T>
		{
			CoreUnsafeUtils.QuickSort<int>(self.Count, self.BufferPtr);
		}
	}
	public class ObjectPool<T> where T : new()
	{
		public struct PooledObject : IDisposable
		{
			private readonly T m_ToReturn;

			private readonly ObjectPool<T> m_Pool;

			internal PooledObject(T value, ObjectPool<T> pool)
			{
				m_ToReturn = value;
				m_Pool = pool;
			}

			void IDisposable.Dispose()
			{
				m_Pool.Release(m_ToReturn);
			}
		}

		private readonly Stack<T> m_Stack = new Stack<T>();

		private readonly UnityAction<T> m_ActionOnGet;

		private readonly UnityAction<T> m_ActionOnRelease;

		private readonly bool m_CollectionCheck = true;

		public int countAll { get; private set; }

		public int countActive => countAll - countInactive;

		public int countInactive => m_Stack.Count;

		public ObjectPool(UnityAction<T> actionOnGet, UnityAction<T> actionOnRelease, bool collectionCheck = true)
		{
			m_ActionOnGet = actionOnGet;
			m_ActionOnRelease = actionOnRelease;
			m_CollectionCheck = collectionCheck;
		}

		public T Get()
		{
			T val;
			if (m_Stack.Count == 0)
			{
				val = new T();
				countAll++;
			}
			else
			{
				val = m_Stack.Pop();
			}
			if (m_ActionOnGet != null)
			{
				m_ActionOnGet(val);
			}
			return val;
		}

		public PooledObject Get(out T v)
		{
			return new PooledObject(v = Get(), this);
		}

		public void Release(T element)
		{
			if (m_ActionOnRelease != null)
			{
				m_ActionOnRelease(element);
			}
			m_Stack.Push(element);
		}
	}
	public static class GenericPool<T> where T : new()
	{
		private static readonly ObjectPool<T> s_Pool = new ObjectPool<T>(null, null);

		public static T Get()
		{
			return s_Pool.Get();
		}

		public static ObjectPool<T>.PooledObject Get(out T value)
		{
			return s_Pool.Get(out value);
		}

		public static void Release(T toRelease)
		{
			s_Pool.Release(toRelease);
		}
	}
	public static class UnsafeGenericPool<T> where T : new()
	{
		private static readonly ObjectPool<T> s_Pool = new ObjectPool<T>(null, null, collectionCheck: false);

		public static T Get()
		{
			return s_Pool.Get();
		}

		public static ObjectPool<T>.PooledObject Get(out T value)
		{
			return s_Pool.Get(out value);
		}

		public static void Release(T toRelease)
		{
			s_Pool.Release(toRelease);
		}
	}
	public static class ListPool<T>
	{
		private static readonly ObjectPool<List<T>> s_Pool = new ObjectPool<List<T>>(null, delegate(List<T> l)
		{
			l.Clear();
		});

		public static List<T> Get()
		{
			return s_Pool.Get();
		}

		public static ObjectPool<List<T>>.PooledObject Get(out List<T> value)
		{
			return s_Pool.Get(out value);
		}

		public static void Release(List<T> toRelease)
		{
			s_Pool.Release(toRelease);
		}
	}
	public static class HashSetPool<T>
	{
		private static readonly ObjectPool<HashSet<T>> s_Pool = new ObjectPool<HashSet<T>>(null, delegate(HashSet<T> l)
		{
			l.Clear();
		});

		public static HashSet<T> Get()
		{
			return s_Pool.Get();
		}

		public static ObjectPool<HashSet<T>>.PooledObject Get(out HashSet<T> value)
		{
			return s_Pool.Get(out value);
		}

		public static void Release(HashSet<T> toRelease)
		{
			s_Pool.Release(toRelease);
		}
	}
	public static class DictionaryPool<TKey, TValue>
	{
		private static readonly ObjectPool<Dictionary<TKey, TValue>> s_Pool = new ObjectPool<Dictionary<TKey, TValue>>(null, delegate(Dictionary<TKey, TValue> l)
		{
			l.Clear();
		});

		public static Dictionary<TKey, TValue> Get()
		{
			return s_Pool.Get();
		}

		public static ObjectPool<Dictionary<TKey, TValue>>.PooledObject Get(out Dictionary<TKey, TValue> value)
		{
			return s_Pool.Get(out value);
		}

		public static void Release(Dictionary<TKey, TValue> toRelease)
		{
			s_Pool.Release(toRelease);
		}
	}
	public sealed class ListChangedEventArgs<T> : EventArgs
	{
		public readonly int index;

		public readonly T item;

		public ListChangedEventArgs(int index, T item)
		{
			this.index = index;
			this.item = item;
		}
	}
	public delegate void ListChangedEventHandler<T>(ObservableList<T> sender, ListChangedEventArgs<T> e);
	public class ObservableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		private IList<T> m_List;

		public T this[int index]
		{
			get
			{
				return m_List[index];
			}
			set
			{
				OnEvent(this.ItemRemoved, index, m_List[index]);
				m_List[index] = value;
				OnEvent(this.ItemAdded, index, value);
			}
		}

		public int Count => m_List.Count;

		public bool IsReadOnly => false;

		public event ListChangedEventHandler<T> ItemAdded;

		public event ListChangedEventHandler<T> ItemRemoved;

		public ObservableList()
			: this(0)
		{
		}

		public ObservableList(int capacity)
		{
			m_List = new List<T>(capacity);
		}

		public ObservableList(IEnumerable<T> collection)
		{
			m_List = new List<T>(collection);
		}

		private void OnEvent(ListChangedEventHandler<T> e, int index, T item)
		{
			e?.Invoke(this, new ListChangedEventArgs<T>(index, item));
		}

		public bool Contains(T item)
		{
			return m_List.Contains(item);
		}

		public int IndexOf(T item)
		{
			return m_List.IndexOf(item);
		}

		public void Add(T item)
		{
			m_List.Add(item);
			OnEvent(this.ItemAdded, m_List.IndexOf(item), item);
		}

		public void Add(params T[] items)
		{
			foreach (T item in items)
			{
				Add(item);
			}
		}

		public void Insert(int index, T item)
		{
			m_List.Insert(index, item);
			OnEvent(this.ItemAdded, index, item);
		}

		public bool Remove(T item)
		{
			int index = m_List.IndexOf(item);
			bool num = m_List.Remove(item);
			if (num)
			{
				OnEvent(this.ItemRemoved, index, item);
			}
			return num;
		}

		public int Remove(params T[] items)
		{
			if (items == null)
			{
				return 0;
			}
			int num = 0;
			foreach (T item in items)
			{
				num += (Remove(item) ? 1 : 0);
			}
			return num;
		}

		public void RemoveAt(int index)
		{
			T item = m_List[index];
			m_List.RemoveAt(index);
			OnEvent(this.ItemRemoved, index, item);
		}

		public void Clear()
		{
			while (Count > 0)
			{
				RemoveAt(Count - 1);
			}
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			m_List.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return m_List.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	public static class RemoveRangeExtensions
	{
		[CollectionAccess(CollectionAccessType.ModifyExistingContent)]
		[MustUseReturnValue]
		public static bool TryRemoveElementsInRange<TValue>([DisallowNull] this IList<TValue> list, int index, int count, [NotNullWhen(false)] out Exception error)
		{
			try
			{
				if (list is List<TValue> list2)
				{
					list2.RemoveRange(index, count);
				}
				else
				{
					if (index < 0)
					{
						throw new ArgumentOutOfRangeException("index");
					}
					if (count < 0)
					{
						throw new ArgumentOutOfRangeException("count");
					}
					if (list.Count - index < count)
					{
						throw new ArgumentException("index and count do not denote a valid range of elements in the list");
					}
					for (int num = count; num > 0; num--)
					{
						list.RemoveAt(index);
					}
				}
			}
			catch (Exception ex)
			{
				error = ex;
				return false;
			}
			error = null;
			return true;
		}
	}
	[Serializable]
	public class SerializableEnum
	{
		[SerializeField]
		private string m_EnumValueAsString;

		[SerializeField]
		private string m_EnumTypeAsString;

		public Enum value
		{
			get
			{
				if (string.IsNullOrEmpty(m_EnumTypeAsString) || !Enum.TryParse(Type.GetType(m_EnumTypeAsString), m_EnumValueAsString, out var result))
				{
					return null;
				}
				return (Enum)result;
			}
			set
			{
				m_EnumValueAsString = value.ToString();
			}
		}

		public SerializableEnum(Type enumType)
		{
			m_EnumTypeAsString = enumType.AssemblyQualifiedName;
			m_EnumValueAsString = Enum.GetNames(enumType)[0];
		}
	}
	[Serializable]
	public class SerializedDictionary<K, V> : SerializedDictionary<K, V, K, V>
	{
		public override K SerializeKey(K key)
		{
			return key;
		}

		public override V SerializeValue(V val)
		{
			return val;
		}

		public override K DeserializeKey(K key)
		{
			return key;
		}

		public override V DeserializeValue(V val)
		{
			return val;
		}
	}
	[Serializable]
	public abstract class SerializedDictionary<K, V, SK, SV> : Dictionary<K, V>, ISerializationCallbackReceiver
	{
		[SerializeField]
		private List<SK> m_Keys = new List<SK>();

		[SerializeField]
		private List<SV> m_Values = new List<SV>();

		public abstract SK SerializeKey(K key);

		public abstract SV SerializeValue(V value);

		public abstract K DeserializeKey(SK serializedKey);

		public abstract V DeserializeValue(SV serializedValue);

		public void OnBeforeSerialize()
		{
			m_Keys.Clear();
			m_Values.Clear();
			using Enumerator enumerator = GetEnumerator();
			while (enumerator.MoveNext())
			{
				KeyValuePair<K, V> current = enumerator.Current;
				m_Keys.Add(SerializeKey(current.Key));
				m_Values.Add(SerializeValue(current.Value));
			}
		}

		public void OnAfterDeserialize()
		{
			for (int i = 0; i < m_Keys.Count; i++)
			{
				Add(DeserializeKey(m_Keys[i]), DeserializeValue(m_Values[i]));
			}
			m_Keys.Clear();
			m_Values.Clear();
		}
	}
	public static class SwapCollectionExtensions
	{
		[CollectionAccess(CollectionAccessType.ModifyExistingContent)]
		[MustUseReturnValue]
		public static bool TrySwap<TValue>([DisallowNull] this IList<TValue> list, int from, int to, [NotNullWhen(false)] out Exception error)
		{
			error = null;
			if (list == null)
			{
				error = new ArgumentNullException("list");
			}
			else
			{
				if (from < 0 || from >= list.Count)
				{
					error = new ArgumentOutOfRangeException("from");
				}
				if (to < 0 || to >= list.Count)
				{
					error = new ArgumentOutOfRangeException("to");
				}
			}
			if (error != null)
			{
				return false;
			}
			TValue val = list[from];
			TValue val2 = list[to];
			TValue val3 = (list[to] = val);
			val3 = (list[from] = val2);
			return true;
		}
	}
	[Serializable]
	public class XRGraphics
	{
		public enum StereoRenderingMode
		{
			MultiPass,
			SinglePass,
			SinglePassInstanced,
			SinglePassMultiView
		}

		public static float eyeTextureResolutionScale
		{
			get
			{
				return 1f;
			}
			set
			{
			}
		}

		public static float renderViewportScale => 1f;

		public static bool enabled => false;

		public static bool isDeviceActive => false;

		public static string loadedDeviceName => "No XR device loaded";

		public static string[] supportedDevices => new string[1];

		public static StereoRenderingMode stereoRenderingMode => StereoRenderingMode.SinglePass;

		public static RenderTextureDescriptor eyeTextureDesc => new RenderTextureDescriptor(0, 0);

		public static int eyeTextureWidth => 0;

		public static int eyeTextureHeight => 0;
	}
	public abstract class DebugDisplaySettings<T> : IDebugDisplaySettings, IDebugDisplaySettingsQuery where T : IDebugDisplaySettings, new()
	{
		protected readonly HashSet<IDebugDisplaySettingsData> m_Settings = new HashSet<IDebugDisplaySettingsData>();

		private static readonly Lazy<T> s_Instance = new Lazy<T>(delegate
		{
			T result = new T();
			result.Reset();
			return result;
		});

		public static T Instance => s_Instance.Value;

		public virtual bool AreAnySettingsActive
		{
			get
			{
				foreach (IDebugDisplaySettingsData setting in m_Settings)
				{
					if (setting.AreAnySettingsActive)
					{
						return true;
					}
				}
				return false;
			}
		}

		public virtual bool IsPostProcessingAllowed
		{
			get
			{
				bool flag = true;
				foreach (IDebugDisplaySettingsData setting in m_Settings)
				{
					flag &= setting.IsPostProcessingAllowed;
				}
				return flag;
			}
		}

		public virtual bool IsLightingActive
		{
			get
			{
				bool flag = true;
				foreach (IDebugDisplaySettingsData setting in m_Settings)
				{
					flag &= setting.IsLightingActive;
				}
				return flag;
			}
		}

		protected TData Add<TData>(TData newData) where TData : IDebugDisplaySettingsData
		{
			m_Settings.Add(newData);
			return newData;
		}

		public void ForEach(Action<IDebugDisplaySettingsData> onExecute)
		{
			foreach (IDebugDisplaySettingsData setting in m_Settings)
			{
				onExecute(setting);
			}
		}

		public virtual void Reset()
		{
			m_Settings.Clear();
		}

		public virtual bool TryGetScreenClearColor(ref Color color)
		{
			foreach (IDebugDisplaySettingsData setting in m_Settings)
			{
				if (setting.TryGetScreenClearColor(ref color))
				{
					return true;
				}
			}
			return false;
		}
	}
	public abstract class DebugDisplaySettingsPanel : IDebugDisplaySettingsPanelDisposable, IDebugDisplaySettingsPanel, IDisposable
	{
		private readonly List<DebugUI.Widget> m_Widgets = new List<DebugUI.Widget>();

		private readonly DisplayInfoAttribute m_DisplayInfo;

		public virtual string PanelName => m_DisplayInfo?.name ?? string.Empty;

		public virtual int Order => m_DisplayInfo?.order ?? 0;

		public DebugUI.Widget[] Widgets => m_Widgets.ToArray();

		public virtual DebugUI.Flags Flags => DebugUI.Flags.None;

		protected void AddWidget(DebugUI.Widget widget)
		{
			if (widget == null)
			{
				throw new ArgumentNullException("widget");
			}
			m_Widgets.Add(widget);
		}

		protected void Clear()
		{
			m_Widgets.Clear();
		}

		public void Dispose()
		{
			Clear();
		}

		protected DebugDisplaySettingsPanel()
		{
			m_DisplayInfo = GetType().GetCustomAttribute<DisplayInfoAttribute>();
			if (m_DisplayInfo == null)
			{
				Debug.Log(string.Format("Type {0} should specify the attribute {1}", GetType(), "DisplayInfoAttribute"));
			}
		}
	}
	public abstract class DebugDisplaySettingsPanel<T> : DebugDisplaySettingsPanel where T : IDebugDisplaySettingsData
	{
		internal T m_Data;

		public T data
		{
			get
			{
				return m_Data;
			}
			internal set
			{
				m_Data = value;
			}
		}

		protected DebugDisplaySettingsPanel(T data)
		{
			m_Data = data;
		}
	}
	public class DebugDisplaySettingsUI : IDebugData
	{
		private IEnumerable<IDebugDisplaySettingsPanelDisposable> m_DisposablePanels;

		private IDebugDisplaySettings m_Settings;

		private void Reset()
		{
			if (m_Settings != null)
			{
				m_Settings.Reset();
				UnregisterDebug();
				RegisterDebug(m_Settings);
				DebugManager.instance.RefreshEditor();
			}
		}

		public void RegisterDebug(IDebugDisplaySettings settings)
		{
			DebugManager debugManager = DebugManager.instance;
			List<IDebugDisplaySettingsPanelDisposable> panels = new List<IDebugDisplaySettingsPanelDisposable>();
			debugManager.RegisterData(this);
			m_Settings = settings;
			m_DisposablePanels = panels;
			Action<IDebugDisplaySettingsData> onExecute = delegate(IDebugDisplaySettingsData data)
			{
				IDebugDisplaySettingsPanelDisposable debugDisplaySettingsPanelDisposable = data.CreatePanel();
				DebugUI.Widget[] widgets = debugDisplaySettingsPanelDisposable.Widgets;
				DebugUI.Panel panel = debugManager.GetPanel(debugDisplaySettingsPanelDisposable.PanelName, createIfNull: true, (debugDisplaySettingsPanelDisposable is DebugDisplaySettingsPanel debugDisplaySettingsPanel) ? debugDisplaySettingsPanel.Order : 0);
				ObservableList<DebugUI.Widget> children = panel.children;
				panel.flags = debugDisplaySettingsPanelDisposable.Flags;
				panels.Add(debugDisplaySettingsPanelDisposable);
				children.Add(widgets);
			};
			m_Settings.ForEach(onExecute);
		}

		public void UnregisterDebug()
		{
			DebugManager instance = DebugManager.instance;
			foreach (IDebugDisplaySettingsPanelDisposable disposablePanel in m_DisposablePanels)
			{
				DebugUI.Widget[] widgets = disposablePanel.Widgets;
				string panelName = disposablePanel.PanelName;
				ObservableList<DebugUI.Widget> children = instance.GetPanel(panelName, createIfNull: true).children;
				disposablePanel.Dispose();
				children.Remove(widgets);
			}
			m_DisposablePanels = null;
			instance.UnregisterData(this);
		}

		public Action GetReset()
		{
			return Reset;
		}
	}
	public class DebugDisplaySettingsVolume : IDebugDisplaySettingsData, IDebugDisplaySettingsQuery
	{
		private static class Styles
		{
			public static readonly GUIContent none = new GUIContent("None");

			public static readonly GUIContent editorCamera = new GUIContent("Editor Camera");
		}

		private static class Strings
		{
			public static readonly string none = "None";

			public static readonly string camera = "Camera";

			public static readonly string parameter = "Parameter";

			public static readonly string component = "Component";

			public static readonly string debugViewNotSupported = "Debug view not supported";

			public static readonly string volumeInfo = "Volume Info";

			public static readonly string interpolatedValue = "Interpolated Value";

			public static readonly string defaultValue = "Default Value";

			public static readonly string global = "Global";

			public static readonly string local = "Local";
		}

		internal static class WidgetFactory
		{
			public static DebugUI.EnumField CreateComponentSelector(SettingsPanel panel, Action<DebugUI.Field<int>, int> refresh)
			{
				int num = 0;
				List<GUIContent> list = new List<GUIContent> { Styles.none };
				List<int> list2 = new List<int> { num++ };
				foreach (var item in panel.data.volumeDebugSettings.volumeComponentsPathAndType)
				{
					GUIContent gUIContent = new GUIContent();
					(gUIContent.text, _) = item;
					list.Add(gUIContent);
					list2.Add(num++);
				}
				return new DebugUI.EnumField
				{
					displayName = Strings.component,
					getter = () => panel.data.volumeDebugSettings.selectedComponent,
					setter = delegate(int value)
					{
						panel.data.volumeDebugSettings.selectedComponent = value;
					},
					enumNames = list.ToArray(),
					enumValues = list2.ToArray(),
					getIndex = () => panel.data.volumeComponentEnumIndex,
					setIndex = delegate(int value)
					{
						panel.data.volumeComponentEnumIndex = value;
					},
					onValueChanged = refresh
				};
			}

			public static DebugUI.ObjectPopupField CreateCameraSelector(SettingsPanel panel, Action<DebugUI.Field<Object>, Object> refresh)
			{
				return new DebugUI.ObjectPopupField
				{
					displayName = Strings.camera,
					getter = () => panel.data.volumeDebugSettings.selectedCamera,
					setter = delegate(Object value)
					{
						Camera[] array = panel.data.volumeDebugSettings.cameras.ToArray();
						panel.data.volumeDebugSettings.selectedCameraIndex = Array.IndexOf(array, value as Camera);
					},
					getObjects = () => panel.data.volumeDebugSettings.cameras,
					onValueChanged = refresh
				};
			}

			private static DebugUI.Widget CreateVolumeParameterWidget(string name, VolumeParameter param, Func<bool> isHiddenCallback = null)
			{
				if (param == null)
				{
					return new DebugUI.Value
					{
						displayName = name,
						getter = () => "-"
					};
				}
				Type parameterType = param.GetType();
				if (parameterType == typeof(ColorParameter))
				{
					ColorParameter p = (ColorParameter)param;
					return new DebugUI.ColorField
					{
						displayName = name,
						hdr = p.hdr,
						showAlpha = p.showAlpha,
						getter = () => p.value,
						setter = delegate(Color value)
						{
							p.value = value;
						},
						isHiddenCallback = isHiddenCallback
					};
				}
				if (parameterType == typeof(BoolParameter))
				{
					BoolParameter p2 = (BoolParameter)param;
					return new DebugUI.BoolField
					{
						displayName = name,
						getter = () => p2.value,
						setter = delegate(bool value)
						{
							p2.value = value;
						},
						isHiddenCallback = isHiddenCallback
					};
				}
				Type[] genericTypeArguments = parameterType.GetTypeInfo().BaseType.GenericTypeArguments;
				if (genericTypeArguments.Length != 0 && genericTypeArguments[0].IsArray)
				{
					return new DebugUI.ObjectListField
					{
						displayName = name,
						getter = () => (Object[])parameterType.GetProperty("value").GetValue(param, null),
						type = parameterType
					};
				}
				PropertyInfo property = param.GetType().GetProperty("value");
				MethodInfo method = property.PropertyType.GetMethod("ToString", Type.EmptyTypes);
				if (method == null || method.DeclaringType == typeof(object) || method.DeclaringType == typeof(Object))
				{
					PropertyInfo nameProp = property.PropertyType.GetProperty("name");
					if (nameProp == null)
					{
						return new DebugUI.Value
						{
							displayName = name,
							getter = () => Strings.debugViewNotSupported
						};
					}
					return new DebugUI.Value
					{
						displayName = name,
						getter = delegate
						{
							object value = property.GetValue(param);
							return (value == null || value.Equals(null)) ? Strings.none : (nameProp.GetValue(value) ?? Strings.none);
						},
						isHiddenCallback = isHiddenCallback
					};
				}
				return new DebugUI.Value
				{
					displayName = name,
					getter = delegate
					{
						object value = property.GetValue(param);
						return (value != null) ? value.ToString() : Strings.none;
					},
					isHiddenCallback = isHiddenCallback
				};
			}

			public static DebugUI.Table CreateVolumeTable(DebugDisplaySettingsVolume data)
			{
				DebugUI.Table table = new DebugUI.Table
				{
					displayName = Strings.parameter,
					isReadOnly = true
				};
				Type selectedType = data.volumeDebugSettings.selectedComponentType;
				if (selectedType == null)
				{
					return table;
				}
				VolumeStack volumeStack = data.volumeDebugSettings.selectedCameraVolumeStack ?? VolumeManager.instance.stack;
				VolumeComponent stackComponent = volumeStack.GetComponent(selectedType);
				if (stackComponent == null)
				{
					return table;
				}
				Volume[] volumes = data.volumeDebugSettings.GetVolumes();
				VolumeComponent inst = (VolumeComponent)ScriptableObject.CreateInstance(selectedType);
				DebugUI.Table.Row row = new DebugUI.Table.Row
				{
					displayName = Strings.volumeInfo,
					opened = true,
					children = { (DebugUI.Widget)new DebugUI.Value
					{
						displayName = Strings.interpolatedValue,
						getter = () => string.Empty
					} }
				};
				DebugUI.Table.Row row2 = new DebugUI.Table.Row
				{
					displayName = "GameObject",
					children = { (DebugUI.Widget)new DebugUI.Value
					{
						getter = () => string.Empty
					} }
				};
				Volume[] array = volumes;
				foreach (Volume volume in array)
				{
					VolumeProfile volumeProfile = (volume.HasInstantiatedProfile() ? volume.profile : volume.sharedProfile);
					row.children.Add(new DebugUI.Value
					{
						displayName = volumeProfile.name,
						getter = delegate
						{
							string obj = (volume.isGlobal ? Strings.global : Strings.local);
							float volumeWeight = data.volumeDebugSettings.GetVolumeWeight(volume);
							return obj + " (" + volumeWeight * 100f + "%)";
						}
					});
					row2.children.Add(new DebugUI.ObjectField
					{
						displayName = volumeProfile.name,
						getter = () => volume
					});
				}
				row.children.Add(new DebugUI.Value
				{
					displayName = Strings.defaultValue,
					getter = () => string.Empty
				});
				table.children.Add(row);
				row2.children.Add(new DebugUI.Value
				{
					getter = () => string.Empty
				});
				table.children.Add(row2);
				List<DebugUI.Table.Row> rows = new List<DebugUI.Table.Row>();
				AddParameterRows(selectedType);
				foreach (DebugUI.Table.Row item in rows.OrderBy((DebugUI.Table.Row t) => t.displayName))
				{
					table.children.Add(item);
				}
				data.volumeDebugSettings.RefreshVolumes(volumes);
				for (int num2 = 0; num2 < volumes.Length; num2++)
				{
					table.SetColumnVisibility(num2 + 1, data.volumeDebugSettings.VolumeHasInfluence(volumes[num2]));
				}
				float timer = 0f;
				float refreshRate = 0.2f;
				table.isHiddenCallback = delegate
				{
					timer += Time.deltaTime;
					if (timer >= refreshRate)
					{
						if (data.volumeDebugSettings.selectedCamera != null)
						{
							Volume[] volumes2 = data.volumeDebugSettings.GetVolumes();
							if (!data.volumeDebugSettings.RefreshVolumes(volumes2))
							{
								for (int i = 0; i < volumes2.Length; i++)
								{
									bool visible = data.volumeDebugSettings.VolumeHasInfluence(volumes2[i]);
									table.SetColumnVisibility(i + 1, visible);
								}
							}
							if (!volumes.SequenceEqual(volumes2))
							{
								volumes = volumes2;
								DebugManager.instance.ReDrawOnScreenDebug();
							}
						}
						timer = 0f;
					}
					return false;
				};
				return table;
				int AddParameterRows(Type type, string baseName = null, int skip = 0)
				{
					foreach (FieldInfo item2 in from t in type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
						orderby t.MetadataToken
						select t)
					{
						if (item2.GetCustomAttributes(typeof(ObsoleteAttribute), inherit: false).Length != 0)
						{
							skip++;
						}
						else
						{
							Type fieldType = item2.FieldType;
							if (fieldType.IsSubclassOf(typeof(VolumeParameter)))
							{
								AddRow(item2, baseName ?? string.Empty, skip);
							}
							else if (!fieldType.IsArray && fieldType.IsClass)
							{
								skip += AddParameterRows(fieldType, baseName ?? (item2.Name + " "), skip);
							}
						}
					}
					return skip;
				}
				void AddRow(FieldInfo f, string prefix, int skip)
				{
					string displayName = prefix + f.Name;
					DisplayInfoAttribute[] array2 = (DisplayInfoAttribute[])f.GetCustomAttributes(typeof(DisplayInfoAttribute), inherit: true);
					if (array2.Length != 0)
					{
						displayName = prefix + array2[0].name;
					}
					int currentParam = rows.Count + skip;
					row = new DebugUI.Table.Row
					{
						displayName = displayName,
						children = { CreateVolumeParameterWidget(Strings.interpolatedValue, stackComponent.parameterList[currentParam]) }
					};
					Volume[] array3 = volumes;
					foreach (Volume volume2 in array3)
					{
						VolumeParameter param = null;
						VolumeProfile volumeProfile2 = (volume2.HasInstantiatedProfile() ? volume2.profile : volume2.sharedProfile);
						if (volumeProfile2.TryGet<VolumeComponent>(selectedType, out var component))
						{
							param = component.parameterList[currentParam];
						}
						row.children.Add(CreateVolumeParameterWidget(volume2.name + " (" + volumeProfile2.name + ")", param, () => !component.parameterList[currentParam].overrideState));
					}
					row.children.Add(CreateVolumeParameterWidget(Strings.defaultValue, inst.parameterList[currentParam]));
					rows.Add(row);
				}
			}
		}

		[DisplayInfo(name = "Volume", order = int.MaxValue)]
		internal class SettingsPanel : DebugDisplaySettingsPanel<DebugDisplaySettingsVolume>
		{
			private DebugUI.Table m_VolumeTable;

			public SettingsPanel(DebugDisplaySettingsVolume data)
				: base(data)
			{
				AddWidget(WidgetFactory.CreateComponentSelector(this, delegate
				{
					Refresh();
				}));
				AddWidget(WidgetFactory.CreateCameraSelector(this, delegate
				{
					Refresh();
				}));
			}

			private void Refresh()
			{
				DebugUI.Panel panel = DebugManager.instance.GetPanel(PanelName);
				if (panel != null)
				{
					bool flag = false;
					if (m_VolumeTable != null)
					{
						flag = true;
						panel.children.Remove(m_VolumeTable);
					}
					if (m_Data.volumeDebugSettings.selectedComponent > 0 && m_Data.volumeDebugSettings.selectedCamera != null)
					{
						flag = true;
						m_VolumeTable = WidgetFactory.CreateVolumeTable(m_Data);
						AddWidget(m_VolumeTable);
						panel.children.Add(m_VolumeTable);
					}
					if (flag)
					{
						DebugManager.instance.ReDrawOnScreenDebug();
					}
				}
			}
		}

		internal int volumeComponentEnumIndex;

		public IVolumeDebugSettings2 volumeDebugSettings { get; }

		public bool AreAnySettingsActive => false;

		public bool IsPostProcessingAllowed => true;

		public bool IsLightingActive => true;

		public DebugDisplaySettingsVolume(IVolumeDebugSettings2 volumeDebugSettings)
		{
			this.volumeDebugSettings = volumeDebugSettings;
		}

		public bool TryGetScreenClearColor(ref Color color)
		{
			return false;
		}

		public IDebugDisplaySettingsPanelDisposable CreatePanel()
		{
			return new SettingsPanel(this);
		}
	}
	public class DebugFrameTiming
	{
		private const string k_FpsFormatString = "{0:F1}";

		private const string k_MsFormatString = "{0:F2}ms";

		private const float k_RefreshRate = 0.2f;

		internal FrameTimeSampleHistory m_FrameHistory;

		internal BottleneckHistory m_BottleneckHistory;

		private FrameTiming[] m_Timing = new FrameTiming[1];

		private FrameTimeSample m_Sample;

		public int bottleneckHistorySize { get; set; } = 60;

		public int sampleHistorySize { get; set; } = 30;

		public DebugFrameTiming()
		{
			m_FrameHistory = new FrameTimeSampleHistory(sampleHistorySize);
			m_BottleneckHistory = new BottleneckHistory(bottleneckHistorySize);
		}

		public void UpdateFrameTiming()
		{
			m_Timing[0] = default(FrameTiming);
			m_Sample = default(FrameTimeSample);
			FrameTimingManager.CaptureFrameTimings();
			FrameTimingManager.GetLatestTimings(1u, m_Timing);
			if (m_Timing.Length != 0)
			{
				m_Sample.FullFrameTime = (float)m_Timing.First().cpuFrameTime;
				m_Sample.FramesPerSecond = ((m_Sample.FullFrameTime > 0f) ? (1000f / m_Sample.FullFrameTime) : 0f);
				m_Sample.MainThreadCPUFrameTime = (float)m_Timing.First().cpuMainThreadFrameTime;
				m_Sample.MainThreadCPUPresentWaitTime = (float)m_Timing.First().cpuMainThreadPresentWaitTime;
				m_Sample.RenderThreadCPUFrameTime = (float)m_Timing.First().cpuRenderThreadFrameTime;
				m_Sample.GPUFrameTime = (float)m_Timing.First().gpuFrameTime;
			}
			m_FrameHistory.DiscardOldSamples(sampleHistorySize);
			m_FrameHistory.Add(m_Sample);
			m_FrameHistory.ComputeAggregateValues();
			m_BottleneckHistory.DiscardOldSamples(bottleneckHistorySize);
			m_BottleneckHistory.AddBottleneckFromAveragedSample(m_FrameHistory.SampleAverage);
			m_BottleneckHistory.ComputeHistogram();
		}

		public void RegisterDebugUI(List<DebugUI.Widget> list)
		{
			list.Add(new DebugUI.Foldout
			{
				displayName = "Frame Stats",
				opened = true,
				columnLabels = new string[3] { "Avg", "Min", "Max" },
				children = 
				{
					(DebugUI.Widget)new DebugUI.ValueTuple
					{
						displayName = "Frame Rate (FPS)",
						values = new DebugUI.Value[3]
						{
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F1}",
								getter = () => m_FrameHistory.SampleAverage.FramesPerSecond
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F1}",
								getter = () => m_FrameHistory.SampleMin.FramesPerSecond
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F1}",
								getter = () => m_FrameHistory.SampleMax.FramesPerSecond
							}
						}
					},
					(DebugUI.Widget)new DebugUI.ValueTuple
					{
						displayName = "Frame Time",
						values = new DebugUI.Value[3]
						{
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleAverage.FullFrameTime
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleMin.FullFrameTime
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleMax.FullFrameTime
							}
						}
					},
					(DebugUI.Widget)new DebugUI.ValueTuple
					{
						displayName = "CPU Main Thread Frame",
						values = new DebugUI.Value[3]
						{
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleAverage.MainThreadCPUFrameTime
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleMin.MainThreadCPUFrameTime
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleMax.MainThreadCPUFrameTime
							}
						}
					},
					(DebugUI.Widget)new DebugUI.ValueTuple
					{
						displayName = "CPU Render Thread Frame",
						values = new DebugUI.Value[3]
						{
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleAverage.RenderThreadCPUFrameTime
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleMin.RenderThreadCPUFrameTime
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleMax.RenderThreadCPUFrameTime
							}
						}
					},
					(DebugUI.Widget)new DebugUI.ValueTuple
					{
						displayName = "CPU Present Wait",
						values = new DebugUI.Value[3]
						{
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleAverage.MainThreadCPUPresentWaitTime
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleMin.MainThreadCPUPresentWaitTime
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleMax.MainThreadCPUPresentWaitTime
							}
						}
					},
					(DebugUI.Widget)new DebugUI.ValueTuple
					{
						displayName = "GPU Frame",
						values = new DebugUI.Value[3]
						{
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleAverage.GPUFrameTime
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleMin.GPUFrameTime
							},
							new DebugUI.Value
							{
								refreshRate = 0.2f,
								formatString = "{0:F2}ms",
								getter = () => m_FrameHistory.SampleMax.GPUFrameTime
							}
						}
					}
				}
			});
			list.Add(new DebugUI.Foldout
			{
				displayName = "Bottlenecks",
				children = 
				{
					(DebugUI.Widget)new DebugUI.ProgressBarValue
					{
						displayName = "CPU",
						getter = () => m_BottleneckHistory.Histogram.CPU
					},
					(DebugUI.Widget)new DebugUI.ProgressBarValue
					{
						displayName = "GPU",
						getter = () => m_BottleneckHistory.Histogram.GPU
					},
					(DebugUI.Widget)new DebugUI.ProgressBarValue
					{
						displayName = "Present limited",
						getter = () => m_BottleneckHistory.Histogram.PresentLimited
					},
					(DebugUI.Widget)new DebugUI.ProgressBarValue
					{
						displayName = "Balanced",
						getter = () => m_BottleneckHistory.Histogram.Balanced
					}
				}
			});
		}

		internal void Reset()
		{
			m_BottleneckHistory.Clear();
			m_FrameHistory.Clear();
		}
	}
	internal enum DebugAction
	{
		EnableDebugMenu,
		PreviousDebugPanel,
		NextDebugPanel,
		Action,
		MakePersistent,
		MoveVertical,
		MoveHorizontal,
		Multiplier,
		ResetAll,
		DebugActionCount
	}
	internal enum DebugActionRepeatMode
	{
		Never,
		Delay
	}
	public sealed class DebugManager
	{
		public enum UIMode
		{
			EditorMode,
			RuntimeMode
		}

		private class UIState
		{
			public UIMode mode;

			[SerializeField]
			private bool m_Open;

			public bool open
			{
				get
				{
					return m_Open;
				}
				set
				{
					if (m_Open != value)
					{
						m_Open = value;
						DebugManager.windowStateChanged?.Invoke(mode, m_Open);
					}
				}
			}
		}

		private const string kEnableDebugBtn1 = "Enable Debug Button 1";

		private const string kEnableDebugBtn2 = "Enable Debug Button 2";

		private const string kDebugPreviousBtn = "Debug Previous";

		private const string kDebugNextBtn = "Debug Next";

		private const string kValidateBtn = "Debug Validate";

		private const string kPersistentBtn = "Debug Persistent";

		private const string kDPadVertical = "Debug Vertical";

		private const string kDPadHorizontal = "Debug Horizontal";

		private const string kMultiplierBtn = "Debug Multiplier";

		private const string kResetBtn = "Debug Reset";

		private const string kEnableDebug = "Enable Debug";

		private DebugActionDesc[] m_DebugActions;

		private DebugActionState[] m_DebugActionStates;

		private static readonly Lazy<DebugManager> s_Instance = new Lazy<DebugManager>(() => new DebugManager());

		private ReadOnlyCollection<DebugUI.Panel> m_ReadOnlyPanels;

		private readonly List<DebugUI.Panel> m_Panels = new List<DebugUI.Panel>();

		public bool refreshEditorRequested;

		private int? m_RequestedPanelIndex;

		private GameObject m_Root;

		private DebugUIHandlerCanvas m_RootUICanvas;

		private GameObject m_PersistentRoot;

		private DebugUIHandlerPersistentCanvas m_RootUIPersistentCanvas;

		private UIState editorUIState = new UIState
		{
			mode = UIMode.EditorMode
		};

		private bool m_EnableRuntimeUI = true;

		private UIState runtimeUIState = new UIState
		{
			mode = UIMode.RuntimeMode
		};

		public static DebugManager instance => s_Instance.Value;

		public ReadOnlyCollection<DebugUI.Panel> panels
		{
			get
			{
				if (m_ReadOnlyPanels == null)
				{
					UpdateReadOnlyCollection();
				}
				return m_ReadOnlyPanels;
			}
		}

		public bool isAnyDebugUIActive
		{
			get
			{
				if (!displayRuntimeUI)
				{
					return displayPersistentRuntimeUI;
				}
				return true;
			}
		}

		public bool displayEditorUI
		{
			get
			{
				return editorUIState.open;
			}
			set
			{
				editorUIState.open = value;
			}
		}

		public bool enableRuntimeUI
		{
			get
			{
				return m_EnableRuntimeUI;
			}
			set
			{
				if (value != m_EnableRuntimeUI)
				{
					m_EnableRuntimeUI = value;
					DebugUpdater.SetEnabled(value);
				}
			}
		}

		public bool displayRuntimeUI
		{
			get
			{
				if (m_Root != null)
				{
					return m_Root.activeInHierarchy;
				}
				return false;
			}
			set
			{
				if (value)
				{
					m_Root = Object.Instantiate(Resources.Load<Transform>("DebugUICanvas")).gameObject;
					m_Root.name = "[Debug Canvas]";
					m_Root.transform.localPosition = Vector3.zero;
					m_RootUICanvas = m_Root.GetComponent<DebugUIHandlerCanvas>();
					m_Root.SetActive(value: true);
				}
				else
				{
					CoreUtils.Destroy(m_Root);
					m_Root = null;
					m_RootUICanvas = null;
				}
				this.onDisplayRuntimeUIChanged(value);
				DebugUpdater.HandleInternalEventSystemComponents(value);
				runtimeUIState.open = m_Root != null && m_Root.activeInHierarchy;
			}
		}

		public bool displayPersistentRuntimeUI
		{
			get
			{
				if (m_RootUIPersistentCanvas != null)
				{
					return m_PersistentRoot.activeInHierarchy;
				}
				return false;
			}
			set
			{
				if (value)
				{
					EnsurePersistentCanvas();
					return;
				}
				CoreUtils.Destroy(m_PersistentRoot);
				m_PersistentRoot = null;
				m_RootUIPersistentCanvas = null;
			}
		}

		public event Action<bool> onDisplayRuntimeUIChanged = delegate
		{
		};

		public event Action onSetDirty = delegate
		{
		};

		private event Action resetData;

		public static event Action<UIMode, bool> windowStateChanged;

		private void RegisterActions()
		{
			m_DebugActions = new DebugActionDesc[9];
			m_DebugActionStates = new DebugActionState[9];
			DebugActionDesc debugActionDesc = new DebugActionDesc();
			debugActionDesc.buttonTriggerList.Add(new string[2] { "Enable Debug Button 1", "Enable Debug Button 2" });
			debugActionDesc.keyTriggerList.Add(new KeyCode[2]
			{
				KeyCode.LeftControl,
				KeyCode.Backspace
			});
			debugActionDesc.repeatMode = DebugActionRepeatMode.Never;
			AddAction(DebugAction.EnableDebugMenu, debugActionDesc);
			DebugActionDesc debugActionDesc2 = new DebugActionDesc();
			debugActionDesc2.keyTriggerList.Add(new KeyCode[2]
			{
				KeyCode.LeftAlt,
				KeyCode.Backspace
			});
			debugActionDesc2.buttonTriggerList.Add(new string[2] { "Debug Reset", "Enable Debug Button 2" });
			debugActionDesc2.repeatMode = DebugActionRepeatMode.Never;
			AddAction(DebugAction.ResetAll, debugActionDesc2);
			DebugActionDesc debugActionDesc3 = new DebugActionDesc();
			debugActionDesc3.buttonTriggerList.Add(new string[1] { "Debug Next" });
			debugActionDesc3.repeatMode = DebugActionRepeatMode.Never;
			AddAction(DebugAction.NextDebugPanel, debugActionDesc3);
			DebugActionDesc debugActionDesc4 = new DebugActionDesc();
			debugActionDesc4.buttonTriggerList.Add(new string[1] { "Debug Previous" });
			debugActionDesc4.repeatMode = DebugActionRepeatMode.Never;
			AddAction(DebugAction.PreviousDebugPanel, debugActionDesc4);
			DebugActionDesc debugActionDesc5 = new DebugActionDesc();
			debugActionDesc5.buttonTriggerList.Add(new string[1] { "Debug Validate" });
			debugActionDesc5.repeatMode = DebugActionRepeatMode.Never;
			AddAction(DebugAction.Action, debugActionDesc5);
			DebugActionDesc debugActionDesc6 = new DebugActionDesc();
			debugActionDesc6.buttonTriggerList.Add(new string[1] { "Debug Persistent" });
			debugActionDesc6.repeatMode = DebugActionRepeatMode.Never;
			AddAction(DebugAction.MakePersistent, debugActionDesc6);
			DebugActionDesc debugActionDesc7 = new DebugActionDesc();
			debugActionDesc7.buttonTriggerList.Add(new string[1] { "Debug Multiplier" });
			debugActionDesc7.repeatMode = DebugActionRepeatMode.Delay;
			debugActionDesc5.repeatDelay = 0f;
			AddAction(DebugAction.Multiplier, debugActionDesc7);
			DebugActionDesc debugActionDesc8 = new DebugActionDesc();
			debugActionDesc8.axisTrigger = "Debug Vertical";
			debugActionDesc8.repeatMode = DebugActionRepeatMode.Delay;
			debugActionDesc8.repeatDelay = 0.16f;
			AddAction(DebugAction.MoveVertical, debugActionDesc8);
			DebugActionDesc debugActionDesc9 = new DebugActionDesc();
			debugActionDesc9.axisTrigger = "Debug Horizontal";
			debugActionDesc9.repeatMode = DebugActionRepeatMode.Delay;
			debugActionDesc9.repeatDelay = 0.16f;
			AddAction(DebugAction.MoveHorizontal, debugActionDesc9);
		}

		internal void EnableInputActions()
		{
		}

		private void AddAction(DebugAction action, DebugActionDesc desc)
		{
			m_DebugActions[(int)action] = desc;
			m_DebugActionStates[(int)action] = new DebugActionState();
		}

		private void SampleAction(int actionIndex)
		{
			DebugActionDesc debugActionDesc = m_DebugActions[actionIndex];
			DebugActionState debugActionState = m_DebugActionStates[actionIndex];
			if (debugActionState.runningAction)
			{
				return;
			}
			for (int i = 0; i < debugActionDesc.buttonTriggerList.Count; i++)
			{
				string[] array = debugActionDesc.buttonTriggerList[i];
				bool flag = true;
				try
				{
					string[] array2 = array;
					for (int j = 0; j < array2.Length; j++)
					{
						flag = Input.GetButton(array2[j]);
						if (!flag)
						{
							break;
						}
					}
				}
				catch (ArgumentException)
				{
					flag = false;
				}
				if (flag)
				{
					debugActionState.TriggerWithButton(array, 1f);
					break;
				}
			}
			if (debugActionDesc.axisTrigger != "")
			{
				try
				{
					float axis = Input.GetAxis(debugActionDesc.axisTrigger);
					if (axis != 0f)
					{
						debugActionState.TriggerWithAxis(debugActionDesc.axisTrigger, axis);
					}
				}
				catch (ArgumentException)
				{
				}
			}
			for (int k = 0; k < debugActionDesc.keyTriggerList.Count; k++)
			{
				bool flag2 = true;
				KeyCode[] array3 = debugActionDesc.keyTriggerList[k];
				try
				{
					KeyCode[] array4 = array3;
					for (int j = 0; j < array4.Length; j++)
					{
						flag2 = Input.GetKey(array4[j]);
						if (!flag2)
						{
							break;
						}
					}
				}
				catch (ArgumentException)
				{
					flag2 = false;
				}
				if (flag2)
				{
					debugActionState.TriggerWithKey(array3, 1f);
					break;
				}
			}
		}

		private void UpdateAction(int actionIndex)
		{
			DebugActionDesc desc = m_DebugActions[actionIndex];
			DebugActionState debugActionState = m_DebugActionStates[actionIndex];
			if (debugActionState.runningAction)
			{
				debugActionState.Update(desc);
			}
		}

		internal void UpdateActions()
		{
			for (int i = 0; i < m_DebugActions.Length; i++)
			{
				UpdateAction(i);
				SampleAction(i);
			}
		}

		internal float GetAction(DebugAction action)
		{
			return m_DebugActionStates[(int)action].actionState;
		}

		internal bool GetActionToggleDebugMenuWithTouch()
		{
			int touchCount = Input.touchCount;
			TouchPhase? touchPhase = TouchPhase.Began;
			if (touchCount == 3)
			{
				Touch[] touches = Input.touches;
				for (int i = 0; i < touches.Length; i++)
				{
					Touch touch = touches[i];
					if ((!touchPhase.HasValue || touch.phase == touchPhase.Value) && touch.tapCount == 2)
					{
						return true;
					}
				}
			}
			return false;
		}

		internal bool GetActionReleaseScrollTarget()
		{
			bool num = Input.mouseScrollDelta != Vector2.zero;
			bool touchSupported = Input.touchSupported;
			return num || touchSupported;
		}

		private void RegisterInputs()
		{
		}

		private void UpdateReadOnlyCollection()
		{
			m_Panels.Sort();
			m_ReadOnlyPanels = m_Panels.AsReadOnly();
		}

		private DebugManager()
		{
		}

		public void RefreshEditor()
		{
			refreshEditorRequested = true;
		}

		public void Reset()
		{
			this.resetData?.Invoke();
			ReDrawOnScreenDebug();
		}

		public void ReDrawOnScreenDebug()
		{
			if (displayRuntimeUI)
			{
				m_RootUICanvas?.RequestHierarchyReset();
			}
		}

		public void RegisterData(IDebugData data)
		{
			resetData += data.GetReset();
		}

		public void UnregisterData(IDebugData data)
		{
			resetData -= data.GetReset();
		}

		public int GetState()
		{
			int num = 17;
			foreach (DebugUI.Panel panel in m_Panels)
			{
				num = num * 23 + panel.GetHashCode();
			}
			return num;
		}

		internal void RegisterRootCanvas(DebugUIHandlerCanvas root)
		{
			Assert.IsNotNull(root);
			m_Root = root.gameObject;
			m_RootUICanvas = root;
		}

		internal void ChangeSelection(DebugUIHandlerWidget widget, bool fromNext)
		{
			m_RootUICanvas.ChangeSelection(widget, fromNext);
		}

		internal void SetScrollTarget(DebugUIHandlerWidget widget)
		{
			if (m_RootUICanvas != null)
			{
				m_RootUICanvas.SetScrollTarget(widget);
			}
		}

		private void EnsurePersistentCanvas()
		{
			if (m_RootUIPersistentCanvas == null)
			{
				DebugUIHandlerPersistentCanvas debugUIHandlerPersistentCanvas = Object.FindObjectOfType<DebugUIHandlerPersistentCanvas>();
				if (debugUIHandlerPersistentCanvas == null)
				{
					m_PersistentRoot = Object.Instantiate(Resources.Load<Transform>("DebugUIPersistentCanvas")).gameObject;
					m_PersistentRoot.name = "[Debug Canvas - Persistent]";
					m_PersistentRoot.transform.localPosition = Vector3.zero;
				}
				else
				{
					m_PersistentRoot = debugUIHandlerPersistentCanvas.gameObject;
				}
				m_RootUIPersistentCanvas = m_PersistentRoot.GetComponent<DebugUIHandlerPersistentCanvas>();
			}
		}

		internal void TogglePersistent(DebugUI.Widget widget, int? forceTupleIndex = null)
		{
			if (widget == null)
			{
				return;
			}
			EnsurePersistentCanvas();
			if (!(widget is DebugUI.Value widget2))
			{
				if (!(widget is DebugUI.ValueTuple widget3))
				{
					if (widget is DebugUI.Container container)
					{
						int value = container.children.Max((DebugUI.Widget w) => (w as DebugUI.ValueTuple)?.pinnedElementIndex ?? (-1));
						{
							foreach (DebugUI.Widget child in container.children)
							{
								if (child is DebugUI.Value || child is DebugUI.ValueTuple)
								{
									TogglePersistent(child, value);
								}
							}
							return;
						}
					}
					Debug.Log("Only readonly items can be made persistent.");
				}
				else
				{
					m_RootUIPersistentCanvas.Toggle(widget3, forceTupleIndex);
				}
			}
			else
			{
				m_RootUIPersistentCanvas.Toggle(widget2);
			}
		}

		private void OnPanelDirty(DebugUI.Panel panel)
		{
			this.onSetDirty();
		}

		public int PanelIndex([DisallowNull] string displayName)
		{
			if (displayName == null)
			{
				displayName = string.Empty;
			}
			for (int i = 0; i < m_Panels.Count; i++)
			{
				if (displayName.Equals(m_Panels[i].displayName, StringComparison.InvariantCultureIgnoreCase))
				{
					return i;
				}
			}
			return -1;
		}

		public string PanelDiplayName([DisallowNull] int panelIndex)
		{
			if (panelIndex < 0 || panelIndex > m_Panels.Count - 1)
			{
				return string.Empty;
			}
			return m_Panels[panelIndex].displayName;
		}

		public void RequestEditorWindowPanelIndex(int index)
		{
			m_RequestedPanelIndex = index;
		}

		internal int? GetRequestedEditorWindowPanelIndex()
		{
			int? requestedPanelIndex = m_RequestedPanelIndex;
			m_RequestedPanelIndex = null;
			return requestedPanelIndex;
		}

		public DebugUI.Panel GetPanel(string displayName, bool createIfNull = false, int groupIndex = 0, bool overrideIfExist = false)
		{
			int num = PanelIndex(displayName);
			DebugUI.Panel panel = ((num >= 0) ? m_Panels[num] : null);
			if (panel != null)
			{
				if (!overrideIfExist)
				{
					return panel;
				}
				panel.onSetDirty -= OnPanelDirty;
				RemovePanel(panel);
				panel = null;
			}
			if (createIfNull)
			{
				panel = new DebugUI.Panel
				{
					displayName = displayName,
					groupIndex = groupIndex
				};
				panel.onSetDirty += OnPanelDirty;
				m_Panels.Add(panel);
				UpdateReadOnlyCollection();
			}
			return panel;
		}

		public int FindPanelIndex(string displayName)
		{
			return m_Panels.FindIndex((DebugUI.Panel p) => p.displayName == displayName);
		}

		public void RemovePanel(string displayName)
		{
			DebugUI.Panel panel = null;
			foreach (DebugUI.Panel panel2 in m_Panels)
			{
				if (panel2.displayName == displayName)
				{
					panel2.onSetDirty -= OnPanelDirty;
					panel = panel2;
					break;
				}
			}
			RemovePanel(panel);
		}

		public void RemovePanel(DebugUI.Panel panel)
		{
			if (panel != null)
			{
				m_Panels.Remove(panel);
				UpdateReadOnlyCollection();
			}
		}

		public DebugUI.Widget[] GetItems(DebugUI.Flags flags)
		{
			List<DebugUI.Widget> value;
			using (ListPool<DebugUI.Widget>.Get(out value))
			{
				foreach (DebugUI.Panel panel in m_Panels)
				{
					DebugUI.Widget[] itemsFromContainer = GetItemsFromContainer(flags, panel);
					value.AddRange(itemsFromContainer);
				}
				return value.ToArray();
			}
		}

		internal DebugUI.Widget[] GetItemsFromContainer(DebugUI.Flags flags, DebugUI.IContainer container)
		{
			List<DebugUI.Widget> value;
			using (ListPool<DebugUI.Widget>.Get(out value))
			{
				foreach (DebugUI.Widget child in container.children)
				{
					if (child.flags.HasFlag(flags))
					{
						value.Add(child);
					}
					else if (child is DebugUI.IContainer container2)
					{
						value.AddRange(GetItemsFromContainer(flags, container2));
					}
				}
				return value.ToArray();
			}
		}

		public DebugUI.Widget GetItem(string queryPath)
		{
			foreach (DebugUI.Panel panel in m_Panels)
			{
				DebugUI.Widget item = GetItem(queryPath, panel);
				if (item != null)
				{
					return item;
				}
			}
			return null;
		}

		private DebugUI.Widget GetItem(string queryPath, DebugUI.IContainer container)
		{
			foreach (DebugUI.Widget child in container.children)
			{
				if (child.queryPath == queryPath)
				{
					return child;
				}
				if (child is DebugUI.IContainer container2)
				{
					DebugUI.Widget item = GetItem(queryPath, container2);
					if (item != null)
					{
						return item;
					}
				}
			}
			return null;
		}

		[Obsolete("Use DebugManager.instance.displayEditorUI.open property instead. #from(23.1)")]
		public void ToggleEditorUI(bool open)
		{
			editorUIState.open = open;
		}
	}
	internal class DebugActionDesc
	{
		public string axisTrigger = "";

		public List<string[]> buttonTriggerList = new List<string[]>();

		public List<KeyCode[]> keyTriggerList = new List<KeyCode[]>();

		public DebugActionRepeatMode repeatMode;

		public float repeatDelay;
	}
	internal class DebugActionState
	{
		private enum DebugActionKeyType
		{
			Button,
			Axis,
			Key
		}

		private DebugActionKeyType m_Type;

		private string[] m_PressedButtons;

		private string m_PressedAxis = "";

		private KeyCode[] m_PressedKeys;

		private bool[] m_TriggerPressedUp;

		private float m_Timer;

		internal bool runningAction { get; private set; }

		internal float actionState { get; private set; }

		private void Trigger(int triggerCount, float state)
		{
			actionState = state;
			runningAction = true;
			m_Timer = 0f;
			m_TriggerPressedUp = new bool[triggerCount];
			for (int i = 0; i < m_TriggerPressedUp.Length; i++)
			{
				m_TriggerPressedUp[i] = false;
			}
		}

		public void TriggerWithButton(string[] buttons, float state)
		{
			m_Type = DebugActionKeyType.Button;
			m_PressedButtons = buttons;
			m_PressedAxis = "";
			Trigger(buttons.Length, state);
		}

		public void TriggerWithAxis(string axis, float state)
		{
			m_Type = DebugActionKeyType.Axis;
			m_PressedAxis = axis;
			Trigger(1, state);
		}

		public void TriggerWithKey(KeyCode[] keys, float state)
		{
			m_Type = DebugActionKeyType.Key;
			m_PressedKeys = keys;
			m_PressedAxis = "";
			Trigger(keys.Length, state);
		}

		private void Reset()
		{
			runningAction = false;
			m_Timer = 0f;
			m_TriggerPressedUp = null;
		}

		public void Update(DebugActionDesc desc)
		{
			actionState = 0f;
			if (m_TriggerPressedUp == null)
			{
				return;
			}
			m_Timer += Time.deltaTime;
			for (int i = 0; i < m_TriggerPressedUp.Length; i++)
			{
				if (m_Type == DebugActionKeyType.Button)
				{
					m_TriggerPressedUp[i] |= Input.GetButtonUp(m_PressedButtons[i]);
				}
				else if (m_Type == DebugActionKeyType.Axis)
				{
					m_TriggerPressedUp[i] |= Mathf.Approximately(Input.GetAxis(m_PressedAxis), 0f);
				}
				else
				{
					m_TriggerPressedUp[i] |= Input.GetKeyUp(m_PressedKeys[i]);
				}
			}
			bool flag = true;
			bool[] triggerPressedUp = m_TriggerPressedUp;
			foreach (bool flag2 in triggerPressedUp)
			{
				flag = flag && flag2;
			}
			if (flag || (m_Timer > desc.repeatDelay && desc.repeatMode == DebugActionRepeatMode.Delay))
			{
				Reset();
			}
		}
	}
	public interface IDebugData
	{
		Action GetReset();
	}
	public class DebugShapes
	{
		private static DebugShapes s_Instance;

		private Mesh m_sphereMesh;

		private Mesh m_boxMesh;

		private Mesh m_coneMesh;

		private Mesh m_pyramidMesh;

		public static DebugShapes instance
		{
			get
			{
				if (s_Instance == null)
				{
					s_Instance = new DebugShapes();
				}
				return s_Instance;
			}
		}

		private void BuildSphere(ref Mesh outputMesh, float radius, uint longSubdiv, uint latSubdiv)
		{
			outputMesh.Clear();
			Vector3[] array = new Vector3[(longSubdiv + 1) * latSubdiv + 2];
			float num = MathF.PI;
			float num2 = num * 2f;
			array[0] = Vector3.up * radius;
			for (int i = 0; i < latSubdiv; i++)
			{
				float f = num * (float)(i + 1) / (float)(latSubdiv + 1);
				float num3 = Mathf.Sin(f);
				float y = Mathf.Cos(f);
				for (int j = 0; j <= longSubdiv; j++)
				{
					float f2 = num2 * (float)((j != longSubdiv) ? j : 0) / (float)longSubdiv;
					float num4 = Mathf.Sin(f2);
					float num5 = Mathf.Cos(f2);
					array[j + i * (longSubdiv + 1) + 1] = new Vector3(num3 * num5, y, num3 * num4) * radius;
				}
			}
			array[^1] = Vector3.up * (0f - radius);
			Vector3[] array2 = new Vector3[array.Length];
			for (int k = 0; k < array.Length; k++)
			{
				array2[k] = array[k].normalized;
			}
			Vector2[] array3 = new Vector2[array.Length];
			array3[0] = Vector2.up;
			array3[^1] = Vector2.zero;
			for (int l = 0; l < latSubdiv; l++)
			{
				for (int m = 0; m <= longSubdiv; m++)
				{
					array3[m + l * (longSubdiv + 1) + 1] = new Vector2((float)m / (float)longSubdiv, 1f - (float)(l + 1) / (float)(latSubdiv + 1));
				}
			}
			int[] array4 = new int[array.Length * 2 * 3];
			int num6 = 0;
			for (int n = 0; n < longSubdiv; n++)
			{
				array4[num6++] = n + 2;
				array4[num6++] = n + 1;
				array4[num6++] = 0;
			}
			for (uint num7 = 0u; num7 < latSubdiv - 1; num7++)
			{
				for (uint num8 = 0u; num8 < longSubdiv; num8++)
				{
					uint num9 = num8 + num7 * (longSubdiv + 1) + 1;
					uint num10 = num9 + longSubdiv + 1;
					array4[num6++] = (int)num9;
					array4[num6++] = (int)(num9 + 1);
					array4[num6++] = (int)(num10 + 1);
					array4[num6++] = (int)num9;
					array4[num6++] = (int)(num10 + 1);
					array4[num6++] = (int)num10;
				}
			}
			for (int num11 = 0; num11 < longSubdiv; num11++)
			{
				array4[num6++] = array.Length - 1;
				array4[num6++] = array.Length - (num11 + 2) - 1;
				array4[num6++] = array.Length - (num11 + 1) - 1;
			}
			outputMesh.vertices = array;
			outputMesh.normals = array2;
			outputMesh.uv = array3;
			outputMesh.triangles = array4;
			outputMesh.RecalculateBounds();
		}

		private void BuildBox(ref Mesh outputMesh, float length, float width, float height)
		{
			outputMesh.Clear();
			Vector3 vector = new Vector3((0f - length) * 0.5f, (0f - width) * 0.5f, height * 0.5f);
			Vector3 vector2 = new Vector3(length * 0.5f, (0f - width) * 0.5f, height * 0.5f);
			Vector3 vector3 = new Vector3(length * 0.5f, (0f - width) * 0.5f, (0f - height) * 0.5f);
			Vector3 vector4 = new Vector3((0f - length) * 0.5f, (0f - width) * 0.5f, (0f - height) * 0.5f);
			Vector3 vector5 = new Vector3((0f - length) * 0.5f, width * 0.5f, height * 0.5f);
			Vector3 vector6 = new Vector3(length * 0.5f, width * 0.5f, height * 0.5f);
			Vector3 vector7 = new Vector3(length * 0.5f, width * 0.5f, (0f - height) * 0.5f);
			Vector3 vector8 = new Vector3((0f - length) * 0.5f, width * 0.5f, (0f - height) * 0.5f);
			Vector3[] vertices = new Vector3[24]
			{
				vector, vector2, vector3, vector4, vector8, vector5, vector, vector4, vector5, vector6,
				vector2, vector, vector7, vector8, vector4, vector3, vector6, vector7, vector3, vector2,
				vector8, vector7, vector6, vector5
			};
			Vector3 up = Vector3.up;
			Vector3 down = Vector3.down;
			Vector3 forward = Vector3.forward;
			Vector3 back = Vector3.back;
			Vector3 left = Vector3.left;
			Vector3 right = Vector3.right;
			Vector3[] normals = new Vector3[24]
			{
				down, down, down, down, left, left, left, left, forward, forward,
				forward, forward, back, back, back, back, right, right, right, right,
				up, up, up, up
			};
			Vector2 vector9 = new Vector2(0f, 0f);
			Vector2 vector10 = new Vector2(1f, 0f);
			Vector2 vector11 = new Vector2(0f, 1f);
			Vector2 vector12 = new Vector2(1f, 1f);
			Vector2[] uv = new Vector2[24]
			{
				vector12, vector11, vector9, vector10, vector12, vector11, vector9, vector10, vector12, vector11,
				vector9, vector10, vector12, vector11, vector9, vector10, vector12, vector11, vector9, vector10,
				vector12, vector11, vector9, vector10
			};
			int[] triangles = new int[36]
			{
				3, 1, 0, 3, 2, 1, 7, 5, 4, 7,
				6, 5, 11, 9, 8, 11, 10, 9, 15, 13,
				12, 15, 14, 13, 19, 17, 16, 19, 18, 17,
				23, 21, 20, 23, 22, 21
			};
			outputMesh.vertices = vertices;
			outputMesh.normals = normals;
			outputMesh.uv = uv;
			outputMesh.triangles = triangles;
			outputMesh.RecalculateBounds();
		}

		private void BuildCone(ref Mesh outputMesh, float height, float topRadius, float bottomRadius, int nbSides)
		{
			outputMesh.Clear();
			int num = nbSides + 1;
			Vector3[] array = new Vector3[num + num + nbSides * 2 + 2];
			int i = 0;
			float num2 = MathF.PI * 2f;
			array[i++] = new Vector3(0f, 0f, 0f);
			for (; i <= nbSides; i++)
			{
				float f = (float)i / (float)nbSides * num2;
				array[i] = new Vector3(Mathf.Sin(f) * bottomRadius, Mathf.Cos(f) * bottomRadius, 0f);
			}
			array[i++] = new Vector3(0f, 0f, height);
			for (; i <= nbSides * 2 + 1; i++)
			{
				float f2 = (float)(i - nbSides - 1) / (float)nbSides * num2;
				array[i] = new Vector3(Mathf.Sin(f2) * topRadius, Mathf.Cos(f2) * topRadius, height);
			}
			int num3 = 0;
			while (i <= array.Length - 4)
			{
				float f3 = (float)num3 / (float)nbSides * num2;
				array[i] = new Vector3(Mathf.Sin(f3) * topRadius, Mathf.Cos(f3) * topRadius, height);
				array[i + 1] = new Vector3(Mathf.Sin(f3) * bottomRadius, Mathf.Cos(f3) * bottomRadius, 0f);
				i += 2;
				num3++;
			}
			array[i] = array[nbSides * 2 + 2];
			array[i + 1] = array[nbSides * 2 + 3];
			Vector3[] array2 = new Vector3[array.Length];
			i = 0;
			while (i <= nbSides)
			{
				array2[i++] = new Vector3(0f, 0f, -1f);
			}
			while (i <= nbSides * 2 + 1)
			{
				array2[i++] = new Vector3(0f, 0f, 1f);
			}
			num3 = 0;
			while (i <= array.Length - 4)
			{
				float f4 = (float)num3 / (float)nbSides * num2;
				float y = Mathf.Cos(f4);
				float x = Mathf.Sin(f4);
				array2[i] = new Vector3(x, y, 0f);
				array2[i + 1] = array2[i];
				i += 2;
				num3++;
			}
			array2[i] = array2[nbSides * 2 + 2];
			array2[i + 1] = array2[nbSides * 2 + 3];
			Vector2[] array3 = new Vector2[array.Length];
			int j = 0;
			array3[j++] = new Vector2(0.5f, 0.5f);
			for (; j <= nbSides; j++)
			{
				float f5 = (float)j / (float)nbSides * num2;
				array3[j] = new Vector2(Mathf.Cos(f5) * 0.5f + 0.5f, Mathf.Sin(f5) * 0.5f + 0.5f);
			}
			array3[j++] = new Vector2(0.5f, 0.5f);
			for (; j <= nbSides * 2 + 1; j++)
			{
				float f6 = (float)j / (float)nbSides * num2;
				array3[j] = new Vector2(Mathf.Cos(f6) * 0.5f + 0.5f, Mathf.Sin(f6) * 0.5f + 0.5f);
			}
			int num4 = 0;
			while (j <= array3.Length - 4)
			{
				float x2 = (float)num4 / (float)nbSides;
				array3[j] = new Vector3(x2, 1f);
				array3[j + 1] = new Vector3(x2, 0f);
				j += 2;
				num4++;
			}
			array3[j] = new Vector2(1f, 1f);
			array3[j + 1] = new Vector2(1f, 0f);
			int num5 = nbSides + nbSides + nbSides * 2;
			int[] array4 = new int[num5 * 3 + 3];
			int num6 = 0;
			int num7 = 0;
			while (num6 < nbSides - 1)
			{
				array4[num7] = 0;
				array4[num7 + 1] = num6 + 1;
				array4[num7 + 2] = num6 + 2;
				num6++;
				num7 += 3;
			}
			array4[num7] = 0;
			array4[num7 + 1] = num6 + 1;
			array4[num7 + 2] = 1;
			num6++;
			num7 += 3;
			while (num6 < nbSides * 2)
			{
				array4[num7] = num6 + 2;
				array4[num7 + 1] = num6 + 1;
				array4[num7 + 2] = num;
				num6++;
				num7 += 3;
			}
			array4[num7] = num + 1;
			array4[num7 + 1] = num6 + 1;
			array4[num7 + 2] = num;
			num6++;
			num7 += 3;
			num6++;
			while (num6 <= num5)
			{
				array4[num7] = num6 + 2;
				array4[num7 + 1] = num6 + 1;
				array4[num7 + 2] = num6;
				num6++;
				num7 += 3;
				array4[num7] = num6 + 1;
				array4[num7 + 1] = num6 + 2;
				array4[num7 + 2] = num6;
				num6++;
				num7 += 3;
			}
			outputMesh.vertices = array;
			outputMesh.normals = array2;
			outputMesh.uv = array3;
			outputMesh.triangles = array4;
			outputMesh.RecalculateBounds();
		}

		private void BuildPyramid(ref Mesh outputMesh, float width, float height, float depth)
		{
			outputMesh.Clear();
			Vector3[] array = new Vector3[16]
			{
				new Vector3(0f, 0f, 0f),
				new Vector3((0f - width) / 2f, height / 2f, depth),
				new Vector3(width / 2f, height / 2f, depth),
				new Vector3(0f, 0f, 0f),
				new Vector3(width / 2f, height / 2f, depth),
				new Vector3(width / 2f, (0f - height) / 2f, depth),
				new Vector3(0f, 0f, 0f),
				new Vector3(width / 2f, (0f - height) / 2f, depth),
				new Vector3((0f - width) / 2f, (0f - height) / 2f, depth),
				new Vector3(0f, 0f, 0f),
				new Vector3((0f - width) / 2f, (0f - height) / 2f, depth),
				new Vector3((0f - width) / 2f, height / 2f, depth),
				new Vector3((0f - width) / 2f, height / 2f, depth),
				new Vector3((0f - width) / 2f, (0f - height) / 2f, depth),
				new Vector3(width / 2f, (0f - height) / 2f, depth),
				new Vector3(width / 2f, height / 2f, depth)
			};
			Vector3[] normals = new Vector3[array.Length];
			Vector2[] uv = new Vector2[array.Length];
			int[] array2 = new int[18];
			for (int i = 0; i < 12; i++)
			{
				array2[i] = i;
			}
			array2[12] = 12;
			array2[13] = 13;
			array2[14] = 14;
			array2[15] = 12;
			array2[16] = 14;
			array2[17] = 15;
			outputMesh.vertices = array;
			outputMesh.normals = normals;
			outputMesh.uv = uv;
			outputMesh.triangles = array2;
			outputMesh.RecalculateBounds();
		}

		private void BuildShapes()
		{
			m_sphereMesh = new Mesh();
			BuildSphere(ref m_sphereMesh, 1f, 24u, 16u);
			m_boxMesh = new Mesh();
			BuildBox(ref m_boxMesh, 1f, 1f, 1f);
			m_coneMesh = new Mesh();
			BuildCone(ref m_coneMesh, 1f, 1f, 0f, 16);
			m_pyramidMesh = new Mesh();
			BuildPyramid(ref m_pyramidMesh, 1f, 1f, 1f);
		}

		private void RebuildResources()
		{
			if (m_sphereMesh == null || m_boxMesh == null || m_coneMesh == null || m_pyramidMesh == null)
			{
				BuildShapes();
			}
		}

		public Mesh RequestSphereMesh()
		{
			RebuildResources();
			return m_sphereMesh;
		}

		public Mesh RequestBoxMesh()
		{
			RebuildResources();
			return m_boxMesh;
		}

		public Mesh RequestConeMesh()
		{
			RebuildResources();
			return m_coneMesh;
		}

		public Mesh RequestPyramidMesh()
		{
			RebuildResources();
			return m_pyramidMesh;
		}
	}
	public class DebugUI
	{
		public class Container : Widget, IContainer
		{
			private const string k_IDToken = "#";

			internal bool hideDisplayName
			{
				get
				{
					if (!string.IsNullOrEmpty(base.displayName))
					{
						return base.displayName.StartsWith("#");
					}
					return true;
				}
			}

			public ObservableList<Widget> children { get; private set; }

			public override Panel panel
			{
				get
				{
					return m_Panel;
				}
				internal set
				{
					if (value == null || !value.flags.HasFlag(Flags.FrequentlyUsed))
					{
						m_Panel = value;
						int count = children.Count;
						for (int i = 0; i < count; i++)
						{
							children[i].panel = value;
						}
					}
				}
			}

			public Container()
				: this(string.Empty, new ObservableList<Widget>())
			{
			}

			public Container(string id)
				: this("#" + id, new ObservableList<Widget>())
			{
			}

			public Container(string displayName, ObservableList<Widget> children)
			{
				base.displayName = displayName;
				this.children = children;
				children.ItemAdded += OnItemAdded;
				children.ItemRemoved += OnItemRemoved;
				for (int i = 0; i < this.children.Count; i++)
				{
					OnItemAdded(this.children, new ListChangedEventArgs<Widget>(i, this.children[i]));
				}
			}

			internal override void GenerateQueryPath()
			{
				base.GenerateQueryPath();
				int count = children.Count;
				for (int i = 0; i < count; i++)
				{
					children[i].GenerateQueryPath();
				}
			}

			protected virtual void OnItemAdded(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e)
			{
				if (e.item != null)
				{
					e.item.panel = m_Panel;
					e.item.parent = this;
				}
				if (m_Panel != null)
				{
					m_Panel.SetDirty();
				}
			}

			protected virtual void OnItemRemoved(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e)
			{
				if (e.item != null)
				{
					e.item.panel = null;
					e.item.parent = null;
				}
				if (m_Panel != null)
				{
					m_Panel.SetDirty();
				}
			}

			public override int GetHashCode()
			{
				int num = 17;
				num = num * 23 + base.queryPath.GetHashCode();
				num = num * 23 + base.isHidden.GetHashCode();
				int count = children.Count;
				for (int i = 0; i < count; i++)
				{
					num = num * 23 + children[i].GetHashCode();
				}
				return num;
			}
		}

		public class Foldout : Container, IValueField
		{
			public struct ContextMenuItem
			{
				public string displayName;

				public Action action;
			}

			public bool opened;

			public bool isHeader;

			public List<ContextMenuItem> contextMenuItems;

			public bool isReadOnly => false;

			public string[] columnLabels { get; set; }

			public string[] columnTooltips { get; set; }

			public Foldout()
			{
			}

			public Foldout(string displayName, ObservableList<Widget> children, string[] columnLabels = null, string[] columnTooltips = null)
				: base(displayName, children)
			{
				this.columnLabels = columnLabels;
				this.columnTooltips = columnTooltips;
			}

			public bool GetValue()
			{
				return opened;
			}

			object IValueField.GetValue()
			{
				return GetValue();
			}

			public void SetValue(object value)
			{
				SetValue((bool)value);
			}

			public object ValidateValue(object value)
			{
				return value;
			}

			public void SetValue(bool value)
			{
				opened = value;
			}
		}

		public class HBox : Container
		{
			public HBox()
			{
				base.displayName = "HBox";
			}
		}

		public class VBox : Container
		{
			public VBox()
			{
				base.displayName = "VBox";
			}
		}

		public class Table : Container
		{
			public class Row : Foldout
			{
				public Row()
				{
					base.displayName = "Row";
				}
			}

			public bool isReadOnly;

			private bool[] m_Header;

			public bool[] VisibleColumns
			{
				get
				{
					if (m_Header != null)
					{
						return m_Header;
					}
					int num = 0;
					if (base.children.Count != 0)
					{
						num = ((Container)base.children[0]).children.Count;
						for (int i = 1; i < base.children.Count; i++)
						{
							if (((Container)base.children[i]).children.Count != num)
							{
								Debug.LogError("All rows must have the same number of children.");
								return null;
							}
						}
					}
					m_Header = new bool[num];
					for (int j = 0; j < num; j++)
					{
						m_Header[j] = true;
					}
					return m_Header;
				}
			}

			public Table()
			{
				base.displayName = "Array";
			}

			public void SetColumnVisibility(int index, bool visible)
			{
				bool[] visibleColumns = VisibleColumns;
				if (index >= 0 && index <= visibleColumns.Length)
				{
					visibleColumns[index] = visible;
				}
			}

			public bool GetColumnVisibility(int index)
			{
				bool[] visibleColumns = VisibleColumns;
				if (index < 0 || index > visibleColumns.Length)
				{
					return false;
				}
				return visibleColumns[index];
			}

			protected override void OnItemAdded(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e)
			{
				base.OnItemAdded(sender, e);
				m_Header = null;
			}

			protected override void OnItemRemoved(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e)
			{
				base.OnItemRemoved(sender, e);
				m_Header = null;
			}
		}

		[Flags]
		public enum Flags
		{
			None = 0,
			EditorOnly = 2,
			RuntimeOnly = 4,
			EditorForceUpdate = 8,
			FrequentlyUsed = 0x10
		}

		public abstract class Widget
		{
			public struct NameAndTooltip
			{
				public string name;

				public string tooltip;
			}

			protected Panel m_Panel;

			protected IContainer m_Parent;

			public Func<bool> isHiddenCallback;

			public virtual Panel panel
			{
				get
				{
					return m_Panel;
				}
				internal set
				{
					m_Panel = value;
				}
			}

			public virtual IContainer parent
			{
				get
				{
					return m_Parent;
				}
				internal set
				{
					m_Parent = value;
				}
			}

			public Flags flags { get; set; }

			public string displayName { get; set; }

			public string tooltip { get; set; }

			public string queryPath { get; private set; }

			public bool isEditorOnly => flags.HasFlag(Flags.EditorOnly);

			public bool isRuntimeOnly => flags.HasFlag(Flags.RuntimeOnly);

			public bool isInactiveInEditor
			{
				get
				{
					if (isRuntimeOnly)
					{
						return !Application.isPlaying;
					}
					return false;
				}
			}

			public bool isHidden => isHiddenCallback?.Invoke() ?? false;

			public NameAndTooltip nameAndTooltip
			{
				set
				{
					displayName = value.name;
					tooltip = value.tooltip;
				}
			}

			internal virtual void GenerateQueryPath()
			{
				queryPath = displayName.Trim();
				if (m_Parent != null)
				{
					queryPath = m_Parent.queryPath + " -> " + queryPath;
				}
			}

			public override int GetHashCode()
			{
				return queryPath.GetHashCode() ^ isHidden.GetHashCode();
			}
		}

		public interface IContainer
		{
			ObservableList<Widget> children { get; }

			string displayName { get; set; }

			string queryPath { get; }
		}

		public interface IValueField
		{
			object GetValue();

			void SetValue(object value);

			object ValidateValue(object value);
		}

		public class Button : Widget
		{
			public Action action { get; set; }
		}

		public class Value : Widget
		{
			public float refreshRate = 0.1f;

			public string formatString;

			public Func<object> getter { get; set; }

			public Value()
			{
				base.displayName = "";
			}

			public virtual object GetValue()
			{
				Assert.IsNotNull(getter);
				return getter();
			}

			public virtual string FormatString(object value)
			{
				if (!string.IsNullOrEmpty(formatString))
				{
					return string.Format(formatString, value);
				}
				return $"{value}";
			}
		}

		public class ProgressBarValue : Value
		{
			public float min;

			public float max = 1f;

			public override string FormatString(object value)
			{
				float num = Remap(Mathf.Clamp((float)value, min, max), min, max);
				return $"{num:P1}";
				static float Remap(float v, float x0, float y0)
				{
					return (v - x0) / (y0 - x0);
				}
			}
		}

		public class ValueTuple : Widget
		{
			public Value[] values;

			public int pinnedElementIndex = -1;

			public int numElements
			{
				get
				{
					Assert.IsTrue(values.Length != 0);
					return values.Length;
				}
			}

			public float refreshRate => values.FirstOrDefault()?.refreshRate ?? 0.1f;
		}

		public abstract class Field<T> : Widget, IValueField
		{
			public Action<Field<T>, T> onValueChanged;

			public Func<T> getter { get; set; }

			public Action<T> setter { get; set; }

			object IValueField.ValidateValue(object value)
			{
				return ValidateValue((T)value);
			}

			public virtual T ValidateValue(T value)
			{
				return value;
			}

			object IValueField.GetValue()
			{
				return GetValue();
			}

			public T GetValue()
			{
				Assert.IsNotNull(getter);
				return getter();
			}

			public void SetValue(object value)
			{
				SetValue((T)value);
			}

			public virtual void SetValue(T value)
			{
				Assert.IsNotNull(setter);
				T val = ValidateValue(value);
				if (val == null || !val.Equals(getter()))
				{
					setter(val);
					onValueChanged?.Invoke(this, val);
				}
			}
		}

		public class BoolField : Field<bool>
		{
		}

		public class HistoryBoolField : BoolField
		{
			public Func<bool>[] historyGetter { get; set; }

			public int historyDepth
			{
				get
				{
					Func<bool>[] array = historyGetter;
					if (array == null)
					{
						return 0;
					}
					return array.Length;
				}
			}

			public bool GetHistoryValue(int historyIndex)
			{
				Assert.IsNotNull(historyGetter);
				Assert.IsTrue(historyIndex >= 0 && historyIndex < historyGetter.Length, "out of range historyIndex");
				Assert.IsNotNull(historyGetter[historyIndex]);
				return historyGetter[historyIndex]();
			}
		}

		public class IntField : Field<int>
		{
			public Func<int> min;

			public Func<int> max;

			public int incStep = 1;

			public int intStepMult = 10;

			public override int ValidateValue(int value)
			{
				if (min != null)
				{
					value = Mathf.Max(value, min());
				}
				if (max != null)
				{
					value = Mathf.Min(value, max());
				}
				return value;
			}
		}

		public class UIntField : Field<uint>
		{
			public Func<uint> min;

			public Func<uint> max;

			public uint incStep = 1u;

			public uint intStepMult = 10u;

			public override uint ValidateValue(uint value)
			{
				if (min != null)
				{
					value = (uint)Mathf.Max((int)value, (int)min());
				}
				if (max != null)
				{
					value = (uint)Mathf.Min((int)value, (int)max());
				}
				return value;
			}
		}

		public class FloatField : Field<float>
		{
			public Func<float> min;

			public Func<float> max;

			public float incStep = 0.1f;

			public float incStepMult = 10f;

			public int decimals = 3;

			public override float ValidateValue(float value)
			{
				if (min != null)
				{
					value = Mathf.Max(value, min());
				}
				if (max != null)
				{
					value = Mathf.Min(value, max());
				}
				return value;
			}
		}

		public abstract class EnumField<T> : Field<T>
		{
			public GUIContent[] enumNames;

			private int[] m_EnumValues;

			private static Regex s_NicifyRegEx = new Regex("([a-z](?=[A-Z])|[A-Z](?=[A-Z][a-z]))", RegexOptions.Compiled);

			public int[] enumValues
			{
				get
				{
					return m_EnumValues;
				}
				set
				{
					if (value?.Distinct().Count() != value?.Count())
					{
						Debug.LogWarning(base.displayName + " - The values of the enum are duplicated, this might lead to a errors displaying the enum");
					}
					m_EnumValues = value;
				}
			}

			protected void AutoFillFromType(Type enumType)
			{
				if (enumType == null || !enumType.IsEnum)
				{
					throw new ArgumentException("enumType must not be null and it must be an Enum type");
				}
				List<GUIContent> value;
				using (ListPool<GUIContent>.Get(out value))
				{
					List<int> value2;
					using (ListPool<int>.Get(out value2))
					{
						foreach (FieldInfo item2 in from fieldInfo in enumType.GetFields(BindingFlags.Static | BindingFlags.Public)
							where !fieldInfo.IsDefined(typeof(ObsoleteAttribute)) && !fieldInfo.IsDefined(typeof(HideInInspector))
							select fieldInfo)
						{
							InspectorNameAttribute customAttribute = item2.GetCustomAttribute<InspectorNameAttribute>();
							GUIContent item = new GUIContent((customAttribute == null) ? s_NicifyRegEx.Replace(item2.Name, "$1 ") : customAttribute.displayName);
							value.Add(item);
							value2.Add((int)Enum.Parse(enumType, item2.Name));
						}
						enumNames = value.ToArray();
						enumValues = value2.ToArray();
					}
				}
			}
		}

		public class EnumField : EnumField<int>
		{
			internal int[] quickSeparators;

			private int[] m_Indexes;

			internal int[] indexes
			{
				get
				{
					int[] array = m_Indexes;
					if (array == null)
					{
						GUIContent[] array2 = enumNames;
						array = (m_Indexes = Enumerable.Range(0, (array2 != null) ? array2.Length : 0).ToArray());
					}
					return array;
				}
			}

			public Func<int> getIndex { get; set; }

			public Action<int> setIndex { get; set; }

			public int currentIndex
			{
				get
				{
					return getIndex();
				}
				set
				{
					setIndex(value);
				}
			}

			public Type autoEnum
			{
				set
				{
					AutoFillFromType(value);
					InitQuickSeparators();
				}
			}

			internal void InitQuickSeparators()
			{
				IEnumerable<string> source = enumNames.Select(delegate(GUIContent x)
				{
					string[] array = x.text.Split('/');
					return (array.Length == 1) ? "" : array[0];
				});
				quickSeparators = new int[source.Distinct().Count()];
				string text = null;
				int num = 0;
				int num2 = 0;
				for (; num < quickSeparators.Length; num++)
				{
					string text2 = source.ElementAt(num2);
					while (text == text2)
					{
						text2 = source.ElementAt(++num2);
					}
					text = text2;
					quickSeparators[num] = num2++;
				}
			}

			public override void SetValue(int value)
			{
				Assert.IsNotNull(base.setter);
				int num = ValidateValue(value);
				int num2 = Array.IndexOf(base.enumValues, num);
				if (currentIndex != num2 && !num.Equals(base.getter()))
				{
					base.setter(num);
					onValueChanged?.Invoke(this, num);
					if (num2 > -1)
					{
						currentIndex = num2;
					}
				}
			}
		}

		public class ObjectPopupField : Field<Object>
		{
			public Func<IEnumerable<Object>> getObjects { get; set; }
		}

		public class HistoryEnumField : EnumField
		{
			public Func<int>[] historyIndexGetter { get; set; }

			public int historyDepth
			{
				get
				{
					Func<int>[] array = historyIndexGetter;
					if (array == null)
					{
						return 0;
					}
					return array.Length;
				}
			}

			public int GetHistoryValue(int historyIndex)
			{
				Assert.IsNotNull(historyIndexGetter);
				Assert.IsTrue(historyIndex >= 0 && historyIndex < historyIndexGetter.Length, "out of range historyIndex");
				Assert.IsNotNull(historyIndexGetter[historyIndex]);
				return historyIndexGetter[historyIndex]();
			}
		}

		public class BitField : EnumField<Enum>
		{
			private Type m_EnumType;

			public Type enumType
			{
				get
				{
					return m_EnumType;
				}
				set
				{
					m_EnumType = value;
					AutoFillFromType(value);
				}
			}
		}

		public class ColorField : Field<Color>
		{
			public bool hdr;

			public bool showAlpha = true;

			public bool showPicker = true;

			public float incStep = 0.025f;

			public float incStepMult = 5f;

			public int decimals = 3;

			public override Color ValidateValue(Color value)
			{
				if (!hdr)
				{
					value.r = Mathf.Clamp01(value.r);
					value.g = Mathf.Clamp01(value.g);
					value.b = Mathf.Clamp01(value.b);
					value.a = Mathf.Clamp01(value.a);
				}
				return value;
			}
		}

		public class Vector2Field : Field<Vector2>
		{
			public float incStep = 0.025f;

			public float incStepMult = 10f;

			public int decimals = 3;
		}

		public class Vector3Field : Field<Vector3>
		{
			public float incStep = 0.025f;

			public float incStepMult = 10f;

			public int decimals = 3;
		}

		public class Vector4Field : Field<Vector4>
		{
			public float incStep = 0.025f;

			public float incStepMult = 10f;

			public int decimals = 3;
		}

		public class ObjectField : Field<Object>
		{
			public Type type = typeof(Object);
		}

		public class ObjectListField : Field<Object[]>
		{
			public Type type = typeof(Object);
		}

		public class MessageBox : Widget
		{
			public enum Style
			{
				Info,
				Warning,
				Error
			}

			public Style style;
		}

		public class Panel : IContainer, IComparable<Panel>
		{
			public Flags flags { get; set; }

			public string displayName { get; set; }

			public int groupIndex { get; set; }

			public string queryPath => displayName;

			public bool isEditorOnly => (flags & Flags.EditorOnly) != 0;

			public bool isRuntimeOnly => (flags & Flags.RuntimeOnly) != 0;

			public bool isInactiveInEditor
			{
				get
				{
					if (isRuntimeOnly)
					{
						return !Application.isPlaying;
					}
					return false;
				}
			}

			public bool editorForceUpdate => (flags & Flags.EditorForceUpdate) != 0;

			public ObservableList<Widget> children { get; private set; }

			public event Action<Panel> onSetDirty = delegate
			{
			};

			public Panel()
			{
				children = new ObservableList<Widget>();
				children.ItemAdded += OnItemAdded;
				children.ItemRemoved += OnItemRemoved;
			}

			protected virtual void OnItemAdded(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e)
			{
				if (e.item != null)
				{
					e.item.panel = this;
					e.item.parent = this;
				}
				SetDirty();
			}

			protected virtual void OnItemRemoved(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e)
			{
				if (e.item != null)
				{
					e.item.panel = null;
					e.item.parent = null;
				}
				SetDirty();
			}

			public void SetDirty()
			{
				int count = children.Count;
				for (int i = 0; i < count; i++)
				{
					children[i].GenerateQueryPath();
				}
				this.onSetDirty(this);
			}

			public override int GetHashCode()
			{
				int num = 17;
				num = num * 23 + displayName.GetHashCode();
				int count = children.Count;
				for (int i = 0; i < count; i++)
				{
					num = num * 23 + children[i].GetHashCode();
				}
				return num;
			}

			int IComparable<Panel>.CompareTo(Panel other)
			{
				if (other != null)
				{
					return groupIndex.CompareTo(other.groupIndex);
				}
				return 1;
			}
		}
	}
	internal class DebugUpdater : MonoBehaviour
	{
		private static DebugUpdater s_Instance;

		private ScreenOrientation m_Orientation;

		private bool m_RuntimeUiWasVisibleLastFrame;

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
		private static void RuntimeInit()
		{
		}

		internal static void SetEnabled(bool enabled)
		{
			if (enabled)
			{
				EnableRuntime();
			}
			else
			{
				DisableRuntime();
			}
		}

		private static void EnableRuntime()
		{
			if (!(s_Instance != null))
			{
				GameObject obj = new GameObject
				{
					name = "[Debug Updater]"
				};
				s_Instance = obj.AddComponent<DebugUpdater>();
				s_Instance.m_Orientation = Screen.orientation;
				Object.DontDestroyOnLoad(obj);
				DebugManager.instance.EnableInputActions();
			}
		}

		private static void DisableRuntime()
		{
			DebugManager instance = DebugManager.instance;
			instance.displayRuntimeUI = false;
			instance.displayPersistentRuntimeUI = false;
			if (s_Instance != null)
			{
				CoreUtils.Destroy(s_Instance.gameObject);
				s_Instance = null;
			}
		}

		internal static void HandleInternalEventSystemComponents(bool uiEnabled)
		{
			if (!(s_Instance == null))
			{
				if (uiEnabled)
				{
					s_Instance.EnsureExactlyOneEventSystem();
				}
				else
				{
					s_Instance.DestroyDebugEventSystem();
				}
			}
		}

		private void EnsureExactlyOneEventSystem()
		{
			EventSystem[] array = Object.FindObjectsOfType<EventSystem>();
			EventSystem component = GetComponent<EventSystem>();
			if (array.Length > 1 && component != null)
			{
				Debug.Log("More than one EventSystem detected in scene. Destroying EventSystem owned by DebugUpdater.");
				DestroyDebugEventSystem();
			}
			else if (array.Length == 0)
			{
				Debug.Log("No EventSystem available. Creating a new EventSystem to enable Rendering Debugger runtime UI.");
				CreateDebugEventSystem();
			}
			else
			{
				StartCoroutine(DoAfterInputModuleUpdated(CheckInputModuleExists));
			}
		}

		private IEnumerator DoAfterInputModuleUpdated(Action action)
		{
			yield return new WaitForEndOfFrame();
			yield return new WaitForEndOfFrame();
			action();
		}

		private void CheckInputModuleExists()
		{
			if (EventSystem.current != null && EventSystem.current.currentInputModule == null)
			{
				Debug.LogWarning("Found a game object with EventSystem component but no corresponding BaseInputModule component - Debug UI input might not work correctly.");
			}
		}

		private void CreateDebugEventSystem()
		{
			base.gameObject.AddComponent<EventSystem>();
			base.gameObject.AddComponent<StandaloneInputModule>();
		}

		private void DestroyDebugEventSystem()
		{
			EventSystem component = GetComponent<EventSystem>();
			CoreUtils.Destroy(GetComponent<StandaloneInputModule>());
			CoreUtils.Destroy(GetComponent<BaseInput>());
			CoreUtils.Destroy(component);
		}

		private void Update()
		{
			DebugManager instance = DebugManager.instance;
			if (m_RuntimeUiWasVisibleLastFrame != instance.displayRuntimeUI)
			{
				HandleInternalEventSystemComponents(instance.displayRuntimeUI);
			}
			instance.UpdateActions();
			if (instance.GetAction(DebugAction.EnableDebugMenu) != 0f || instance.GetActionToggleDebugMenuWithTouch())
			{
				instance.displayRuntimeUI = !instance.displayRuntimeUI;
			}
			if (instance.displayRuntimeUI)
			{
				if (instance.GetAction(DebugAction.ResetAll) != 0f)
				{
					instance.Reset();
				}
				if (instance.GetActionReleaseScrollTarget())
				{
					instance.SetScrollTarget(null);
				}
			}
			if (m_Orientation != Screen.orientation)
			{
				StartCoroutine(RefreshRuntimeUINextFrame());
				m_Orientation = Screen.orientation;
			}
			m_RuntimeUiWasVisibleLastFrame = instance.displayRuntimeUI;
		}

		private static IEnumerator RefreshRuntimeUINextFrame()
		{
			yield return null;
			DebugManager.instance.ReDrawOnScreenDebug();
		}
	}
	internal enum PerformanceBottleneck
	{
		Indeterminate,
		PresentLimited,
		CPU,
		GPU,
		Balanced
	}
	internal struct BottleneckHistogram
	{
		internal float PresentLimited;

		internal float CPU;

		internal float GPU;

		internal float Balanced;
	}
	internal class BottleneckHistory
	{
		private List<PerformanceBottleneck> m_Bottlenecks = new List<PerformanceBottleneck>();

		internal BottleneckHistogram Histogram;

		public BottleneckHistory(int initialCapacity)
		{
			m_Bottlenecks.Capacity = initialCapacity;
		}

		internal void DiscardOldSamples(int historySize)
		{
			Debug.Assert(historySize > 0, "Invalid sampleHistorySize");
			while (m_Bottlenecks.Count >= historySize)
			{
				m_Bottlenecks.RemoveAt(0);
			}
			m_Bottlenecks.Capacity = historySize;
		}

		internal void AddBottleneckFromAveragedSample(FrameTimeSample frameHistorySampleAverage)
		{
			PerformanceBottleneck item = DetermineBottleneck(frameHistorySampleAverage);
			m_Bottlenecks.Add(item);
		}

		internal void ComputeHistogram()
		{
			BottleneckHistogram histogram = default(BottleneckHistogram);
			for (int i = 0; i < m_Bottlenecks.Count; i++)
			{
				switch (m_Bottlenecks[i])
				{
				case PerformanceBottleneck.Balanced:
					histogram.Balanced += 1f;
					break;
				case PerformanceBottleneck.CPU:
					histogram.CPU += 1f;
					break;
				case PerformanceBottleneck.GPU:
					histogram.GPU += 1f;
					break;
				case PerformanceBottleneck.PresentLimited:
					histogram.PresentLimited += 1f;
					break;
				}
			}
			histogram.Balanced /= m_Bottlenecks.Count;
			histogram.CPU /= m_Bottlenecks.Count;
			histogram.GPU /= m_Bottlenecks.Count;
			histogram.PresentLimited /= m_Bottlenecks.Count;
			Histogram = histogram;
		}

		private static PerformanceBottleneck DetermineBottleneck(FrameTimeSample s)
		{
			if (s.GPUFrameTime == 0f || s.MainThreadCPUFrameTime == 0f)
			{
				return PerformanceBottleneck.Indeterminate;
			}
			float num = 0.8f * s.FullFrameTime;
			if (s.GPUFrameTime > num && s.MainThreadCPUFrameTime < num && s.RenderThreadCPUFrameTime < num)
			{
				return PerformanceBottleneck.GPU;
			}
			if (s.GPUFrameTime < num && (s.MainThreadCPUFrameTime > num || s.RenderThreadCPUFrameTime > num))
			{
				return PerformanceBottleneck.CPU;
			}
			if (s.MainThreadCPUPresentWaitTime > 0.5f && s.GPUFrameTime < num && s.MainThreadCPUFrameTime < num && s.RenderThreadCPUFrameTime < num)
			{
				return PerformanceBottleneck.PresentLimited;
			}
			return PerformanceBottleneck.Balanced;
		}

		internal void Clear()
		{
			m_Bottlenecks.Clear();
			Histogram = default(BottleneckHistogram);
		}
	}
	internal struct FrameTimeSample
	{
		internal float FramesPerSecond;

		internal float FullFrameTime;

		internal float MainThreadCPUFrameTime;

		internal float MainThreadCPUPresentWaitTime;

		internal float RenderThreadCPUFrameTime;

		internal float GPUFrameTime;

		internal FrameTimeSample(float initValue)
		{
			FramesPerSecond = initValue;
			FullFrameTime = initValue;
			MainThreadCPUFrameTime = initValue;
			MainThreadCPUPresentWaitTime = initValue;
			RenderThreadCPUFrameTime = initValue;
			GPUFrameTime = initValue;
		}
	}
	internal class FrameTimeSampleHistory
	{
		private List<FrameTimeSample> m_Samples = new List<FrameTimeSample>();

		internal FrameTimeSample SampleAverage;

		internal FrameTimeSample SampleMin;

		internal FrameTimeSample SampleMax;

		private static Func<float, float, float> s_SampleValueAdd = (float value, float other) => value + other;

		private static Func<float, float, float> s_SampleValueMin = (float value, float other) => (!(other > 0f)) ? value : Mathf.Min(value, other);

		private static Func<float, float, float> s_SampleValueMax = (float value, float other) => Mathf.Max(value, other);

		private static Func<float, float, float> s_SampleValueCountValid = (float value, float other) => (!(other > 0f)) ? value : (value + 1f);

		private static Func<float, float, float> s_SampleValueEnsureValid = (float value, float other) => (!(other > 0f)) ? 0f : value;

		private static Func<float, float, float> s_SampleValueDivide = (float value, float other) => (!(other > 0f)) ? 0f : (value / other);

		public FrameTimeSampleHistory(int initialCapacity)
		{
			m_Samples.Capacity = initialCapacity;
		}

		internal void Add(FrameTimeSample sample)
		{
			m_Samples.Add(sample);
		}

		internal void ComputeAggregateValues()
		{
			FrameTimeSample aggregate = default(FrameTimeSample);
			FrameTimeSample aggregate2 = new FrameTimeSample(float.MaxValue);
			FrameTimeSample aggregate3 = new FrameTimeSample(float.MinValue);
			FrameTimeSample aggregate4 = default(FrameTimeSample);
			for (int i = 0; i < m_Samples.Count; i++)
			{
				FrameTimeSample sample = m_Samples[i];
				ForEachSampleMember(ref aggregate2, sample, s_SampleValueMin);
				ForEachSampleMember(ref aggregate3, sample, s_SampleValueMax);
				ForEachSampleMember(ref aggregate, sample, s_SampleValueAdd);
				ForEachSampleMember(ref aggregate4, sample, s_SampleValueCountValid);
			}
			ForEachSampleMember(ref aggregate2, aggregate4, s_SampleValueEnsureValid);
			ForEachSampleMember(ref aggregate3, aggregate4, s_SampleValueEnsureValid);
			ForEachSampleMember(ref aggregate, aggregate4, s_SampleValueDivide);
			SampleAverage = aggregate;
			SampleMin = aggregate2;
			SampleMax = aggregate3;
			static void ForEachSampleMember(ref FrameTimeSample reference, FrameTimeSample frameTimeSample, Func<float, float, float> func)
			{
				reference.FramesPerSecond = func(reference.FramesPerSecond, frameTimeSample.FramesPerSecond);
				reference.FullFrameTime = func(reference.FullFrameTime, frameTimeSample.FullFrameTime);
				reference.MainThreadCPUFrameTime = func(reference.MainThreadCPUFrameTime, frameTimeSample.MainThreadCPUFrameTime);
				reference.MainThreadCPUPresentWaitTime = func(reference.MainThreadCPUPresentWaitTime, frameTimeSample.MainThreadCPUPresentWaitTime);
				reference.RenderThreadCPUFrameTime = func(reference.RenderThreadCPUFrameTime, frameTimeSample.RenderThreadCPUFrameTime);
				reference.GPUFrameTime = func(reference.GPUFrameTime, frameTimeSample.GPUFrameTime);
			}
		}

		internal void DiscardOldSamples(int sampleHistorySize)
		{
			Debug.Assert(sampleHistorySize > 0, "Invalid sampleHistorySize");
			while (m_Samples.Count >= sampleHistorySize)
			{
				m_Samples.RemoveAt(0);
			}
			m_Samples.Capacity = sampleHistorySize;
		}

		internal void Clear()
		{
			m_Samples.Clear();
		}
	}
	public interface IDebugDisplaySettings : IDebugDisplaySettingsQuery
	{
		void Reset();

		void ForEach(Action<IDebugDisplaySettingsData> onExecute);
	}
	public interface IDebugDisplaySettingsData : IDebugDisplaySettingsQuery
	{
		IDebugDisplaySettingsPanelDisposable CreatePanel();
	}
	public interface IDebugDisplaySettingsPanel
	{
		string PanelName { get; }

		DebugUI.Widget[] Widgets { get; }

		DebugUI.Flags Flags { get; }
	}
	public interface IDebugDisplaySettingsPanelDisposable : IDebugDisplaySettingsPanel, IDisposable
	{
	}
	public interface IDebugDisplaySettingsQuery
	{
		bool AreAnySettingsActive { get; }

		bool IsPostProcessingAllowed { get; }

		bool IsLightingActive { get; }

		bool TryGetScreenClearColor(ref Color color);
	}
	[Obsolete("This variant is obsolete and kept only for not breaking user code. Use IVolumeDebugSettings2 for all new usage.", false)]
	public interface IVolumeDebugSettings
	{
		int selectedComponent { get; set; }

		Camera selectedCamera { get; }

		IEnumerable<Camera> cameras { get; }

		int selectedCameraIndex { get; set; }

		VolumeStack selectedCameraVolumeStack { get; }

		LayerMask selectedCameraLayerMask { get; }

		Vector3 selectedCameraPosition { get; }

		Type selectedComponentType { get; set; }

		Volume[] GetVolumes();

		bool VolumeHasInfluence(Volume volume);

		bool RefreshVolumes(Volume[] newVolumes);

		float GetVolumeWeight(Volume volume);
	}
	public interface IVolumeDebugSettings2 : IVolumeDebugSettings
	{
		Type targetRenderPipeline { get; }

		List<(string, Type)> volumeComponentsPathAndType { get; }
	}
	public class MousePositionDebug
	{
		private static MousePositionDebug s_Instance;

		public static MousePositionDebug instance
		{
			get
			{
				if (s_Instance == null)
				{
					s_Instance = new MousePositionDebug();
				}
				return s_Instance;
			}
		}

		public void Build()
		{
		}

		public void Cleanup()
		{
		}

		public Vector2 GetMousePosition(float ScreenHeight, bool sceneView)
		{
			return GetInputMousePosition();
		}

		private Vector2 GetInputMousePosition()
		{
			return Input.mousePosition;
		}

		public Vector2 GetMouseClickPosition(float ScreenHeight)
		{
			return Vector2.zero;
		}
	}
	internal class TProfilingSampler<TEnum> : ProfilingSampler where TEnum : Enum
	{
		internal static Dictionary<TEnum, TProfilingSampler<TEnum>> samples;

		static TProfilingSampler()
		{
			samples = new Dictionary<TEnum, TProfilingSampler<TEnum>>();
			string[] names = Enum.GetNames(typeof(TEnum));
			Array values = Enum.GetValues(typeof(TEnum));
			for (int i = 0; i < names.Length; i++)
			{
				TProfilingSampler<TEnum> value = new TProfilingSampler<TEnum>(names[i]);
				samples.Add((TEnum)values.GetValue(i), value);
			}
		}

		public TProfilingSampler(string name)
			: base(name)
		{
		}
	}
	[IgnoredByDeepProfiler]
	public class ProfilingSampler
	{
		private Recorder m_Recorder;

		private Recorder m_InlineRecorder;

		internal CustomSampler sampler { get; private set; }

		internal CustomSampler inlineSampler { get; private set; }

		public string name { get; private set; }

		public bool enableRecording
		{
			set
			{
				m_Recorder.enabled = value;
				m_InlineRecorder.enabled = value;
			}
		}

		public float gpuElapsedTime
		{
			get
			{
				if (!m_Recorder.enabled)
				{
					return 0f;
				}
				return (float)m_Recorder.gpuElapsedNanoseconds / 1000000f;
			}
		}

		public int gpuSampleCount
		{
			get
			{
				if (!m_Recorder.enabled)
				{
					return 0;
				}
				return m_Recorder.gpuSampleBlockCount;
			}
		}

		public float cpuElapsedTime
		{
			get
			{
				if (!m_Recorder.enabled)
				{
					return 0f;
				}
				return (float)m_Recorder.elapsedNanoseconds / 1000000f;
			}
		}

		public int cpuSampleCount
		{
			get
			{
				if (!m_Recorder.enabled)
				{
					return 0;
				}
				return m_Recorder.sampleBlockCount;
			}
		}

		public float inlineCpuElapsedTime
		{
			get
			{
				if (!m_InlineRecorder.enabled)
				{
					return 0f;
				}
				return (float)m_InlineRecorder.elapsedNanoseconds / 1000000f;
			}
		}

		public int inlineCpuSampleCount
		{
			get
			{
				if (!m_InlineRecorder.enabled)
				{
					return 0;
				}
				return m_InlineRecorder.sampleBlockCount;
			}
		}

		public static ProfilingSampler Get<TEnum>(TEnum marker) where TEnum : Enum
		{
			TProfilingSampler<TEnum>.samples.TryGetValue(marker, out var value);
			return value;
		}

		public ProfilingSampler(string name)
		{
			sampler = CustomSampler.Create(name, collectGpuData: true);
			inlineSampler = CustomSampler.Create("Inl_" + name);
			this.name = name;
			m_Recorder = sampler.GetRecorder();
			m_Recorder.enabled = false;
			m_InlineRecorder = inlineSampler.GetRecorder();
			m_InlineRecorder.enabled = false;
		}

		public void Begin(CommandBuffer cmd)
		{
			if (cmd != null)
			{
				if (sampler != null && sampler.isValid)
				{
					cmd.BeginSample(sampler);
				}
				else
				{
					cmd.BeginSample(name);
				}
			}
		}

		public void End(CommandBuffer cmd)
		{
			if (cmd != null)
			{
				if (sampler != null && sampler.isValid)
				{
					cmd.EndSample(sampler);
				}
				else
				{
					cmd.EndSample(name);
				}
			}
		}

		internal bool IsValid()
		{
			if (sampler != null)
			{
				return inlineSampler != null;
			}
			return false;
		}

		private ProfilingSampler()
		{
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct ProfilingScope : IDisposable
	{
		public ProfilingScope(CommandBuffer cmd, ProfilingSampler sampler)
		{
		}

		public void Dispose()
		{
		}
	}
	[Obsolete("Please use ProfilingScope")]
	[IgnoredByDeepProfiler]
	public struct ProfilingSample : IDisposable
	{
		private readonly CommandBuffer m_Cmd;

		private readonly string m_Name;

		private bool m_Disposed;

		private CustomSampler m_Sampler;

		public ProfilingSample(CommandBuffer cmd, string name, CustomSampler sampler = null)
		{
			m_Cmd = cmd;
			m_Name = name;
			m_Disposed = false;
			if (cmd != null && name != "")
			{
				cmd.BeginSample(name);
			}
			m_Sampler = sampler;
		}

		public ProfilingSample(CommandBuffer cmd, string format, object arg)
			: this(cmd, string.Format(format, arg))
		{
		}

		public ProfilingSample(CommandBuffer cmd, string format, params object[] args)
			: this(cmd, string.Format(format, args))
		{
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (!m_Disposed)
			{
				if (disposing && m_Cmd != null && m_Name != "")
				{
					m_Cmd.EndSample(m_Name);
				}
				m_Disposed = true;
			}
		}
	}
	public sealed class ShaderDebugPrintManager
	{
		private static class Profiling
		{
			public static readonly ProfilingSampler BufferReadComplete = new ProfilingSampler("ShaderDebugPrintManager.BufferReadComplete");
		}

		private enum DebugValueType
		{
			TypeUint = 1,
			TypeInt,
			TypeFloat,
			TypeUint2,
			TypeInt2,
			TypeFloat2,
			TypeUint3,
			TypeInt3,
			TypeFloat3,
			TypeUint4,
			TypeInt4,
			TypeFloat4,
			TypeBool
		}

		private static readonly ShaderDebugPrintManager s_Instance = new ShaderDebugPrintManager();

		private const int k_DebugUAVSlot = 7;

		private const int k_FramesInFlight = 4;

		private const int k_MaxBufferElements = 16384;

		private List<GraphicsBuffer> m_OutputBuffers = new List<GraphicsBuffer>();

		private List<AsyncGPUReadbackRequest> m_ReadbackRequests = new List<AsyncGPUReadbackRequest>();

		private Action<AsyncGPUReadbackRequest> m_BufferReadCompleteAction;

		private int m_FrameCounter;

		private bool m_FrameCleared;

		private string m_OutputLine = "";

		private Action<string> m_OutputAction;

		private static readonly int m_ShaderPropertyIDInputMouse = Shader.PropertyToID("_ShaderDebugPrintInputMouse");

		private static readonly int m_ShaderPropertyIDInputFrame = Shader.PropertyToID("_ShaderDebugPrintInputFrame");

		private const uint k_TypeHasTag = 128u;

		public static ShaderDebugPrintManager instance => s_Instance;

		public string outputLine => m_OutputLine;

		public Action<string> outputAction
		{
			set
			{
				m_OutputAction = value;
			}
		}

		private int DebugValueTypeToElemSize(DebugValueType type)
		{
			switch (type)
			{
			case DebugValueType.TypeUint:
			case DebugValueType.TypeInt:
			case DebugValueType.TypeFloat:
			case DebugValueType.TypeBool:
				return 1;
			case DebugValueType.TypeUint2:
			case DebugValueType.TypeInt2:
			case DebugValueType.TypeFloat2:
				return 2;
			case DebugValueType.TypeUint3:
			case DebugValueType.TypeInt3:
			case DebugValueType.TypeFloat3:
				return 3;
			case DebugValueType.TypeUint4:
			case DebugValueType.TypeInt4:
			case DebugValueType.TypeFloat4:
				return 4;
			default:
				return 0;
			}
		}

		private ShaderDebugPrintManager()
		{
			for (int i = 0; i < 4; i++)
			{
				m_OutputBuffers.Add(new GraphicsBuffer(GraphicsBuffer.Target.Structured, 16384, 4));
				m_ReadbackRequests.Add(default(AsyncGPUReadbackRequest));
			}
			m_BufferReadCompleteAction = BufferReadComplete;
			m_OutputAction = DefaultOutput;
		}

		public void SetShaderDebugPrintInputConstants(CommandBuffer cmd, ShaderDebugPrintInput input)
		{
			Vector4 value = new Vector4(input.pos.x, input.pos.y, input.leftDown ? 1 : 0, input.rightDown ? 1 : 0);
			cmd.SetGlobalVector(m_ShaderPropertyIDInputMouse, value);
			cmd.SetGlobalInt(m_ShaderPropertyIDInputFrame, m_FrameCounter);
		}

		public void SetShaderDebugPrintBindings(CommandBuffer cmd)
		{
			int index = m_FrameCounter % 4;
			if (!m_ReadbackRequests[index].done)
			{
				m_ReadbackRequests[index].WaitForCompletion();
			}
			cmd.SetRandomWriteTarget(7, m_OutputBuffers[index]);
			ClearShaderDebugPrintBuffer();
		}

		private void ClearShaderDebugPrintBuffer()
		{
			if (!m_FrameCleared)
			{
				int index = m_FrameCounter % 4;
				NativeArray<uint> data = new NativeArray<uint>(1, Allocator.Temp);
				data[0] = 0u;
				m_OutputBuffers[index].SetData(data, 0, 0, 1);
				m_FrameCleared = true;
			}
		}

		private unsafe void BufferReadComplete(AsyncGPUReadbackRequest request)
		{
			using (new ProfilingScope(null, Profiling.BufferReadComplete))
			{
				Assert.IsTrue(request.done);
				if (!request.hasError)
				{
					NativeArray<uint> data = request.GetData<uint>();
					uint num = data[0];
					if (num >= 16384)
					{
						num = 16384u;
						Debug.LogWarning("Debug Shader Print Buffer Full!");
					}
					string text = "";
					if (num != 0)
					{
						text = text + "Frame #" + m_FrameCounter + ": ";
					}
					uint* unsafePtr = (uint*)data.GetUnsafePtr();
					int num2 = 1;
					while (num2 < num)
					{
						DebugValueType debugValueType = (DebugValueType)(data[num2] & 0xF);
						if ((data[num2] & 0x80) == 128 && num2 + 1 < num)
						{
							uint num3 = data[num2 + 1];
							num2++;
							for (int i = 0; i < 4; i++)
							{
								char c = (char)(num3 & 0xFF);
								if (c != 0)
								{
									text += c;
									num3 >>= 8;
								}
							}
							text += " ";
						}
						int num4 = DebugValueTypeToElemSize(debugValueType);
						if (num2 + num4 > num)
						{
							break;
						}
						num2++;
						switch (debugValueType)
						{
						case DebugValueType.TypeUint:
							text += $"{data[num2]}u";
							break;
						case DebugValueType.TypeInt:
						{
							int num5 = (int)unsafePtr[num2];
							text += num5;
							break;
						}
						case DebugValueType.TypeFloat:
						{
							float num6 = *(float*)(unsafePtr + num2);
							text += $"{num6}f";
							break;
						}
						case DebugValueType.TypeUint2:
						{
							uint* ptr9 = unsafePtr + num2;
							text += $"uint2({*ptr9}, {ptr9[1]})";
							break;
						}
						case DebugValueType.TypeInt2:
						{
							int* ptr8 = (int*)(unsafePtr + num2);
							text += $"int2({*ptr8}, {ptr8[1]})";
							break;
						}
						case DebugValueType.TypeFloat2:
						{
							float* ptr7 = (float*)(unsafePtr + num2);
							text += $"float2({*ptr7}, {ptr7[1]})";
							break;
						}
						case DebugValueType.TypeUint3:
						{
							uint* ptr6 = unsafePtr + num2;
							text += $"uint3({*ptr6}, {ptr6[1]}, {ptr6[2]})";
							break;
						}
						case DebugValueType.TypeInt3:
						{
							int* ptr5 = (int*)(unsafePtr + num2);
							text += $"int3({*ptr5}, {ptr5[1]}, {ptr5[2]})";
							break;
						}
						case DebugValueType.TypeFloat3:
						{
							float* ptr4 = (float*)(unsafePtr + num2);
							text += $"float3({*ptr4}, {ptr4[1]}, {ptr4[2]})";
							break;
						}
						case DebugValueType.TypeUint4:
						{
							uint* ptr3 = unsafePtr + num2;
							text += $"uint4({*ptr3}, {ptr3[1]}, {ptr3[2]}, {ptr3[3]})";
							break;
						}
						case DebugValueType.TypeInt4:
						{
							int* ptr2 = (int*)(unsafePtr + num2);
							text += $"int4({*ptr2}, {ptr2[1]}, {ptr2[2]}, {ptr2[3]})";
							break;
						}
						case DebugValueType.TypeFloat4:
						{
							float* ptr = (float*)(unsafePtr + num2);
							text += $"float4({*ptr}, {ptr[1]}, {ptr[2]}, {ptr[3]})";
							break;
						}
						case DebugValueType.TypeBool:
							text += ((data[num2] == 0) ? "False" : "True");
							break;
						default:
							num2 = (int)num;
							break;
						}
						num2 += num4;
						text += " ";
					}
					if (num != 0)
					{
						m_OutputLine = text;
						m_OutputAction(text);
					}
				}
				else
				{
					m_OutputLine = "Error at read back!";
					m_OutputAction("Error at read back!");
				}
			}
		}

		public void EndFrame()
		{
			int index = m_FrameCounter % 4;
			m_ReadbackRequests[index] = AsyncGPUReadback.Request(m_OutputBuffers[index], m_BufferReadCompleteAction);
			m_FrameCounter++;
			m_FrameCleared = false;
		}

		public void DefaultOutput(string line)
		{
			Debug.Log(line);
		}
	}
	public struct ShaderDebugPrintInput
	{
		public Vector2 pos { get; set; }

		public bool leftDown { get; set; }

		public bool rightDown { get; set; }

		public bool middleDown { get; set; }

		public string String()
		{
			return $"Mouse: {pos.x}x{pos.y}  Btns: Left:{leftDown} Right:{rightDown} Middle:{middleDown} ";
		}
	}
	public static class ShaderDebugPrintInputProducer
	{
		public static ShaderDebugPrintInput Get()
		{
			return new ShaderDebugPrintInput
			{
				pos = Input.mousePosition,
				leftDown = Input.GetMouseButton(0),
				rightDown = Input.GetMouseButton(1),
				middleDown = Input.GetMouseButton(2)
			};
		}
	}
	public abstract class VolumeDebugSettings<T> : IVolumeDebugSettings2, IVolumeDebugSettings where T : MonoBehaviour, IAdditionalData
	{
		private Camera m_SelectedCamera;

		protected int m_SelectedCameraIndex = -1;

		private Camera[] m_CamerasArray;

		private List<Camera> m_Cameras = new List<Camera>();

		private static List<(string, Type)> s_ComponentPathAndType;

		private float[] weights;

		private Volume[] volumes;

		private VolumeParameter[,] savedStates;

		private static List<Type> s_ComponentTypes;

		public int selectedComponent { get; set; }

		public Camera selectedCamera => m_SelectedCamera;

		public int selectedCameraIndex
		{
			get
			{
				return m_SelectedCameraIndex;
			}
			set
			{
				m_SelectedCameraIndex = value;
				int num = cameras.Count();
				if (num != 0)
				{
					m_SelectedCamera = ((m_SelectedCameraIndex < 0 || m_SelectedCameraIndex >= num) ? cameras.First() : cameras.ElementAt(m_SelectedCameraIndex));
				}
				else
				{
					m_SelectedCamera = null;
				}
			}
		}

		public IEnumerable<Camera> cameras
		{
			get
			{
				m_Cameras.Clear();
				if (m_CamerasArray == null || m_CamerasArray.Length != Camera.allCamerasCount)
				{
					m_CamerasArray = new Camera[Camera.allCamerasCount];
				}
				Camera.GetAllCameras(m_CamerasArray);
				Camera[] camerasArray = m_CamerasArray;
				foreach (Camera camera in camerasArray)
				{
					if (!(camera == null) && camera.cameraType != CameraType.Preview && camera.cameraType != CameraType.Reflection && camera.TryGetComponent<T>(out var _))
					{
						m_Cameras.Add(camera);
					}
				}
				return m_Cameras;
			}
		}

		public abstract VolumeStack selectedCameraVolumeStack { get; }

		public abstract LayerMask selectedCameraLayerMask { get; }

		public abstract Vector3 selectedCameraPosition { get; }

		public Type selectedComponentType
		{
			get
			{
				return volumeComponentsPathAndType[selectedComponent - 1].Item2;
			}
			set
			{
				int num = volumeComponentsPathAndType.FindIndex(((string, Type) t) => t.Item2 == value);
				if (num != -1)
				{
					selectedComponent = num + 1;
				}
			}
		}

		public List<(string, Type)> volumeComponentsPathAndType => s_ComponentPathAndType ?? (s_ComponentPathAndType = VolumeManager.GetSupportedVolumeComponents(targetRenderPipeline));

		public abstract Type targetRenderPipeline { get; }

		[Obsolete("Please use volumeComponentsPathAndType instead, and get the second element of the tuple", false)]
		public static List<Type> componentTypes
		{
			get
			{
				if (s_ComponentTypes == null)
				{
					s_ComponentTypes = (from t in VolumeManager.instance.baseComponentTypeArray
						where !t.IsDefined(typeof(HideInInspector), inherit: false)
						where !t.IsDefined(typeof(ObsoleteAttribute), inherit: false)
						orderby ComponentDisplayName(t)
						select t).ToList();
				}
				return s_ComponentTypes;
			}
		}

		[Obsolete("Cameras are auto registered/unregistered, use property cameras", false)]
		protected static List<T> additionalCameraDatas { get; private set; } = new List<T>();

		internal VolumeParameter GetParameter(VolumeComponent component, FieldInfo field)
		{
			return (VolumeParameter)field.GetValue(component);
		}

		internal VolumeParameter GetParameter(FieldInfo field)
		{
			VolumeStack volumeStack = selectedCameraVolumeStack;
			if (volumeStack != null)
			{
				return GetParameter(volumeStack.GetComponent(selectedComponentType), field);
			}
			return null;
		}

		internal VolumeParameter GetParameter(Volume volume, FieldInfo field)
		{
			if (!(volume.HasInstantiatedProfile() ? volume.profile : volume.sharedProfile).TryGet<VolumeComponent>(selectedComponentType, out var component))
			{
				return null;
			}
			VolumeParameter parameter = GetParameter(component, field);
			if (!parameter.overrideState)
			{
				return null;
			}
			return parameter;
		}

		private float ComputeWeight(Volume volume, Vector3 triggerPos)
		{
			if (volume == null)
			{
				return 0f;
			}
			VolumeProfile volumeProfile = (volume.HasInstantiatedProfile() ? volume.profile : volume.sharedProfile);
			if (!volume.gameObject.activeInHierarchy)
			{
				return 0f;
			}
			if (!volume.enabled || volumeProfile == null || volume.weight <= 0f)
			{
				return 0f;
			}
			if (!volumeProfile.TryGet<VolumeComponent>(selectedComponentType, out var component))
			{
				return 0f;
			}
			if (!component.active)
			{
				return 0f;
			}
			float num = Mathf.Clamp01(volume.weight);
			if (!volume.isGlobal)
			{
				Collider[] components = volume.GetComponents<Collider>();
				float num2 = float.PositiveInfinity;
				Collider[] array = components;
				foreach (Collider collider in array)
				{
					if (collider.enabled)
					{
						float sqrMagnitude = (collider.ClosestPoint(triggerPos) - triggerPos).sqrMagnitude;
						if (sqrMagnitude < num2)
						{
							num2 = sqrMagnitude;
						}
					}
				}
				float num3 = volume.blendDistance * volume.blendDistance;
				if (num2 > num3)
				{
					num = 0f;
				}
				else if (num3 > 0f)
				{
					num *= 1f - num2 / num3;
				}
			}
			return num;
		}

		public Volume[] GetVolumes()
		{
			return (from v in VolumeManager.instance.GetVolumes(selectedCameraLayerMask)
				where v.sharedProfile != null
				select v).Reverse().ToArray();
		}

		private VolumeParameter[,] GetStates()
		{
			FieldInfo[] array = (from t in selectedComponentType.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
				where t.FieldType.IsSubclassOf(typeof(VolumeParameter))
				select t).ToArray();
			VolumeParameter[,] array2 = new VolumeParameter[volumes.Length, array.Length];
			for (int num = 0; num < volumes.Length; num++)
			{
				if ((volumes[num].HasInstantiatedProfile() ? volumes[num].profile : volumes[num].sharedProfile).TryGet<VolumeComponent>(selectedComponentType, out var component))
				{
					for (int num2 = 0; num2 < array.Length; num2++)
					{
						VolumeParameter parameter = GetParameter(component, array[num2]);
						array2[num, num2] = (parameter.overrideState ? parameter : null);
					}
				}
			}
			return array2;
		}

		private bool ChangedStates(VolumeParameter[,] newStates)
		{
			if (savedStates.GetLength(1) != newStates.GetLength(1))
			{
				return true;
			}
			for (int i = 0; i < savedStates.GetLength(0); i++)
			{
				for (int j = 0; j < savedStates.GetLength(1); j++)
				{
					if (savedStates[i, j] == null != (newStates[i, j] == null))
					{
						return true;
					}
				}
			}
			return false;
		}

		public bool RefreshVolumes(Volume[] newVolumes)
		{
			bool result = false;
			if (volumes == null || !newVolumes.SequenceEqual(volumes))
			{
				volumes = (Volume[])newVolumes.Clone();
				savedStates = GetStates();
				result = true;
			}
			else
			{
				VolumeParameter[,] states = GetStates();
				if (savedStates == null || ChangedStates(states))
				{
					savedStates = states;
					result = true;
				}
			}
			Vector3 triggerPos = selectedCameraPosition;
			weights = new float[volumes.Length];
			for (int i = 0; i < volumes.Length; i++)
			{
				weights[i] = ComputeWeight(volumes[i], triggerPos);
			}
			return result;
		}

		public float GetVolumeWeight(Volume volume)
		{
			if (weights == null)
			{
				return 0f;
			}
			float num = 0f;
			float num2 = 0f;
			for (int i = 0; i < volumes.Length; i++)
			{
				num2 = weights[i];
				num2 *= 1f - num;
				num += num2;
				if (volumes[i] == volume)
				{
					return num2;
				}
			}
			return 0f;
		}

		public bool VolumeHasInfluence(Volume volume)
		{
			if (weights == null)
			{
				return false;
			}
			int num = Array.IndexOf(volumes, volume);
			if (num == -1)
			{
				return false;
			}
			return weights[num] != 0f;
		}

		[Obsolete("Please use componentPathAndType instead, and get the first element of the tuple", false)]
		public static string ComponentDisplayName(Type component)
		{
			if (component.GetCustomAttribute(typeof(VolumeComponentMenuForRenderPipeline), inherit: false) is VolumeComponentMenuForRenderPipeline volumeComponentMenuForRenderPipeline)
			{
				return volumeComponentMenuForRenderPipeline.menu;
			}
			if (component.GetCustomAttribute(typeof(VolumeComponentMenu), inherit: false) is VolumeComponentMenuForRenderPipeline volumeComponentMenuForRenderPipeline2)
			{
				return volumeComponentMenuForRenderPipeline2.menu;
			}
			return component.Name;
		}

		[Obsolete("Cameras are auto registered/unregistered", false)]
		public static void RegisterCamera(T additionalCamera)
		{
			if (!additionalCameraDatas.Contains(additionalCamera))
			{
				additionalCameraDatas.Add(additionalCamera);
			}
		}

		[Obsolete("Cameras are auto registered/unregistered", false)]
		public static void UnRegisterCamera(T additionalCamera)
		{
			if (additionalCameraDatas.Contains(additionalCamera))
			{
				additionalCameraDatas.Remove(additionalCamera);
			}
		}
	}
	[Conditional("UNITY_EDITOR")]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum, AllowMultiple = false)]
	public class CoreRPHelpURLAttribute : HelpURLAttribute
	{
		public CoreRPHelpURLAttribute(string pageName, string packageName = "com.unity.render-pipelines.core")
			: base(DocumentationInfo.GetPageLink(packageName, pageName, ""))
		{
		}

		public CoreRPHelpURLAttribute(string pageName, string pageHash, string packageName = "com.unity.render-pipelines.core")
			: base(DocumentationInfo.GetPageLink(packageName, pageName, pageHash))
		{
		}
	}
	public class DocumentationInfo
	{
		private const string fallbackVersion = "13.1";

		private const string url = "https://docs.unity3d.com/Packages/{0}@{1}/manual/{2}.html{3}";

		public static string version => "13.1";

		public static string GetPageLink(string packageName, string pageName)
		{
			return string.Format("https://docs.unity3d.com/Packages/{0}@{1}/manual/{2}.html{3}", packageName, version, pageName, "");
		}

		public static string GetPageLink(string packageName, string pageName, string pageHash)
		{
			return $"https://docs.unity3d.com/Packages/{packageName}@{version}/manual/{pageName}.html{pageHash}";
		}
	}
	public static class DocumentationUtils
	{
		public static string GetHelpURL<TEnum>(TEnum mask = default(TEnum)) where TEnum : struct, IConvertible
		{
			HelpURLAttribute helpURLAttribute = (HelpURLAttribute)mask.GetType().GetCustomAttributes(typeof(HelpURLAttribute), inherit: false).FirstOrDefault();
			if (helpURLAttribute != null)
			{
				return $"{helpURLAttribute.URL}#{mask}";
			}
			return string.Empty;
		}

		public static bool TryGetHelpURL(Type type, out string url)
		{
			HelpURLAttribute customAttribute = type.GetCustomAttribute<HelpURLAttribute>(inherit: false);
			url = customAttribute?.URL;
			return customAttribute != null;
		}
	}
	internal class ProbeBrickIndex
	{
		[Serializable]
		[DebuggerDisplay("Brick [{position}, {subdivisionLevel}]")]
		public struct Brick : IEquatable<Brick>
		{
			public Vector3Int position;

			public int subdivisionLevel;

			internal Brick(Vector3Int position, int subdivisionLevel)
			{
				this.position = position;
				this.subdivisionLevel = subdivisionLevel;
			}

			public bool Equals(Brick other)
			{
				if (position == other.position)
				{
					return subdivisionLevel == other.subdivisionLevel;
				}
				return false;
			}
		}

		[DebuggerDisplay("Brick [{brick.position}, {brick.subdivisionLevel}], {flattenedIdx}")]
		private struct ReservedBrick
		{
			public Brick brick;

			public int flattenedIdx;
		}

		private class VoxelMeta
		{
			public ProbeReferenceVolume.Cell cell;

			public List<ushort> brickIndices = new List<ushort>();

			public void Clear()
			{
				cell = null;
				brickIndices.Clear();
			}
		}

		private class BrickMeta
		{
			public HashSet<Vector3Int> voxels = new HashSet<Vector3Int>();

			public List<ReservedBrick> bricks = new List<ReservedBrick>();

			public void Clear()
			{
				voxels.Clear();
				bricks.Clear();
			}
		}

		public struct CellIndexUpdateInfo
		{
			public int firstChunkIndex;

			public int numberOfChunks;

			public int minSubdivInCell;

			public Vector3Int minValidBrickIndexForCellAtMaxRes;

			public Vector3Int maxValidBrickIndexForCellAtMaxResPlusOne;

			public Vector3Int cellPositionInBricksAtMaxRes;
		}

		internal const int kMaxSubdivisionLevels = 7;

		internal const int kIndexChunkSize = 243;

		private BitArray m_IndexChunks;

		private int m_IndexInChunks;

		private int m_NextFreeChunk;

		private int m_AvailableChunkCount;

		private ComputeBuffer m_PhysicalIndexBuffer;

		private int[] m_PhysicalIndexBufferData;

		private Vector3Int m_CenterRS;

		private Dictionary<Vector3Int, List<VoxelMeta>> m_VoxelToBricks;

		private Dictionary<ProbeReferenceVolume.Cell, BrickMeta> m_BricksToVoxels;

		private ObjectPool<BrickMeta> m_BrickMetaPool = new ObjectPool<BrickMeta>(delegate(BrickMeta x)
		{
			x.Clear();
		}, null, collectionCheck: false);

		private ObjectPool<List<VoxelMeta>> m_VoxelMetaListPool = new ObjectPool<List<VoxelMeta>>(delegate(List<VoxelMeta> x)
		{
			x.Clear();
		}, null, collectionCheck: false);

		private ObjectPool<VoxelMeta> m_VoxelMetaPool = new ObjectPool<VoxelMeta>(delegate(VoxelMeta x)
		{
			x.Clear();
		}, null, collectionCheck: false);

		private bool m_NeedUpdateIndexComputeBuffer;

		private int m_UpdateMinIndex = int.MaxValue;

		private int m_UpdateMaxIndex = int.MinValue;

		private static ProbeReferenceVolume.Cell g_Cell;

		internal int estimatedVMemCost { get; private set; }

		private int GetVoxelSubdivLevel()
		{
			return Mathf.Min(3, ProbeReferenceVolume.instance.GetMaxSubdivision() - 1);
		}

		private int SizeOfPhysicalIndexFromBudget(ProbeVolumeTextureMemoryBudget memoryBudget)
		{
			return memoryBudget switch
			{
				ProbeVolumeTextureMemoryBudget.MemoryBudgetLow => 16000000, 
				ProbeVolumeTextureMemoryBudget.MemoryBudgetMedium => 32000000, 
				ProbeVolumeTextureMemoryBudget.MemoryBudgetHigh => 64000000, 
				_ => 32000000, 
			};
		}

		internal ProbeBrickIndex(ProbeVolumeTextureMemoryBudget memoryBudget)
		{
			m_CenterRS = new Vector3Int(0, 0, 0);
			m_VoxelToBricks = new Dictionary<Vector3Int, List<VoxelMeta>>();
			m_BricksToVoxels = new Dictionary<ProbeReferenceVolume.Cell, BrickMeta>();
			m_NeedUpdateIndexComputeBuffer = false;
			m_IndexInChunks = Mathf.CeilToInt((float)SizeOfPhysicalIndexFromBudget(memoryBudget) / 243f);
			m_AvailableChunkCount = m_IndexInChunks;
			m_IndexChunks = new BitArray(Mathf.Max(1, m_IndexInChunks));
			int num = m_IndexInChunks * 243;
			m_PhysicalIndexBufferData = new int[num];
			m_PhysicalIndexBuffer = new ComputeBuffer(num, 4, ComputeBufferType.Structured);
			m_NextFreeChunk = 0;
			estimatedVMemCost = num * 4;
			Clear();
		}

		public int GetRemainingChunkCount()
		{
			return m_AvailableChunkCount;
		}

		internal void UploadIndexData()
		{
			Debug.Assert(m_UpdateMinIndex >= 0 && m_UpdateMaxIndex < m_PhysicalIndexBufferData.Length);
			int count = m_UpdateMaxIndex - m_UpdateMinIndex + 1;
			m_PhysicalIndexBuffer.SetData(m_PhysicalIndexBufferData, m_UpdateMinIndex, m_UpdateMinIndex, count);
			m_NeedUpdateIndexComputeBuffer = false;
			m_UpdateMaxIndex = int.MinValue;
			m_UpdateMinIndex = int.MaxValue;
		}

		internal void Clear()
		{
			for (int i = 0; i < m_PhysicalIndexBufferData.Length; i++)
			{
				m_PhysicalIndexBufferData[i] = -1;
			}
			m_NeedUpdateIndexComputeBuffer = true;
			m_UpdateMinIndex = 0;
			m_UpdateMaxIndex = m_PhysicalIndexBufferData.Length - 1;
			m_NextFreeChunk = 0;
			m_IndexChunks.SetAll(value: false);
			foreach (List<VoxelMeta> value in m_VoxelToBricks.Values)
			{
				foreach (VoxelMeta item in value)
				{
					m_VoxelMetaPool.Release(item);
				}
				m_VoxelMetaListPool.Release(value);
			}
			m_VoxelToBricks.Clear();
			foreach (BrickMeta value2 in m_BricksToVoxels.Values)
			{
				m_BrickMetaPool.Release(value2);
			}
			m_BricksToVoxels.Clear();
		}

		private void MapBrickToVoxels(Brick brick, HashSet<Vector3Int> voxels)
		{
			int subdivisionLevel = brick.subdivisionLevel;
			int num = (int)Mathf.Pow(3f, Mathf.Max(0, subdivisionLevel - GetVoxelSubdivLevel()));
			Vector3Int vector3Int = brick.position;
			int num2 = ProbeReferenceVolume.CellSize(brick.subdivisionLevel);
			int num3 = ProbeReferenceVolume.CellSize(GetVoxelSubdivLevel());
			if (num <= 1)
			{
				Vector3 vector = brick.position;
				vector *= 1f / (float)num3;
				vector3Int = new Vector3Int(Mathf.FloorToInt(vector.x) * num3, Mathf.FloorToInt(vector.y) * num3, Mathf.FloorToInt(vector.z) * num3);
			}
			for (int i = vector3Int.z; i < vector3Int.z + num2; i += num3)
			{
				for (int j = vector3Int.y; j < vector3Int.y + num2; j += num3)
				{
					for (int k = vector3Int.x; k < vector3Int.x + num2; k += num3)
					{
						voxels.Add(new Vector3Int(k, j, i));
					}
				}
			}
		}

		private void ClearVoxel(Vector3Int pos, CellIndexUpdateInfo cellInfo)
		{
			ClipToIndexSpace(pos, GetVoxelSubdivLevel(), out var outMinpos, out var outMaxpos, cellInfo);
			UpdatePhysicalIndex(outMinpos, outMaxpos, -1, cellInfo);
		}

		internal void GetRuntimeResources(ref ProbeReferenceVolume.RuntimeResources rr)
		{
			if (m_NeedUpdateIndexComputeBuffer)
			{
				UploadIndexData();
			}
			rr.index = m_PhysicalIndexBuffer;
		}

		internal void Cleanup()
		{
			CoreUtils.SafeRelease(m_PhysicalIndexBuffer);
			m_PhysicalIndexBuffer = null;
		}

		private int MergeIndex(int index, int size)
		{
			return (index & -1879048193) | ((size & 7) << 28);
		}

		internal bool AssignIndexChunksToCell(int bricksCount, ref CellIndexUpdateInfo cellUpdateInfo, bool ignoreErrorLog)
		{
			int num = Mathf.CeilToInt((float)bricksCount / 243f);
			int num2 = -1;
			for (int i = 0; i < m_IndexInChunks; i++)
			{
				if (!m_IndexChunks[i] && i + num < m_IndexInChunks)
				{
					int num3 = 0;
					for (int j = i; j < i + num && !m_IndexChunks[j]; j++)
					{
						num3++;
					}
					if (num3 == num)
					{
						num2 = i;
						break;
					}
				}
			}
			if (num2 < 0)
			{
				if (!ignoreErrorLog)
				{
					Debug.LogError("APV Index Allocation failed.");
				}
				return false;
			}
			cellUpdateInfo.firstChunkIndex = num2;
			cellUpdateInfo.numberOfChunks = num;
			for (int k = num2; k < num2 + num; k++)
			{
				Debug.Assert(!m_IndexChunks[k]);
				m_IndexChunks[k] = true;
			}
			m_NextFreeChunk += Mathf.Max(0, num2 + num - m_NextFreeChunk);
			m_AvailableChunkCount -= num;
			return true;
		}

		public void AddBricks(ProbeReferenceVolume.Cell cell, NativeArray<Brick> bricks, List<ProbeBrickPool.BrickChunkAlloc> allocations, int allocationSize, int poolWidth, int poolHeight, CellIndexUpdateInfo cellInfo)
		{
			Debug.Assert(bricks.Length <= 65535, "Cannot add more than 65K bricks per RegId.");
			int num = ProbeReferenceVolume.CellSize(7);
			g_Cell = cell;
			BrickMeta brickMeta = m_BrickMetaPool.Get();
			m_BricksToVoxels.Add(cell, brickMeta);
			int num2 = 0;
			for (int i = 0; i < allocations.Count; i++)
			{
				ProbeBrickPool.BrickChunkAlloc brickChunkAlloc = allocations[i];
				int num3 = Mathf.Min(allocationSize, bricks.Length - num2);
				int num4 = 0;
				while (num4 < num3)
				{
					Brick brick = bricks[num2];
					int num5 = ProbeReferenceVolume.CellSize(brick.subdivisionLevel);
					Debug.Assert(num5 <= num, "Cell sizes are not correctly sorted.");
					num = Mathf.Min(num, num5);
					MapBrickToVoxels(brick, brickMeta.voxels);
					ReservedBrick item = new ReservedBrick
					{
						brick = brick,
						flattenedIdx = MergeIndex(brickChunkAlloc.flattenIndex(poolWidth, poolHeight), brick.subdivisionLevel)
					};
					brickMeta.bricks.Add(item);
					foreach (Vector3Int voxel in brickMeta.voxels)
					{
						if (!m_VoxelToBricks.TryGetValue(voxel, out var value))
						{
							value = m_VoxelMetaListPool.Get();
							m_VoxelToBricks.Add(voxel, value);
						}
						VoxelMeta voxelMeta = null;
						int num6 = value.FindIndex((VoxelMeta lhs) => lhs.cell == g_Cell);
						if (num6 == -1)
						{
							voxelMeta = m_VoxelMetaPool.Get();
							voxelMeta.cell = cell;
							value.Add(voxelMeta);
						}
						else
						{
							voxelMeta = value[num6];
						}
						voxelMeta.brickIndices.Add((ushort)num2);
					}
					num4++;
					num2++;
					brickChunkAlloc.x += 4;
				}
			}
			foreach (Vector3Int voxel2 in brickMeta.voxels)
			{
				UpdateIndexForVoxel(voxel2, cellInfo);
			}
		}

		public void RemoveBricks(ProbeReferenceVolume.CellInfo cellInfo)
		{
			if (!m_BricksToVoxels.ContainsKey(cellInfo.cell))
			{
				return;
			}
			CellIndexUpdateInfo updateInfo = cellInfo.updateInfo;
			g_Cell = cellInfo.cell;
			BrickMeta brickMeta = m_BricksToVoxels[cellInfo.cell];
			foreach (Vector3Int voxel in brickMeta.voxels)
			{
				List<VoxelMeta> list = m_VoxelToBricks[voxel];
				int num = list.FindIndex((VoxelMeta lhs) => lhs.cell == g_Cell);
				if (num >= 0)
				{
					m_VoxelMetaPool.Release(list[num]);
					list.RemoveAt(num);
					if (list.Count > 0)
					{
						UpdateIndexForVoxel(voxel, updateInfo);
						continue;
					}
					ClearVoxel(voxel, updateInfo);
					m_VoxelMetaListPool.Release(list);
					m_VoxelToBricks.Remove(voxel);
				}
			}
			m_BrickMetaPool.Release(brickMeta);
			m_BricksToVoxels.Remove(cellInfo.cell);
			for (int num2 = updateInfo.firstChunkIndex; num2 < updateInfo.firstChunkIndex + updateInfo.numberOfChunks; num2++)
			{
				m_IndexChunks[num2] = false;
			}
			m_AvailableChunkCount += updateInfo.numberOfChunks;
		}

		private void UpdateIndexForVoxel(Vector3Int voxel, CellIndexUpdateInfo cellInfo)
		{
			ClearVoxel(voxel, cellInfo);
			foreach (VoxelMeta item in m_VoxelToBricks[voxel])
			{
				List<ReservedBrick> bricks = m_BricksToVoxels[item.cell].bricks;
				List<ushort> brickIndices = item.brickIndices;
				UpdateIndexForVoxel(voxel, bricks, brickIndices, cellInfo);
			}
		}

		private void UpdatePhysicalIndex(Vector3Int brickMin, Vector3Int brickMax, int value, CellIndexUpdateInfo cellInfo)
		{
			brickMin -= cellInfo.cellPositionInBricksAtMaxRes;
			brickMax -= cellInfo.cellPositionInBricksAtMaxRes;
			brickMin /= ProbeReferenceVolume.CellSize(cellInfo.minSubdivInCell);
			brickMax /= ProbeReferenceVolume.CellSize(cellInfo.minSubdivInCell);
			int num = ProbeReferenceVolume.CellSize(ProbeReferenceVolume.instance.GetMaxSubdivision() - 1 - cellInfo.minSubdivInCell);
			Debug.Assert(brickMin.x >= 0 && brickMin.y >= 0 && brickMin.z >= 0 && brickMax.x >= 0 && brickMax.y >= 0 && brickMax.z >= 0);
			Debug.Assert(brickMin.x < num && brickMin.y < num && brickMin.z < num && brickMax.x <= num && brickMax.y <= num && brickMax.z <= num);
			Vector3Int vector3Int = cellInfo.minValidBrickIndexForCellAtMaxRes / ProbeReferenceVolume.CellSize(cellInfo.minSubdivInCell);
			Vector3Int vector3Int2 = cellInfo.maxValidBrickIndexForCellAtMaxResPlusOne / ProbeReferenceVolume.CellSize(cellInfo.minSubdivInCell);
			brickMin -= vector3Int;
			brickMax -= vector3Int;
			Debug.Assert(brickMin.x >= 0 && brickMin.y >= 0 && brickMin.z >= 0 && brickMax.x >= 0 && brickMax.y >= 0 && brickMax.z >= 0);
			Vector3Int vector3Int3 = vector3Int2 - vector3Int;
			int num2 = cellInfo.firstChunkIndex * 243;
			int val = num2 + brickMin.z * (vector3Int3.x * vector3Int3.y) + brickMin.x * vector3Int3.y + brickMin.y;
			int val2 = num2 + Math.Max(0, brickMax.z - 1) * (vector3Int3.x * vector3Int3.y) + Math.Max(0, brickMax.x - 1) * vector3Int3.y + Math.Max(0, brickMax.y - 1);
			m_UpdateMinIndex = Math.Min(m_UpdateMinIndex, val);
			m_UpdateMaxIndex = Math.Max(m_UpdateMaxIndex, val2);
			for (int i = brickMin.x; i < brickMax.x; i++)
			{
				for (int j = brickMin.z; j < brickMax.z; j++)
				{
					for (int k = brickMin.y; k < brickMax.y; k++)
					{
						int num3 = j * (vector3Int3.x * vector3Int3.y) + i * vector3Int3.y + k;
						int num4 = num2 + num3;
						m_PhysicalIndexBufferData[num4] = value;
					}
				}
			}
			m_NeedUpdateIndexComputeBuffer = true;
		}

		private void ClipToIndexSpace(Vector3Int pos, int subdiv, out Vector3Int outMinpos, out Vector3Int outMaxpos, CellIndexUpdateInfo cellInfo)
		{
			int num = ProbeReferenceVolume.CellSize(subdiv);
			Vector3Int vector3Int = cellInfo.cellPositionInBricksAtMaxRes + cellInfo.minValidBrickIndexForCellAtMaxRes;
			Vector3Int vector3Int2 = cellInfo.cellPositionInBricksAtMaxRes + cellInfo.maxValidBrickIndexForCellAtMaxResPlusOne - Vector3Int.one;
			int num2 = pos.x - m_CenterRS.x;
			int y = pos.y;
			int num3 = pos.z - m_CenterRS.z;
			int a = num2 + num;
			int a2 = y + num;
			int a3 = num3 + num;
			num2 = Mathf.Max(num2, vector3Int.x);
			y = Mathf.Max(y, vector3Int.y);
			num3 = Mathf.Max(num3, vector3Int.z);
			a = Mathf.Min(a, vector3Int2.x);
			a2 = Mathf.Min(a2, vector3Int2.y);
			a3 = Mathf.Min(a3, vector3Int2.z);
			outMinpos = new Vector3Int(num2, y, num3);
			outMaxpos = new Vector3Int(a, a2, a3);
		}

		private void UpdateIndexForVoxel(Vector3Int voxel, List<ReservedBrick> bricks, List<ushort> indices, CellIndexUpdateInfo cellInfo)
		{
			ClipToIndexSpace(voxel, GetVoxelSubdivLevel(), out var outMinpos, out var outMaxpos, cellInfo);
			foreach (ReservedBrick brick in bricks)
			{
				int num = ProbeReferenceVolume.CellSize(brick.brick.subdivisionLevel);
				Vector3Int position = brick.brick.position;
				Vector3Int brickMax = brick.brick.position + Vector3Int.one * num;
				position.x = Mathf.Max(outMinpos.x, position.x - m_CenterRS.x);
				position.y = Mathf.Max(outMinpos.y, position.y);
				position.z = Mathf.Max(outMinpos.z, position.z - m_CenterRS.z);
				brickMax.x = Mathf.Min(outMaxpos.x, brickMax.x - m_CenterRS.x);
				brickMax.y = Mathf.Min(outMaxpos.y, brickMax.y);
				brickMax.z = Mathf.Min(outMaxpos.z, brickMax.z - m_CenterRS.z);
				UpdatePhysicalIndex(position, brickMax, brick.flattenedIdx, cellInfo);
			}
		}
	}
	internal class ProbeBrickPool
	{
		[DebuggerDisplay("Chunk ({x}, {y}, {z})")]
		public struct BrickChunkAlloc
		{
			public int x;

			public int y;

			public int z;

			internal int flattenIndex(int sx, int sy)
			{
				return z * (sx * sy) + y * sx + x;
			}
		}

		public struct DataLocation
		{
			internal Texture TexL0_L1rx;

			internal Texture TexL1_G_ry;

			internal Texture TexL1_B_rz;

			internal Texture TexL2_0;

			internal Texture TexL2_1;

			internal Texture TexL2_2;

			internal Texture TexL2_3;

			internal Texture3D TexValidity;

			internal int width;

			internal int height;

			internal int depth;

			internal void Cleanup()
			{
				CoreUtils.Destroy(TexL0_L1rx);
				CoreUtils.Destroy(TexL1_G_ry);
				CoreUtils.Destroy(TexL1_B_rz);
				CoreUtils.Destroy(TexL2_0);
				CoreUtils.Destroy(TexL2_1);
				CoreUtils.Destroy(TexL2_2);
				CoreUtils.Destroy(TexL2_3);
				CoreUtils.Destroy(TexValidity);
				TexL0_L1rx = null;
				TexL1_G_ry = null;
				TexL1_B_rz = null;
				TexL2_0 = null;
				TexL2_1 = null;
				TexL2_2 = null;
				TexL2_3 = null;
				TexValidity = null;
			}
		}

		private const int kProbePoolChunkSizeInBricks = 128;

		internal const int kBrickCellCount = 3;

		internal const int kBrickProbeCountPerDim = 4;

		internal const int kBrickProbeCountTotal = 64;

		internal const int kChunkProbeCountPerDim = 512;

		private const int kMaxPoolWidth = 2048;

		internal DataLocation m_Pool;

		private BrickChunkAlloc m_NextFreeChunk;

		private Stack<BrickChunkAlloc> m_FreeList;

		private int m_AvailableChunkCount;

		private ProbeVolumeSHBands m_SHBands;

		private bool m_ContainsValidity;

		internal int estimatedVMemCost { get; private set; }

		internal ProbeBrickPool(ProbeVolumeTextureMemoryBudget memoryBudget, ProbeVolumeSHBands shBands, bool allocateValidityData = true)
		{
			m_NextFreeChunk.x = (m_NextFreeChunk.y = (m_NextFreeChunk.z = 0));
			m_SHBands = shBands;
			m_ContainsValidity = allocateValidityData;
			m_FreeList = new Stack<BrickChunkAlloc>(256);
			DerivePoolSizeFromBudget(memoryBudget, out var width, out var height, out var depth);
			m_Pool = CreateDataLocation(width * height * depth, compressed: false, shBands, "APV", allocateRendertexture: true, allocateValidityData, out var allocatedBytes);
			estimatedVMemCost = allocatedBytes;
			m_AvailableChunkCount = m_Pool.width / 512 * (m_Pool.height / 4) * (m_Pool.depth / 4);
		}

		public int GetRemainingChunkCount()
		{
			return m_AvailableChunkCount;
		}

		internal void EnsureTextureValidity()
		{
			if (m_Pool.TexL0_L1rx == null)
			{
				m_Pool.Cleanup();
				m_Pool = CreateDataLocation(m_Pool.width * m_Pool.height * m_Pool.depth, compressed: false, m_SHBands, "APV", allocateRendertexture: true, m_ContainsValidity, out var allocatedBytes);
				estimatedVMemCost = allocatedBytes;
			}
		}

		internal static int GetChunkSizeInBrickCount()
		{
			return 128;
		}

		internal static int GetChunkSizeInProbeCount()
		{
			return 8192;
		}

		internal int GetPoolWidth()
		{
			return m_Pool.width;
		}

		internal int GetPoolHeight()
		{
			return m_Pool.height;
		}

		internal Vector3Int GetPoolDimensions()
		{
			return new Vector3Int(m_Pool.width, m_Pool.height, m_Pool.depth);
		}

		internal void GetRuntimeResources(ref ProbeReferenceVolume.RuntimeResources rr)
		{
			rr.L0_L1rx = m_Pool.TexL0_L1rx as RenderTexture;
			rr.L1_G_ry = m_Pool.TexL1_G_ry as RenderTexture;
			rr.L1_B_rz = m_Pool.TexL1_B_rz as RenderTexture;
			rr.L2_0 = m_Pool.TexL2_0 as RenderTexture;
			rr.L2_1 = m_Pool.TexL2_1 as RenderTexture;
			rr.L2_2 = m_Pool.TexL2_2 as RenderTexture;
			rr.L2_3 = m_Pool.TexL2_3 as RenderTexture;
			rr.Validity = m_Pool.TexValidity;
		}

		internal void Clear()
		{
			m_FreeList.Clear();
			m_NextFreeChunk.x = (m_NextFreeChunk.y = (m_NextFreeChunk.z = 0));
		}

		internal static int GetChunkCount(int brickCount, int chunkSizeInBricks)
		{
			return (brickCount + chunkSizeInBricks - 1) / chunkSizeInBricks;
		}

		internal bool Allocate(int numberOfBrickChunks, List<BrickChunkAlloc> outAllocations, bool ignoreErrorLog)
		{
			while (m_FreeList.Count > 0 && numberOfBrickChunks > 0)
			{
				outAllocations.Add(m_FreeList.Pop());
				numberOfBrickChunks--;
				m_AvailableChunkCount--;
			}
			for (uint num = 0u; num < numberOfBrickChunks; num++)
			{
				if (m_NextFreeChunk.z >= m_Pool.depth)
				{
					if (!ignoreErrorLog)
					{
						Debug.LogError("Cannot allocate more brick chunks, probe volume brick pool is full.");
					}
					return false;
				}
				outAllocations.Add(m_NextFreeChunk);
				m_AvailableChunkCount--;
				m_NextFreeChunk.x += 512;
				if (m_NextFreeChunk.x >= m_Pool.width)
				{
					m_NextFreeChunk.x = 0;
					m_NextFreeChunk.y += 4;
					if (m_NextFreeChunk.y >= m_Pool.height)
					{
						m_NextFreeChunk.y = 0;
						m_NextFreeChunk.z += 4;
					}
				}
			}
			return true;
		}

		internal void Deallocate(List<BrickChunkAlloc> allocations)
		{
			m_AvailableChunkCount += allocations.Count;
			foreach (BrickChunkAlloc allocation in allocations)
			{
				m_FreeList.Push(allocation);
			}
		}

		internal void Update(DataLocation source, List<BrickChunkAlloc> srcLocations, List<BrickChunkAlloc> dstLocations, int destStartIndex, ProbeVolumeSHBands bands)
		{
			for (int i = 0; i < srcLocations.Count; i++)
			{
				BrickChunkAlloc brickChunkAlloc = srcLocations[i];
				BrickChunkAlloc brickChunkAlloc2 = dstLocations[destStartIndex + i];
				for (int j = 0; j < 4; j++)
				{
					int srcWidth = Mathf.Min(512, source.width - brickChunkAlloc.x);
					Graphics.CopyTexture(source.TexL0_L1rx, brickChunkAlloc.z + j, 0, brickChunkAlloc.x, brickChunkAlloc.y, srcWidth, 4, m_Pool.TexL0_L1rx, brickChunkAlloc2.z + j, 0, brickChunkAlloc2.x, brickChunkAlloc2.y);
					Graphics.CopyTexture(source.TexL1_G_ry, brickChunkAlloc.z + j, 0, brickChunkAlloc.x, brickChunkAlloc.y, srcWidth, 4, m_Pool.TexL1_G_ry, brickChunkAlloc2.z + j, 0, brickChunkAlloc2.x, brickChunkAlloc2.y);
					Graphics.CopyTexture(source.TexL1_B_rz, brickChunkAlloc.z + j, 0, brickChunkAlloc.x, brickChunkAlloc.y, srcWidth, 4, m_Pool.TexL1_B_rz, brickChunkAlloc2.z + j, 0, brickChunkAlloc2.x, brickChunkAlloc2.y);
					if (m_ContainsValidity)
					{
						Graphics.CopyTexture(source.TexValidity, brickChunkAlloc.z + j, 0, brickChunkAlloc.x, brickChunkAlloc.y, srcWidth, 4, m_Pool.TexValidity, brickChunkAlloc2.z + j, 0, brickChunkAlloc2.x, brickChunkAlloc2.y);
					}
					if (bands == ProbeVolumeSHBands.SphericalHarmonicsL2)
					{
						Graphics.CopyTexture(source.TexL2_0, brickChunkAlloc.z + j, 0, brickChunkAlloc.x, brickChunkAlloc.y, srcWidth, 4, m_Pool.TexL2_0, brickChunkAlloc2.z + j, 0, brickChunkAlloc2.x, brickChunkAlloc2.y);
						Graphics.CopyTexture(source.TexL2_1, brickChunkAlloc.z + j, 0, brickChunkAlloc.x, brickChunkAlloc.y, srcWidth, 4, m_Pool.TexL2_1, brickChunkAlloc2.z + j, 0, brickChunkAlloc2.x, brickChunkAlloc2.y);
						Graphics.CopyTexture(source.TexL2_2, brickChunkAlloc.z + j, 0, brickChunkAlloc.x, brickChunkAlloc.y, srcWidth, 4, m_Pool.TexL2_2, brickChunkAlloc2.z + j, 0, brickChunkAlloc2.x, brickChunkAlloc2.y);
						Graphics.CopyTexture(source.TexL2_3, brickChunkAlloc.z + j, 0, brickChunkAlloc.x, brickChunkAlloc.y, srcWidth, 4, m_Pool.TexL2_3, brickChunkAlloc2.z + j, 0, brickChunkAlloc2.x, brickChunkAlloc2.y);
					}
				}
			}
		}

		internal void UpdateValidity(DataLocation source, List<BrickChunkAlloc> srcLocations, List<BrickChunkAlloc> dstLocations, int destStartIndex)
		{
			Debug.Assert(m_ContainsValidity);
			for (int i = 0; i < srcLocations.Count; i++)
			{
				BrickChunkAlloc brickChunkAlloc = srcLocations[i];
				BrickChunkAlloc brickChunkAlloc2 = dstLocations[destStartIndex + i];
				for (int j = 0; j < 4; j++)
				{
					int srcWidth = Mathf.Min(512, source.width - brickChunkAlloc.x);
					Graphics.CopyTexture(source.TexValidity, brickChunkAlloc.z + j, 0, brickChunkAlloc.x, brickChunkAlloc.y, srcWidth, 4, m_Pool.TexValidity, brickChunkAlloc2.z + j, 0, brickChunkAlloc2.x, brickChunkAlloc2.y);
				}
			}
		}

		internal static Vector3Int ProbeCountToDataLocSize(int numProbes)
		{
			Debug.Assert(numProbes != 0);
			Debug.Assert(numProbes % 64 == 0);
			int num = numProbes / 64;
			int num2 = 512;
			int num3 = (num + num2 * num2 - 1) / (num2 * num2);
			int num4;
			int num5;
			if (num3 > 1)
			{
				num4 = (num5 = num2);
			}
			else
			{
				num5 = (num + num2 - 1) / num2;
				num4 = ((num5 <= 1) ? num : num2);
			}
			num4 *= 4;
			num5 *= 4;
			num3 *= 4;
			return new Vector3Int(num4, num5, num3);
		}

		public static Texture CreateDataTexture(int width, int height, int depth, GraphicsFormat format, string name, bool allocateRendertexture, ref int allocatedBytes)
		{
			allocatedBytes += width * height * depth * format switch
			{
				GraphicsFormat.R8G8B8A8_UNorm => 4, 
				GraphicsFormat.R16G16B16A16_SFloat => 8, 
				_ => 1, 
			};
			Texture texture = ((!allocateRendertexture) ? ((Texture)new Texture3D(width, height, depth, format, TextureCreationFlags.None, 1)) : ((Texture)new RenderTexture(new RenderTextureDescriptor
			{
				width = width,
				height = height,
				volumeDepth = depth,
				graphicsFormat = format,
				mipCount = 1,
				enableRandomWrite = true,
				dimension = TextureDimension.Tex3D,
				msaaSamples = 1
			})));
			texture.hideFlags = HideFlags.HideAndDontSave;
			texture.name = name;
			if (allocateRendertexture)
			{
				(texture as RenderTexture).Create();
			}
			return texture;
		}

		public static DataLocation CreateDataLocation(int numProbes, bool compressed, ProbeVolumeSHBands bands, string name, bool allocateRendertexture, bool allocateValidityData, out int allocatedBytes)
		{
			Vector3Int vector3Int = ProbeCountToDataLocSize(numProbes);
			int x = vector3Int.x;
			int y = vector3Int.y;
			int z = vector3Int.z;
			GraphicsFormat format = GraphicsFormat.R16G16B16A16_SFloat;
			GraphicsFormat format2 = (compressed ? GraphicsFormat.RGBA_BC7_UNorm : GraphicsFormat.R8G8B8A8_UNorm);
			allocatedBytes = 0;
			DataLocation result = default(DataLocation);
			result.TexL0_L1rx = CreateDataTexture(x, y, z, format, name + "_TexL0_L1rx", allocateRendertexture, ref allocatedBytes);
			result.TexL1_G_ry = CreateDataTexture(x, y, z, format2, name + "_TexL1_G_ry", allocateRendertexture, ref allocatedBytes);
			result.TexL1_B_rz = CreateDataTexture(x, y, z, format2, name + "_TexL1_B_rz", allocateRendertexture, ref allocatedBytes);
			if (allocateValidityData)
			{
				result.TexValidity = CreateDataTexture(x, y, z, GraphicsFormat.R8_UNorm, name + "_Validity", allocateRendertexture: false, ref allocatedBytes) as Texture3D;
			}
			else
			{
				result.TexValidity = null;
			}
			if (bands == ProbeVolumeSHBands.SphericalHarmonicsL2)
			{
				result.TexL2_0 = CreateDataTexture(x, y, z, format2, name + "_TexL2_0", allocateRendertexture, ref allocatedBytes);
				result.TexL2_1 = CreateDataTexture(x, y, z, format2, name + "_TexL2_1", allocateRendertexture, ref allocatedBytes);
				result.TexL2_2 = CreateDataTexture(x, y, z, format2, name + "_TexL2_2", allocateRendertexture, ref allocatedBytes);
				result.TexL2_3 = CreateDataTexture(x, y, z, format2, name + "_TexL2_3", allocateRendertexture, ref allocatedBytes);
			}
			else
			{
				result.TexL2_0 = null;
				result.TexL2_1 = null;
				result.TexL2_2 = null;
				result.TexL2_3 = null;
			}
			result.width = x;
			result.height = y;
			result.depth = z;
			return result;
		}

		private void DerivePoolSizeFromBudget(ProbeVolumeTextureMemoryBudget memoryBudget, out int width, out int height, out int depth)
		{
			width = (int)memoryBudget;
			height = (int)memoryBudget;
			depth = 4;
		}

		internal void Cleanup()
		{
			m_Pool.Cleanup();
		}
	}
	internal class ProbeBrickBlendingPool
	{
		private static ComputeShader stateBlendShader;

		private static int scenarioBlendingKernel = -1;

		private static readonly int _PoolDim_LerpFactor = Shader.PropertyToID("_PoolDim_LerpFactor");

		private static readonly int _ChunkList = Shader.PropertyToID("_ChunkList");

		private static readonly int _State0_L0_L1Rx = Shader.PropertyToID("_State0_L0_L1Rx");

		private static readonly int _State0_L1G_L1Ry = Shader.PropertyToID("_State0_L1G_L1Ry");

		private static readonly int _State0_L1B_L1Rz = Shader.PropertyToID("_State0_L1B_L1Rz");

		private static readonly int _State0_L2_0 = Shader.PropertyToID("_State0_L2_0");

		private static readonly int _State0_L2_1 = Shader.PropertyToID("_State0_L2_1");

		private static readonly int _State0_L2_2 = Shader.PropertyToID("_State0_L2_2");

		private static readonly int _State0_L2_3 = Shader.PropertyToID("_State0_L2_3");

		private static readonly int _State1_L0_L1Rx = Shader.PropertyToID("_State1_L0_L1Rx");

		private static readonly int _State1_L1G_L1Ry = Shader.PropertyToID("_State1_L1G_L1Ry");

		private static readonly int _State1_L1B_L1Rz = Shader.PropertyToID("_State1_L1B_L1Rz");

		private static readonly int _State1_L2_0 = Shader.PropertyToID("_State1_L2_0");

		private static readonly int _State1_L2_1 = Shader.PropertyToID("_State1_L2_1");

		private static readonly int _State1_L2_2 = Shader.PropertyToID("_State1_L2_2");

		private static readonly int _State1_L2_3 = Shader.PropertyToID("_State1_L2_3");

		private static readonly int _Out_L0_L1Rx = Shader.PropertyToID("_Out_L0_L1Rx");

		private static readonly int _Out_L1G_L1Ry = Shader.PropertyToID("_Out_L1G_L1Ry");

		private static readonly int _Out_L1B_L1Rz = Shader.PropertyToID("_Out_L1B_L1Rz");

		private static readonly int _Out_L2_0 = Shader.PropertyToID("_Out_L2_0");

		private static readonly int _Out_L2_1 = Shader.PropertyToID("_Out_L2_1");

		private static readonly int _Out_L2_2 = Shader.PropertyToID("_Out_L2_2");

		private static readonly int _Out_L2_3 = Shader.PropertyToID("_Out_L2_3");

		private Vector4[] m_ChunkList;

		private int m_MappedChunks;

		private ProbeBrickPool m_State0;

		private ProbeBrickPool m_State1;

		private ProbeVolumeTextureMemoryBudget m_MemoryBudget;

		private ProbeVolumeSHBands m_ShBands;

		internal static bool isSupported => stateBlendShader != null;

		internal bool isAllocated => m_State0 != null;

		internal int estimatedVMemCost
		{
			get
			{
				if (!isAllocated)
				{
					return 0;
				}
				return m_State0.estimatedVMemCost + m_State1.estimatedVMemCost;
			}
		}

		internal static void Initialize(in ProbeVolumeSystemParameters parameters)
		{
			stateBlendShader = parameters.scenarioBlendingShader;
			scenarioBlendingKernel = (stateBlendShader ? stateBlendShader.FindKernel("BlendScenarios") : (-1));
		}

		internal int GetPoolWidth()
		{
			return m_State0.m_Pool.width;
		}

		internal int GetPoolHeight()
		{
			return m_State0.m_Pool.height;
		}

		internal int GetPoolDepth()
		{
			return m_State0.m_Pool.depth;
		}

		internal ProbeBrickBlendingPool(ProbeVolumeBlendingTextureMemoryBudget memoryBudget, ProbeVolumeSHBands shBands)
		{
			m_MemoryBudget = (ProbeVolumeTextureMemoryBudget)memoryBudget;
			m_ShBands = shBands;
		}

		internal void AllocateResourcesIfNeeded()
		{
			if (!isAllocated)
			{
				m_State0 = new ProbeBrickPool(m_MemoryBudget, m_ShBands, allocateValidityData: false);
				m_State1 = new ProbeBrickPool(m_MemoryBudget, m_ShBands, allocateValidityData: false);
				int num = GetPoolWidth() / 512 * (GetPoolHeight() / 4) * (GetPoolDepth() / 4);
				m_ChunkList = new Vector4[num];
				m_MappedChunks = 0;
			}
		}

		internal void Update(ProbeBrickPool.DataLocation source, List<ProbeBrickPool.BrickChunkAlloc> srcLocations, List<ProbeBrickPool.BrickChunkAlloc> dstLocations, int destStartIndex, ProbeVolumeSHBands bands, int state)
		{
			((state == 0) ? m_State0 : m_State1).Update(source, srcLocations, dstLocations, destStartIndex, bands);
		}

		private static int DivRoundUp(int x, int y)
		{
			return (x + y - 1) / y;
		}

		internal void PerformBlending(CommandBuffer cmd, float factor, ProbeBrickPool dstPool)
		{
			if (m_MappedChunks != 0)
			{
				cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State0_L0_L1Rx, m_State0.m_Pool.TexL0_L1rx);
				cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State0_L1G_L1Ry, m_State0.m_Pool.TexL1_G_ry);
				cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State0_L1B_L1Rz, m_State0.m_Pool.TexL1_B_rz);
				cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State1_L0_L1Rx, m_State1.m_Pool.TexL0_L1rx);
				cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State1_L1G_L1Ry, m_State1.m_Pool.TexL1_G_ry);
				cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State1_L1B_L1Rz, m_State1.m_Pool.TexL1_B_rz);
				cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _Out_L0_L1Rx, dstPool.m_Pool.TexL0_L1rx);
				cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _Out_L1G_L1Ry, dstPool.m_Pool.TexL1_G_ry);
				cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _Out_L1B_L1Rz, dstPool.m_Pool.TexL1_B_rz);
				if (m_ShBands == ProbeVolumeSHBands.SphericalHarmonicsL2)
				{
					stateBlendShader.EnableKeyword("PROBE_VOLUMES_L2");
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State0_L2_0, m_State0.m_Pool.TexL2_0);
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State0_L2_1, m_State0.m_Pool.TexL2_1);
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State0_L2_2, m_State0.m_Pool.TexL2_2);
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State0_L2_3, m_State0.m_Pool.TexL2_3);
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State1_L2_0, m_State1.m_Pool.TexL2_0);
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State1_L2_1, m_State1.m_Pool.TexL2_1);
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State1_L2_2, m_State1.m_Pool.TexL2_2);
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _State1_L2_3, m_State1.m_Pool.TexL2_3);
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _Out_L2_0, dstPool.m_Pool.TexL2_0);
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _Out_L2_1, dstPool.m_Pool.TexL2_1);
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _Out_L2_2, dstPool.m_Pool.TexL2_2);
					cmd.SetComputeTextureParam(stateBlendShader, scenarioBlendingKernel, _Out_L2_3, dstPool.m_Pool.TexL2_3);
				}
				else
				{
					stateBlendShader.DisableKeyword("PROBE_VOLUMES_L2");
				}
				Vector4 val = new Vector4(dstPool.GetPoolWidth(), dstPool.GetPoolHeight(), factor, 0f);
				int threadGroupsX = DivRoundUp(512, 4);
				int threadGroupsY = DivRoundUp(4, 4);
				int num = DivRoundUp(4, 4);
				cmd.SetComputeVectorArrayParam(stateBlendShader, _ChunkList, m_ChunkList);
				cmd.SetComputeVectorParam(stateBlendShader, _PoolDim_LerpFactor, val);
				cmd.DispatchCompute(stateBlendShader, scenarioBlendingKernel, threadGroupsX, threadGroupsY, num * m_MappedChunks);
				m_MappedChunks = 0;
			}
		}

		internal void BlendChunks(ProbeReferenceVolume.BlendingCellInfo blendingCell, ProbeBrickPool dstPool)
		{
			for (int i = 0; i < blendingCell.chunkList.Count; i++)
			{
				ProbeBrickPool.BrickChunkAlloc brickChunkAlloc = blendingCell.chunkList[i];
				int num = blendingCell.cellInfo.chunkList[i].flattenIndex(dstPool.GetPoolWidth(), dstPool.GetPoolHeight());
				m_ChunkList[m_MappedChunks++] = new Vector4(brickChunkAlloc.x, brickChunkAlloc.y, brickChunkAlloc.z, num);
			}
		}

		internal void Clear()
		{
			m_State0?.Clear();
		}

		internal bool Allocate(int numberOfBrickChunks, List<ProbeBrickPool.BrickChunkAlloc> outAllocations)
		{
			AllocateResourcesIfNeeded();
			if (numberOfBrickChunks > m_State0.GetRemainingChunkCount())
			{
				return false;
			}
			return m_State0.Allocate(numberOfBrickChunks, outAllocations, ignoreErrorLog: false);
		}

		internal void Deallocate(List<ProbeBrickPool.BrickChunkAlloc> allocations)
		{
			if (allocations.Count != 0)
			{
				m_State0.Deallocate(allocations);
			}
		}

		internal void EnsureTextureValidity()
		{
			if (isAllocated)
			{
				m_State0.EnsureTextureValidity();
				m_State1.EnsureTextureValidity();
			}
		}

		internal void Cleanup()
		{
			if (isAllocated)
			{
				m_State0.Cleanup();
				m_State1.Cleanup();
			}
		}
	}
	internal class ProbeCellIndices
	{
		internal struct IndexMetaData
		{
			private static uint[] s_PackedValues = new uint[3];

			internal Vector3Int minLocalIdx;

			internal Vector3Int maxLocalIdx;

			internal int firstChunkIndex;

			internal int minSubdiv;

			internal void Pack(out uint[] vals)
			{
				vals = s_PackedValues;
				for (int i = 0; i < 3; i++)
				{
					vals[i] = 0u;
				}
				vals[0] = (uint)(firstChunkIndex & 0x1FFFFFFF);
				vals[0] |= (uint)((minSubdiv & 7) << 29);
				vals[1] = (uint)(minLocalIdx.x & 0x3FF);
				vals[1] |= (uint)((minLocalIdx.y & 0x3FF) << 10);
				vals[1] |= (uint)((minLocalIdx.z & 0x3FF) << 20);
				vals[2] = (uint)(maxLocalIdx.x & 0x3FF);
				vals[2] |= (uint)((maxLocalIdx.y & 0x3FF) << 10);
				vals[2] |= (uint)((maxLocalIdx.z & 0x3FF) << 20);
			}
		}

		private const int kUintPerEntry = 3;

		private ComputeBuffer m_IndexOfIndicesBuffer;

		private uint[] m_IndexOfIndicesData;

		private Vector3Int m_CellCount;

		private Vector3Int m_CellMin;

		private int m_CellSizeInMinBricks;

		private bool m_NeedUpdateComputeBuffer;

		internal int estimatedVMemCost { get; private set; }

		internal Vector3Int GetCellIndexDimension()
		{
			return m_CellCount;
		}

		internal Vector3Int GetCellMinPosition()
		{
			return m_CellMin;
		}

		private int GetFlatIndex(Vector3Int normalizedPos)
		{
			return normalizedPos.z * (m_CellCount.x * m_CellCount.y) + normalizedPos.y * m_CellCount.x + normalizedPos.x;
		}

		internal ProbeCellIndices(Vector3Int cellMin, Vector3Int cellMax, int cellSizeInMinBricks)
		{
			Vector3Int vector3Int = (m_CellCount = cellMax + Vector3Int.one - cellMin);
			m_CellMin = cellMin;
			m_CellSizeInMinBricks = cellSizeInMinBricks;
			int num = vector3Int.x * vector3Int.y * vector3Int.z;
			int num2 = 3 * num;
			m_IndexOfIndicesBuffer = new ComputeBuffer(num, 12);
			m_IndexOfIndicesData = new uint[num2];
			m_NeedUpdateComputeBuffer = false;
			estimatedVMemCost = num * 3 * 4;
		}

		internal int GetFlatIdxForCell(Vector3Int cellPosition)
		{
			Vector3Int normalizedPos = cellPosition - m_CellMin;
			Debug.Assert(normalizedPos.x >= 0 && normalizedPos.y >= 0 && normalizedPos.z >= 0);
			return GetFlatIndex(normalizedPos);
		}

		internal void UpdateCell(int cellFlatIdx, ProbeBrickIndex.CellIndexUpdateInfo cellUpdateInfo)
		{
			int num = ProbeReferenceVolume.CellSize(cellUpdateInfo.minSubdivInCell);
			IndexMetaData indexMetaData = default(IndexMetaData);
			indexMetaData.minSubdiv = cellUpdateInfo.minSubdivInCell;
			indexMetaData.minLocalIdx = cellUpdateInfo.minValidBrickIndexForCellAtMaxRes / num;
			indexMetaData.maxLocalIdx = cellUpdateInfo.maxValidBrickIndexForCellAtMaxResPlusOne / num;
			indexMetaData.firstChunkIndex = cellUpdateInfo.firstChunkIndex;
			indexMetaData.Pack(out var vals);
			for (int i = 0; i < 3; i++)
			{
				m_IndexOfIndicesData[cellFlatIdx * 3 + i] = vals[i];
			}
			m_NeedUpdateComputeBuffer = true;
		}

		internal void MarkCellAsUnloaded(int cellFlatIdx)
		{
			for (int i = 0; i < 3; i++)
			{
				m_IndexOfIndicesData[cellFlatIdx * 3 + i] = uint.MaxValue;
			}
			m_NeedUpdateComputeBuffer = true;
		}

		internal void PushComputeData()
		{
			m_IndexOfIndicesBuffer.SetData(m_IndexOfIndicesData);
			m_NeedUpdateComputeBuffer = false;
		}

		internal void GetRuntimeResources(ref ProbeReferenceVolume.RuntimeResources rr)
		{
			if (m_NeedUpdateComputeBuffer)
			{
				PushComputeData();
			}
			rr.cellIndices = m_IndexOfIndicesBuffer;
		}

		internal void Cleanup()
		{
			CoreUtils.SafeRelease(m_IndexOfIndicesBuffer);
			m_IndexOfIndicesBuffer = null;
		}
	}
	public struct ProbeVolumeSystemParameters
	{
		public ProbeVolumeTextureMemoryBudget memoryBudget;

		public ProbeVolumeBlendingTextureMemoryBudget blendingMemoryBudget;

		public Mesh probeDebugMesh;

		public Shader probeDebugShader;

		public Mesh offsetDebugMesh;

		public Shader offsetDebugShader;

		public ComputeShader scenarioBlendingShader;

		public ProbeVolumeSceneData sceneData;

		public ProbeVolumeSHBands shBands;

		public bool supportsRuntimeDebug;

		public bool supportStreaming;
	}
	public struct ProbeVolumeShadingParameters
	{
		public float normalBias;

		public float viewBias;

		public bool scaleBiasByMinDistanceBetweenProbes;

		public float samplingNoise;

		public float weight;

		public APVLeakReductionMode leakReductionMode;

		public float occlusionWeightContribution;

		public float minValidNormalWeight;

		public int frameIndexForNoise;

		public float reflNormalizationLowerClamp;

		public float reflNormalizationUpperClamp;
	}
	[Serializable]
	public enum ProbeVolumeTextureMemoryBudget
	{
		MemoryBudgetLow = 0x200,
		MemoryBudgetMedium = 0x400,
		MemoryBudgetHigh = 0x800
	}
	[Serializable]
	public enum ProbeVolumeBlendingTextureMemoryBudget
	{
		None = 0,
		MemoryBudgetLow = 0x80,
		MemoryBudgetMedium = 0x100,
		MemoryBudgetHigh = 0x200
	}
	[Serializable]
	public enum ProbeVolumeSHBands
	{
		SphericalHarmonicsL1 = 1,
		SphericalHarmonicsL2
	}
	public class ProbeReferenceVolume
	{
		[Serializable]
		[DebuggerDisplay("Index = {index} position = {position}")]
		internal class Cell
		{
			public struct PerScenarioData
			{
				public NativeArray<ushort> shL0L1RxData { get; internal set; }

				public NativeArray<byte> shL1GL1RyData { get; internal set; }

				public NativeArray<byte> shL1BL1RzData { get; internal set; }

				public NativeArray<byte> shL2Data_0 { get; internal set; }

				public NativeArray<byte> shL2Data_1 { get; internal set; }

				public NativeArray<byte> shL2Data_2 { get; internal set; }

				public NativeArray<byte> shL2Data_3 { get; internal set; }
			}

			public Vector3Int position;

			public int index;

			public int probeCount;

			public int minSubdiv;

			public int maxSubdiv;

			public int indexChunkCount;

			public int shChunkCount;

			public bool hasTwoScenarios;

			public ProbeVolumeSHBands shBands;

			[NonSerialized]
			public PerScenarioData scenario0;

			[NonSerialized]
			public PerScenarioData scenario1;

			public NativeArray<ProbeBrickIndex.Brick> bricks { get; internal set; }

			public NativeArray<byte> validityNeighMaskData { get; internal set; }

			public NativeArray<Vector3> probePositions { get; internal set; }

			public NativeArray<float> touchupVolumeInteraction { get; internal set; }

			public NativeArray<Vector3> offsetVectors { get; internal set; }

			public NativeArray<float> validity { get; internal set; }

			public PerScenarioData bakingScenario => scenario0;
		}

		[DebuggerDisplay("Index = {cell.index} Loaded = {loaded}")]
		internal class CellInfo : IComparable<CellInfo>
		{
			public Cell cell;

			public BlendingCellInfo blendingCell;

			public List<ProbeBrickPool.BrickChunkAlloc> chunkList = new List<ProbeBrickPool.BrickChunkAlloc>();

			public int flatIdxInCellIndices = -1;

			public bool loaded;

			public ProbeBrickIndex.CellIndexUpdateInfo updateInfo;

			public bool indexUpdated;

			public ProbeBrickIndex.CellIndexUpdateInfo tempUpdateInfo;

			public int sourceAssetInstanceID;

			public float streamingScore;

			public int referenceCount;

			public CellInstancedDebugProbes debugProbes;

			public int CompareTo(CellInfo other)
			{
				if (streamingScore < other.streamingScore)
				{
					return -1;
				}
				if (streamingScore > other.streamingScore)
				{
					return 1;
				}
				return 0;
			}

			public void Clear()
			{
				cell = null;
				blendingCell = null;
				chunkList.Clear();
				flatIdxInCellIndices = -1;
				loaded = false;
				updateInfo = default(ProbeBrickIndex.CellIndexUpdateInfo);
				sourceAssetInstanceID = -1;
				streamingScore = 0f;
				referenceCount = 0;
				debugProbes = null;
			}
		}

		[DebuggerDisplay("Index = {cellInfo.cell.index} Factor = {blendingFactor} Score = {streamingScore}")]
		internal class BlendingCellInfo : IComparable<BlendingCellInfo>
		{
			public CellInfo cellInfo;

			public List<ProbeBrickPool.BrickChunkAlloc> chunkList = new List<ProbeBrickPool.BrickChunkAlloc>();

			public float streamingScore;

			public float blendingFactor;

			public bool blending;

			public int CompareTo(BlendingCellInfo other)
			{
				if (streamingScore < other.streamingScore)
				{
					return -1;
				}
				if (streamingScore > other.streamingScore)
				{
					return 1;
				}
				return 0;
			}

			public void Clear()
			{
				cellInfo = null;
				chunkList.Clear();
				blendingFactor = 0f;
				streamingScore = 0f;
				blending = false;
			}

			public void MarkUpToDate()
			{
				streamingScore = float.MaxValue;
			}

			public bool IsUpToDate()
			{
				return streamingScore == float.MaxValue;
			}

			public void ForceReupload()
			{
				blendingFactor = -1f;
			}

			public bool ShouldReupload()
			{
				return blendingFactor == -1f;
			}

			public void Prioritize()
			{
				blendingFactor = -2f;
			}

			public bool ShouldPrioritize()
			{
				return blendingFactor == -2f;
			}
		}

		internal struct Volume : IEquatable<Volume>
		{
			internal Vector3 corner;

			internal Vector3 X;

			internal Vector3 Y;

			internal Vector3 Z;

			internal float maxSubdivisionMultiplier;

			internal float minSubdivisionMultiplier;

			public Volume(Matrix4x4 trs, float maxSubdivision, float minSubdivision)
			{
				X = trs.GetColumn(0);
				Y = trs.GetColumn(1);
				Z = trs.GetColumn(2);
				corner = (Vector3)trs.GetColumn(3) - X * 0.5f - Y * 0.5f - Z * 0.5f;
				maxSubdivisionMultiplier = maxSubdivision;
				minSubdivisionMultiplier = minSubdivision;
			}

			public Volume(Vector3 corner, Vector3 X, Vector3 Y, Vector3 Z, float maxSubdivision = 1f, float minSubdivision = 0f)
			{
				this.corner = corner;
				this.X = X;
				this.Y = Y;
				this.Z = Z;
				maxSubdivisionMultiplier = maxSubdivision;
				minSubdivisionMultiplier = minSubdivision;
			}

			public Volume(Volume copy)
			{
				X = copy.X;
				Y = copy.Y;
				Z = copy.Z;
				corner = copy.corner;
				maxSubdivisionMultiplier = copy.maxSubdivisionMultiplier;
				minSubdivisionMultiplier = copy.minSubdivisionMultiplier;
			}

			public Volume(Bounds bounds)
			{
				Vector3 size = bounds.size;
				corner = bounds.center - size * 0.5f;
				X = new Vector3(size.x, 0f, 0f);
				Y = new Vector3(0f, size.y, 0f);
				Z = new Vector3(0f, 0f, size.z);
				maxSubdivisionMultiplier = (minSubdivisionMultiplier = 0f);
			}

			public Bounds CalculateAABB()
			{
				Vector3 vector = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
				Vector3 vector2 = new Vector3(float.MinValue, float.MinValue, float.MinValue);
				for (int i = 0; i < 2; i++)
				{
					for (int j = 0; j < 2; j++)
					{
						for (int k = 0; k < 2; k++)
						{
							Vector3 vector3 = new Vector3(i, j, k);
							Vector3 rhs = corner + X * vector3.x + Y * vector3.y + Z * vector3.z;
							vector = Vector3.Min(vector, rhs);
							vector2 = Vector3.Max(vector2, rhs);
						}
					}
				}
				return new Bounds((vector + vector2) / 2f, vector2 - vector);
			}

			public void CalculateCenterAndSize(out Vector3 center, out Vector3 size)
			{
				size = new Vector3(X.magnitude, Y.magnitude, Z.magnitude);
				center = corner + X * 0.5f + Y * 0.5f + Z * 0.5f;
			}

			public void Transform(Matrix4x4 trs)
			{
				corner = trs.MultiplyPoint(corner);
				X = trs.MultiplyVector(X);
				Y = trs.MultiplyVector(Y);
				Z = trs.MultiplyVector(Z);
			}

			public override string ToString()
			{
				return $"Corner: {corner}, X: {X}, Y: {Y}, Z: {Z}, MaxSubdiv: {maxSubdivisionMultiplier}";
			}

			public bool Equals(Volume other)
			{
				if (corner == other.corner && X == other.X && Y == other.Y && Z == other.Z && minSubdivisionMultiplier == other.minSubdivisionMultiplier)
				{
					return maxSubdivisionMultiplier == other.maxSubdivisionMultiplier;
				}
				return false;
			}
		}

		internal struct RefVolTransform
		{
			public Vector3 posWS;

			public Quaternion rot;

			public float scale;
		}

		public struct RuntimeResources
		{
			public ComputeBuffer index;

			public ComputeBuffer cellIndices;

			public RenderTexture L0_L1rx;

			public RenderTexture L1_G_ry;

			public RenderTexture L1_B_rz;

			public RenderTexture L2_0;

			public RenderTexture L2_1;

			public RenderTexture L2_2;

			public RenderTexture L2_3;

			public Texture3D Validity;
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		public struct ExtraDataActionInput
		{
		}

		private struct InitInfo
		{
			public Vector3Int pendingMinCellPosition;

			public Vector3Int pendingMaxCellPosition;
		}

		internal class CellInstancedDebugProbes
		{
			public List<Matrix4x4[]> probeBuffers;

			public List<Matrix4x4[]> offsetBuffers;

			public List<MaterialPropertyBlock> props;
		}

		private bool m_IsInitialized;

		private bool m_SupportStreaming;

		private RefVolTransform m_Transform;

		private int m_MaxSubdivision;

		private ProbeBrickPool m_Pool;

		private ProbeBrickIndex m_Index;

		private ProbeCellIndices m_CellIndices;

		private ProbeBrickBlendingPool m_BlendingPool;

		private List<ProbeBrickPool.BrickChunkAlloc> m_TmpSrcChunks = new List<ProbeBrickPool.BrickChunkAlloc>();

		private float[] m_PositionOffsets = new float[4];

		private Bounds m_CurrGlobalBounds;

		internal Dictionary<int, CellInfo> cells = new Dictionary<int, CellInfo>();

		private ObjectPool<CellInfo> m_CellInfoPool = new ObjectPool<CellInfo>(delegate(CellInfo x)
		{
			x.Clear();
		}, null, collectionCheck: false);

		private ObjectPool<BlendingCellInfo> m_BlendingCellInfoPool = new ObjectPool<BlendingCellInfo>(delegate(BlendingCellInfo x)
		{
			x.Clear();
		}, null, collectionCheck: false);

		private ProbeBrickPool.DataLocation m_TemporaryDataLocation;

		private int m_TemporaryDataLocationMemCost;

		private int m_CurrentProbeVolumeChunkSizeInBricks;

		internal ProbeVolumeSceneData sceneData;

		private Vector3Int minLoadedCellPos = new Vector3Int(int.MaxValue, int.MaxValue, int.MaxValue);

		private Vector3Int maxLoadedCellPos = new Vector3Int(int.MinValue, int.MinValue, int.MinValue);

		public Action<ExtraDataActionInput> retrieveExtraDataAction;

		public Action checksDuringBakeAction;

		private bool m_BricksLoaded;

		private Dictionary<string, ProbeVolumeAsset> m_PendingAssetsToBeLoaded = new Dictionary<string, ProbeVolumeAsset>();

		private Dictionary<string, ProbeVolumeAsset> m_PendingAssetsToBeUnloaded = new Dictionary<string, ProbeVolumeAsset>();

		private Dictionary<string, ProbeVolumeAsset> m_ActiveAssets = new Dictionary<string, ProbeVolumeAsset>();

		private bool m_NeedLoadAsset;

		private bool m_ProbeReferenceVolumeInit;

		private bool m_EnabledBySRP;

		private InitInfo m_PendingInitInfo;

		private bool m_NeedsIndexRebuild;

		private bool m_HasChangedIndex;

		private int m_CBShaderID = Shader.PropertyToID("ShaderVariablesProbeVolumes");

		private int m_NumberOfCellsLoadedPerFrame = 2;

		private int m_NumberOfCellsBlendedPerFrame = 10000;

		private float m_TurnoverRate = 0.1f;

		private ProbeVolumeTextureMemoryBudget m_MemoryBudget;

		private ProbeVolumeBlendingTextureMemoryBudget m_BlendingMemoryBudget;

		private ProbeVolumeSHBands m_SHBands;

		private float m_ProbeVolumesWeight;

		internal bool clearAssetsOnVolumeClear;

		internal static string defaultLightingScenario = "Default";

		private static ProbeReferenceVolume _instance = new ProbeReferenceVolume();

		private const int kProbesPerBatch = 511;

		public static readonly string k_DebugPanelName = "Probe Volume";

		private DebugUI.Widget[] m_DebugItems;

		private Mesh m_DebugMesh;

		private Material m_DebugMaterial;

		private Mesh m_DebugOffsetMesh;

		private Material m_DebugOffsetMaterial;

		private Plane[] m_DebugFrustumPlanes = new Plane[6];

		private GUIContent[] m_DebugScenarioNames = new GUIContent[0];

		private int[] m_DebugScenarioValues = new int[0];

		private string m_DebugActiveSceneGUID;

		private string m_DebugActiveScenario;

		private DebugUI.EnumField m_DebugScenarioField;

		internal ProbeVolumeBakingProcessSettings bakingProcessSettings;

		internal Dictionary<Bounds, ProbeBrickIndex.Brick[]> realtimeSubdivisionInfo = new Dictionary<Bounds, ProbeBrickIndex.Brick[]>();

		private bool m_MaxSubdivVisualizedIsMaxAvailable;

		private DynamicArray<CellInfo> m_LoadedCells = new DynamicArray<CellInfo>();

		private DynamicArray<CellInfo> m_ToBeLoadedCells = new DynamicArray<CellInfo>();

		private DynamicArray<CellInfo> m_TempCellToLoadList = new DynamicArray<CellInfo>();

		private DynamicArray<CellInfo> m_TempCellToUnloadList = new DynamicArray<CellInfo>();

		private DynamicArray<BlendingCellInfo> m_LoadedBlendingCells = new DynamicArray<BlendingCellInfo>();

		private DynamicArray<BlendingCellInfo> m_ToBeLoadedBlendingCells = new DynamicArray<BlendingCellInfo>();

		private DynamicArray<BlendingCellInfo> m_TempBlendingCellToLoadList = new DynamicArray<BlendingCellInfo>();

		private DynamicArray<BlendingCellInfo> m_TempBlendingCellToUnloadList = new DynamicArray<BlendingCellInfo>();

		private Vector3 m_FrozenCameraPosition;

		private bool m_HasRemainingCellsToBlend;

		internal Bounds globalBounds
		{
			get
			{
				return m_CurrGlobalBounds;
			}
			set
			{
				m_CurrGlobalBounds = value;
			}
		}

		public bool isInitialized => m_ProbeReferenceVolumeInit;

		internal bool enabledBySRP => m_EnabledBySRP;

		internal bool hasUnloadedCells => m_ToBeLoadedCells.size != 0;

		internal bool enableScenarioBlending
		{
			get
			{
				if (m_BlendingMemoryBudget != ProbeVolumeBlendingTextureMemoryBudget.None)
				{
					return ProbeBrickBlendingPool.isSupported;
				}
				return false;
			}
		}

		internal int numberOfCellsLoadedPerFrame => m_NumberOfCellsLoadedPerFrame;

		public int numberOfCellsBlendedPerFrame
		{
			get
			{
				return m_NumberOfCellsBlendedPerFrame;
			}
			set
			{
				m_NumberOfCellsBlendedPerFrame = Mathf.Max(1, value);
			}
		}

		public float turnoverRate
		{
			get
			{
				return m_TurnoverRate;
			}
			set
			{
				m_TurnoverRate = Mathf.Clamp01(value);
			}
		}

		public ProbeVolumeSHBands shBands => m_SHBands;

		public string lightingScenario
		{
			get
			{
				return sceneData.lightingScenario;
			}
			set
			{
				sceneData.SetActiveScenario(value);
			}
		}

		public float scenarioBlendingFactor
		{
			get
			{
				return sceneData.scenarioBlendingFactor;
			}
			set
			{
				sceneData.BlendLightingScenario(sceneData.otherScenario, value);
			}
		}

		public ProbeVolumeTextureMemoryBudget memoryBudget => m_MemoryBudget;

		public float probeVolumesWeight
		{
			get
			{
				return m_ProbeVolumesWeight;
			}
			set
			{
				m_ProbeVolumesWeight = Mathf.Clamp01(value);
			}
		}

		internal List<ProbeVolumePerSceneData> perSceneDataList { get; private set; } = new List<ProbeVolumePerSceneData>();

		public static ProbeReferenceVolume instance => _instance;

		internal ProbeVolumeDebug probeVolumeDebug { get; } = new ProbeVolumeDebug();

		public Color[] subdivisionDebugColors { get; } = new Color[7];

		public void BlendLightingScenario(string otherScenario, float blendingFactor)
		{
			sceneData.BlendLightingScenario(otherScenario, blendingFactor);
		}

		internal void RegisterPerSceneData(ProbeVolumePerSceneData data)
		{
			if (!perSceneDataList.Contains(data))
			{
				perSceneDataList.Add(data);
			}
		}

		internal void UnregisterPerSceneData(ProbeVolumePerSceneData data)
		{
			perSceneDataList.Remove(data);
		}

		public void Initialize(in ProbeVolumeSystemParameters parameters)
		{
			if (m_IsInitialized)
			{
				Debug.LogError("Probe Volume System has already been initialized.");
				return;
			}
			m_MemoryBudget = parameters.memoryBudget;
			m_BlendingMemoryBudget = parameters.blendingMemoryBudget;
			m_SHBands = parameters.shBands;
			m_ProbeVolumesWeight = 1f;
			InitializeDebug(in parameters);
			ProbeBrickBlendingPool.Initialize(in parameters);
			InitProbeReferenceVolume(m_MemoryBudget, m_BlendingMemoryBudget, m_SHBands);
			m_IsInitialized = true;
			m_NeedsIndexRebuild = true;
			sceneData = parameters.sceneData;
			m_SupportStreaming = parameters.supportStreaming;
			m_EnabledBySRP = true;
			if (sceneData == null)
			{
				return;
			}
			foreach (ProbeVolumePerSceneData perSceneData in instance.perSceneDataList)
			{
				perSceneData.Initialize();
			}
		}

		public void SetEnableStateFromSRP(bool srpEnablesPV)
		{
			m_EnabledBySRP = srpEnablesPV;
		}

		internal void ForceSHBand(ProbeVolumeSHBands shBands)
		{
			if (m_ProbeReferenceVolumeInit)
			{
				CleanupLoadedData();
			}
			m_SHBands = shBands;
			m_ProbeReferenceVolumeInit = false;
			InitProbeReferenceVolume(m_MemoryBudget, m_BlendingMemoryBudget, shBands);
		}

		public void Cleanup()
		{
			if (m_ProbeReferenceVolumeInit)
			{
				if (!m_IsInitialized)
				{
					Debug.LogError("Probe Volume System has not been initialized first before calling cleanup.");
					return;
				}
				CleanupLoadedData();
				CleanupDebug();
				m_IsInitialized = false;
			}
		}

		public int GetVideoMemoryCost()
		{
			if (!m_ProbeReferenceVolumeInit)
			{
				return 0;
			}
			return m_Pool.estimatedVMemCost + m_Index.estimatedVMemCost + m_CellIndices.estimatedVMemCost + m_BlendingPool.estimatedVMemCost + m_TemporaryDataLocationMemCost;
		}

		private void RemoveCell(Cell cell)
		{
			if (!cells.TryGetValue(cell.index, out var value))
			{
				return;
			}
			value.referenceCount--;
			if (value.referenceCount <= 0)
			{
				cells.Remove(cell.index);
				if (value.loaded)
				{
					m_LoadedCells.Remove(value);
					UnloadCell(value);
				}
				else
				{
					m_ToBeLoadedCells.Remove(value);
				}
				m_BlendingCellInfoPool.Release(value.blendingCell);
				m_CellInfoPool.Release(value);
			}
		}

		internal void UnloadCell(CellInfo cellInfo)
		{
			if (cellInfo.loaded)
			{
				if (cellInfo.blendingCell.blending)
				{
					m_LoadedBlendingCells.Remove(cellInfo.blendingCell);
					UnloadBlendingCell(cellInfo.blendingCell);
				}
				else
				{
					m_ToBeLoadedBlendingCells.Remove(cellInfo.blendingCell);
				}
				if (cellInfo.flatIdxInCellIndices >= 0)
				{
					m_CellIndices.MarkCellAsUnloaded(cellInfo.flatIdxInCellIndices);
				}
				ReleaseBricks(cellInfo);
				cellInfo.loaded = false;
				cellInfo.debugProbes = null;
				cellInfo.updateInfo = default(ProbeBrickIndex.CellIndexUpdateInfo);
				ClearDebugData();
			}
		}

		internal void UnloadBlendingCell(BlendingCellInfo blendingCell)
		{
			if (blendingCell.blending)
			{
				m_BlendingPool.Deallocate(blendingCell.chunkList);
				blendingCell.chunkList.Clear();
				blendingCell.blending = false;
			}
		}

		internal void UnloadAllCells()
		{
			for (int i = 0; i < m_LoadedCells.size; i++)
			{
				UnloadCell(m_LoadedCells[i]);
			}
			m_ToBeLoadedCells.AddRange(m_LoadedCells);
			m_LoadedCells.Clear();
		}

		internal void UnloadAllBlendingCells()
		{
			for (int i = 0; i < m_LoadedBlendingCells.size; i++)
			{
				UnloadBlendingCell(m_LoadedBlendingCells[i]);
			}
			m_ToBeLoadedBlendingCells.AddRange(m_LoadedBlendingCells);
			m_LoadedBlendingCells.Clear();
		}

		private void AddCell(Cell cell, int assetInstanceID)
		{
			if (!cells.TryGetValue(cell.index, out var value))
			{
				value = m_CellInfoPool.Get();
				value.cell = cell;
				value.flatIdxInCellIndices = m_CellIndices.GetFlatIdxForCell(cell.position);
				value.sourceAssetInstanceID = assetInstanceID;
				value.referenceCount = 1;
				cells[cell.index] = value;
				BlendingCellInfo blendingCellInfo = m_BlendingCellInfoPool.Get();
				blendingCellInfo.cellInfo = value;
				value.blendingCell = blendingCellInfo;
				m_ToBeLoadedCells.Add(in value);
			}
			else
			{
				value.referenceCount++;
			}
		}

		internal bool LoadCell(CellInfo cellInfo, bool ignoreErrorLog = false)
		{
			if (GetCellIndexUpdate(cellInfo.cell, out var cellUpdateInfo, ignoreErrorLog))
			{
				minLoadedCellPos = Vector3Int.Min(minLoadedCellPos, cellInfo.cell.position);
				maxLoadedCellPos = Vector3Int.Max(maxLoadedCellPos, cellInfo.cell.position);
				return AddBricks(cellInfo, cellUpdateInfo, ignoreErrorLog);
			}
			return false;
		}

		internal void LoadAllCells()
		{
			int size = m_LoadedCells.size;
			for (int i = 0; i < m_ToBeLoadedCells.size; i++)
			{
				CellInfo value = m_ToBeLoadedCells[i];
				if (LoadCell(value, ignoreErrorLog: true))
				{
					m_LoadedCells.Add(in value);
				}
			}
			for (int j = size; j < m_LoadedCells.size; j++)
			{
				m_ToBeLoadedCells.Remove(m_LoadedCells[j]);
			}
		}

		private void RecomputeMinMaxLoadedCellPos()
		{
			minLoadedCellPos = new Vector3Int(int.MaxValue, int.MaxValue, int.MaxValue);
			maxLoadedCellPos = new Vector3Int(int.MinValue, int.MinValue, int.MinValue);
			foreach (CellInfo value in cells.Values)
			{
				if (value.loaded)
				{
					minLoadedCellPos = Vector3Int.Min(value.cell.position, minLoadedCellPos);
					maxLoadedCellPos = Vector3Int.Max(value.cell.position, maxLoadedCellPos);
				}
			}
		}

		private bool CheckCompatibilityWithCollection(ProbeVolumeAsset asset, Dictionary<string, ProbeVolumeAsset> collection)
		{
			if (collection.Count > 0)
			{
				foreach (ProbeVolumeAsset value in collection.Values)
				{
					if (!m_PendingAssetsToBeUnloaded.ContainsKey(value.GetSerializedFullPath()))
					{
						return value.CompatibleWith(asset);
					}
				}
			}
			return true;
		}

		internal void AddPendingAssetLoading(ProbeVolumeAsset asset)
		{
			string serializedFullPath = asset.GetSerializedFullPath();
			if (m_PendingAssetsToBeLoaded.ContainsKey(serializedFullPath))
			{
				m_PendingAssetsToBeLoaded.Remove(serializedFullPath);
			}
			if (!CheckCompatibilityWithCollection(asset, m_ActiveAssets))
			{
				Debug.LogError("Trying to load Probe Volume data for a scene that has been baked with different settings than currently loaded ones. Please make sure all loaded scenes are in the same baking set.");
				return;
			}
			if (!CheckCompatibilityWithCollection(asset, m_PendingAssetsToBeLoaded))
			{
				Debug.LogError("Trying to load Probe Volume data for a scene that has been baked with different settings from other scenes that are being loaded. Please make sure all loaded scenes are in the same baking set.");
				return;
			}
			m_PendingAssetsToBeLoaded.Add(serializedFullPath, asset);
			m_NeedLoadAsset = true;
			_ = Vector3Int.zero;
			Vector3Int vector3Int = Vector3Int.one * 10000;
			Vector3Int vector3Int2 = Vector3Int.one * -10000;
			bool flag = true;
			foreach (ProbeVolumeAsset value in m_PendingAssetsToBeLoaded.Values)
			{
				vector3Int = Vector3Int.Min(vector3Int, value.minCellPosition);
				vector3Int2 = Vector3Int.Max(vector3Int2, value.maxCellPosition);
				if (flag)
				{
					m_CurrGlobalBounds = value.globalBounds;
					flag = false;
				}
				else
				{
					m_CurrGlobalBounds.Encapsulate(value.globalBounds);
				}
			}
			foreach (ProbeVolumeAsset value2 in m_ActiveAssets.Values)
			{
				vector3Int = Vector3Int.Min(vector3Int, value2.minCellPosition);
				vector3Int2 = Vector3Int.Max(vector3Int2, value2.maxCellPosition);
				if (flag)
				{
					m_CurrGlobalBounds = value2.globalBounds;
					flag = false;
				}
				else
				{
					m_CurrGlobalBounds.Encapsulate(value2.globalBounds);
				}
			}
			m_NeedsIndexRebuild |= m_Index == null || m_PendingInitInfo.pendingMinCellPosition != vector3Int || m_PendingInitInfo.pendingMaxCellPosition != vector3Int2;
			m_PendingInitInfo.pendingMinCellPosition = vector3Int;
			m_PendingInitInfo.pendingMaxCellPosition = vector3Int2;
		}

		internal void AddPendingAssetRemoval(ProbeVolumeAsset asset)
		{
			string serializedFullPath = asset.GetSerializedFullPath();
			if (m_PendingAssetsToBeLoaded.ContainsKey(serializedFullPath))
			{
				m_PendingAssetsToBeLoaded.Remove(serializedFullPath);
			}
			if (m_ActiveAssets.ContainsKey(serializedFullPath))
			{
				m_PendingAssetsToBeUnloaded[serializedFullPath] = asset;
			}
		}

		internal void RemovePendingAsset(ProbeVolumeAsset asset)
		{
			string serializedFullPath = asset.GetSerializedFullPath();
			if (m_ActiveAssets.ContainsKey(serializedFullPath))
			{
				m_ActiveAssets.Remove(serializedFullPath);
			}
			Cell[] array = asset.cells;
			foreach (Cell cell in array)
			{
				RemoveCell(cell);
			}
			int instanceID = asset.GetInstanceID();
			for (int num = m_LoadedCells.size - 1; num >= 0; num--)
			{
				if (m_LoadedCells[num].sourceAssetInstanceID == instanceID)
				{
					if (m_LoadedCells[num].blendingCell.blending)
					{
						m_LoadedBlendingCells.Remove(m_LoadedCells[num].blendingCell);
					}
					else
					{
						m_ToBeLoadedBlendingCells.Remove(m_LoadedCells[num].blendingCell);
					}
					m_LoadedCells.RemoveAt(num);
				}
			}
			for (int num2 = m_ToBeLoadedCells.size - 1; num2 >= 0; num2--)
			{
				if (m_ToBeLoadedCells[num2].sourceAssetInstanceID == instanceID)
				{
					m_ToBeLoadedCells.RemoveAt(num2);
				}
			}
			ClearDebugData();
			RecomputeMinMaxLoadedCellPos();
		}

		private void PerformPendingIndexChangeAndInit()
		{
			if (m_NeedsIndexRebuild)
			{
				CleanupLoadedData();
				InitProbeReferenceVolume(m_MemoryBudget, m_BlendingMemoryBudget, m_SHBands);
				m_HasChangedIndex = true;
				m_NeedsIndexRebuild = false;
			}
			else
			{
				m_HasChangedIndex = false;
			}
		}

		internal void SetMinBrickAndMaxSubdiv(float minBrickSize, int maxSubdiv)
		{
			SetTRS(Vector3.zero, Quaternion.identity, minBrickSize);
			SetMaxSubdivision(maxSubdiv);
		}

		private void LoadAsset(ProbeVolumeAsset asset)
		{
			if (asset.Version != 5)
			{
				Debug.LogWarning("Trying to load an asset " + asset.GetSerializedFullPath() + " that has been baked with a previous version of the system. Please re-bake the data.");
				return;
			}
			SetMinBrickAndMaxSubdiv(asset.minBrickSize, asset.maxSubdivision);
			if (asset.chunkSizeInBricks != m_CurrentProbeVolumeChunkSizeInBricks)
			{
				m_CurrentProbeVolumeChunkSizeInBricks = asset.chunkSizeInBricks;
				AllocateTemporaryDataLocation();
			}
			ClearDebugData();
			for (int i = 0; i < asset.cells.Length; i++)
			{
				AddCell(asset.cells[i], asset.GetInstanceID());
			}
		}

		private void PerformPendingLoading()
		{
			if ((m_PendingAssetsToBeLoaded.Count == 0 && m_ActiveAssets.Count == 0) || !m_NeedLoadAsset || !m_ProbeReferenceVolumeInit)
			{
				return;
			}
			m_Pool.EnsureTextureValidity();
			m_BlendingPool.EnsureTextureValidity();
			if (m_HasChangedIndex)
			{
				foreach (ProbeVolumeAsset value in m_ActiveAssets.Values)
				{
					LoadAsset(value);
				}
			}
			foreach (ProbeVolumeAsset value2 in m_PendingAssetsToBeLoaded.Values)
			{
				LoadAsset(value2);
				if (!m_ActiveAssets.ContainsKey(value2.GetSerializedFullPath()))
				{
					m_ActiveAssets.Add(value2.GetSerializedFullPath(), value2);
				}
			}
			m_PendingAssetsToBeLoaded.Clear();
			m_NeedLoadAsset = false;
		}

		private void PerformPendingDeletion()
		{
			if (!m_ProbeReferenceVolumeInit)
			{
				m_PendingAssetsToBeUnloaded.Clear();
			}
			foreach (ProbeVolumeAsset value in m_PendingAssetsToBeUnloaded.Values)
			{
				RemovePendingAsset(value);
			}
			m_PendingAssetsToBeUnloaded.Clear();
		}

		internal int GetNumberOfBricksAtSubdiv(Vector3Int position, int minSubdiv, out Vector3Int minValidLocalIdxAtMaxRes, out Vector3Int sizeOfValidIndicesAtMaxRes)
		{
			minValidLocalIdxAtMaxRes = Vector3Int.zero;
			sizeOfValidIndicesAtMaxRes = Vector3Int.one;
			Vector3 vector = new Vector3((float)position.x * MaxBrickSize(), (float)position.y * MaxBrickSize(), (float)position.z * MaxBrickSize());
			Bounds bounds = new Bounds
			{
				min = vector,
				max = vector + Vector3.one * MaxBrickSize()
			};
			Bounds bounds2 = new Bounds
			{
				min = Vector3.Max(bounds.min, m_CurrGlobalBounds.min),
				max = Vector3.Min(bounds.max, m_CurrGlobalBounds.max)
			};
			Vector3 vector2 = bounds2.min - bounds.min;
			minValidLocalIdxAtMaxRes.x = Mathf.CeilToInt(vector2.x / MinBrickSize());
			minValidLocalIdxAtMaxRes.y = Mathf.CeilToInt(vector2.y / MinBrickSize());
			minValidLocalIdxAtMaxRes.z = Mathf.CeilToInt(vector2.z / MinBrickSize());
			Vector3 vector3 = bounds2.max - bounds.min;
			sizeOfValidIndicesAtMaxRes.x = Mathf.CeilToInt(vector3.x / MinBrickSize()) - minValidLocalIdxAtMaxRes.x + 1;
			sizeOfValidIndicesAtMaxRes.y = Mathf.CeilToInt(vector3.y / MinBrickSize()) - minValidLocalIdxAtMaxRes.y + 1;
			sizeOfValidIndicesAtMaxRes.z = Mathf.CeilToInt(vector3.z / MinBrickSize()) - minValidLocalIdxAtMaxRes.z + 1;
			Vector3Int vector3Int = default(Vector3Int);
			vector3Int = sizeOfValidIndicesAtMaxRes / CellSize(minSubdiv);
			return vector3Int.x * vector3Int.y * vector3Int.z;
		}

		private bool GetCellIndexUpdate(Cell cell, out ProbeBrickIndex.CellIndexUpdateInfo cellUpdateInfo, bool ignoreErrorLog)
		{
			cellUpdateInfo = default(ProbeBrickIndex.CellIndexUpdateInfo);
			Vector3Int minValidLocalIdxAtMaxRes;
			Vector3Int sizeOfValidIndicesAtMaxRes;
			int numberOfBricksAtSubdiv = GetNumberOfBricksAtSubdiv(cell.position, cell.minSubdiv, out minValidLocalIdxAtMaxRes, out sizeOfValidIndicesAtMaxRes);
			cellUpdateInfo.cellPositionInBricksAtMaxRes = cell.position * CellSize(m_MaxSubdivision - 1);
			cellUpdateInfo.minSubdivInCell = cell.minSubdiv;
			cellUpdateInfo.minValidBrickIndexForCellAtMaxRes = minValidLocalIdxAtMaxRes;
			cellUpdateInfo.maxValidBrickIndexForCellAtMaxResPlusOne = sizeOfValidIndicesAtMaxRes + minValidLocalIdxAtMaxRes;
			return m_Index.AssignIndexChunksToCell(numberOfBricksAtSubdiv, ref cellUpdateInfo, ignoreErrorLog);
		}

		public void PerformPendingOperations()
		{
			PerformPendingDeletion();
			PerformPendingIndexChangeAndInit();
			PerformPendingLoading();
		}

		private void InitProbeReferenceVolume(ProbeVolumeTextureMemoryBudget memoryBudget, ProbeVolumeBlendingTextureMemoryBudget blendingMemoryBudget, ProbeVolumeSHBands shBands)
		{
			Vector3Int pendingMinCellPosition = m_PendingInitInfo.pendingMinCellPosition;
			Vector3Int pendingMaxCellPosition = m_PendingInitInfo.pendingMaxCellPosition;
			if (!m_ProbeReferenceVolumeInit)
			{
				m_Pool = new ProbeBrickPool(memoryBudget, shBands);
				m_BlendingPool = new ProbeBrickBlendingPool(blendingMemoryBudget, shBands);
				m_Index = new ProbeBrickIndex(memoryBudget);
				m_CellIndices = new ProbeCellIndices(pendingMinCellPosition, pendingMaxCellPosition, (int)Mathf.Pow(3f, m_MaxSubdivision - 1));
				if (m_CurrentProbeVolumeChunkSizeInBricks != 0)
				{
					AllocateTemporaryDataLocation();
				}
				m_PositionOffsets[0] = 0f;
				float num = 1f / 3f;
				for (int i = 1; i < 3; i++)
				{
					m_PositionOffsets[i] = (float)i * num;
				}
				m_PositionOffsets[m_PositionOffsets.Length - 1] = 1f;
				m_ProbeReferenceVolumeInit = true;
				ClearDebugData();
				m_NeedLoadAsset = true;
			}
		}

		private void AllocateTemporaryDataLocation()
		{
			m_TemporaryDataLocation.Cleanup();
			m_TemporaryDataLocation = ProbeBrickPool.CreateDataLocation(m_CurrentProbeVolumeChunkSizeInBricks * 64, compressed: false, m_SHBands, "APV_Intermediate", allocateRendertexture: false, allocateValidityData: true, out m_TemporaryDataLocationMemCost);
		}

		private ProbeReferenceVolume()
		{
			m_Transform.posWS = Vector3.zero;
			m_Transform.rot = Quaternion.identity;
			m_Transform.scale = 1f;
		}

		public RuntimeResources GetRuntimeResources()
		{
			if (!m_ProbeReferenceVolumeInit)
			{
				return default(RuntimeResources);
			}
			RuntimeResources rr = default(RuntimeResources);
			m_Index.GetRuntimeResources(ref rr);
			m_CellIndices.GetRuntimeResources(ref rr);
			m_Pool.GetRuntimeResources(ref rr);
			return rr;
		}

		internal void SetTRS(Vector3 position, Quaternion rotation, float minBrickSize)
		{
			m_Transform.posWS = position;
			m_Transform.rot = rotation;
			m_Transform.scale = minBrickSize;
		}

		internal void SetMaxSubdivision(int maxSubdivision)
		{
			m_MaxSubdivision = Math.Min(maxSubdivision, 7);
		}

		internal static int CellSize(int subdivisionLevel)
		{
			return (int)Mathf.Pow(3f, subdivisionLevel);
		}

		internal float BrickSize(int subdivisionLevel)
		{
			return m_Transform.scale * (float)CellSize(subdivisionLevel);
		}

		internal float MinBrickSize()
		{
			return m_Transform.scale;
		}

		internal float MaxBrickSize()
		{
			return BrickSize(m_MaxSubdivision - 1);
		}

		internal RefVolTransform GetTransform()
		{
			return m_Transform;
		}

		internal int GetMaxSubdivision()
		{
			return m_MaxSubdivision;
		}

		internal int GetMaxSubdivision(float multiplier)
		{
			return Mathf.CeilToInt((float)m_MaxSubdivision * multiplier);
		}

		internal float GetDistanceBetweenProbes(int subdivisionLevel)
		{
			return BrickSize(subdivisionLevel) / 3f;
		}

		internal float MinDistanceBetweenProbes()
		{
			return GetDistanceBetweenProbes(0);
		}

		public bool DataHasBeenLoaded()
		{
			return m_BricksLoaded;
		}

		internal void Clear()
		{
			if (m_ProbeReferenceVolumeInit)
			{
				UnloadAllCells();
				m_Pool.Clear();
				m_BlendingPool.Clear();
				m_Index.Clear();
				cells.Clear();
			}
			if (clearAssetsOnVolumeClear)
			{
				m_PendingAssetsToBeLoaded.Clear();
				m_ActiveAssets.Clear();
			}
		}

		private List<ProbeBrickPool.BrickChunkAlloc> GetSourceLocations(int count, int chunkSize, ProbeBrickPool.DataLocation dataLoc)
		{
			ProbeBrickPool.BrickChunkAlloc item = default(ProbeBrickPool.BrickChunkAlloc);
			m_TmpSrcChunks.Clear();
			m_TmpSrcChunks.Add(item);
			for (int i = 1; i < count; i++)
			{
				item.x += chunkSize * 4;
				if (item.x >= dataLoc.width)
				{
					item.x = 0;
					item.y += 4;
					if (item.y >= dataLoc.height)
					{
						item.y = 0;
						item.z += 4;
					}
				}
				m_TmpSrcChunks.Add(item);
			}
			return m_TmpSrcChunks;
		}

		private void UpdatePool(List<ProbeBrickPool.BrickChunkAlloc> chunkList, Cell.PerScenarioData data, NativeArray<byte> validityNeighMaskData, int chunkIndex, int poolIndex)
		{
			int num = m_CurrentProbeVolumeChunkSizeInBricks * 64;
			int start = chunkIndex * num;
			int num2 = num * 4;
			int start2 = chunkIndex * num2;
			(m_TemporaryDataLocation.TexL0_L1rx as Texture3D).SetPixelData(data.shL0L1RxData.GetSubArray(start2, num2), 0);
			(m_TemporaryDataLocation.TexL0_L1rx as Texture3D).Apply(updateMipmaps: false);
			(m_TemporaryDataLocation.TexL1_G_ry as Texture3D).SetPixelData(data.shL1GL1RyData.GetSubArray(start2, num2), 0);
			(m_TemporaryDataLocation.TexL1_G_ry as Texture3D).Apply(updateMipmaps: false);
			(m_TemporaryDataLocation.TexL1_B_rz as Texture3D).SetPixelData(data.shL1BL1RzData.GetSubArray(start2, num2), 0);
			(m_TemporaryDataLocation.TexL1_B_rz as Texture3D).Apply(updateMipmaps: false);
			if (poolIndex == -1)
			{
				m_TemporaryDataLocation.TexValidity.SetPixelData(validityNeighMaskData.GetSubArray(start, num), 0);
				m_TemporaryDataLocation.TexValidity.Apply(updateMipmaps: false);
			}
			if (m_SHBands == ProbeVolumeSHBands.SphericalHarmonicsL2)
			{
				(m_TemporaryDataLocation.TexL2_0 as Texture3D).SetPixelData(data.shL2Data_0.GetSubArray(start2, num2), 0);
				(m_TemporaryDataLocation.TexL2_0 as Texture3D).Apply(updateMipmaps: false);
				(m_TemporaryDataLocation.TexL2_1 as Texture3D).SetPixelData(data.shL2Data_1.GetSubArray(start2, num2), 0);
				(m_TemporaryDataLocation.TexL2_1 as Texture3D).Apply(updateMipmaps: false);
				(m_TemporaryDataLocation.TexL2_2 as Texture3D).SetPixelData(data.shL2Data_2.GetSubArray(start2, num2), 0);
				(m_TemporaryDataLocation.TexL2_2 as Texture3D).Apply(updateMipmaps: false);
				(m_TemporaryDataLocation.TexL2_3 as Texture3D).SetPixelData(data.shL2Data_3.GetSubArray(start2, num2), 0);
				(m_TemporaryDataLocation.TexL2_3 as Texture3D).Apply(updateMipmaps: false);
			}
			List<ProbeBrickPool.BrickChunkAlloc> sourceLocations = GetSourceLocations(1, m_CurrentProbeVolumeChunkSizeInBricks, m_TemporaryDataLocation);
			if (poolIndex == -1)
			{
				m_Pool.Update(m_TemporaryDataLocation, sourceLocations, chunkList, chunkIndex, m_SHBands);
			}
			else
			{
				m_BlendingPool.Update(m_TemporaryDataLocation, sourceLocations, chunkList, chunkIndex, m_SHBands, poolIndex);
			}
		}

		private void UpdatePoolValidity(List<ProbeBrickPool.BrickChunkAlloc> chunkList, Cell.PerScenarioData data, NativeArray<byte> validityNeighMaskData, int chunkIndex)
		{
			int num = m_CurrentProbeVolumeChunkSizeInBricks * 64;
			int start = chunkIndex * num;
			m_TemporaryDataLocation.TexValidity.SetPixelData(validityNeighMaskData.GetSubArray(start, num), 0);
			m_TemporaryDataLocation.TexValidity.Apply(updateMipmaps: false);
			List<ProbeBrickPool.BrickChunkAlloc> sourceLocations = GetSourceLocations(1, m_CurrentProbeVolumeChunkSizeInBricks, m_TemporaryDataLocation);
			m_Pool.UpdateValidity(m_TemporaryDataLocation, sourceLocations, chunkList, chunkIndex);
		}

		private bool AddBlendingBricks(BlendingCellInfo blendingCell)
		{
			Debug.Assert(blendingCell.cellInfo.loaded);
			using (new ProfilerMarker("AddBlendingBricks").Auto())
			{
				Cell cell = blendingCell.cellInfo.cell;
				Debug.Assert(blendingCell.chunkList.Count == 0);
				bool flag = sceneData.otherScenario == null || !cell.hasTwoScenarios;
				if (!flag && !m_BlendingPool.Allocate(cell.shChunkCount, blendingCell.chunkList))
				{
					return false;
				}
				List<ProbeBrickPool.BrickChunkAlloc> list = (flag ? blendingCell.cellInfo.chunkList : blendingCell.chunkList);
				int count = list.Count;
				if (!blendingCell.cellInfo.indexUpdated)
				{
					UpdateCellIndex(blendingCell.cellInfo);
					for (int i = 0; i < count; i++)
					{
						UpdatePoolValidity(list, cell.scenario0, cell.validityNeighMaskData, i);
					}
				}
				if (flag)
				{
					if (blendingCell.blendingFactor != scenarioBlendingFactor)
					{
						for (int j = 0; j < count; j++)
						{
							UpdatePool(list, cell.scenario0, cell.validityNeighMaskData, j, -1);
						}
					}
				}
				else
				{
					for (int k = 0; k < count; k++)
					{
						UpdatePool(list, cell.scenario0, cell.validityNeighMaskData, k, 0);
						UpdatePool(list, cell.scenario1, cell.validityNeighMaskData, k, 1);
					}
				}
				blendingCell.blending = true;
				return true;
			}
		}

		private bool AddBricks(CellInfo cellInfo, ProbeBrickIndex.CellIndexUpdateInfo cellUpdateInfo, bool ignoreErrorLog)
		{
			using (new ProfilerMarker("AddBricks").Auto())
			{
				Cell cell = cellInfo.cell;
				int chunkCount = ProbeBrickPool.GetChunkCount(cell.bricks.Length, m_CurrentProbeVolumeChunkSizeInBricks);
				cellInfo.chunkList.Clear();
				Debug.Assert(chunkCount == cell.shChunkCount);
				if (!m_Pool.Allocate(chunkCount, cellInfo.chunkList, ignoreErrorLog))
				{
					return false;
				}
				if (enableScenarioBlending)
				{
					m_ToBeLoadedBlendingCells.Add(in cellInfo.blendingCell);
				}
				cellInfo.tempUpdateInfo = cellUpdateInfo;
				if (!enableScenarioBlending || scenarioBlendingFactor == 0f || !cell.hasTwoScenarios)
				{
					for (int i = 0; i < cellInfo.chunkList.Count; i++)
					{
						UpdatePool(cellInfo.chunkList, cell.scenario0, cell.validityNeighMaskData, i, -1);
					}
					UpdateCellIndex(cellInfo);
					cellInfo.blendingCell.blendingFactor = 0f;
				}
				else if (enableScenarioBlending)
				{
					cellInfo.blendingCell.Prioritize();
					m_HasRemainingCellsToBlend = true;
					cellInfo.indexUpdated = false;
				}
				cellInfo.loaded = true;
				ClearDebugData();
				return true;
			}
		}

		private void UpdateCellIndex(CellInfo cellInfo)
		{
			cellInfo.indexUpdated = true;
			m_BricksLoaded = true;
			NativeArray<ProbeBrickIndex.Brick> bricks = cellInfo.cell.bricks;
			ProbeBrickIndex.CellIndexUpdateInfo tempUpdateInfo = cellInfo.tempUpdateInfo;
			m_Index.AddBricks(cellInfo.cell, bricks, cellInfo.chunkList, m_CurrentProbeVolumeChunkSizeInBricks, m_Pool.GetPoolWidth(), m_Pool.GetPoolHeight(), tempUpdateInfo);
			cellInfo.updateInfo = tempUpdateInfo;
			m_CellIndices.UpdateCell(cellInfo.flatIdxInCellIndices, tempUpdateInfo);
		}

		private void ReleaseBricks(CellInfo cellInfo)
		{
			if (cellInfo.chunkList.Count == 0)
			{
				Debug.Log("Tried to release bricks from an empty Cell.");
				return;
			}
			m_Index.RemoveBricks(cellInfo);
			m_Pool.Deallocate(cellInfo.chunkList);
			cellInfo.chunkList.Clear();
		}

		public void UpdateConstantBuffer(CommandBuffer cmd, ProbeVolumeShadingParameters parameters)
		{
			float num = parameters.normalBias;
			float num2 = parameters.viewBias;
			if (parameters.scaleBiasByMinDistanceBetweenProbes)
			{
				num *= MinDistanceBetweenProbes();
				num2 *= MinDistanceBetweenProbes();
			}
			Vector3Int cellMinPosition = m_CellIndices.GetCellMinPosition();
			Vector3Int cellIndexDimension = m_CellIndices.GetCellIndexDimension();
			Vector3Int poolDimensions = m_Pool.GetPoolDimensions();
			ShaderVariablesProbeVolumes data = default(ShaderVariablesProbeVolumes);
			data._Biases_CellInMinBrick_MinBrickSize = new Vector4(num, num2, (int)Mathf.Pow(3f, m_MaxSubdivision - 1), MinBrickSize());
			data._IndicesDim_IndexChunkSize = new Vector4(cellIndexDimension.x, cellIndexDimension.y, cellIndexDimension.z, 243f);
			data._MinCellPos_Noise = new Vector4(cellMinPosition.x, cellMinPosition.y, cellMinPosition.z, parameters.samplingNoise);
			data._PoolDim_CellInMeters = new Vector4(poolDimensions.x, poolDimensions.y, poolDimensions.z, MaxBrickSize());
			data._Weight_MinLoadedCell = new Vector4(parameters.weight, minLoadedCellPos.x, minLoadedCellPos.y, minLoadedCellPos.z);
			data._MaxLoadedCell_FrameIndex = new Vector4(maxLoadedCellPos.x, maxLoadedCellPos.y, maxLoadedCellPos.z, parameters.frameIndexForNoise);
			data._LeakReductionParams = new Vector4((float)parameters.leakReductionMode, parameters.occlusionWeightContribution, parameters.minValidNormalWeight, 0f);
			data._NormalizationClamp_Padding12 = new Vector4(parameters.reflNormalizationLowerClamp, parameters.reflNormalizationUpperClamp, 0f, 0f);
			ConstantBuffer.PushGlobal(cmd, in data, m_CBShaderID);
		}

		private void CleanupLoadedData()
		{
			m_BricksLoaded = false;
			UnloadAllCells();
			if (m_ProbeReferenceVolumeInit)
			{
				m_Index.Cleanup();
				m_CellIndices.Cleanup();
				m_Pool.Cleanup();
				m_BlendingPool.Cleanup();
				m_TemporaryDataLocation.Cleanup();
			}
			m_ProbeReferenceVolumeInit = false;
			ClearDebugData();
		}

		public void RenderDebug(Camera camera)
		{
			if (camera.cameraType != CameraType.Reflection && camera.cameraType != CameraType.Preview)
			{
				DrawProbeDebug(camera);
			}
		}

		private void InitializeDebug(in ProbeVolumeSystemParameters parameters)
		{
			if (parameters.supportsRuntimeDebug)
			{
				m_DebugMesh = parameters.probeDebugMesh;
				m_DebugMaterial = CoreUtils.CreateEngineMaterial(parameters.probeDebugShader);
				m_DebugMaterial.enableInstancing = true;
				m_DebugOffsetMesh = parameters.offsetDebugMesh;
				m_DebugOffsetMaterial = CoreUtils.CreateEngineMaterial(parameters.offsetDebugShader);
				m_DebugOffsetMaterial.enableInstancing = true;
				Debug.Assert(condition: true);
				subdivisionDebugColors[0] = new Color(1f, 0f, 0f);
				subdivisionDebugColors[1] = new Color(0f, 1f, 0f);
				subdivisionDebugColors[2] = new Color(0f, 0f, 1f);
				subdivisionDebugColors[3] = new Color(1f, 1f, 0f);
				subdivisionDebugColors[4] = new Color(1f, 0f, 1f);
				subdivisionDebugColors[5] = new Color(0f, 1f, 1f);
				subdivisionDebugColors[6] = new Color(0.5f, 0.5f, 0.5f);
			}
			RegisterDebug(parameters);
		}

		private void CleanupDebug()
		{
			UnregisterDebug(destroyPanel: true);
			CoreUtils.Destroy(m_DebugMaterial);
			CoreUtils.Destroy(m_DebugOffsetMaterial);
		}

		private void DebugCellIndexChanged<T>(DebugUI.Field<T> field, T value)
		{
			ClearDebugData();
		}

		private void RegisterDebug(ProbeVolumeSystemParameters parameters)
		{
			List<DebugUI.Widget> list = new List<DebugUI.Widget>();
			DebugUI.Container container = new DebugUI.Container
			{
				displayName = "Subdivision Visualization"
			};
			container.children.Add(new DebugUI.BoolField
			{
				displayName = "Display Cells",
				getter = () => probeVolumeDebug.drawCells,
				setter = delegate(bool value)
				{
					probeVolumeDebug.drawCells = value;
				},
				onValueChanged = RefreshDebug<bool>
			});
			container.children.Add(new DebugUI.BoolField
			{
				displayName = "Display Bricks",
				getter = () => probeVolumeDebug.drawBricks,
				setter = delegate(bool value)
				{
					probeVolumeDebug.drawBricks = value;
				},
				onValueChanged = RefreshDebug<bool>
			});
			container.children.Add(new DebugUI.FloatField
			{
				displayName = "Culling Distance",
				getter = () => probeVolumeDebug.subdivisionViewCullingDistance,
				setter = delegate(float value)
				{
					probeVolumeDebug.subdivisionViewCullingDistance = value;
				},
				min = () => 0f
			});
			DebugUI.Container container2 = new DebugUI.Container
			{
				displayName = "Probe Visualization"
			};
			container2.children.Add(new DebugUI.BoolField
			{
				displayName = "Display Probes",
				getter = () => probeVolumeDebug.drawProbes,
				setter = delegate(bool value)
				{
					probeVolumeDebug.drawProbes = value;
				},
				onValueChanged = RefreshDebug<bool>
			});
			if (probeVolumeDebug.drawProbes)
			{
				DebugUI.Container container3 = new DebugUI.Container();
				container3.children.Add(new DebugUI.EnumField
				{
					displayName = "Probe Shading Mode",
					getter = () => (int)probeVolumeDebug.probeShading,
					setter = delegate(int value)
					{
						probeVolumeDebug.probeShading = (DebugProbeShadingMode)value;
					},
					autoEnum = typeof(DebugProbeShadingMode),
					getIndex = () => (int)probeVolumeDebug.probeShading,
					setIndex = delegate(int value)
					{
						probeVolumeDebug.probeShading = (DebugProbeShadingMode)value;
					},
					onValueChanged = RefreshDebug<int>
				});
				container3.children.Add(new DebugUI.FloatField
				{
					displayName = "Probe Size",
					getter = () => probeVolumeDebug.probeSize,
					setter = delegate(float value)
					{
						probeVolumeDebug.probeSize = value;
					},
					min = () => 0.05f,
					max = () => 10f
				});
				if (probeVolumeDebug.probeShading == DebugProbeShadingMode.SH || probeVolumeDebug.probeShading == DebugProbeShadingMode.SHL0 || probeVolumeDebug.probeShading == DebugProbeShadingMode.SHL0L1)
				{
					container3.children.Add(new DebugUI.FloatField
					{
						displayName = "Probe Exposure Compensation",
						getter = () => probeVolumeDebug.exposureCompensation,
						setter = delegate(float value)
						{
							probeVolumeDebug.exposureCompensation = value;
						}
					});
				}
				container3.children.Add(new DebugUI.IntField
				{
					displayName = "Max subdivision displayed",
					getter = () => probeVolumeDebug.maxSubdivToVisualize,
					setter = delegate(int v)
					{
						probeVolumeDebug.maxSubdivToVisualize = Mathf.Min(v, instance.GetMaxSubdivision() - 1);
					},
					min = () => 0,
					max = () => instance.GetMaxSubdivision() - 1
				});
				container3.children.Add(new DebugUI.IntField
				{
					displayName = "Min subdivision displayed",
					getter = () => probeVolumeDebug.minSubdivToVisualize,
					setter = delegate(int v)
					{
						probeVolumeDebug.minSubdivToVisualize = Mathf.Max(v, 0);
					},
					min = () => 0,
					max = () => instance.GetMaxSubdivision() - 1
				});
				container2.children.Add(container3);
			}
			container2.children.Add(new DebugUI.BoolField
			{
				displayName = "Virtual Offset",
				getter = () => probeVolumeDebug.drawVirtualOffsetPush,
				setter = delegate(bool value)
				{
					probeVolumeDebug.drawVirtualOffsetPush = value;
					if (probeVolumeDebug.drawVirtualOffsetPush && probeVolumeDebug.drawProbes)
					{
						float value2 = (float)CellSize(0) * MinBrickSize() / 3f * bakingProcessSettings.virtualOffsetSettings.searchMultiplier + bakingProcessSettings.virtualOffsetSettings.outOfGeoOffset;
						probeVolumeDebug.probeSize = Mathf.Min(probeVolumeDebug.probeSize, Mathf.Clamp(value2, 0.05f, 10f));
					}
				},
				onValueChanged = RefreshDebug<bool>
			});
			if (probeVolumeDebug.drawVirtualOffsetPush)
			{
				DebugUI.FloatField item = new DebugUI.FloatField
				{
					displayName = "Offset Size",
					getter = () => probeVolumeDebug.offsetSize,
					setter = delegate(float value)
					{
						probeVolumeDebug.offsetSize = value;
					},
					min = () => 0.001f,
					max = () => 0.1f
				};
				container2.children.Add(new DebugUI.Container
				{
					children = { (DebugUI.Widget)item }
				});
			}
			container2.children.Add(new DebugUI.FloatField
			{
				displayName = "Culling Distance",
				getter = () => probeVolumeDebug.probeCullingDistance,
				setter = delegate(float value)
				{
					probeVolumeDebug.probeCullingDistance = value;
				},
				min = () => 0f
			});
			DebugUI.Container container4 = new DebugUI.Container
			{
				displayName = "Streaming"
			};
			container4.children.Add(new DebugUI.BoolField
			{
				displayName = "Freeze Streaming",
				getter = () => probeVolumeDebug.freezeStreaming,
				setter = delegate(bool value)
				{
					probeVolumeDebug.freezeStreaming = value;
				}
			});
			container4.children.Add(new DebugUI.IntField
			{
				displayName = "Number Of Cells Loaded Per Frame",
				getter = () => instance.numberOfCellsLoadedPerFrame,
				setter = delegate(int value)
				{
					instance.SetNumberOfCellsLoadedPerFrame(value);
				},
				min = () => 0
			});
			if (parameters.supportsRuntimeDebug)
			{
				if (Application.isEditor)
				{
					list.Add(container);
				}
				list.Add(container2);
			}
			if (parameters.supportStreaming)
			{
				list.Add(container4);
			}
			if (parameters.scenarioBlendingShader != null && parameters.blendingMemoryBudget != ProbeVolumeBlendingTextureMemoryBudget.None)
			{
				DebugUI.Container container5 = new DebugUI.Container
				{
					displayName = "Scenario Blending"
				};
				container5.children.Add(new DebugUI.IntField
				{
					displayName = "Number Of Cells Blended Per Frame",
					getter = () => instance.numberOfCellsBlendedPerFrame,
					setter = delegate(int value)
					{
						instance.numberOfCellsBlendedPerFrame = value;
					},
					min = () => 0
				});
				container5.children.Add(new DebugUI.FloatField
				{
					displayName = "Turnover Rate",
					getter = () => instance.turnoverRate,
					setter = delegate(float value)
					{
						instance.turnoverRate = value;
					},
					min = () => 0f,
					max = () => 1f
				});
				m_DebugScenarioField = new DebugUI.EnumField
				{
					displayName = "Scenario To Blend With",
					enumNames = m_DebugScenarioNames,
					enumValues = m_DebugScenarioValues,
					getIndex = delegate
					{
						RefreshScenarioNames(ProbeVolumeSceneData.GetSceneGUID(SceneManager.GetActiveScene()));
						probeVolumeDebug.otherStateIndex = 0;
						if (!string.IsNullOrEmpty(sceneData.otherScenario))
						{
							for (int i = 1; i < m_DebugScenarioNames.Length; i++)
							{
								if (m_DebugScenarioNames[i].text == sceneData.otherScenario)
								{
									probeVolumeDebug.otherStateIndex = i;
									break;
								}
							}
						}
						return probeVolumeDebug.otherStateIndex;
					},
					setIndex = delegate(int value)
					{
						string otherScenario = ((value == 0) ? null : m_DebugScenarioNames[value].text);
						sceneData.BlendLightingScenario(otherScenario, sceneData.scenarioBlendingFactor);
						probeVolumeDebug.otherStateIndex = value;
					},
					getter = () => probeVolumeDebug.otherStateIndex,
					setter = delegate(int value)
					{
						probeVolumeDebug.otherStateIndex = value;
					}
				};
				container5.children.Add(m_DebugScenarioField);
				container5.children.Add(new DebugUI.FloatField
				{
					displayName = "Scenario Blending Factor",
					getter = () => instance.scenarioBlendingFactor,
					setter = delegate(float value)
					{
						instance.scenarioBlendingFactor = value;
					},
					min = () => 0f,
					max = () => 1f
				});
				list.Add(container5);
			}
			if (list.Count > 0)
			{
				m_DebugItems = list.ToArray();
				DebugManager.instance.GetPanel(k_DebugPanelName, createIfNull: true).children.Add(m_DebugItems);
			}
			DebugManager.instance.RegisterData(probeVolumeDebug);
			void RefreshDebug<T>(DebugUI.Field<T> field, T value)
			{
				UnregisterDebug(destroyPanel: false);
				RegisterDebug(parameters);
			}
			void RefreshScenarioNames(string guid)
			{
				HashSet<string> hashSet = new HashSet<string>();
				foreach (ProbeVolumeSceneData.BakingSet bakingSet in parameters.sceneData.bakingSets)
				{
					if (bakingSet.sceneGUIDs.Contains(guid))
					{
						foreach (string lightingScenario in bakingSet.lightingScenarios)
						{
							hashSet.Add(lightingScenario);
						}
					}
				}
				hashSet.Remove(sceneData.lightingScenario);
				if (!(m_DebugActiveSceneGUID == guid) || hashSet.Count + 1 != m_DebugScenarioNames.Length || !(m_DebugActiveScenario == sceneData.lightingScenario))
				{
					int num = 0;
					ArrayExtensions.ResizeArray(ref m_DebugScenarioNames, hashSet.Count + 1);
					ArrayExtensions.ResizeArray(ref m_DebugScenarioValues, hashSet.Count + 1);
					m_DebugScenarioNames[0] = new GUIContent("None");
					m_DebugScenarioValues[0] = 0;
					foreach (string item2 in hashSet)
					{
						num++;
						m_DebugScenarioNames[num] = new GUIContent(item2);
						m_DebugScenarioValues[num] = num;
					}
					m_DebugActiveSceneGUID = guid;
					m_DebugActiveScenario = sceneData.lightingScenario;
					m_DebugScenarioField.enumNames = m_DebugScenarioNames;
					m_DebugScenarioField.enumValues = m_DebugScenarioValues;
					if (probeVolumeDebug.otherStateIndex >= m_DebugScenarioNames.Length)
					{
						probeVolumeDebug.otherStateIndex = 0;
					}
				}
			}
		}

		private void UnregisterDebug(bool destroyPanel)
		{
			if (destroyPanel)
			{
				DebugManager.instance.RemovePanel(k_DebugPanelName);
			}
			else
			{
				DebugManager.instance.GetPanel(k_DebugPanelName).children.Remove(m_DebugItems);
			}
		}

		private bool ShouldCullCell(Vector3 cellPosition, Transform cameraTransform, Plane[] frustumPlanes)
		{
			float num = MaxBrickSize();
			Vector3 posWS = GetTransform().posWS;
			Vector3 vector = cellPosition * num + posWS + Vector3.one * (num / 2f);
			float num2 = (float)Mathf.CeilToInt(probeVolumeDebug.probeCullingDistance / num) * num;
			if (Vector3.Distance(cameraTransform.position, vector) > num2)
			{
				return true;
			}
			Bounds bounds = new Bounds(vector, num * Vector3.one);
			return !GeometryUtility.TestPlanesAABB(frustumPlanes, bounds);
		}

		private void DrawProbeDebug(Camera camera)
		{
			if (!enabledBySRP || !isInitialized || (!probeVolumeDebug.drawProbes && !probeVolumeDebug.drawVirtualOffsetPush))
			{
				return;
			}
			GeometryUtility.CalculateFrustumPlanes(camera, m_DebugFrustumPlanes);
			m_DebugMaterial.shaderKeywords = null;
			if (m_SHBands == ProbeVolumeSHBands.SphericalHarmonicsL1)
			{
				m_DebugMaterial.EnableKeyword("PROBE_VOLUMES_L1");
			}
			else if (m_SHBands == ProbeVolumeSHBands.SphericalHarmonicsL2)
			{
				m_DebugMaterial.EnableKeyword("PROBE_VOLUMES_L2");
			}
			m_DebugMaterial.renderQueue = 3000;
			m_DebugOffsetMaterial.renderQueue = 3000;
			int num = ((instance.cells.Count > 0) ? (instance.GetMaxSubdivision() - 1) : 0);
			foreach (CellInfo value in instance.cells.Values)
			{
				num = Mathf.Min(num, value.cell.minSubdiv);
			}
			probeVolumeDebug.maxSubdivToVisualize = Mathf.Min(probeVolumeDebug.maxSubdivToVisualize, instance.GetMaxSubdivision() - 1);
			m_MaxSubdivVisualizedIsMaxAvailable = probeVolumeDebug.maxSubdivToVisualize == instance.GetMaxSubdivision() - 1;
			probeVolumeDebug.minSubdivToVisualize = Mathf.Clamp(probeVolumeDebug.minSubdivToVisualize, num, probeVolumeDebug.maxSubdivToVisualize);
			foreach (CellInfo value2 in instance.cells.Values)
			{
				if (ShouldCullCell(value2.cell.position, camera.transform, m_DebugFrustumPlanes))
				{
					continue;
				}
				CellInstancedDebugProbes cellInstancedDebugProbes = CreateInstancedProbes(value2);
				if (cellInstancedDebugProbes == null)
				{
					continue;
				}
				for (int i = 0; i < cellInstancedDebugProbes.probeBuffers.Count; i++)
				{
					MaterialPropertyBlock materialPropertyBlock = cellInstancedDebugProbes.props[i];
					materialPropertyBlock.SetInt("_ShadingMode", (int)probeVolumeDebug.probeShading);
					materialPropertyBlock.SetFloat("_ExposureCompensation", probeVolumeDebug.exposureCompensation);
					materialPropertyBlock.SetFloat("_ProbeSize", probeVolumeDebug.probeSize);
					materialPropertyBlock.SetFloat("_CullDistance", probeVolumeDebug.probeCullingDistance);
					materialPropertyBlock.SetInt("_MaxAllowedSubdiv", probeVolumeDebug.maxSubdivToVisualize);
					materialPropertyBlock.SetInt("_MinAllowedSubdiv", probeVolumeDebug.minSubdivToVisualize);
					materialPropertyBlock.SetFloat("_ValidityThreshold", bakingProcessSettings.dilationSettings.dilationValidityThreshold);
					materialPropertyBlock.SetFloat("_OffsetSize", probeVolumeDebug.offsetSize);
					if (probeVolumeDebug.drawProbes)
					{
						Matrix4x4[] array = cellInstancedDebugProbes.probeBuffers[i];
						Graphics.DrawMeshInstanced(m_DebugMesh, 0, m_DebugMaterial, array, array.Length, materialPropertyBlock, ShadowCastingMode.Off, receiveShadows: false, 0, camera, LightProbeUsage.Off, null);
					}
					if (probeVolumeDebug.drawVirtualOffsetPush)
					{
						Matrix4x4[] array2 = cellInstancedDebugProbes.offsetBuffers[i];
						Graphics.DrawMeshInstanced(m_DebugOffsetMesh, 0, m_DebugOffsetMaterial, array2, array2.Length, materialPropertyBlock, ShadowCastingMode.Off, receiveShadows: false, 0, camera, LightProbeUsage.Off, null);
					}
				}
			}
		}

		internal void ResetDebugViewToMaxSubdiv()
		{
			if (m_MaxSubdivVisualizedIsMaxAvailable)
			{
				probeVolumeDebug.maxSubdivToVisualize = instance.GetMaxSubdivision() - 1;
			}
		}

		private void ClearDebugData()
		{
			realtimeSubdivisionInfo.Clear();
		}

		private CellInstancedDebugProbes CreateInstancedProbes(CellInfo cellInfo)
		{
			if (cellInfo.debugProbes != null)
			{
				return cellInfo.debugProbes;
			}
			int num = instance.GetMaxSubdivision() - 1;
			Cell cell = cellInfo.cell;
			if (!cell.bricks.IsCreated || cell.bricks.Length == 0 || !cellInfo.loaded)
			{
				return null;
			}
			List<Matrix4x4[]> list = new List<Matrix4x4[]>();
			List<Matrix4x4[]> list2 = new List<Matrix4x4[]>();
			List<MaterialPropertyBlock> list3 = new List<MaterialPropertyBlock>();
			List<ProbeBrickPool.BrickChunkAlloc> chunkList = cellInfo.chunkList;
			Vector4[] array = new Vector4[511];
			float[] array2 = new float[511];
			float[] array3 = new float[511];
			float[] array4 = ((cell.touchupVolumeInteraction.Length > 0) ? new float[511] : null);
			Vector4[] array5 = ((cell.offsetVectors.Length > 0) ? new Vector4[511] : null);
			List<Matrix4x4> list4 = new List<Matrix4x4>();
			List<Matrix4x4> list5 = new List<Matrix4x4>();
			CellInstancedDebugProbes cellInstancedDebugProbes = new CellInstancedDebugProbes();
			cellInstancedDebugProbes.probeBuffers = list;
			cellInstancedDebugProbes.offsetBuffers = list2;
			cellInstancedDebugProbes.props = list3;
			int num2 = m_CurrentProbeVolumeChunkSizeInBricks * 64;
			Vector3Int vector3Int = ProbeBrickPool.ProbeCountToDataLocSize(num2);
			int num3 = 0;
			int num4 = 0;
			int num5 = cell.probeCount / 64;
			int num6 = 0;
			int num7 = 0;
			int num8 = 0;
			for (int i = 0; i < num5; i++)
			{
				Debug.Assert(num8 < vector3Int.z);
				int subdivisionLevel = cell.bricks[i].subdivisionLevel;
				int num9 = i / m_CurrentProbeVolumeChunkSizeInBricks;
				ProbeBrickPool.BrickChunkAlloc brickChunkAlloc = chunkList[num9];
				Vector3Int vector3Int2 = new Vector3Int(brickChunkAlloc.x + num6, brickChunkAlloc.y + num7, brickChunkAlloc.z + num8);
				for (int j = 0; j < 4; j++)
				{
					for (int k = 0; k < 4; k++)
					{
						for (int l = 0; l < 4; l++)
						{
							Vector3Int vector3Int3 = new Vector3Int(vector3Int2.x + l, vector3Int2.y + k, vector3Int2.z + j);
							int index = num9 * num2 + (num6 + l) + vector3Int.x * (num7 + k + vector3Int.y * (num8 + j));
							list4.Add(Matrix4x4.TRS(cell.probePositions[index], Quaternion.identity, Vector3.one * (0.3f * (float)(subdivisionLevel + 1))));
							array2[num3] = cell.validity[index];
							array[num3] = new Vector4(vector3Int3.x, vector3Int3.y, vector3Int3.z, subdivisionLevel);
							array3[num3] = (float)subdivisionLevel / (float)num;
							if (array4 != null)
							{
								array4[num3] = cell.touchupVolumeInteraction[index];
							}
							if (array5 != null)
							{
								Vector3 vector = cell.offsetVectors[index];
								array5[num3] = vector;
								if (vector.sqrMagnitude < 1E-06f)
								{
									list5.Add(Matrix4x4.identity);
								}
								else
								{
									Vector3 pos = cell.probePositions[index] + vector;
									Quaternion q = Quaternion.LookRotation(-vector);
									Vector3 s = new Vector3(0.5f, 0.5f, vector.magnitude);
									list5.Add(Matrix4x4.TRS(pos, q, s));
								}
							}
							num3++;
							if (list4.Count >= 511 || num4 == cell.probeCount - 1)
							{
								num3 = 0;
								MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
								materialPropertyBlock.SetFloatArray("_Validity", array2);
								materialPropertyBlock.SetFloatArray("_TouchupedByVolume", array4);
								materialPropertyBlock.SetFloatArray("_RelativeSize", array3);
								materialPropertyBlock.SetVectorArray("_IndexInAtlas", array);
								if (array5 != null)
								{
									materialPropertyBlock.SetVectorArray("_Offset", array5);
								}
								list3.Add(materialPropertyBlock);
								list.Add(list4.ToArray());
								list4 = new List<Matrix4x4>();
								list4.Clear();
								list2.Add(list5.ToArray());
								list5.Clear();
							}
							num4++;
						}
					}
				}
				num6 += 4;
				if (num6 < vector3Int.x)
				{
					continue;
				}
				num6 = 0;
				num7 += 4;
				if (num7 >= vector3Int.y)
				{
					num7 = 0;
					num8 += 4;
					if (num8 >= vector3Int.z)
					{
						num6 = 0;
						num7 = 0;
						num8 = 0;
					}
				}
			}
			cellInfo.debugProbes = cellInstancedDebugProbes;
			return cellInstancedDebugProbes;
		}

		private void OnClearLightingdata()
		{
			ClearDebugData();
		}

		internal void ScenarioBlendingChanged(bool scenarioChanged)
		{
			m_HasRemainingCellsToBlend = true;
			if (scenarioChanged)
			{
				UnloadAllBlendingCells();
				for (int i = 0; i < m_ToBeLoadedBlendingCells.size; i++)
				{
					m_ToBeLoadedBlendingCells[i].ForceReupload();
				}
			}
		}

		public void SetNumberOfCellsLoadedPerFrame(int numberOfCells)
		{
			m_NumberOfCellsLoadedPerFrame = Mathf.Max(1, numberOfCells);
		}

		private void ComputeCellCameraDistance(Vector3 cameraPosition, DynamicArray<CellInfo> cells)
		{
			for (int i = 0; i < cells.size; i++)
			{
				CellInfo cellInfo = cells[i];
				cellInfo.streamingScore = Vector3.Distance(cameraPosition, cellInfo.cell.position);
			}
		}

		private void ComputeStreamingScoreForBlending(DynamicArray<BlendingCellInfo> cells, float worstScore)
		{
			float num = scenarioBlendingFactor;
			for (int i = 0; i < cells.size; i++)
			{
				BlendingCellInfo blendingCellInfo = cells[i];
				if (num == blendingCellInfo.blendingFactor)
				{
					blendingCellInfo.MarkUpToDate();
					continue;
				}
				blendingCellInfo.streamingScore = blendingCellInfo.cellInfo.streamingScore;
				if (blendingCellInfo.ShouldPrioritize())
				{
					blendingCellInfo.streamingScore -= worstScore;
				}
			}
		}

		private bool TryLoadCell(CellInfo cellInfo, ref int shBudget, ref int indexBudget, DynamicArray<CellInfo> loadedCells)
		{
			if (cellInfo.cell.shChunkCount <= shBudget && cellInfo.cell.indexChunkCount <= indexBudget && LoadCell(cellInfo))
			{
				loadedCells.Add(in cellInfo);
				shBudget -= cellInfo.cell.shChunkCount;
				indexBudget -= cellInfo.cell.indexChunkCount;
				return true;
			}
			return false;
		}

		private void UnloadBlendingCell(BlendingCellInfo blendingCell, DynamicArray<BlendingCellInfo> unloadedCells)
		{
			UnloadBlendingCell(blendingCell);
			unloadedCells.Add(in blendingCell);
		}

		private bool TryLoadBlendingCell(BlendingCellInfo blendingCell, DynamicArray<BlendingCellInfo> loadedCells)
		{
			if (!AddBlendingBricks(blendingCell))
			{
				return false;
			}
			loadedCells.Add(in blendingCell);
			return true;
		}

		public void UpdateCellStreaming(CommandBuffer cmd, Camera camera)
		{
			if (!isInitialized)
			{
				return;
			}
			using (new ProfilingScope(null, ProfilingSampler.Get(CoreProfileId.APVCellStreamingUpdate)))
			{
				Vector3 position = camera.transform.position;
				if (!probeVolumeDebug.freezeStreaming)
				{
					m_FrozenCameraPosition = position;
				}
				Vector3 cameraPosition = (m_FrozenCameraPosition - m_Transform.posWS) / MaxBrickSize() - Vector3.one * 0.5f;
				ComputeCellCameraDistance(cameraPosition, m_ToBeLoadedCells);
				ComputeCellCameraDistance(cameraPosition, m_LoadedCells);
				m_ToBeLoadedCells.QuickSort();
				m_LoadedCells.QuickSort();
				int indexBudget = m_Index.GetRemainingChunkCount();
				int shBudget = m_Pool.GetRemainingChunkCount();
				int num = Mathf.Min(m_NumberOfCellsLoadedPerFrame, m_ToBeLoadedCells.size);
				if (m_SupportStreaming)
				{
					while (m_TempCellToLoadList.size < num)
					{
						CellInfo cellInfo = m_ToBeLoadedCells[m_TempCellToLoadList.size];
						if (!TryLoadCell(cellInfo, ref shBudget, ref indexBudget, m_TempCellToLoadList))
						{
							break;
						}
					}
					if (m_TempCellToLoadList.size != num)
					{
						int num2 = 0;
						while (m_TempCellToLoadList.size < num && m_LoadedCells.size - num2 != 0)
						{
							CellInfo value = m_LoadedCells[m_LoadedCells.size - num2 - 1];
							CellInfo cellInfo2 = m_ToBeLoadedCells[m_TempCellToLoadList.size];
							if (!(value.streamingScore > cellInfo2.streamingScore))
							{
								break;
							}
							num2++;
							UnloadCell(value);
							shBudget += value.cell.shChunkCount;
							indexBudget += value.cell.indexChunkCount;
							m_TempCellToUnloadList.Add(in value);
							TryLoadCell(cellInfo2, ref shBudget, ref indexBudget, m_TempCellToLoadList);
						}
						if (num2 > 0)
						{
							m_LoadedCells.RemoveRange(m_LoadedCells.size - num2, num2);
							RecomputeMinMaxLoadedCellPos();
						}
					}
				}
				else
				{
					for (int i = 0; i < num; i++)
					{
						CellInfo cellInfo3 = m_ToBeLoadedCells[m_TempCellToLoadList.size];
						TryLoadCell(cellInfo3, ref shBudget, ref indexBudget, m_TempCellToLoadList);
					}
				}
				m_ToBeLoadedCells.RemoveRange(0, m_TempCellToLoadList.size);
				m_LoadedCells.AddRange(m_TempCellToLoadList);
				m_ToBeLoadedCells.AddRange(m_TempCellToUnloadList);
				m_TempCellToLoadList.Clear();
				m_TempCellToUnloadList.Clear();
			}
			if (!enableScenarioBlending)
			{
				return;
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(CoreProfileId.APVScenarioBlendingUpdate)))
			{
				UpdateBlendingCellStreaming(cmd);
			}
		}

		private int FindWorstBlendingCellToBeLoaded()
		{
			int result = -1;
			float num = -1f;
			float num2 = scenarioBlendingFactor;
			for (int i = m_TempBlendingCellToLoadList.size; i < m_ToBeLoadedBlendingCells.size; i++)
			{
				float num3 = Mathf.Abs(m_ToBeLoadedBlendingCells[i].blendingFactor - num2);
				if (num3 > num)
				{
					result = i;
					if (m_ToBeLoadedBlendingCells[i].ShouldReupload())
					{
						break;
					}
					num = num3;
				}
			}
			return result;
		}

		private void UpdateBlendingCellStreaming(CommandBuffer cmd)
		{
			if (!m_HasRemainingCellsToBlend)
			{
				return;
			}
			float a = ((m_LoadedCells.size != 0) ? m_LoadedCells[m_LoadedCells.size - 1].streamingScore : 0f);
			float b = ((m_ToBeLoadedCells.size != 0) ? m_ToBeLoadedCells[m_ToBeLoadedCells.size - 1].streamingScore : 0f);
			float worstScore = Mathf.Max(a, b);
			ComputeStreamingScoreForBlending(m_ToBeLoadedBlendingCells, worstScore);
			ComputeStreamingScoreForBlending(m_LoadedBlendingCells, worstScore);
			m_ToBeLoadedBlendingCells.QuickSort();
			m_LoadedBlendingCells.QuickSort();
			int num = Mathf.Min(m_NumberOfCellsLoadedPerFrame, m_ToBeLoadedBlendingCells.size);
			while (m_TempBlendingCellToLoadList.size < num)
			{
				BlendingCellInfo blendingCell = m_ToBeLoadedBlendingCells[m_TempBlendingCellToLoadList.size];
				if (!TryLoadBlendingCell(blendingCell, m_TempBlendingCellToLoadList))
				{
					break;
				}
			}
			if (m_TempBlendingCellToLoadList.size != num)
			{
				int num2 = -1;
				int num3 = (int)((float)m_LoadedBlendingCells.size * (1f - turnoverRate));
				BlendingCellInfo blendingCellInfo = ((num3 < m_LoadedBlendingCells.size) ? m_LoadedBlendingCells[num3] : null);
				while (m_TempBlendingCellToLoadList.size < num && m_LoadedBlendingCells.size - m_TempBlendingCellToUnloadList.size != 0)
				{
					BlendingCellInfo blendingCellInfo2 = m_LoadedBlendingCells[m_LoadedBlendingCells.size - m_TempBlendingCellToUnloadList.size - 1];
					BlendingCellInfo blendingCellInfo3 = m_ToBeLoadedBlendingCells[m_TempBlendingCellToLoadList.size];
					if (blendingCellInfo3.streamingScore >= (blendingCellInfo ?? blendingCellInfo2).streamingScore)
					{
						if (blendingCellInfo == null)
						{
							break;
						}
						if (num2 == -1)
						{
							num2 = FindWorstBlendingCellToBeLoaded();
						}
						blendingCellInfo3 = m_ToBeLoadedBlendingCells[num2];
						if (blendingCellInfo3.IsUpToDate())
						{
							break;
						}
					}
					UnloadBlendingCell(blendingCellInfo2, m_TempBlendingCellToUnloadList);
					if (TryLoadBlendingCell(blendingCellInfo3, m_TempBlendingCellToLoadList) && num2 != -1)
					{
						m_ToBeLoadedBlendingCells[num2] = m_ToBeLoadedBlendingCells[m_TempBlendingCellToLoadList.size - 1];
						m_ToBeLoadedBlendingCells[m_TempBlendingCellToLoadList.size - 1] = blendingCellInfo3;
						if (++num2 >= m_ToBeLoadedBlendingCells.size)
						{
							num2 = m_TempBlendingCellToLoadList.size;
						}
					}
				}
				m_LoadedBlendingCells.RemoveRange(m_LoadedBlendingCells.size - m_TempBlendingCellToUnloadList.size, m_TempBlendingCellToUnloadList.size);
			}
			m_ToBeLoadedBlendingCells.RemoveRange(0, m_TempBlendingCellToLoadList.size);
			m_LoadedBlendingCells.AddRange(m_TempBlendingCellToLoadList);
			m_TempBlendingCellToLoadList.Clear();
			m_ToBeLoadedBlendingCells.AddRange(m_TempBlendingCellToUnloadList);
			m_TempBlendingCellToUnloadList.Clear();
			if (m_LoadedBlendingCells.size != 0)
			{
				float num4 = scenarioBlendingFactor;
				int num5 = Mathf.Min(numberOfCellsBlendedPerFrame, m_LoadedBlendingCells.size);
				for (int i = 0; i < num5; i++)
				{
					m_LoadedBlendingCells[i].blendingFactor = num4;
					m_BlendingPool.BlendChunks(m_LoadedBlendingCells[i], m_Pool);
				}
				m_BlendingPool.PerformBlending(cmd, num4, m_Pool);
			}
			if (m_ToBeLoadedBlendingCells.size == 0)
			{
				m_HasRemainingCellsToBlend = false;
			}
		}
	}
	[GenerateHLSL(PackingRules.Exact, true, false, false, 1, false, false, false, -1, ".\\Library\\PackageCache\\com.unity.render-pipelines.core@14.0.11\\Runtime\\Lighting\\ProbeVolume\\ProbeReferenceVolume.Debug.cs")]
	public enum DebugProbeShadingMode
	{
		SH,
		SHL0,
		SHL0L1,
		Validity,
		ValidityOverDilationThreshold,
		InvalidatedByTouchupVolumes,
		Size
	}
	internal class ProbeVolumeDebug : IDebugData
	{
		public bool drawProbes;

		public bool drawBricks;

		public bool drawCells;

		public bool realtimeSubdivision;

		public int subdivisionCellUpdatePerFrame = 4;

		public float subdivisionDelayInSeconds = 1f;

		public DebugProbeShadingMode probeShading;

		public float probeSize = 0.3f;

		public float subdivisionViewCullingDistance = 500f;

		public float probeCullingDistance = 200f;

		public int maxSubdivToVisualize = 7;

		public int minSubdivToVisualize;

		public float exposureCompensation;

		public bool drawVirtualOffsetPush;

		public float offsetSize = 0.025f;

		public bool freezeStreaming;

		public int otherStateIndex;

		public ProbeVolumeDebug()
		{
			Init();
		}

		private void Init()
		{
			drawProbes = false;
			drawBricks = false;
			drawCells = false;
			realtimeSubdivision = false;
			subdivisionCellUpdatePerFrame = 4;
			subdivisionDelayInSeconds = 1f;
			probeShading = DebugProbeShadingMode.SH;
			probeSize = 0.3f;
			subdivisionViewCullingDistance = 500f;
			probeCullingDistance = 200f;
			maxSubdivToVisualize = 7;
			minSubdivToVisualize = 0;
			exposureCompensation = 0f;
			drawVirtualOffsetPush = false;
			offsetSize = 0.025f;
			freezeStreaming = false;
			otherStateIndex = 0;
		}

		public Action GetReset()
		{
			return delegate
			{
				Init();
			};
		}
	}
	public sealed class ProbeReferenceVolumeProfile : ScriptableObject
	{
		internal enum Version
		{
			Initial
		}

		[SerializeField]
		private Version version = CoreUtils.GetLastEnumValue<Version>();

		[SerializeField]
		internal bool freezePlacement;

		[Range(2f, 5f)]
		public int simplificationLevels = 3;

		[Min(0.1f)]
		public float minDistanceBetweenProbes = 1f;

		public LayerMask renderersLayerMask = -1;

		[Min(0f)]
		public float minRendererVolumeSize = 0.1f;

		public int cellSizeInBricks => (int)Mathf.Pow(3f, simplificationLevels);

		public int maxSubdivision => simplificationLevels + 1;

		public float minBrickSize => Mathf.Max(0.01f, minDistanceBetweenProbes * 3f);

		public float cellSizeInMeters => (float)cellSizeInBricks * minBrickSize;

		private void OnEnable()
		{
			_ = version;
			CoreUtils.GetLastEnumValue<Version>();
		}

		public bool IsEquivalent(ProbeReferenceVolumeProfile otherProfile)
		{
			if (minDistanceBetweenProbes == otherProfile.minDistanceBetweenProbes && cellSizeInMeters == otherProfile.cellSizeInMeters && simplificationLevels == otherProfile.simplificationLevels)
			{
				return (int)renderersLayerMask == (int)otherProfile.renderersLayerMask;
			}
			return false;
		}
	}
	[ExecuteAlways]
	[AddComponentMenu("Rendering/Probe Volume Touchup")]
	public class ProbeTouchupVolume : MonoBehaviour
	{
		[Range(0.0001f, 2f)]
		public float intensityScale = 1f;

		public bool invalidateProbes;

		public bool overrideDilationThreshold;

		[Range(0f, 0.99f)]
		public float overriddenDilationThreshold = 0.75f;

		public Vector3 size = new Vector3(1f, 1f, 1f);
	}
	[ExecuteAlways]
	[AddComponentMenu("Rendering/Probe Volume")]
	public class ProbeVolume : MonoBehaviour
	{
		public enum Mode
		{
			Global,
			Scene,
			Local
		}

		private enum Version
		{
			Initial,
			LocalMode,
			Count
		}

		[Tooltip("When set to Global this Probe Volume considers all renderers with Contribute Global Illumination enabled. Local only considers renderers in the scene.\nThis list updates every time the Scene is saved or the lighting is baked.")]
		public Mode mode = Mode.Scene;

		public Vector3 size = new Vector3(10f, 10f, 10f);

		[HideInInspector]
		[Min(0f)]
		public bool overrideRendererFilters;

		[HideInInspector]
		[Min(0f)]
		public float minRendererVolumeSize = 0.1f;

		public LayerMask objectLayerMask = -1;

		[HideInInspector]
		public int lowestSubdivLevelOverride;

		[HideInInspector]
		public int highestSubdivLevelOverride = -1;

		[HideInInspector]
		public bool overridesSubdivLevels;

		[SerializeField]
		internal bool mightNeedRebaking;

		[SerializeField]
		internal Matrix4x4 cachedTransform;

		[SerializeField]
		internal int cachedHashCode;

		[HideInInspector]
		[Tooltip("Whether spaces with no renderers need to be filled with bricks at lowest subdivision level.")]
		public bool fillEmptySpaces;

		[SerializeField]
		private Version version;

		[SerializeField]
		[Obsolete("Use mode instead")]
		public bool globalVolume;

		private void Awake()
		{
			if (version != Version.Count && version == Version.Initial)
			{
				mode = (globalVolume ? Mode.Scene : Mode.Local);
				version++;
			}
		}
	}
	[PreferBinarySerialization]
	internal class ProbeVolumeAsset : ScriptableObject
	{
		[Serializable]
		internal enum AssetVersion
		{
			First = 0,
			AddProbeVolumesAtlasEncodingModes = 1,
			PV2 = 2,
			ChunkBasedIndex = 3,
			BinaryRuntimeDebugSplit = 4,
			BinaryTextureData = 5,
			Max = 6,
			Current = 5
		}

		[Serializable]
		internal struct CellCounts
		{
			public int bricksCount;

			public int probesCount;

			public int offsetsCount;

			public int chunksCount;

			public void Add(CellCounts o)
			{
				bricksCount += o.bricksCount;
				probesCount += o.probesCount;
				offsetsCount += o.offsetsCount;
				chunksCount += o.chunksCount;
			}
		}

		[SerializeField]
		protected internal int m_Version = 5;

		[SerializeField]
		internal ProbeReferenceVolume.Cell[] cells;

		[SerializeField]
		internal CellCounts[] cellCounts;

		[SerializeField]
		internal CellCounts totalCellCounts;

		[SerializeField]
		internal Vector3Int maxCellPosition;

		[SerializeField]
		internal Vector3Int minCellPosition;

		[SerializeField]
		internal Bounds globalBounds;

		[SerializeField]
		internal ProbeVolumeSHBands bands;

		[SerializeField]
		internal int chunkSizeInBricks;

		[SerializeField]
		private string m_AssetFullPath = "UNINITIALIZED!";

		[SerializeField]
		internal int cellSizeInBricks;

		[SerializeField]
		internal int simplificationLevels;

		[SerializeField]
		internal float minDistanceBetweenProbes;

		public int Version => m_Version;

		internal int maxSubdivision => simplificationLevels + 1;

		internal float minBrickSize => Mathf.Max(0.01f, minDistanceBetweenProbes * 3f);

		internal bool CompatibleWith(ProbeVolumeAsset otherAsset)
		{
			if (maxSubdivision == otherAsset.maxSubdivision && minBrickSize == otherAsset.minBrickSize && cellSizeInBricks == otherAsset.cellSizeInBricks)
			{
				return chunkSizeInBricks == otherAsset.chunkSizeInBricks;
			}
			return false;
		}

		internal bool IsInvalid()
		{
			if (maxCellPosition.x >= minCellPosition.x && maxCellPosition.y >= minCellPosition.y)
			{
				return maxCellPosition.z < minCellPosition.z;
			}
			return true;
		}

		public string GetSerializedFullPath()
		{
			return m_AssetFullPath;
		}

		private static int AlignUp16(int count)
		{
			int num = 16;
			int num2 = count % num;
			return count + ((num2 != 0) ? (num - num2) : 0);
		}

		private NativeArray<T> GetSubArray<T>(NativeArray<byte> input, int count, ref int offset) where T : struct
		{
			int num = count * UnsafeUtility.SizeOf<T>();
			if (offset + num > input.Length)
			{
				return default(NativeArray<T>);
			}
			NativeArray<T> result = input.GetSubArray(offset, num).Reinterpret<T>(1);
			offset = AlignUp16(offset + num);
			return result;
		}

		internal bool ResolveSharedCellData(TextAsset cellSharedDataAsset, TextAsset cellSupportDataAsset)
		{
			if (cellSharedDataAsset == null)
			{
				return false;
			}
			int num = chunkSizeInBricks * 64;
			int count = totalCellCounts.chunksCount * num;
			NativeArray<byte> data = cellSharedDataAsset.GetData<byte>();
			int offset = 0;
			NativeArray<ProbeBrickIndex.Brick> subArray = GetSubArray<ProbeBrickIndex.Brick>(data, totalCellCounts.bricksCount, ref offset);
			NativeArray<byte> subArray2 = GetSubArray<byte>(data, count, ref offset);
			if (offset != AlignUp16(data.Length))
			{
				return false;
			}
			NativeArray<byte> input = (cellSupportDataAsset ? cellSupportDataAsset.GetData<byte>() : default(NativeArray<byte>));
			bool isCreated = input.IsCreated;
			offset = 0;
			NativeArray<Vector3> nativeArray = (isCreated ? GetSubArray<Vector3>(input, count, ref offset) : default(NativeArray<Vector3>));
			NativeArray<float> nativeArray2 = (isCreated ? GetSubArray<float>(input, count, ref offset) : default(NativeArray<float>));
			NativeArray<float> nativeArray3 = (isCreated ? GetSubArray<float>(input, count, ref offset) : default(NativeArray<float>));
			NativeArray<Vector3> nativeArray4 = (isCreated ? GetSubArray<Vector3>(input, count, ref offset) : default(NativeArray<Vector3>));
			if (isCreated && offset != AlignUp16(input.Length))
			{
				return false;
			}
			CellCounts cellCounts = default(CellCounts);
			for (int i = 0; i < cells.Length; i++)
			{
				ProbeReferenceVolume.Cell cell = cells[i];
				CellCounts o = this.cellCounts[i];
				int start = cellCounts.chunksCount * num;
				int length = o.chunksCount * num;
				cell.bricks = subArray.GetSubArray(cellCounts.bricksCount, o.bricksCount);
				cell.validityNeighMaskData = subArray2.GetSubArray(start, length);
				if (isCreated)
				{
					cell.probePositions = nativeArray.GetSubArray(start, length);
					cell.touchupVolumeInteraction = nativeArray2.GetSubArray(start, length);
					cell.offsetVectors = nativeArray4.GetSubArray(start, length);
					cell.validity = nativeArray3.GetSubArray(start, length);
				}
				cellCounts.Add(o);
			}
			return true;
		}

		internal bool ResolvePerScenarioCellData(TextAsset cellDataAsset, TextAsset cellOptionalDataAsset, int stateIndex)
		{
			if (cellDataAsset == null)
			{
				return false;
			}
			int num = chunkSizeInBricks * 64;
			int num2 = totalCellCounts.chunksCount * num;
			NativeArray<byte> data = cellDataAsset.GetData<byte>();
			int offset = 0;
			NativeArray<ushort> subArray = GetSubArray<ushort>(data, num2 * 4, ref offset);
			NativeArray<byte> subArray2 = GetSubArray<byte>(data, num2 * 4, ref offset);
			NativeArray<byte> subArray3 = GetSubArray<byte>(data, num2 * 4, ref offset);
			if (offset != AlignUp16(data.Length))
			{
				return false;
			}
			NativeArray<byte> input = (cellOptionalDataAsset ? cellOptionalDataAsset.GetData<byte>() : default(NativeArray<byte>));
			bool isCreated = input.IsCreated;
			offset = 0;
			NativeArray<byte> subArray4 = GetSubArray<byte>(input, num2 * 4, ref offset);
			NativeArray<byte> subArray5 = GetSubArray<byte>(input, num2 * 4, ref offset);
			NativeArray<byte> subArray6 = GetSubArray<byte>(input, num2 * 4, ref offset);
			NativeArray<byte> subArray7 = GetSubArray<byte>(input, num2 * 4, ref offset);
			if (isCreated && offset != AlignUp16(input.Length))
			{
				return false;
			}
			CellCounts cellCounts = default(CellCounts);
			for (int i = 0; i < cells.Length; i++)
			{
				CellCounts o = this.cellCounts[i];
				ProbeReferenceVolume.Cell.PerScenarioData perScenarioData = default(ProbeReferenceVolume.Cell.PerScenarioData);
				int start = cellCounts.chunksCount * num * 4;
				int length = o.chunksCount * num * 4;
				perScenarioData.shL0L1RxData = subArray.GetSubArray(start, length);
				perScenarioData.shL1GL1RyData = subArray2.GetSubArray(start, length);
				perScenarioData.shL1BL1RzData = subArray3.GetSubArray(start, length);
				if (isCreated)
				{
					perScenarioData.shL2Data_0 = subArray4.GetSubArray(start, length);
					perScenarioData.shL2Data_1 = subArray5.GetSubArray(start, length);
					perScenarioData.shL2Data_2 = subArray6.GetSubArray(start, length);
					perScenarioData.shL2Data_3 = subArray7.GetSubArray(start, length);
				}
				if (stateIndex == 0)
				{
					cells[i].scenario0 = perScenarioData;
				}
				else
				{
					cells[i].scenario1 = perScenarioData;
				}
				cellCounts.Add(o);
			}
			return true;
		}
	}
	[Serializable]
	internal struct ProbeDilationSettings
	{
		public bool enableDilation;

		public float dilationDistance;

		public float dilationValidityThreshold;

		public int dilationIterations;

		public bool squaredDistWeighting;

		internal void SetDefaults()
		{
			enableDilation = true;
			dilationDistance = 1f;
			dilationValidityThreshold = 0.25f;
			dilationIterations = 1;
			squaredDistWeighting = true;
		}

		internal void UpgradeFromTo(ProbeVolumeBakingProcessSettings.SettingsVersion from, ProbeVolumeBakingProcessSettings.SettingsVersion to)
		{
		}
	}
	[Serializable]
	internal struct VirtualOffsetSettings
	{
		public bool useVirtualOffset;

		[Range(0f, 1f)]
		public float outOfGeoOffset;

		[Range(0f, 2f)]
		public float searchMultiplier;

		[Range(-0.05f, 0f)]
		public float rayOriginBias;

		[Range(4f, 24f)]
		public int maxHitsPerRay;

		public LayerMask collisionMask;

		internal void SetDefaults()
		{
			useVirtualOffset = true;
			outOfGeoOffset = 0.01f;
			searchMultiplier = 0.2f;
			UpgradeFromTo(ProbeVolumeBakingProcessSettings.SettingsVersion.Initial, ProbeVolumeBakingProcessSettings.SettingsVersion.ThreadedVirtualOffset);
		}

		internal void UpgradeFromTo(ProbeVolumeBakingProcessSettings.SettingsVersion from, ProbeVolumeBakingProcessSettings.SettingsVersion to)
		{
			if (from < ProbeVolumeBakingProcessSettings.SettingsVersion.ThreadedVirtualOffset && to >= ProbeVolumeBakingProcessSettings.SettingsVersion.ThreadedVirtualOffset)
			{
				rayOriginBias = -0.001f;
				maxHitsPerRay = 10;
				collisionMask = -5;
			}
		}
	}
	[Serializable]
	internal struct ProbeVolumeBakingProcessSettings
	{
		internal enum SettingsVersion
		{
			Initial = 0,
			ThreadedVirtualOffset = 1,
			Max = 2,
			Current = 1
		}

		[SerializeField]
		private SettingsVersion m_Version;

		public ProbeDilationSettings dilationSettings;

		public VirtualOffsetSettings virtualOffsetSettings;

		internal static ProbeVolumeBakingProcessSettings Default
		{
			get
			{
				ProbeVolumeBakingProcessSettings result = default(ProbeVolumeBakingProcessSettings);
				result.SetDefaults();
				return result;
			}
		}

		internal ProbeVolumeBakingProcessSettings(ProbeDilationSettings dilationSettings, VirtualOffsetSettings virtualOffsetSettings)
		{
			m_Version = SettingsVersion.ThreadedVirtualOffset;
			this.dilationSettings = dilationSettings;
			this.virtualOffsetSettings = virtualOffsetSettings;
		}

		internal void SetDefaults()
		{
			m_Version = SettingsVersion.ThreadedVirtualOffset;
			dilationSettings.SetDefaults();
			virtualOffsetSettings.SetDefaults();
		}

		internal void Upgrade()
		{
			if (m_Version != SettingsVersion.ThreadedVirtualOffset)
			{
				dilationSettings.UpgradeFromTo(m_Version, SettingsVersion.ThreadedVirtualOffset);
				virtualOffsetSettings.UpgradeFromTo(m_Version, SettingsVersion.ThreadedVirtualOffset);
				m_Version = SettingsVersion.ThreadedVirtualOffset;
			}
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	internal struct GIContributors
	{
	}
	[ExecuteAlways]
	[AddComponentMenu("")]
	public class ProbeVolumePerSceneData : MonoBehaviour, ISerializationCallbackReceiver
	{
		[Serializable]
		internal struct PerScenarioData
		{
			public int sceneHash;

			public TextAsset cellDataAsset;

			public TextAsset cellOptionalDataAsset;
		}

		[Serializable]
		private struct SerializablePerScenarioDataItem
		{
			public string scenario;

			public PerScenarioData data;
		}

		[SerializeField]
		internal ProbeVolumeAsset asset;

		[SerializeField]
		internal TextAsset cellSharedDataAsset;

		[SerializeField]
		internal TextAsset cellSupportDataAsset;

		[SerializeField]
		private List<SerializablePerScenarioDataItem> serializedScenarios = new List<SerializablePerScenarioDataItem>();

		internal Dictionary<string, PerScenarioData> scenarios = new Dictionary<string, PerScenarioData>();

		private bool assetLoaded;

		private string activeScenario;

		private string otherScenario;

		void ISerializationCallbackReceiver.OnAfterDeserialize()
		{
			scenarios.Clear();
			foreach (SerializablePerScenarioDataItem serializedScenario in serializedScenarios)
			{
				scenarios.Add(serializedScenario.scenario, serializedScenario.data);
			}
		}

		void ISerializationCallbackReceiver.OnBeforeSerialize()
		{
			serializedScenarios.Clear();
			foreach (KeyValuePair<string, PerScenarioData> scenario in scenarios)
			{
				serializedScenarios.Add(new SerializablePerScenarioDataItem
				{
					scenario = scenario.Key,
					data = scenario.Value
				});
			}
		}

		internal void Clear()
		{
			QueueAssetRemoval();
			scenarios.Clear();
		}

		internal void RemoveScenario(string scenario)
		{
			scenarios.Remove(scenario);
		}

		internal void RenameScenario(string scenario, string newName)
		{
			if (scenarios.TryGetValue(scenario, out var value))
			{
				scenarios.Remove(scenario);
				scenarios.Add(newName, value);
			}
		}

		internal bool ResolveCells()
		{
			if (ResolveSharedCellData())
			{
				return ResolvePerScenarioCellData();
			}
			return false;
		}

		internal bool ResolveSharedCellData()
		{
			if (asset != null)
			{
				return asset.ResolveSharedCellData(cellSharedDataAsset, cellSupportDataAsset);
			}
			return false;
		}

		private bool ResolvePerScenarioCellData()
		{
			int num = 0;
			int num2 = ((otherScenario == null) ? 1 : 2);
			if (activeScenario != null && scenarios.TryGetValue(activeScenario, out var value) && asset.ResolvePerScenarioCellData(value.cellDataAsset, value.cellOptionalDataAsset, 0))
			{
				num++;
			}
			if (otherScenario != null && scenarios.TryGetValue(otherScenario, out var value2) && asset.ResolvePerScenarioCellData(value2.cellDataAsset, value2.cellOptionalDataAsset, num))
			{
				num++;
			}
			for (int i = 0; i < asset.cells.Length; i++)
			{
				asset.cells[i].hasTwoScenarios = num == 2;
			}
			return num == num2;
		}

		internal void QueueAssetLoading()
		{
			if (!(asset == null) && !asset.IsInvalid() && ResolvePerScenarioCellData())
			{
				ProbeReferenceVolume.instance.AddPendingAssetLoading(asset);
				assetLoaded = true;
			}
		}

		internal void QueueAssetRemoval()
		{
			if (asset != null)
			{
				ProbeReferenceVolume.instance.AddPendingAssetRemoval(asset);
			}
			assetLoaded = false;
		}

		private void OnEnable()
		{
			ProbeReferenceVolume.instance.RegisterPerSceneData(this);
			if (ProbeReferenceVolume.instance.sceneData != null)
			{
				Initialize();
			}
		}

		private void OnDisable()
		{
			QueueAssetRemoval();
			activeScenario = (otherScenario = null);
			ProbeReferenceVolume.instance.UnregisterPerSceneData(this);
		}

		internal void Initialize()
		{
			ResolveSharedCellData();
			QueueAssetRemoval();
			activeScenario = ProbeReferenceVolume.instance.sceneData.lightingScenario;
			otherScenario = ProbeReferenceVolume.instance.sceneData.otherScenario;
			QueueAssetLoading();
		}

		internal void UpdateActiveScenario(string activeScenario, string otherScenario)
		{
			if (!(asset == null))
			{
				this.activeScenario = activeScenario;
				this.otherScenario = otherScenario;
				if (!assetLoaded)
				{
					QueueAssetLoading();
				}
				else if (!ResolvePerScenarioCellData())
				{
					QueueAssetRemoval();
				}
			}
		}
	}
	[Serializable]
	public class ProbeVolumeSceneData : ISerializationCallbackReceiver
	{
		[Serializable]
		private struct SerializableBoundItem
		{
			[SerializeField]
			public string sceneGUID;

			[SerializeField]
			public Bounds bounds;
		}

		[Serializable]
		private struct SerializableHasPVItem
		{
			[SerializeField]
			public string sceneGUID;

			[SerializeField]
			public bool hasProbeVolumes;
		}

		[Serializable]
		private struct SerializablePVProfile
		{
			[SerializeField]
			public string sceneGUID;

			[SerializeField]
			public ProbeReferenceVolumeProfile profile;
		}

		[Serializable]
		private struct SerializablePVBakeSettings
		{
			public string sceneGUID;

			public ProbeVolumeBakingProcessSettings settings;
		}

		[Serializable]
		internal class BakingSet
		{
			public string name;

			public List<string> sceneGUIDs = new List<string>();

			public ProbeVolumeBakingProcessSettings settings;

			public ProbeReferenceVolumeProfile profile;

			public List<string> lightingScenarios = new List<string>();

			internal string CreateScenario(string name)
			{
				if (lightingScenarios.Contains(name))
				{
					int num = 1;
					string text;
					do
					{
						text = $"{name} ({num++})";
					}
					while (lightingScenarios.Contains(text));
					name = text;
				}
				lightingScenarios.Add(name);
				return name;
			}

			internal bool RemoveScenario(string name)
			{
				return lightingScenarios.Remove(name);
			}
		}

		private static PropertyInfo s_SceneGUID = typeof(Scene).GetProperty("guid", BindingFlags.Instance | BindingFlags.NonPublic);

		[SerializeField]
		private List<SerializableBoundItem> serializedBounds;

		[SerializeField]
		private List<SerializableHasPVItem> serializedHasVolumes;

		[SerializeField]
		private List<SerializablePVProfile> serializedProfiles;

		[SerializeField]
		private List<SerializablePVBakeSettings> serializedBakeSettings;

		[SerializeField]
		private List<BakingSet> serializedBakingSets;

		internal Object parentAsset;

		internal string parentSceneDataPropertyName;

		public Dictionary<string, Bounds> sceneBounds;

		internal Dictionary<string, bool> hasProbeVolumes;

		internal Dictionary<string, ProbeReferenceVolumeProfile> sceneProfiles;

		internal Dictionary<string, ProbeVolumeBakingProcessSettings> sceneBakingSettings;

		internal List<BakingSet> bakingSets;

		[SerializeField]
		private string m_LightingScenario = ProbeReferenceVolume.defaultLightingScenario;

		private string m_OtherScenario;

		private float m_ScenarioBlendingFactor;

		internal string lightingScenario => m_LightingScenario;

		internal string otherScenario => m_OtherScenario;

		internal float scenarioBlendingFactor => m_ScenarioBlendingFactor;

		internal static string GetSceneGUID(Scene scene)
		{
			Debug.Assert(s_SceneGUID != null, "Reflection for scene GUID failed");
			return (string)s_SceneGUID.GetValue(scene);
		}

		internal void SetActiveScenario(string scenario)
		{
			if (m_LightingScenario == scenario && m_ScenarioBlendingFactor == 0f)
			{
				return;
			}
			m_LightingScenario = scenario;
			m_OtherScenario = null;
			m_ScenarioBlendingFactor = 0f;
			foreach (ProbeVolumePerSceneData perSceneData in ProbeReferenceVolume.instance.perSceneDataList)
			{
				perSceneData.UpdateActiveScenario(m_LightingScenario, m_OtherScenario);
			}
			if (ProbeReferenceVolume.instance.enableScenarioBlending)
			{
				ProbeReferenceVolume.instance.ScenarioBlendingChanged(scenarioChanged: true);
			}
			else
			{
				ProbeReferenceVolume.instance.UnloadAllCells();
			}
		}

		internal void BlendLightingScenario(string otherScenario, float blendingFactor)
		{
			if (!ProbeReferenceVolume.instance.enableScenarioBlending)
			{
				if (!ProbeBrickBlendingPool.isSupported)
				{
					Debug.LogError("Blending between lighting scenarios is not supported by this render pipeline.");
				}
				else
				{
					Debug.LogError("Blending between lighting scenarios is disabled in the render pipeline settings.");
				}
				return;
			}
			blendingFactor = Mathf.Clamp01(blendingFactor);
			if (otherScenario == m_LightingScenario || string.IsNullOrEmpty(otherScenario))
			{
				otherScenario = null;
			}
			if (otherScenario == null)
			{
				blendingFactor = 0f;
			}
			if (otherScenario == m_OtherScenario && Mathf.Approximately(blendingFactor, m_ScenarioBlendingFactor))
			{
				return;
			}
			bool flag = otherScenario != m_OtherScenario;
			m_OtherScenario = otherScenario;
			m_ScenarioBlendingFactor = blendingFactor;
			if (flag)
			{
				foreach (ProbeVolumePerSceneData perSceneData in ProbeReferenceVolume.instance.perSceneDataList)
				{
					perSceneData.UpdateActiveScenario(m_LightingScenario, m_OtherScenario);
				}
			}
			ProbeReferenceVolume.instance.ScenarioBlendingChanged(flag);
		}

		public ProbeVolumeSceneData(Object parentAsset, string parentSceneDataPropertyName)
		{
			this.parentAsset = parentAsset;
			this.parentSceneDataPropertyName = parentSceneDataPropertyName;
			sceneBounds = new Dictionary<string, Bounds>();
			hasProbeVolumes = new Dictionary<string, bool>();
			sceneProfiles = new Dictionary<string, ProbeReferenceVolumeProfile>();
			sceneBakingSettings = new Dictionary<string, ProbeVolumeBakingProcessSettings>();
			bakingSets = new List<BakingSet>();
			serializedBounds = new List<SerializableBoundItem>();
			serializedHasVolumes = new List<SerializableHasPVItem>();
			serializedProfiles = new List<SerializablePVProfile>();
			serializedBakeSettings = new List<SerializablePVBakeSettings>();
			UpdateBakingSets();
		}

		public void SetParentObject(Object parent, string parentSceneDataPropertyName)
		{
			parentAsset = parent;
			this.parentSceneDataPropertyName = parentSceneDataPropertyName;
			UpdateBakingSets();
		}

		public void OnAfterDeserialize()
		{
			if (serializedBounds == null || serializedHasVolumes == null || serializedProfiles == null || serializedBakeSettings == null)
			{
				return;
			}
			sceneBounds = new Dictionary<string, Bounds>();
			hasProbeVolumes = new Dictionary<string, bool>();
			sceneProfiles = new Dictionary<string, ProbeReferenceVolumeProfile>();
			sceneBakingSettings = new Dictionary<string, ProbeVolumeBakingProcessSettings>();
			bakingSets = new List<BakingSet>();
			foreach (SerializableBoundItem serializedBound in serializedBounds)
			{
				sceneBounds.Add(serializedBound.sceneGUID, serializedBound.bounds);
			}
			foreach (SerializableHasPVItem serializedHasVolume in serializedHasVolumes)
			{
				hasProbeVolumes.Add(serializedHasVolume.sceneGUID, serializedHasVolume.hasProbeVolumes);
			}
			foreach (SerializablePVProfile serializedProfile in serializedProfiles)
			{
				sceneProfiles.Add(serializedProfile.sceneGUID, serializedProfile.profile);
			}
			foreach (SerializablePVBakeSettings serializedBakeSetting in serializedBakeSettings)
			{
				sceneBakingSettings.Add(serializedBakeSetting.sceneGUID, serializedBakeSetting.settings);
			}
			if (string.IsNullOrEmpty(m_LightingScenario))
			{
				m_LightingScenario = ProbeReferenceVolume.defaultLightingScenario;
			}
			foreach (BakingSet serializedBakingSet in serializedBakingSets)
			{
				serializedBakingSet.settings.Upgrade();
				bakingSets.Add(serializedBakingSet);
			}
			if (m_OtherScenario == "")
			{
				m_OtherScenario = null;
			}
		}

		private void UpdateBakingSets()
		{
			foreach (BakingSet serializedBakingSet in serializedBakingSets)
			{
				if (serializedBakingSet.profile == null)
				{
					InitializeBakingSet(serializedBakingSet, serializedBakingSet.name);
				}
				if (serializedBakingSet.lightingScenarios.Count == 0)
				{
					InitializeScenarios(serializedBakingSet);
				}
			}
			SyncBakingSetSettings();
		}

		public void OnBeforeSerialize()
		{
			if (sceneBounds == null || hasProbeVolumes == null || sceneBakingSettings == null || sceneProfiles == null || serializedBounds == null || serializedHasVolumes == null || serializedBakeSettings == null || serializedProfiles == null || serializedBakingSets == null)
			{
				return;
			}
			serializedBounds.Clear();
			serializedHasVolumes.Clear();
			serializedProfiles.Clear();
			serializedBakeSettings.Clear();
			serializedBakingSets.Clear();
			SerializableBoundItem item = default(SerializableBoundItem);
			foreach (string key5 in sceneBounds.Keys)
			{
				string key = (item.sceneGUID = key5);
				item.bounds = sceneBounds[key];
				serializedBounds.Add(item);
			}
			SerializableHasPVItem item2 = default(SerializableHasPVItem);
			foreach (string key6 in hasProbeVolumes.Keys)
			{
				string key2 = (item2.sceneGUID = key6);
				item2.hasProbeVolumes = hasProbeVolumes[key2];
				serializedHasVolumes.Add(item2);
			}
			SerializablePVBakeSettings item3 = default(SerializablePVBakeSettings);
			foreach (string key7 in sceneBakingSettings.Keys)
			{
				string key3 = (item3.sceneGUID = key7);
				item3.settings = sceneBakingSettings[key3];
				serializedBakeSettings.Add(item3);
			}
			SerializablePVProfile item4 = default(SerializablePVProfile);
			foreach (string key8 in sceneProfiles.Keys)
			{
				string key4 = (item4.sceneGUID = key8);
				item4.profile = sceneProfiles[key4];
				serializedProfiles.Add(item4);
			}
			foreach (BakingSet bakingSet in bakingSets)
			{
				serializedBakingSets.Add(bakingSet);
			}
		}

		internal BakingSet CreateNewBakingSet(string name)
		{
			BakingSet bakingSet = new BakingSet();
			InitializeBakingSet(bakingSet, name);
			bakingSets.Add(bakingSet);
			return bakingSet;
		}

		private void InitializeBakingSet(BakingSet set, string name)
		{
			ProbeReferenceVolumeProfile probeReferenceVolumeProfile = ScriptableObject.CreateInstance<ProbeReferenceVolumeProfile>();
			set.name = probeReferenceVolumeProfile.name;
			set.profile = probeReferenceVolumeProfile;
			set.settings = ProbeVolumeBakingProcessSettings.Default;
			InitializeScenarios(set);
		}

		private void InitializeScenarios(BakingSet set)
		{
			set.lightingScenarios = new List<string> { ProbeReferenceVolume.defaultLightingScenario };
		}

		internal void SyncBakingSetSettings()
		{
			foreach (BakingSet bakingSet in bakingSets)
			{
				foreach (string sceneGUID in bakingSet.sceneGUIDs)
				{
					sceneBakingSettings[sceneGUID] = bakingSet.settings;
					sceneProfiles[sceneGUID] = bakingSet.profile;
				}
			}
		}
	}
	public enum APVConstantBufferRegister
	{
		GlobalRegister = 5
	}
	[GenerateHLSL(PackingRules.Exact, true, false, false, 1, false, false, false, -1, ".\\Library\\PackageCache\\com.unity.render-pipelines.core@14.0.11\\Runtime\\Lighting\\ProbeVolume\\ShaderVariablesProbeVolumes.cs")]
	public enum APVLeakReductionMode
	{
		None,
		ValidityAndNormalBased
	}
	[GenerateHLSL(PackingRules.Exact, true, false, false, 1, false, false, false, -1, ".\\Library\\PackageCache\\com.unity.render-pipelines.core@14.0.11\\Runtime\\Lighting\\ProbeVolume\\ShaderVariablesProbeVolumes.cs", needAccessors = false, generateCBuffer = true, constantRegister = 5)]
	internal struct ShaderVariablesProbeVolumes
	{
		public Vector4 _PoolDim_CellInMeters;

		public Vector4 _MinCellPos_Noise;

		public Vector4 _IndicesDim_IndexChunkSize;

		public Vector4 _Biases_CellInMinBrick_MinBrickSize;

		public Vector4 _LeakReductionParams;

		public Vector4 _Weight_MinLoadedCell;

		public Vector4 _MaxLoadedCell_FrameIndex;

		public Vector4 _NormalizationClamp_Padding12;
	}
	[Serializable]
	public struct SphericalHarmonicsL1
	{
		public Vector4 shAr;

		public Vector4 shAg;

		public Vector4 shAb;

		public static readonly SphericalHarmonicsL1 zero = new SphericalHarmonicsL1
		{
			shAr = Vector4.zero,
			shAg = Vector4.zero,
			shAb = Vector4.zero
		};

		public static SphericalHarmonicsL1 operator +(SphericalHarmonicsL1 lhs, SphericalHarmonicsL1 rhs)
		{
			return new SphericalHarmonicsL1
			{
				shAr = lhs.shAr + rhs.shAr,
				shAg = lhs.shAg + rhs.shAg,
				shAb = lhs.shAb + rhs.shAb
			};
		}

		public static SphericalHarmonicsL1 operator -(SphericalHarmonicsL1 lhs, SphericalHarmonicsL1 rhs)
		{
			return new SphericalHarmonicsL1
			{
				shAr = lhs.shAr - rhs.shAr,
				shAg = lhs.shAg - rhs.shAg,
				shAb = lhs.shAb - rhs.shAb
			};
		}

		public static SphericalHarmonicsL1 operator *(SphericalHarmonicsL1 lhs, float rhs)
		{
			return new SphericalHarmonicsL1
			{
				shAr = lhs.shAr * rhs,
				shAg = lhs.shAg * rhs,
				shAb = lhs.shAb * rhs
			};
		}

		public static SphericalHarmonicsL1 operator /(SphericalHarmonicsL1 lhs, float rhs)
		{
			return new SphericalHarmonicsL1
			{
				shAr = lhs.shAr / rhs,
				shAg = lhs.shAg / rhs,
				shAb = lhs.shAb / rhs
			};
		}

		public static bool operator ==(SphericalHarmonicsL1 lhs, SphericalHarmonicsL1 rhs)
		{
			if (lhs.shAr == rhs.shAr && lhs.shAg == rhs.shAg)
			{
				return lhs.shAb == rhs.shAb;
			}
			return false;
		}

		public static bool operator !=(SphericalHarmonicsL1 lhs, SphericalHarmonicsL1 rhs)
		{
			return !(lhs == rhs);
		}

		public override bool Equals(object other)
		{
			if (!(other is SphericalHarmonicsL1))
			{
				return false;
			}
			return this == (SphericalHarmonicsL1)other;
		}

		public override int GetHashCode()
		{
			return ((391 + shAr.GetHashCode()) * 23 + shAg.GetHashCode()) * 23 + shAb.GetHashCode();
		}
	}
	public class SphericalHarmonicsL2Utils
	{
		public static void GetL1(SphericalHarmonicsL2 sh, out Vector3 L1_R, out Vector3 L1_G, out Vector3 L1_B)
		{
			L1_R = new Vector3(sh[0, 1], sh[0, 2], sh[0, 3]);
			L1_G = new Vector3(sh[1, 1], sh[1, 2], sh[1, 3]);
			L1_B = new Vector3(sh[2, 1], sh[2, 2], sh[2, 3]);
		}

		public static void GetL2(SphericalHarmonicsL2 sh, out Vector3 L2_0, out Vector3 L2_1, out Vector3 L2_2, out Vector3 L2_3, out Vector3 L2_4)
		{
			L2_0 = new Vector3(sh[0, 4], sh[1, 4], sh[2, 4]);
			L2_1 = new Vector3(sh[0, 5], sh[1, 5], sh[2, 5]);
			L2_2 = new Vector3(sh[0, 6], sh[1, 6], sh[2, 6]);
			L2_3 = new Vector3(sh[0, 7], sh[1, 7], sh[2, 7]);
			L2_4 = new Vector3(sh[0, 8], sh[1, 8], sh[2, 8]);
		}

		public static void SetL0(ref SphericalHarmonicsL2 sh, Vector3 L0)
		{
			sh[0, 0] = L0.x;
			sh[1, 0] = L0.y;
			sh[2, 0] = L0.z;
		}

		public static void SetL1R(ref SphericalHarmonicsL2 sh, Vector3 L1_R)
		{
			sh[0, 1] = L1_R.x;
			sh[0, 2] = L1_R.y;
			sh[0, 3] = L1_R.z;
		}

		public static void SetL1G(ref SphericalHarmonicsL2 sh, Vector3 L1_G)
		{
			sh[1, 1] = L1_G.x;
			sh[1, 2] = L1_G.y;
			sh[1, 3] = L1_G.z;
		}

		public static void SetL1B(ref SphericalHarmonicsL2 sh, Vector3 L1_B)
		{
			sh[2, 1] = L1_B.x;
			sh[2, 2] = L1_B.y;
			sh[2, 3] = L1_B.z;
		}

		public static void SetL1(ref SphericalHarmonicsL2 sh, Vector3 L1_R, Vector3 L1_G, Vector3 L1_B)
		{
			SetL1R(ref sh, L1_R);
			SetL1G(ref sh, L1_G);
			SetL1B(ref sh, L1_B);
		}

		public static void SetCoefficient(ref SphericalHarmonicsL2 sh, int index, Vector3 coefficient)
		{
			Debug.Assert(index < 9);
			sh[0, index] = coefficient.x;
			sh[1, index] = coefficient.y;
			sh[2, index] = coefficient.z;
		}

		public static Vector3 GetCoefficient(SphericalHarmonicsL2 sh, int index)
		{
			Debug.Assert(index < 9);
			return new Vector3(sh[0, index], sh[1, index], sh[2, index]);
		}
	}
	[GenerateHLSL(PackingRules.Exact, true, false, false, 1, false, false, false, -1, ".\\Library\\PackageCache\\com.unity.render-pipelines.core@14.0.11\\Runtime\\PostProcessing\\HDROutputDefines.cs")]
	public enum HDRRangeReduction
	{
		None,
		Reinhard,
		BT2390,
		ACES1000Nits,
		ACES2000Nits,
		ACES4000Nits
	}
	[GenerateHLSL(PackingRules.Exact, true, false, false, 1, false, false, false, -1, ".\\Library\\PackageCache\\com.unity.render-pipelines.core@14.0.11\\Runtime\\PostProcessing\\HDROutputDefines.cs")]
	public enum HDRColorspace
	{
		Rec709,
		Rec2020,
		P3D65
	}
	[GenerateHLSL(PackingRules.Exact, true, false, false, 1, false, false, false, -1, ".\\Library\\PackageCache\\com.unity.render-pipelines.core@14.0.11\\Runtime\\PostProcessing\\HDROutputDefines.cs")]
	public enum HDREncoding
	{
		Linear = 3,
		PQ = 2,
		Gamma22 = 4,
		sRGB = 0
	}
	public sealed class LensFlareCommonSRP
	{
		internal class LensFlareCompInfo
		{
			internal int index;

			internal LensFlareComponentSRP comp;

			internal LensFlareCompInfo(int idx, LensFlareComponentSRP cmp)
			{
				index = idx;
				comp = cmp;
			}
		}

		private static LensFlareCommonSRP m_Instance = null;

		private static readonly object m_Padlock = new object();

		private static List<LensFlareCompInfo> m_Data = new List<LensFlareCompInfo>();

		private static List<int> m_AvailableIndicies = new List<int>();

		public static int maxLensFlareWithOcclusion = 128;

		public static int maxLensFlareWithOcclusionTemporalSample = 8;

		public static int mergeNeeded = 1;

		public static RTHandle occlusionRT = null;

		private static int frameIdx = 0;

		private static readonly bool s_SupportsLensFlareTexFormat = SystemInfo.IsFormatSupported(GraphicsFormat.R32_SFloat, FormatUsage.Render);

		public static LensFlareCommonSRP Instance
		{
			get
			{
				if (m_Instance == null)
				{
					lock (m_Padlock)
					{
						if (m_Instance == null)
						{
							m_Instance = new LensFlareCommonSRP();
						}
					}
				}
				return m_Instance;
			}
		}

		private List<LensFlareCompInfo> Data => m_Data;

		private LensFlareCommonSRP()
		{
		}

		public static bool IsOcclusionRTCompatible()
		{
			return false;
		}

		public static void Initialize()
		{
			frameIdx = 0;
			if (IsOcclusionRTCompatible() && occlusionRT == null)
			{
				occlusionRT = RTHandles.Alloc(maxLensFlareWithOcclusion, Mathf.Max(mergeNeeded * (maxLensFlareWithOcclusionTemporalSample + 1), 1), TextureXR.slices, DepthBits.None, GraphicsFormat.R32_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2DArray, enableRandomWrite: true);
			}
		}

		public static void Dispose()
		{
			if (IsOcclusionRTCompatible() && occlusionRT != null)
			{
				RTHandles.Release(occlusionRT);
				occlusionRT = null;
			}
		}

		public bool IsEmpty()
		{
			return Data.Count == 0;
		}

		private int GetNextAvailableIndex()
		{
			if (m_AvailableIndicies.Count == 0)
			{
				return m_Data.Count;
			}
			int result = m_AvailableIndicies[m_AvailableIndicies.Count - 1];
			m_AvailableIndicies.RemoveAt(m_AvailableIndicies.Count - 1);
			return result;
		}

		public void AddData(LensFlareComponentSRP newData)
		{
			Debug.Assert(Instance == this, "LensFlareCommonSRP can have only one instance");
			if (!m_Data.Exists((LensFlareCompInfo x) => x.comp == newData))
			{
				m_Data.Add(new LensFlareCompInfo(GetNextAvailableIndex(), newData));
			}
		}

		public void RemoveData(LensFlareComponentSRP data)
		{
			Debug.Assert(Instance == this, "LensFlareCommonSRP can have only one instance");
			LensFlareCompInfo lensFlareCompInfo = m_Data.Find((LensFlareCompInfo x) => x.comp == data);
			if (lensFlareCompInfo != null)
			{
				int index = lensFlareCompInfo.index;
				m_Data.Remove(lensFlareCompInfo);
				m_AvailableIndicies.Add(index);
				if (m_Data.Count == 0)
				{
					m_AvailableIndicies.Clear();
				}
			}
		}

		public static float ShapeAttenuationPointLight()
		{
			return 1f;
		}

		public static float ShapeAttenuationDirLight(Vector3 forward, Vector3 wo)
		{
			return Mathf.Max(Vector3.Dot(forward, wo), 0f);
		}

		public static float ShapeAttenuationSpotConeLight(Vector3 forward, Vector3 wo, float spotAngle, float innerSpotPercent01)
		{
			float num = Mathf.Max(Mathf.Cos(0.5f * spotAngle * (MathF.PI / 180f)), 0f);
			float num2 = Mathf.Max(Mathf.Cos(0.5f * spotAngle * (MathF.PI / 180f) * innerSpotPercent01), 0f);
			return Mathf.Clamp01((Mathf.Max(Vector3.Dot(forward, wo), 0f) - num) / (num2 - num));
		}

		public static float ShapeAttenuationSpotBoxLight(Vector3 forward, Vector3 wo)
		{
			return Mathf.Max(Mathf.Sign(Vector3.Dot(forward, wo)), 0f);
		}

		public static float ShapeAttenuationSpotPyramidLight(Vector3 forward, Vector3 wo)
		{
			return ShapeAttenuationSpotBoxLight(forward, wo);
		}

		public static float ShapeAttenuationAreaTubeLight(Vector3 lightPositionWS, Vector3 lightSide, float lightWidth, Camera cam)
		{
			Vector3 position = lightPositionWS + lightSide * lightWidth * 0.5f;
			Vector3 position2 = lightPositionWS - lightSide * lightWidth * 0.5f;
			Vector3 position3 = lightPositionWS + cam.transform.right * lightWidth * 0.5f;
			Vector3 position4 = lightPositionWS - cam.transform.right * lightWidth * 0.5f;
			Vector3 p = cam.transform.InverseTransformPoint(position);
			Vector3 p2 = cam.transform.InverseTransformPoint(position2);
			Vector3 p3 = cam.transform.InverseTransformPoint(position3);
			Vector3 p4 = cam.transform.InverseTransformPoint(position4);
			float num = DiffLineIntegral(p3, p4);
			float num2 = DiffLineIntegral(p, p2);
			if (!(num > 0f))
			{
				return 1f;
			}
			return num2 / num;
			static float DiffLineIntegral(Vector3 vector2, Vector3 vector)
			{
				Vector3 normalized = (vector - vector2).normalized;
				if ((double)vector2.z <= 0.0 && (double)vector.z <= 0.0)
				{
					return 0f;
				}
				if ((double)vector2.z < 0.0)
				{
					vector2 = (vector2 * vector.z - vector * vector2.z) / (vector.z - vector2.z);
				}
				if ((double)vector.z < 0.0)
				{
					vector = (-vector2 * vector.z + vector * vector2.z) / (0f - vector.z + vector2.z);
				}
				float num3 = Vector3.Dot(vector2, normalized);
				float l = Vector3.Dot(vector, normalized);
				Vector3 vector3 = vector2 - num3 * normalized;
				float magnitude = vector3.magnitude;
				return ((Fpo(magnitude, l) - Fpo(magnitude, num3)) * vector3.z + (Fwt(magnitude, l) - Fwt(magnitude, num3)) * normalized.z) / MathF.PI;
			}
			static float Fpo(float d, float l)
			{
				return l / (d * (d * d + l * l)) + Mathf.Atan(l / d) / (d * d);
			}
			static float Fwt(float d, float l)
			{
				return l * l / (d * (d * d + l * l));
			}
		}

		public static float ShapeAttenuationAreaRectangleLight(Vector3 forward, Vector3 wo)
		{
			return ShapeAttenuationDirLight(forward, wo);
		}

		public static float ShapeAttenuationAreaDiscLight(Vector3 forward, Vector3 wo)
		{
			return ShapeAttenuationDirLight(forward, wo);
		}

		private static bool IsLensFlareSRPHidden(Camera cam, LensFlareComponentSRP comp, LensFlareDataSRP data)
		{
			if (!comp.enabled || !comp.gameObject.activeSelf || !comp.gameObject.activeInHierarchy || data == null || data.elements == null || data.elements.Length == 0 || comp.intensity <= 0f || (cam.cullingMask & (1 << comp.gameObject.layer)) == 0)
			{
				return true;
			}
			return false;
		}

		public static Vector4 GetFlareData0(Vector2 screenPos, Vector2 translationScale, Vector2 rayOff0, Vector2 vLocalScreenRatio, float angleDeg, float position, float angularOffset, Vector2 positionOffset, bool autoRotate)
		{
			if (!SystemInfo.graphicsUVStartsAtTop)
			{
				angleDeg *= -1f;
				positionOffset.y *= -1f;
			}
			float num = Mathf.Cos((0f - angularOffset) * (MathF.PI / 180f));
			float num2 = Mathf.Sin((0f - angularOffset) * (MathF.PI / 180f));
			Vector2 vector = -translationScale * (screenPos + screenPos * (position - 1f));
			vector = new Vector2(num * vector.x - num2 * vector.y, num2 * vector.x + num * vector.y);
			float num3 = angleDeg;
			num3 += 180f;
			if (autoRotate)
			{
				Vector2 vector2 = vector.normalized * vLocalScreenRatio * translationScale;
				num3 += -57.29578f * Mathf.Atan2(vector2.y, vector2.x);
			}
			num3 *= MathF.PI / 180f;
			float x = Mathf.Cos(0f - num3);
			float y = Mathf.Sin(0f - num3);
			return new Vector4(x, y, positionOffset.x + rayOff0.x * translationScale.x, 0f - positionOffset.y + rayOff0.y * translationScale.y);
		}

		private static Vector2 GetLensFlareRayOffset(Vector2 screenPos, float position, float globalCos0, float globalSin0)
		{
			Vector2 vector = -(screenPos + screenPos * (position - 1f));
			return new Vector2(globalCos0 * vector.x - globalSin0 * vector.y, globalSin0 * vector.x + globalCos0 * vector.y);
		}

		private static Vector3 WorldToViewport(Camera camera, bool isLocalLight, bool isCameraRelative, Matrix4x4 viewProjMatrix, Vector3 positionWS)
		{
			if (isLocalLight)
			{
				return WorldToViewportLocal(isCameraRelative, viewProjMatrix, camera.transform.position, positionWS);
			}
			return WorldToViewportDistance(camera, positionWS);
		}

		private static Vector3 WorldToViewportLocal(bool isCameraRelative, Matrix4x4 viewProjMatrix, Vector3 cameraPosWS, Vector3 positionWS)
		{
			Vector3 vector = positionWS;
			if (isCameraRelative)
			{
				vector -= cameraPosWS;
			}
			Vector4 vector2 = viewProjMatrix * vector;
			Vector3 result = new Vector3(vector2.x, vector2.y, 0f);
			result /= vector2.w;
			result.x = result.x * 0.5f + 0.5f;
			result.y = result.y * 0.5f + 0.5f;
			result.y = 1f - result.y;
			result.z = vector2.w;
			return result;
		}

		private static Vector3 WorldToViewportDistance(Camera cam, Vector3 positionWS)
		{
			Vector4 vector = cam.worldToCameraMatrix * positionWS;
			Vector4 vector2 = cam.projectionMatrix * vector;
			Vector3 result = new Vector3(vector2.x, vector2.y, 0f);
			result /= vector2.w;
			result.x = result.x * 0.5f + 0.5f;
			result.y = result.y * 0.5f + 0.5f;
			result.z = vector2.w;
			return result;
		}

		public static bool IsCloudLayerOpacityNeeded(Camera cam)
		{
			if (Instance.IsEmpty())
			{
				return false;
			}
			foreach (LensFlareCompInfo datum in Instance.Data)
			{
				if (datum != null && !(datum.comp == null))
				{
					LensFlareComponentSRP comp = datum.comp;
					LensFlareDataSRP lensFlareData = comp.lensFlareData;
					if (!IsLensFlareSRPHidden(cam, comp, lensFlareData) && comp.useOcclusion && (!comp.useOcclusion || comp.sampleCount != 0) && comp.useBackgroundCloudOcclusion)
					{
						return true;
					}
				}
			}
			return false;
		}

		private static void SetOcclusionPermutation(CommandBuffer cmd, bool useBackgroundCloudOcclusion, bool volumetricCloudOcclusion, bool hasCloudLayer, int _FlareCloudOpacity, int _FlareSunOcclusionTex, Texture cloudOpacityTexture, Texture sunOcclusionTexture)
		{
			if (useBackgroundCloudOcclusion && hasCloudLayer)
			{
				cmd.EnableShaderKeyword("FLARE_CLOUD_BACKGROUND_OCCLUSION");
				cmd.SetGlobalTexture(_FlareCloudOpacity, cloudOpacityTexture);
			}
			else
			{
				cmd.DisableShaderKeyword("FLARE_CLOUD_BACKGROUND_OCCLUSION");
			}
			if (sunOcclusionTexture != null)
			{
				if (volumetricCloudOcclusion)
				{
					cmd.EnableShaderKeyword("FLARE_VOLUMETRIC_CLOUD_OCCLUSION");
					cmd.SetGlobalTexture(_FlareSunOcclusionTex, sunOcclusionTexture);
				}
				else
				{
					cmd.DisableShaderKeyword("FLARE_VOLUMETRIC_CLOUD_OCCLUSION");
				}
			}
			else
			{
				cmd.DisableShaderKeyword("FLARE_VOLUMETRIC_CLOUD_OCCLUSION");
			}
		}

		public static void ComputeOcclusion(Material lensFlareShader, Camera cam, float actualWidth, float actualHeight, bool usePanini, float paniniDistance, float paniniCropToFit, bool isCameraRelative, Vector3 cameraPositionWS, Matrix4x4 viewProjMatrix, CommandBuffer cmd, bool taaEnabled, bool hasCloudLayer, Texture cloudOpacityTexture, Texture sunOcclusionTexture, int _FlareOcclusionTex, int _FlareCloudOpacity, int _FlareOcclusionIndex, int _FlareTex, int _FlareColorValue, int _FlareSunOcclusionTex, int _FlareData0, int _FlareData1, int _FlareData2, int _FlareData3, int _FlareData4)
		{
			if (!IsOcclusionRTCompatible() || Instance.IsEmpty())
			{
				return;
			}
			Vector2 vector = new Vector2(actualWidth, actualHeight);
			float x = vector.x / vector.y;
			Vector2 vLocalScreenRatio = new Vector2(x, 1f);
			CoreUtils.SetRenderTarget(cmd, occlusionRT);
			if (!taaEnabled)
			{
				cmd.ClearRenderTarget(clearDepth: false, clearColor: true, Color.black);
			}
			_ = 1f / (float)maxLensFlareWithOcclusion;
			_ = 1f / (float)(maxLensFlareWithOcclusionTemporalSample + mergeNeeded);
			_ = 0.5f / (float)maxLensFlareWithOcclusion;
			_ = 0.5f / (float)(maxLensFlareWithOcclusionTemporalSample + mergeNeeded);
			int num = (taaEnabled ? 1 : 0);
			foreach (LensFlareCompInfo datum in m_Data)
			{
				if (datum == null || datum.comp == null)
				{
					continue;
				}
				LensFlareComponentSRP comp = datum.comp;
				LensFlareDataSRP lensFlareData = comp.lensFlareData;
				if (IsLensFlareSRPHidden(cam, comp, lensFlareData) || !comp.useOcclusion || (comp.useOcclusion && comp.sampleCount == 0))
				{
					continue;
				}
				Light component = comp.GetComponent<Light>();
				bool flag = false;
				Vector3 vector2;
				if (component != null && component.type == LightType.Directional)
				{
					vector2 = -component.transform.forward * cam.farClipPlane;
					flag = true;
				}
				else
				{
					vector2 = comp.transform.position;
				}
				Vector3 vector3 = WorldToViewport(cam, !flag, isCameraRelative, viewProjMatrix, vector2);
				if (usePanini && cam == Camera.main)
				{
					vector3 = DoPaniniProjection(vector3, actualWidth, actualHeight, cam.fieldOfView, paniniCropToFit, paniniDistance);
				}
				if (vector3.z < 0f || (!comp.allowOffScreen && (vector3.x < 0f || vector3.x > 1f || vector3.y < 0f || vector3.y > 1f)))
				{
					continue;
				}
				Vector3 rhs = vector2 - cameraPositionWS;
				if (!(Vector3.Dot(cam.transform.forward, rhs) < 0f))
				{
					float magnitude = rhs.magnitude;
					float time = magnitude / comp.maxAttenuationDistance;
					float time2 = magnitude / comp.maxAttenuationScale;
					float num2 = ((!flag && comp.distanceAttenuationCurve.length > 0) ? comp.distanceAttenuationCurve.Evaluate(time) : 1f);
					if (!flag && comp.scaleByDistanceCurve.length >= 1)
					{
						comp.scaleByDistanceCurve.Evaluate(time2);
					}
					Vector3 vector4 = ((!flag) ? (cam.transform.position - comp.transform.position).normalized : comp.transform.forward);
					Vector3 vector5 = WorldToViewport(cam, !flag, isCameraRelative, viewProjMatrix, vector2 + vector4 * comp.occlusionOffset);
					float num3 = (flag ? comp.celestialProjectedOcclusionRadius(cam) : comp.occlusionRadius);
					Vector2 vector6 = vector3;
					float magnitude2 = ((Vector2)WorldToViewport(cam, !flag, isCameraRelative, viewProjMatrix, vector2 + cam.transform.up * num3) - vector6).magnitude;
					cmd.SetGlobalVector(_FlareData1, new Vector4(magnitude2, comp.sampleCount, vector5.z, actualHeight / actualWidth));
					SetOcclusionPermutation(cmd, comp.useBackgroundCloudOcclusion, comp.volumetricCloudOcclusion, hasCloudLayer, _FlareCloudOpacity, _FlareSunOcclusionTex, cloudOpacityTexture, sunOcclusionTexture);
					cmd.EnableShaderKeyword("FLARE_COMPUTE_OCCLUSION");
					Vector2 screenPos = new Vector2(2f * vector3.x - 1f, 2f * vector3.y - 1f);
					if (SystemInfo.graphicsUVStartsAtTop)
					{
						screenPos.y = 0f - screenPos.y;
					}
					Vector2 vector7 = new Vector2(Mathf.Abs(screenPos.x), Mathf.Abs(screenPos.y));
					float time3 = Mathf.Max(vector7.x, vector7.y);
					float num4 = ((comp.radialScreenAttenuationCurve.length > 0) ? comp.radialScreenAttenuationCurve.Evaluate(time3) : 1f);
					if (!(comp.intensity * num4 * num2 <= 0f))
					{
						float globalCos = Mathf.Cos(0f);
						float globalSin = Mathf.Sin(0f);
						float position = 0f;
						float y = Mathf.Clamp01(0.999999f);
						cmd.SetGlobalVector(_FlareData3, new Vector4(comp.allowOffScreen ? 1f : (-1f), y, Mathf.Exp(Mathf.Lerp(0f, 4f, 1f)), 1f / 3f));
						Vector2 lensFlareRayOffset = GetLensFlareRayOffset(screenPos, position, globalCos, globalSin);
						Vector4 flareData = GetFlareData0(screenPos, Vector2.one, lensFlareRayOffset, vLocalScreenRatio, 0f, position, 0f, Vector2.zero, autoRotate: false);
						cmd.SetGlobalVector(_FlareData0, flareData);
						cmd.SetGlobalVector(_FlareData2, new Vector4(screenPos.x, screenPos.y, 0f, 0f));
						Rect viewport = new Rect
						{
							x = datum.index,
							y = (frameIdx + mergeNeeded) * num,
							width = 1f,
							height = 1f
						};
						cmd.SetViewport(viewport);
						Blitter.DrawQuad(cmd, lensFlareShader, 4);
					}
				}
			}
			if (taaEnabled)
			{
				cmd.SetRenderTarget(occlusionRT);
				cmd.SetViewport(new Rect
				{
					x = m_Data.Count,
					y = 0f,
					width = maxLensFlareWithOcclusion - m_Data.Count,
					height = maxLensFlareWithOcclusionTemporalSample + mergeNeeded
				});
				cmd.ClearRenderTarget(clearDepth: false, clearColor: true, Color.black);
			}
			frameIdx++;
			frameIdx %= maxLensFlareWithOcclusionTemporalSample;
		}

		public static void DoLensFlareDataDrivenCommon(Material lensFlareShader, Camera cam, float actualWidth, float actualHeight, bool usePanini, float paniniDistance, float paniniCropToFit, bool isCameraRelative, Vector3 cameraPositionWS, Matrix4x4 viewProjMatrix, CommandBuffer cmd, bool taaEnabled, bool hasCloudLayer, Texture cloudOpacityTexture, Texture sunOcclusionTexture, RenderTargetIdentifier colorBuffer, Func<Light, Camera, Vector3, float> GetLensFlareLightAttenuation, int _FlareOcclusionRemapTex, int _FlareOcclusionTex, int _FlareOcclusionIndex, int _FlareCloudOpacity, int _FlareSunOcclusionTex, int _FlareTex, int _FlareColorValue, int _FlareData0, int _FlareData1, int _FlareData2, int _FlareData3, int _FlareData4, bool debugView)
		{
			if (Instance.IsEmpty())
			{
				return;
			}
			Vector2 vector = new Vector2(actualWidth, actualHeight);
			float x = vector.x / vector.y;
			Vector2 vLocalScreenRatio = new Vector2(x, 1f);
			CoreUtils.SetRenderTarget(cmd, colorBuffer);
			cmd.SetViewport(new Rect
			{
				width = vector.x,
				height = vector.y
			});
			if (debugView)
			{
				cmd.ClearRenderTarget(clearDepth: false, clearColor: true, Color.black);
			}
			foreach (LensFlareCompInfo datum in m_Data)
			{
				if (datum == null || datum.comp == null)
				{
					continue;
				}
				LensFlareComponentSRP comp = datum.comp;
				LensFlareDataSRP lensFlareData = comp.lensFlareData;
				if (IsLensFlareSRPHidden(cam, comp, lensFlareData))
				{
					continue;
				}
				Light component = comp.GetComponent<Light>();
				bool flag = false;
				Vector3 vector2;
				if (component != null && component.type == LightType.Directional)
				{
					vector2 = -component.transform.forward * cam.farClipPlane;
					flag = true;
				}
				else
				{
					vector2 = comp.transform.position;
				}
				Vector3 vector3 = WorldToViewport(cam, !flag, isCameraRelative, viewProjMatrix, vector2);
				if (usePanini && cam == Camera.main)
				{
					vector3 = DoPaniniProjection(vector3, actualWidth, actualHeight, cam.fieldOfView, paniniCropToFit, paniniDistance);
				}
				if (vector3.z < 0f || (!comp.allowOffScreen && (vector3.x < 0f || vector3.x > 1f || vector3.y < 0f || vector3.y > 1f)))
				{
					continue;
				}
				Vector3 rhs = vector2 - cameraPositionWS;
				if (Vector3.Dot(cam.transform.forward, rhs) < 0f)
				{
					continue;
				}
				float magnitude = rhs.magnitude;
				float time = magnitude / comp.maxAttenuationDistance;
				float time2 = magnitude / comp.maxAttenuationScale;
				float num = ((!flag && comp.distanceAttenuationCurve.length > 0) ? comp.distanceAttenuationCurve.Evaluate(time) : 1f);
				float num2 = ((!flag && comp.scaleByDistanceCurve.length >= 1) ? comp.scaleByDistanceCurve.Evaluate(time2) : 1f);
				Color white = Color.white;
				if (component != null && comp.attenuationByLightShape)
				{
					white *= GetLensFlareLightAttenuation(component, cam, -rhs.normalized);
				}
				Vector2 screenPos = new Vector2(2f * vector3.x - 1f, 0f - (2f * vector3.y - 1f));
				if (!SystemInfo.graphicsUVStartsAtTop && flag)
				{
					screenPos.y = 0f - screenPos.y;
				}
				Vector2 vector4 = new Vector2(Mathf.Abs(screenPos.x), Mathf.Abs(screenPos.y));
				float time3 = Mathf.Max(vector4.x, vector4.y);
				float num3 = ((comp.radialScreenAttenuationCurve.length > 0) ? comp.radialScreenAttenuationCurve.Evaluate(time3) : 1f);
				float num4 = comp.intensity * num3 * num;
				if (num4 <= 0f)
				{
					continue;
				}
				white *= num;
				Vector3 normalized = (cam.transform.position - comp.transform.position).normalized;
				Vector3 vector5 = WorldToViewport(cam, !flag, isCameraRelative, viewProjMatrix, vector2 + normalized * comp.occlusionOffset);
				float num5 = (flag ? comp.celestialProjectedOcclusionRadius(cam) : comp.occlusionRadius);
				Vector2 vector6 = vector3;
				float magnitude2 = ((Vector2)WorldToViewport(cam, !flag, isCameraRelative, viewProjMatrix, vector2 + cam.transform.up * num5) - vector6).magnitude;
				cmd.SetGlobalVector(_FlareData1, new Vector4(magnitude2, comp.sampleCount, vector5.z, actualHeight / actualWidth));
				if (comp.useOcclusion)
				{
					cmd.SetGlobalTexture(_FlareOcclusionTex, occlusionRT);
					cmd.EnableShaderKeyword("FLARE_HAS_OCCLUSION");
				}
				else
				{
					cmd.DisableShaderKeyword("FLARE_HAS_OCCLUSION");
				}
				if (IsOcclusionRTCompatible())
				{
					cmd.DisableShaderKeyword("FLARE_OPENGL3_OR_OPENGLCORE");
				}
				else
				{
					cmd.EnableShaderKeyword("FLARE_OPENGL3_OR_OPENGLCORE");
				}
				cmd.SetGlobalVector(_FlareOcclusionIndex, new Vector4(datum.index, 0f, 0f, 0f));
				cmd.SetGlobalTexture(_FlareOcclusionRemapTex, comp.occlusionRemapCurve.GetTexture());
				LensFlareDataElementSRP[] elements = lensFlareData.elements;
				foreach (LensFlareDataElementSRP element in elements)
				{
					if (element == null || !element.visible || (element.lensFlareTexture == null && element.flareType == SRPLensFlareType.Image) || element.localIntensity <= 0f || element.count <= 0 || element.localIntensity <= 0f)
					{
						continue;
					}
					Color color = white;
					if (component != null && element.modulateByLightColor)
					{
						if (component.useColorTemperature)
						{
							color *= component.color * Mathf.CorrelatedColorTemperatureToRGB(component.colorTemperature);
						}
						else
						{
							color *= component.color;
						}
					}
					Color color2 = color;
					float num6 = element.localIntensity * num4;
					if (num6 <= 0f)
					{
						continue;
					}
					Texture lensFlareTexture = element.lensFlareTexture;
					float usedAspectRatio;
					if (element.flareType == SRPLensFlareType.Image)
					{
						usedAspectRatio = (element.preserveAspectRatio ? ((float)lensFlareTexture.height / (float)lensFlareTexture.width) : 1f);
					}
					else
					{
						usedAspectRatio = 1f;
					}
					float rotation = element.rotation;
					Vector2 vector7 = ((!element.preserveAspectRatio) ? new Vector2(element.sizeXY.x, element.sizeXY.y) : ((!(usedAspectRatio >= 1f)) ? new Vector2(element.sizeXY.x, element.sizeXY.y * usedAspectRatio) : new Vector2(element.sizeXY.x / usedAspectRatio, element.sizeXY.y)));
					float num7 = 0.1f;
					Vector2 vector8 = new Vector2(vector7.x, vector7.y);
					float combinedScale = num2 * num7 * element.uniformScale * comp.scale;
					vector8 *= combinedScale;
					color2 *= element.tint;
					color2 *= num6;
					float num8 = (SystemInfo.graphicsUVStartsAtTop ? element.angularOffset : (0f - element.angularOffset));
					float globalCos0 = Mathf.Cos((0f - num8) * (MathF.PI / 180f));
					float globalSin0 = Mathf.Sin((0f - num8) * (MathF.PI / 180f));
					float position = 2f * element.position;
					int shaderPass = element.blendMode switch
					{
						SRPLensFlareBlendMode.Additive => 0, 
						SRPLensFlareBlendMode.Screen => 1, 
						SRPLensFlareBlendMode.Premultiply => 2, 
						SRPLensFlareBlendMode.Lerp => 3, 
						_ => 0, 
					};
					if (element.flareType == SRPLensFlareType.Image)
					{
						cmd.DisableShaderKeyword("FLARE_CIRCLE");
						cmd.DisableShaderKeyword("FLARE_POLYGON");
					}
					else if (element.flareType == SRPLensFlareType.Circle)
					{
						cmd.EnableShaderKeyword("FLARE_CIRCLE");
						cmd.DisableShaderKeyword("FLARE_POLYGON");
					}
					else if (element.flareType == SRPLensFlareType.Polygon)
					{
						cmd.DisableShaderKeyword("FLARE_CIRCLE");
						cmd.EnableShaderKeyword("FLARE_POLYGON");
					}
					if (element.flareType == SRPLensFlareType.Circle || element.flareType == SRPLensFlareType.Polygon)
					{
						if (element.inverseSDF)
						{
							cmd.EnableShaderKeyword("FLARE_INVERSE_SDF");
						}
						else
						{
							cmd.DisableShaderKeyword("FLARE_INVERSE_SDF");
						}
					}
					else
					{
						cmd.DisableShaderKeyword("FLARE_INVERSE_SDF");
					}
					if (element.lensFlareTexture != null)
					{
						cmd.SetGlobalTexture(_FlareTex, element.lensFlareTexture);
					}
					float num9 = Mathf.Clamp01(1f - element.edgeOffset - 1E-06f);
					if (element.flareType == SRPLensFlareType.Polygon)
					{
						num9 = Mathf.Pow(num9 + 1f, 5f);
					}
					float sdfRoundness = element.sdfRoundness;
					cmd.SetGlobalVector(_FlareData3, new Vector4(comp.allowOffScreen ? 1f : (-1f), num9, Mathf.Exp(Mathf.Lerp(0f, 4f, Mathf.Clamp01(1f - element.fallOff))), 1f / (float)element.sideCount));
					if (element.flareType == SRPLensFlareType.Polygon)
					{
						float num10 = 1f / (float)element.sideCount;
						float num11 = Mathf.Cos(MathF.PI * num10);
						float num12 = num11 * sdfRoundness;
						float num13 = num11 - num12;
						float num14 = MathF.PI * 2f * num10;
						float w = num13 * Mathf.Tan(0.5f * num14);
						cmd.SetGlobalVector(_FlareData4, new Vector4(sdfRoundness, num13, num14, w));
					}
					else
					{
						cmd.SetGlobalVector(_FlareData4, new Vector4(sdfRoundness, 0f, 0f, 0f));
					}
					if (!element.allowMultipleElement || element.count == 1)
					{
						Vector2 curSize = vector8;
						Vector2 lensFlareRayOffset = GetLensFlareRayOffset(screenPos, position, globalCos0, globalSin0);
						if (element.enableRadialDistortion)
						{
							Vector2 lensFlareRayOffset2 = GetLensFlareRayOffset(screenPos, 0f, globalCos0, globalSin0);
							curSize = ComputeLocalSize(lensFlareRayOffset, lensFlareRayOffset2, curSize, element.distortionCurve);
						}
						Vector4 flareData = GetFlareData0(screenPos, element.translationScale, lensFlareRayOffset, vLocalScreenRatio, rotation, position, num8, element.positionOffset, element.autoRotate);
						cmd.SetGlobalVector(_FlareData0, flareData);
						cmd.SetGlobalVector(_FlareData2, new Vector4(screenPos.x, screenPos.y, curSize.x, curSize.y));
						cmd.SetGlobalVector(_FlareColorValue, color2);
						Blitter.DrawQuad(cmd, lensFlareShader, shaderPass);
						continue;
					}
					float num15 = 2f * element.lengthSpread / (float)(element.count - 1);
					if (element.distribution == SRPLensFlareDistribution.Uniform)
					{
						float num16 = 0f;
						for (int j = 0; j < element.count; j++)
						{
							Vector2 curSize2 = vector8;
							Vector2 lensFlareRayOffset3 = GetLensFlareRayOffset(screenPos, position, globalCos0, globalSin0);
							if (element.enableRadialDistortion)
							{
								Vector2 lensFlareRayOffset4 = GetLensFlareRayOffset(screenPos, 0f, globalCos0, globalSin0);
								curSize2 = ComputeLocalSize(lensFlareRayOffset3, lensFlareRayOffset4, curSize2, element.distortionCurve);
							}
							float time4 = ((element.count >= 2) ? ((float)j / (float)(element.count - 1)) : 0.5f);
							Color color3 = element.colorGradient.Evaluate(time4);
							Vector4 flareData2 = GetFlareData0(screenPos, element.translationScale, lensFlareRayOffset3, vLocalScreenRatio, rotation + num16, position, num8, element.positionOffset, element.autoRotate);
							cmd.SetGlobalVector(_FlareData0, flareData2);
							cmd.SetGlobalVector(_FlareData2, new Vector4(screenPos.x, screenPos.y, curSize2.x, curSize2.y));
							cmd.SetGlobalVector(_FlareColorValue, color2 * color3);
							Blitter.DrawQuad(cmd, lensFlareShader, shaderPass);
							position += num15;
							num16 += element.uniformAngle;
						}
					}
					else if (element.distribution == SRPLensFlareDistribution.Random)
					{
						Random.State state = Random.state;
						Random.InitState(element.seed);
						Vector2 vector9 = new Vector2(globalSin0, globalCos0);
						vector9 *= element.positionVariation.y;
						for (int k = 0; k < element.count; k++)
						{
							float num17 = RandomRange(-1f, 1f) * element.intensityVariation + 1f;
							Vector2 lensFlareRayOffset5 = GetLensFlareRayOffset(screenPos, position, globalCos0, globalSin0);
							Vector2 vector10 = vector8;
							if (element.enableRadialDistortion)
							{
								Vector2 lensFlareRayOffset6 = GetLensFlareRayOffset(screenPos, 0f, globalCos0, globalSin0);
								vector10 = ComputeLocalSize(lensFlareRayOffset5, lensFlareRayOffset6, vector10, element.distortionCurve);
							}
							vector10 += vector10 * (element.scaleVariation * RandomRange(-1f, 1f));
							Color color4 = element.colorGradient.Evaluate(RandomRange(0f, 1f));
							Vector2 positionOffset = element.positionOffset + RandomRange(-1f, 1f) * vector9;
							float angleDeg = rotation + RandomRange(-MathF.PI, MathF.PI) * element.rotationVariation;
							if (num17 > 0f)
							{
								Vector4 flareData3 = GetFlareData0(screenPos, element.translationScale, lensFlareRayOffset5, vLocalScreenRatio, angleDeg, position, num8, positionOffset, element.autoRotate);
								cmd.SetGlobalVector(_FlareData0, flareData3);
								cmd.SetGlobalVector(_FlareData2, new Vector4(screenPos.x, screenPos.y, vector10.x, vector10.y));
								cmd.SetGlobalVector(_FlareColorValue, color2 * color4 * num17);
								Blitter.DrawQuad(cmd, lensFlareShader, shaderPass);
							}
							position += num15;
							position += 0.5f * num15 * RandomRange(-1f, 1f) * element.positionVariation.x;
						}
						Random.state = state;
					}
					else
					{
						if (element.distribution != SRPLensFlareDistribution.Curve)
						{
							continue;
						}
						for (int l = 0; l < element.count; l++)
						{
							float time5 = ((element.count >= 2) ? ((float)l / (float)(element.count - 1)) : 0.5f);
							Color color5 = element.colorGradient.Evaluate(time5);
							float num18 = ((element.positionCurve.length > 0) ? element.positionCurve.Evaluate(time5) : 1f);
							float position2 = position + 2f * element.lengthSpread * num18;
							Vector2 lensFlareRayOffset7 = GetLensFlareRayOffset(screenPos, position2, globalCos0, globalSin0);
							Vector2 curSize3 = vector8;
							if (element.enableRadialDistortion)
							{
								Vector2 lensFlareRayOffset8 = GetLensFlareRayOffset(screenPos, 0f, globalCos0, globalSin0);
								curSize3 = ComputeLocalSize(lensFlareRayOffset7, lensFlareRayOffset8, curSize3, element.distortionCurve);
							}
							float num19 = ((element.scaleCurve.length > 0) ? element.scaleCurve.Evaluate(time5) : 1f);
							curSize3 *= num19;
							float num20 = element.uniformAngleCurve.Evaluate(time5) * (180f - 180f / (float)element.count);
							Vector4 flareData4 = GetFlareData0(screenPos, element.translationScale, lensFlareRayOffset7, vLocalScreenRatio, rotation + num20, position2, num8, element.positionOffset, element.autoRotate);
							cmd.SetGlobalVector(_FlareData0, flareData4);
							cmd.SetGlobalVector(_FlareData2, new Vector4(screenPos.x, screenPos.y, curSize3.x, curSize3.y));
							cmd.SetGlobalVector(_FlareColorValue, color2 * color5);
							Blitter.DrawQuad(cmd, lensFlareShader, shaderPass);
						}
					}
					Vector2 ComputeLocalSize(Vector2 rayOff, Vector2 rayOff0, Vector2 vector12, AnimationCurve distortionCurve)
					{
						GetLensFlareRayOffset(screenPos, position, globalCos0, globalSin0);
						float time6;
						if (!element.distortionRelativeToCenter)
						{
							Vector2 vector11 = (rayOff - rayOff0) * 0.5f;
							time6 = Mathf.Clamp01(Mathf.Max(Mathf.Abs(vector11.x), Mathf.Abs(vector11.y)));
						}
						else
						{
							time6 = Mathf.Clamp01((screenPos + (rayOff + new Vector2(element.positionOffset.x, 0f - element.positionOffset.y)) * element.translationScale).magnitude);
						}
						float t = Mathf.Clamp01(distortionCurve.Evaluate(time6));
						return new Vector2(Mathf.Lerp(vector12.x, element.targetSizeDistortion.x * combinedScale / usedAspectRatio, t), Mathf.Lerp(vector12.y, element.targetSizeDistortion.y * combinedScale, t));
					}
				}
			}
			static float RandomRange(float min, float max)
			{
				return Random.Range(min, max);
			}
		}

		private static Vector2 DoPaniniProjection(Vector2 screenPos, float actualWidth, float actualHeight, float fieldOfView, float paniniProjectionCropToFit, float paniniProjectionDistance)
		{
			Vector2 vector = CalcViewExtents(actualWidth, actualHeight, fieldOfView);
			Vector2 vector2 = CalcCropExtents(actualWidth, actualHeight, fieldOfView, paniniProjectionDistance);
			float a = vector2.x / vector.x;
			float b = vector2.y / vector.y;
			float value = Mathf.Min(a, b);
			float num = Mathf.Lerp(1f, Mathf.Clamp01(value), paniniProjectionCropToFit);
			Vector2 vector3 = Panini_Generic_Inv(new Vector2(2f * screenPos.x - 1f, 2f * screenPos.y - 1f) * vector, paniniProjectionDistance) / (vector * num);
			return new Vector2(0.5f * vector3.x + 0.5f, 0.5f * vector3.y + 0.5f);
		}

		private static Vector2 CalcViewExtents(float actualWidth, float actualHeight, float fieldOfView)
		{
			float num = fieldOfView * (MathF.PI / 180f);
			float num2 = actualWidth / actualHeight;
			float num3 = Mathf.Tan(0.5f * num);
			return new Vector2(num2 * num3, num3);
		}

		private static Vector2 CalcCropExtents(float actualWidth, float actualHeight, float fieldOfView, float d)
		{
			float num = 1f + d;
			Vector2 vector = CalcViewExtents(actualWidth, actualHeight, fieldOfView);
			float num2 = Mathf.Sqrt(vector.x * vector.x + 1f);
			float num3 = 1f / num2;
			float num4 = num3 + d;
			return vector * num3 * (num / num4);
		}

		private static Vector2 Panini_Generic_Inv(Vector2 projPos, float d)
		{
			float num = 1f + d;
			float num2 = Mathf.Sqrt(projPos.x * projPos.x + 1f);
			float num3 = 1f / num2;
			float num4 = num3 + d;
			return projPos * num3 * (num / num4);
		}
	}
	[ExecuteAlways]
	[AddComponentMenu("Rendering/Lens Flare (SRP)")]
	public sealed class LensFlareComponentSRP : MonoBehaviour
	{
		[SerializeField]
		private LensFlareDataSRP m_LensFlareData;

		[Min(0f)]
		public float intensity = 1f;

		[Min(1E-05f)]
		public float maxAttenuationDistance = 100f;

		[Min(1E-05f)]
		public float maxAttenuationScale = 100f;

		public AnimationCurve distanceAttenuationCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 0f));

		public AnimationCurve scaleByDistanceCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 0f));

		public bool attenuationByLightShape = true;

		public AnimationCurve radialScreenAttenuationCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		public bool useOcclusion;

		[Min(0f)]
		public float occlusionRadius = 0.1f;

		public bool useBackgroundCloudOcclusion;

		[Range(1f, 64f)]
		public uint sampleCount = 32u;

		public float occlusionOffset = 0.05f;

		[Min(0f)]
		public float scale = 1f;

		public bool allowOffScreen;

		public bool volumetricCloudOcclusion;

		private static float sCelestialAngularRadius = 0.057595868f;

		public TextureCurve occlusionRemapCurve = new TextureCurve(AnimationCurve.Linear(0f, 0f, 1f, 1f), 1f, loop: false, new Vector2(0f, 1f));

		public LensFlareDataSRP lensFlareData
		{
			get
			{
				return m_LensFlareData;
			}
			set
			{
				m_LensFlareData = value;
				OnValidate();
			}
		}

		public float celestialProjectedOcclusionRadius(Camera mainCam)
		{
			float num = (float)Math.Tan(sCelestialAngularRadius) * mainCam.farClipPlane;
			return occlusionRadius * num;
		}

		private void OnEnable()
		{
			if ((bool)lensFlareData)
			{
				LensFlareCommonSRP.Instance.AddData(this);
			}
			else
			{
				LensFlareCommonSRP.Instance.RemoveData(this);
			}
		}

		private void OnDisable()
		{
			LensFlareCommonSRP.Instance.RemoveData(this);
		}

		private void OnValidate()
		{
			if (base.isActiveAndEnabled && lensFlareData != null)
			{
				LensFlareCommonSRP.Instance.AddData(this);
			}
			else
			{
				LensFlareCommonSRP.Instance.RemoveData(this);
			}
		}
	}
	[Serializable]
	public enum SRPLensFlareBlendMode
	{
		Additive,
		Screen,
		Premultiply,
		Lerp
	}
	[Serializable]
	public enum SRPLensFlareDistribution
	{
		Uniform,
		Curve,
		Random
	}
	[Serializable]
	public enum SRPLensFlareType
	{
		Image,
		Circle,
		Polygon
	}
	[Serializable]
	public sealed class LensFlareDataElementSRP
	{
		public bool visible;

		public float position;

		public Vector2 positionOffset;

		public float angularOffset;

		public Vector2 translationScale;

		[Min(0f)]
		[SerializeField]
		[FormerlySerializedAs("localIntensity")]
		private float m_LocalIntensity;

		public Texture lensFlareTexture;

		public float uniformScale;

		public Vector2 sizeXY;

		public bool allowMultipleElement;

		[Min(1f)]
		[SerializeField]
		[FormerlySerializedAs("count")]
		private int m_Count;

		public bool preserveAspectRatio;

		public float rotation;

		public Color tint;

		public SRPLensFlareBlendMode blendMode;

		public bool autoRotate;

		public SRPLensFlareType flareType;

		public bool modulateByLightColor;

		[SerializeField]
		private bool isFoldOpened;

		public SRPLensFlareDistribution distribution;

		public float lengthSpread;

		public AnimationCurve positionCurve;

		public AnimationCurve scaleCurve;

		public int seed;

		public Gradient colorGradient;

		[Range(0f, 1f)]
		[SerializeField]
		[FormerlySerializedAs("intensityVariation")]
		private float m_IntensityVariation;

		public Vector2 positionVariation;

		public float scaleVariation;

		public float rotationVariation;

		public bool enableRadialDistortion;

		public Vector2 targetSizeDistortion;

		public AnimationCurve distortionCurve;

		public bool distortionRelativeToCenter;

		[Range(0f, 1f)]
		[SerializeField]
		[FormerlySerializedAs("fallOff")]
		private float m_FallOff;

		[Range(0f, 1f)]
		[SerializeField]
		[FormerlySerializedAs("edgeOffset")]
		private float m_EdgeOffset;

		[Min(3f)]
		[SerializeField]
		[FormerlySerializedAs("sideCount")]
		private int m_SideCount;

		[Range(0f, 1f)]
		[SerializeField]
		[FormerlySerializedAs("sdfRoundness")]
		private float m_SdfRoundness;

		public bool inverseSDF;

		public float uniformAngle;

		public AnimationCurve uniformAngleCurve;

		public float localIntensity
		{
			get
			{
				return m_LocalIntensity;
			}
			set
			{
				m_LocalIntensity = Mathf.Max(0f, value);
			}
		}

		public int count
		{
			get
			{
				return m_Count;
			}
			set
			{
				m_Count = Mathf.Max(1, value);
			}
		}

		public float intensityVariation
		{
			get
			{
				return m_IntensityVariation;
			}
			set
			{
				m_IntensityVariation = Mathf.Max(0f, value);
			}
		}

		public float fallOff
		{
			get
			{
				return m_FallOff;
			}
			set
			{
				m_FallOff = Mathf.Clamp01(value);
			}
		}

		public float edgeOffset
		{
			get
			{
				return m_EdgeOffset;
			}
			set
			{
				m_EdgeOffset = Mathf.Clamp01(value);
			}
		}

		public int sideCount
		{
			get
			{
				return m_SideCount;
			}
			set
			{
				m_SideCount = Mathf.Max(3, value);
			}
		}

		public float sdfRoundness
		{
			get
			{
				return m_SdfRoundness;
			}
			set
			{
				m_SdfRoundness = Mathf.Clamp01(value);
			}
		}

		public LensFlareDataElementSRP()
		{
			visible = true;
			localIntensity = 1f;
			position = 0f;
			positionOffset = new Vector2(0f, 0f);
			angularOffset = 0f;
			translationScale = new Vector2(1f, 1f);
			lensFlareTexture = null;
			uniformScale = 1f;
			sizeXY = Vector2.one;
			allowMultipleElement = false;
			count = 5;
			rotation = 0f;
			tint = new Color(1f, 1f, 1f, 0.5f);
			blendMode = SRPLensFlareBlendMode.Additive;
			autoRotate = false;
			isFoldOpened = true;
			flareType = SRPLensFlareType.Circle;
			distribution = SRPLensFlareDistribution.Uniform;
			lengthSpread = 1f;
			colorGradient = new Gradient();
			colorGradient.SetKeys(new GradientColorKey[2]
			{
				new GradientColorKey(Color.white, 0f),
				new GradientColorKey(Color.white, 1f)
			}, new GradientAlphaKey[2]
			{
				new GradientAlphaKey(1f, 0f),
				new GradientAlphaKey(1f, 1f)
			});
			positionCurve = new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, -1f));
			scaleCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			uniformAngleCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 0f));
			seed = 0;
			intensityVariation = 0.75f;
			positionVariation = new Vector2(1f, 0f);
			scaleVariation = 1f;
			rotationVariation = 180f;
			enableRadialDistortion = false;
			targetSizeDistortion = Vector2.one;
			distortionCurve = new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, -1f));
			distortionRelativeToCenter = false;
			fallOff = 1f;
			edgeOffset = 0.1f;
			sdfRoundness = 0f;
			sideCount = 6;
			inverseSDF = false;
		}
	}
	[Serializable]
	public sealed class LensFlareDataSRP : ScriptableObject
	{
		public LensFlareDataElementSRP[] elements;

		public LensFlareDataSRP()
		{
			elements = null;
		}
	}
	public interface ICloudBackground
	{
		bool IsCloudBackgroundUsable();
	}
	public enum ShaderVariantLogLevel
	{
		[Tooltip("No shader variants are logged")]
		Disabled,
		[Tooltip("Only shaders that are compatible with SRPs (e.g., URP, HDRP) are logged")]
		OnlySRPShaders,
		[Tooltip("All shader variants are logged")]
		AllShaders
	}
	public interface IShaderVariantSettings
	{
		ShaderVariantLogLevel shaderVariantLogLevel { get; set; }

		bool exportShaderVariants { get; set; }
	}
	public interface IVolumetricCloud
	{
		bool IsVolumetricCloudUsable();
	}
	public abstract class RenderPipelineResources : ScriptableObject
	{
		protected virtual string packagePath => null;

		internal string packagePath_Internal => packagePath;
	}
	public enum PackingRules
	{
		Exact,
		Aggressive
	}
	public enum FieldPacking
	{
		NoPacking,
		R11G11B10,
		PackedFloat,
		PackedUint
	}
	public enum FieldPrecision
	{
		Half,
		Real,
		Default
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum)]
	public class GenerateHLSL : Attribute
	{
		public PackingRules packingRules;

		public bool containsPackedFields;

		public bool needAccessors;

		public bool needSetters;

		public bool needParamDebug;

		public int paramDefinesStart;

		public bool omitStructDeclaration;

		public bool generateCBuffer;

		public int constantRegister;

		public string sourcePath;

		public GenerateHLSL(PackingRules rules = PackingRules.Exact, bool needAccessors = true, bool needSetters = false, bool needParamDebug = false, int paramDefinesStart = 1, bool omitStructDeclaration = false, bool containsPackedFields = false, bool generateCBuffer = false, int constantRegister = -1, [CallerFilePath] string sourcePath = null)
		{
			this.sourcePath = sourcePath;
			packingRules = rules;
			this.needAccessors = needAccessors;
			this.needSetters = needSetters;
			this.needParamDebug = needParamDebug;
			this.paramDefinesStart = paramDefinesStart;
			this.omitStructDeclaration = omitStructDeclaration;
			this.containsPackedFields = containsPackedFields;
			this.generateCBuffer = generateCBuffer;
			this.constantRegister = constantRegister;
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	public class SurfaceDataAttributes : Attribute
	{
		public string[] displayNames;

		public bool isDirection;

		public bool sRGBDisplay;

		public FieldPrecision precision;

		public bool checkIsNormalized;

		public string preprocessor;

		public SurfaceDataAttributes(string displayName = "", bool isDirection = false, bool sRGBDisplay = false, FieldPrecision precision = FieldPrecision.Default, bool checkIsNormalized = false, string preprocessor = "")
		{
			displayNames = new string[1];
			displayNames[0] = displayName;
			this.isDirection = isDirection;
			this.sRGBDisplay = sRGBDisplay;
			this.precision = precision;
			this.checkIsNormalized = checkIsNormalized;
			this.preprocessor = preprocessor;
		}

		public SurfaceDataAttributes(string[] displayNames, bool isDirection = false, bool sRGBDisplay = false, FieldPrecision precision = FieldPrecision.Default, bool checkIsNormalized = false, string preprocessor = "")
		{
			this.displayNames = displayNames;
			this.isDirection = isDirection;
			this.sRGBDisplay = sRGBDisplay;
			this.precision = precision;
			this.checkIsNormalized = checkIsNormalized;
			this.preprocessor = preprocessor;
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	public class HLSLArray : Attribute
	{
		public int arraySize;

		public Type elementType;

		public HLSLArray(int arraySize, Type elementType)
		{
			this.arraySize = arraySize;
			this.elementType = elementType;
		}
	}
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
	public class PackingAttribute : Attribute
	{
		public string[] displayNames;

		public float[] range;

		public FieldPacking packingScheme;

		public int offsetInSource;

		public int sizeInBits;

		public bool isDirection;

		public bool sRGBDisplay;

		public bool checkIsNormalized;

		public string preprocessor;

		public PackingAttribute(string[] displayNames, FieldPacking packingScheme = FieldPacking.NoPacking, int bitSize = 32, int offsetInSource = 0, float minValue = 0f, float maxValue = 1f, bool isDirection = false, bool sRGBDisplay = false, bool checkIsNormalized = false, string preprocessor = "")
		{
			this.displayNames = displayNames;
			this.packingScheme = packingScheme;
			this.offsetInSource = offsetInSource;
			this.isDirection = isDirection;
			this.sRGBDisplay = sRGBDisplay;
			this.checkIsNormalized = checkIsNormalized;
			sizeInBits = bitSize;
			range = new float[2] { minValue, maxValue };
			this.preprocessor = preprocessor;
		}

		public PackingAttribute(string displayName = "", FieldPacking packingScheme = FieldPacking.NoPacking, int bitSize = 0, int offsetInSource = 0, float minValue = 0f, float maxValue = 1f, bool isDirection = false, bool sRGBDisplay = false, bool checkIsNormalized = false, string preprocessor = "")
		{
			displayNames = new string[1];
			displayNames[0] = displayName;
			this.packingScheme = packingScheme;
			this.offsetInSource = offsetInSource;
			this.isDirection = isDirection;
			this.sRGBDisplay = sRGBDisplay;
			this.checkIsNormalized = checkIsNormalized;
			sizeInBits = bitSize;
			range = new float[2] { minValue, maxValue };
			this.preprocessor = preprocessor;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct ShaderGenUInt4
	{
	}
	internal static class Hammersley
	{
		[GenerateHLSL(PackingRules.Exact, true, false, false, 1, false, false, false, -1, ".\\Library\\PackageCache\\com.unity.render-pipelines.core@14.0.11\\Runtime\\ShaderLibrary\\Sampling\\Hammersley.cs", needAccessors = false, generateCBuffer = true)]
		private struct Hammersley2dSeq16
		{
			[HLSLArray(16, typeof(Vector4))]
			public unsafe fixed float hammersley2dSeq16[64];
		}

		[GenerateHLSL(PackingRules.Exact, true, false, false, 1, false, false, false, -1, ".\\Library\\PackageCache\\com.unity.render-pipelines.core@14.0.11\\Runtime\\ShaderLibrary\\Sampling\\Hammersley.cs", needAccessors = false, generateCBuffer = true)]
		private struct Hammersley2dSeq32
		{
			[HLSLArray(32, typeof(Vector4))]
			public unsafe fixed float hammersley2dSeq32[128];
		}

		[GenerateHLSL(PackingRules.Exact, true, false, false, 1, false, false, false, -1, ".\\Library\\PackageCache\\com.unity.render-pipelines.core@14.0.11\\Runtime\\ShaderLibrary\\Sampling\\Hammersley.cs", needAccessors = false, generateCBuffer = true)]
		private struct Hammersley2dSeq64
		{
			[HLSLArray(64, typeof(Vector4))]
			public unsafe fixed float hammersley2dSeq64[256];
		}

		[GenerateHLSL(PackingRules.Exact, true, false, false, 1, false, false, false, -1, ".\\Library\\PackageCache\\com.unity.render-pipelines.core@14.0.11\\Runtime\\ShaderLibrary\\Sampling\\Hammersley.cs", needAccessors = false, generateCBuffer = true)]
		private struct Hammersley2dSeq256
		{
			[HLSLArray(256, typeof(Vector4))]
			public unsafe fixed float hammersley2dSeq256[1024];
		}

		private static float[] k_Hammersley2dSeq16 = new float[64]
		{
			0f, 0f, 0f, 0f, 0.0625f, 0.5f, 0f, 0f, 0.125f, 0.25f,
			0f, 0f, 0.1875f, 0.75f, 0f, 0f, 0.25f, 0.125f, 0f, 0f,
			0.3125f, 0.625f, 0f, 0f, 0.375f, 0.375f, 0f, 0f, 0.4375f, 0.875f,
			0f, 0f, 0.5f, 0.0625f, 0f, 0f, 0.5625f, 0.5625f, 0f, 0f,
			0.625f, 0.3125f, 0f, 0f, 0.6875f, 0.8125f, 0f, 0f, 0.75f, 0.1875f,
			0f, 0f, 0.8125f, 0.6875f, 0f, 0f, 0.875f, 0.4375f, 0f, 0f,
			0.9375f, 0.9375f, 0f, 0f
		};

		private static float[] k_Hammersley2dSeq32 = new float[128]
		{
			0f,
			0f,
			0f,
			0f,
			1f / 32f,
			0.5f,
			0f,
			0f,
			0.0625f,
			0.25f,
			0f,
			0f,
			3f / 32f,
			0.75f,
			0f,
			0f,
			0.125f,
			0.125f,
			0f,
			0f,
			5f / 32f,
			0.625f,
			0f,
			0f,
			0.1875f,
			0.375f,
			0f,
			0f,
			7f / 32f,
			0.875f,
			0f,
			0f,
			0.25f,
			0.0625f,
			0f,
			0f,
			9f / 32f,
			0.5625f,
			0f,
			0f,
			0.3125f,
			0.3125f,
			0f,
			0f,
			11f / 32f,
			0.8125f,
			0f,
			0f,
			0.375f,
			0.1875f,
			0f,
			0f,
			13f / 32f,
			0.6875f,
			0f,
			0f,
			0.4375f,
			0.4375f,
			0f,
			0f,
			15f / 32f,
			0.9375f,
			0f,
			0f,
			0.5f,
			1f / 32f,
			0f,
			0f,
			17f / 32f,
			17f / 32f,
			0f,
			0f,
			0.5625f,
			9f / 32f,
			0f,
			0f,
			19f / 32f,
			25f / 32f,
			0f,
			0f,
			0.625f,
			5f / 32f,
			0f,
			0f,
			21f / 32f,
			21f / 32f,
			0f,
			0f,
			0.6875f,
			13f / 32f,
			0f,
			0f,
			23f / 32f,
			29f / 32f,
			0f,
			0f,
			0.75f,
			3f / 32f,
			0f,
			0f,
			25f / 32f,
			19f / 32f,
			0f,
			0f,
			0.8125f,
			11f / 32f,
			0f,
			0f,
			27f / 32f,
			27f / 32f,
			0f,
			0f,
			0.875f,
			7f / 32f,
			0f,
			0f,
			29f / 32f,
			23f / 32f,
			0f,
			0f,
			0.9375f,
			15f / 32f,
			0f,
			0f,
			31f / 32f,
			31f / 32f,
			0f,
			0f
		};

		private static float[] k_Hammersley2dSeq64 = new float[256]
		{
			0f,
			0f,
			0f,
			0f,
			1f / 64f,
			0.5f,
			0f,
			0f,
			1f / 32f,
			0.25f,
			0f,
			0f,
			3f / 64f,
			0.75f,
			0f,
			0f,
			0.0625f,
			0.125f,
			0f,
			0f,
			5f / 64f,
			0.625f,
			0f,
			0f,
			3f / 32f,
			0.375f,
			0f,
			0f,
			7f / 64f,
			0.875f,
			0f,
			0f,
			0.125f,
			0.0625f,
			0f,
			0f,
			9f / 64f,
			0.5625f,
			0f,
			0f,
			5f / 32f,
			0.3125f,
			0f,
			0f,
			11f / 64f,
			0.8125f,
			0f,
			0f,
			0.1875f,
			0.1875f,
			0f,
			0f,
			13f / 64f,
			0.6875f,
			0f,
			0f,
			7f / 32f,
			0.4375f,
			0f,
			0f,
			15f / 64f,
			0.9375f,
			0f,
			0f,
			0.25f,
			1f / 32f,
			0f,
			0f,
			17f / 64f,
			17f / 32f,
			0f,
			0f,
			9f / 32f,
			9f / 32f,
			0f,
			0f,
			19f / 64f,
			25f / 32f,
			0f,
			0f,
			0.3125f,
			5f / 32f,
			0f,
			0f,
			21f / 64f,
			21f / 32f,
			0f,
			0f,
			11f / 32f,
			13f / 32f,
			0f,
			0f,
			23f / 64f,
			29f / 32f,
			0f,
			0f,
			0.375f,
			3f / 32f,
			0f,
			0f,
			25f / 64f,
			19f / 32f,
			0f,
			0f,
			13f / 32f,
			11f / 32f,
			0f,
			0f,
			27f / 64f,
			27f / 32f,
			0f,
			0f,
			0.4375f,
			7f / 32f,
			0f,
			0f,
			29f / 64f,
			23f / 32f,
			0f,
			0f,
			15f / 32f,
			15f / 32f,
			0f,
			0f,
			31f / 64f,
			31f / 32f,
			0f,
			0f,
			0.5f,
			1f / 64f,
			0f,
			0f,
			33f / 64f,
			33f / 64f,
			0f,
			0f,
			17f / 32f,
			17f / 64f,
			0f,
			0f,
			35f / 64f,
			49f / 64f,
			0f,
			0f,
			0.5625f,
			9f / 64f,
			0f,
			0f,
			37f / 64f,
			41f / 64f,
			0f,
			0f,
			19f / 32f,
			25f / 64f,
			0f,
			0f,
			39f / 64f,
			57f / 64f,
			0f,
			0f,
			0.625f,
			5f / 64f,
			0f,
			0f,
			41f / 64f,
			37f / 64f,
			0f,
			0f,
			21f / 32f,
			21f / 64f,
			0f,
			0f,
			43f / 64f,
			53f / 64f,
			0f,
			0f,
			0.6875f,
			13f / 64f,
			0f,
			0f,
			45f / 64f,
			45f / 64f,
			0f,
			0f,
			23f / 32f,
			29f / 64f,
			0f,
			0f,
			47f / 64f,
			61f / 64f,
			0f,
			0f,
			0.75f,
			3f / 64f,
			0f,
			0f,
			49f / 64f,
			35f / 64f,
			0f,
			0f,
			25f / 32f,
			19f / 64f,
			0f,
			0f,
			51f / 64f,
			51f / 64f,
			0f,
			0f,
			0.8125f,
			11f / 64f,
			0f,
			0f,
			53f / 64f,
			43f / 64f,
			0f,
			0f,
			27f / 32f,
			27f / 64f,
			0f,
			0f,
			55f / 64f,
			59f / 64f,
			0f,
			0f,
			0.875f,
			7f / 64f,
			0f,
			0f,
			57f / 64f,
			39f / 64f,
			0f,
			0f,
			29f / 32f,
			23f / 64f,
			0f,
			0f,
			59f / 64f,
			55f / 64f,
			0f,
			0f,
			0.9375f,
			15f / 64f,
			0f,
			0f,
			61f / 64f,
			47f / 64f,
			0f,
			0f,
			31f / 32f,
			31f / 64f,
			0f,
			0f,
			63f / 64f,
			63f / 64f,
			0f,
			0f
		};

		private static float[] k_Hammersley2dSeq256 = new float[1024]
		{
			0f,
			0f,
			0f,
			0f,
			0.00390625f,
			0.5f,
			0f,
			0f,
			1f / 128f,
			0.25f,
			0f,
			0f,
			0.01171875f,
			0.75f,
			0f,
			0f,
			1f / 64f,
			0.125f,
			0f,
			0f,
			0.01953125f,
			0.625f,
			0f,
			0f,
			3f / 128f,
			0.375f,
			0f,
			0f,
			0.02734375f,
			0.875f,
			0f,
			0f,
			1f / 32f,
			0.0625f,
			0f,
			0f,
			0.03515625f,
			0.5625f,
			0f,
			0f,
			5f / 128f,
			0.3125f,
			0f,
			0f,
			0.04296875f,
			0.8125f,
			0f,
			0f,
			3f / 64f,
			0.1875f,
			0f,
			0f,
			0.05078125f,
			0.6875f,
			0f,
			0f,
			7f / 128f,
			0.4375f,
			0f,
			0f,
			0.05859375f,
			0.9375f,
			0f,
			0f,
			0.0625f,
			1f / 32f,
			0f,
			0f,
			0.06640625f,
			17f / 32f,
			0f,
			0f,
			9f / 128f,
			9f / 32f,
			0f,
			0f,
			0.07421875f,
			25f / 32f,
			0f,
			0f,
			5f / 64f,
			5f / 32f,
			0f,
			0f,
			0.08203125f,
			21f / 32f,
			0f,
			0f,
			11f / 128f,
			13f / 32f,
			0f,
			0f,
			0.08984375f,
			29f / 32f,
			0f,
			0f,
			3f / 32f,
			3f / 32f,
			0f,
			0f,
			0.09765625f,
			19f / 32f,
			0f,
			0f,
			13f / 128f,
			11f / 32f,
			0f,
			0f,
			0.10546875f,
			27f / 32f,
			0f,
			0f,
			7f / 64f,
			7f / 32f,
			0f,
			0f,
			0.11328125f,
			23f / 32f,
			0f,
			0f,
			15f / 128f,
			15f / 32f,
			0f,
			0f,
			0.12109375f,
			31f / 32f,
			0f,
			0f,
			0.125f,
			1f / 64f,
			0f,
			0f,
			0.12890625f,
			33f / 64f,
			0f,
			0f,
			17f / 128f,
			17f / 64f,
			0f,
			0f,
			0.13671875f,
			49f / 64f,
			0f,
			0f,
			9f / 64f,
			9f / 64f,
			0f,
			0f,
			0.14453125f,
			41f / 64f,
			0f,
			0f,
			19f / 128f,
			25f / 64f,
			0f,
			0f,
			0.15234375f,
			57f / 64f,
			0f,
			0f,
			5f / 32f,
			5f / 64f,
			0f,
			0f,
			0.16015625f,
			37f / 64f,
			0f,
			0f,
			21f / 128f,
			21f / 64f,
			0f,
			0f,
			0.16796875f,
			53f / 64f,
			0f,
			0f,
			11f / 64f,
			13f / 64f,
			0f,
			0f,
			0.17578125f,
			45f / 64f,
			0f,
			0f,
			23f / 128f,
			29f / 64f,
			0f,
			0f,
			0.18359375f,
			61f / 64f,
			0f,
			0f,
			0.1875f,
			3f / 64f,
			0f,
			0f,
			0.19140625f,
			35f / 64f,
			0f,
			0f,
			25f / 128f,
			19f / 64f,
			0f,
			0f,
			0.19921875f,
			51f / 64f,
			0f,
			0f,
			13f / 64f,
			11f / 64f,
			0f,
			0f,
			0.20703125f,
			43f / 64f,
			0f,
			0f,
			27f / 128f,
			27f / 64f,
			0f,
			0f,
			0.21484375f,
			59f / 64f,
			0f,
			0f,
			7f / 32f,
			7f / 64f,
			0f,
			0f,
			0.22265625f,
			39f / 64f,
			0f,
			0f,
			29f / 128f,
			23f / 64f,
			0f,
			0f,
			0.23046875f,
			55f / 64f,
			0f,
			0f,
			15f / 64f,
			15f / 64f,
			0f,
			0f,
			0.23828125f,
			47f / 64f,
			0f,
			0f,
			31f / 128f,
			31f / 64f,
			0f,
			0f,
			0.24609375f,
			63f / 64f,
			0f,
			0f,
			0.25f,
			1f / 128f,
			0f,
			0f,
			0.25390625f,
			65f / 128f,
			0f,
			0f,
			33f / 128f,
			33f / 128f,
			0f,
			0f,
			0.26171875f,
			97f / 128f,
			0f,
			0f,
			17f / 64f,
			17f / 128f,
			0f,
			0f,
			0.26953125f,
			81f / 128f,
			0f,
			0f,
			35f / 128f,
			49f / 128f,
			0f,
			0f,
			0.27734375f,
			113f / 128f,
			0f,
			0f,
			9f / 32f,
			9f / 128f,
			0f,
			0f,
			0.28515625f,
			73f / 128f,
			0f,
			0f,
			37f / 128f,
			41f / 128f,
			0f,
			0f,
			0.29296875f,
			105f / 128f,
			0f,
			0f,
			19f / 64f,
			25f / 128f,
			0f,
			0f,
			0.30078125f,
			89f / 128f,
			0f,
			0f,
			39f / 128f,
			57f / 128f,
			0f,
			0f,
			0.30859375f,
			121f / 128f,
			0f,
			0f,
			0.3125f,
			5f / 128f,
			0f,
			0f,
			0.31640625f,
			69f / 128f,
			0f,
			0f,
			41f / 128f,
			37f / 128f,
			0f,
			0f,
			0.32421875f,
			101f / 128f,
			0f,
			0f,
			21f / 64f,
			21f / 128f,
			0f,
			0f,
			0.33203125f,
			85f / 128f,
			0f,
			0f,
			43f / 128f,
			53f / 128f,
			0f,
			0f,
			0.33984375f,
			117f / 128f,
			0f,
			0f,
			11f / 32f,
			13f / 128f,
			0f,
			0f,
			0.34765625f,
			77f / 128f,
			0f,
			0f,
			45f / 128f,
			45f / 128f,
			0f,
			0f,
			0.35546875f,
			109f / 128f,
			0f,
			0f,
			23f / 64f,
			29f / 128f,
			0f,
			0f,
			0.36328125f,
			93f / 128f,
			0f,
			0f,
			47f / 128f,
			61f / 128f,
			0f,
			0f,
			0.37109375f,
			125f / 128f,
			0f,
			0f,
			0.375f,
			3f / 128f,
			0f,
			0f,
			0.37890625f,
			67f / 128f,
			0f,
			0f,
			49f / 128f,
			35f / 128f,
			0f,
			0f,
			0.38671875f,
			99f / 128f,
			0f,
			0f,
			25f / 64f,
			19f / 128f,
			0f,
			0f,
			0.39453125f,
			83f / 128f,
			0f,
			0f,
			51f / 128f,
			51f / 128f,
			0f,
			0f,
			0.40234375f,
			115f / 128f,
			0f,
			0f,
			13f / 32f,
			11f / 128f,
			0f,
			0f,
			0.41015625f,
			75f / 128f,
			0f,
			0f,
			53f / 128f,
			43f / 128f,
			0f,
			0f,
			0.41796875f,
			107f / 128f,
			0f,
			0f,
			27f / 64f,
			27f / 128f,
			0f,
			0f,
			0.42578125f,
			91f / 128f,
			0f,
			0f,
			55f / 128f,
			59f / 128f,
			0f,
			0f,
			0.43359375f,
			123f / 128f,
			0f,
			0f,
			0.4375f,
			7f / 128f,
			0f,
			0f,
			0.44140625f,
			71f / 128f,
			0f,
			0f,
			57f / 128f,
			39f / 128f,
			0f,
			0f,
			0.44921875f,
			103f / 128f,
			0f,
			0f,
			29f / 64f,
			23f / 128f,
			0f,
			0f,
			0.45703125f,
			87f / 128f,
			0f,
			0f,
			59f / 128f,
			55f / 128f,
			0f,
			0f,
			0.46484375f,
			119f / 128f,
			0f,
			0f,
			15f / 32f,
			15f / 128f,
			0f,
			0f,
			0.47265625f,
			79f / 128f,
			0f,
			0f,
			61f / 128f,
			47f / 128f,
			0f,
			0f,
			0.48046875f,
			111f / 128f,
			0f,
			0f,
			31f / 64f,
			31f / 128f,
			0f,
			0f,
			0.48828125f,
			95f / 128f,
			0f,
			0f,
			63f / 128f,
			63f / 128f,
			0f,
			0f,
			0.49609375f,
			127f / 128f,
			0f,
			0f,
			0.5f,
			0.00390625f,
			0f,
			0f,
			0.50390625f,
			0.50390625f,
			0f,
			0f,
			65f / 128f,
			0.25390625f,
			0f,
			0f,
			0.51171875f,
			0.75390625f,
			0f,
			0f,
			33f / 64f,
			0.12890625f,
			0f,
			0f,
			0.51953125f,
			0.62890625f,
			0f,
			0f,
			67f / 128f,
			0.37890625f,
			0f,
			0f,
			0.52734375f,
			0.87890625f,
			0f,
			0f,
			17f / 32f,
			0.06640625f,
			0f,
			0f,
			0.53515625f,
			0.56640625f,
			0f,
			0f,
			69f / 128f,
			0.31640625f,
			0f,
			0f,
			0.54296875f,
			0.81640625f,
			0f,
			0f,
			35f / 64f,
			0.19140625f,
			0f,
			0f,
			0.55078125f,
			0.69140625f,
			0f,
			0f,
			71f / 128f,
			0.44140625f,
			0f,
			0f,
			0.55859375f,
			0.94140625f,
			0f,
			0f,
			0.5625f,
			0.03515625f,
			0f,
			0f,
			0.56640625f,
			0.53515625f,
			0f,
			0f,
			73f / 128f,
			0.28515625f,
			0f,
			0f,
			0.57421875f,
			0.78515625f,
			0f,
			0f,
			37f / 64f,
			0.16015625f,
			0f,
			0f,
			0.58203125f,
			0.66015625f,
			0f,
			0f,
			75f / 128f,
			0.41015625f,
			0f,
			0f,
			0.58984375f,
			0.91015625f,
			0f,
			0f,
			19f / 32f,
			0.09765625f,
			0f,
			0f,
			0.59765625f,
			0.59765625f,
			0f,
			0f,
			77f / 128f,
			0.34765625f,
			0f,
			0f,
			0.60546875f,
			0.84765625f,
			0f,
			0f,
			39f / 64f,
			0.22265625f,
			0f,
			0f,
			0.61328125f,
			0.72265625f,
			0f,
			0f,
			79f / 128f,
			0.47265625f,
			0f,
			0f,
			0.62109375f,
			0.97265625f,
			0f,
			0f,
			0.625f,
			0.01953125f,
			0f,
			0f,
			0.62890625f,
			0.51953125f,
			0f,
			0f,
			81f / 128f,
			0.26953125f,
			0f,
			0f,
			0.63671875f,
			0.76953125f,
			0f,
			0f,
			41f / 64f,
			0.14453125f,
			0f,
			0f,
			0.64453125f,
			0.64453125f,
			0f,
			0f,
			83f / 128f,
			0.39453125f,
			0f,
			0f,
			0.65234375f,
			0.89453125f,
			0f,
			0f,
			21f / 32f,
			0.08203125f,
			0f,
			0f,
			0.66015625f,
			0.58203125f,
			0f,
			0f,
			85f / 128f,
			0.33203125f,
			0f,
			0f,
			0.66796875f,
			0.83203125f,
			0f,
			0f,
			43f / 64f,
			0.20703125f,
			0f,
			0f,
			0.67578125f,
			0.70703125f,
			0f,
			0f,
			87f / 128f,
			0.45703125f,
			0f,
			0f,
			0.68359375f,
			0.95703125f,
			0f,
			0f,
			0.6875f,
			0.05078125f,
			0f,
			0f,
			0.69140625f,
			0.55078125f,
			0f,
			0f,
			89f / 128f,
			0.30078125f,
			0f,
			0f,
			0.69921875f,
			0.80078125f,
			0f,
			0f,
			45f / 64f,
			0.17578125f,
			0f,
			0f,
			0.70703125f,
			0.67578125f,
			0f,
			0f,
			91f / 128f,
			0.42578125f,
			0f,
			0f,
			0.71484375f,
			0.92578125f,
			0f,
			0f,
			23f / 32f,
			0.11328125f,
			0f,
			0f,
			0.72265625f,
			0.61328125f,
			0f,
			0f,
			93f / 128f,
			0.36328125f,
			0f,
			0f,
			0.73046875f,
			0.86328125f,
			0f,
			0f,
			47f / 64f,
			0.23828125f,
			0f,
			0f,
			0.73828125f,
			0.73828125f,
			0f,
			0f,
			95f / 128f,
			0.48828125f,
			0f,
			0f,
			0.74609375f,
			0.98828125f,
			0f,
			0f,
			0.75f,
			0.01171875f,
			0f,
			0f,
			0.75390625f,
			0.51171875f,
			0f,
			0f,
			97f / 128f,
			0.26171875f,
			0f,
			0f,
			0.76171875f,
			0.76171875f,
			0f,
			0f,
			49f / 64f,
			0.13671875f,
			0f,
			0f,
			0.76953125f,
			0.63671875f,
			0f,
			0f,
			99f / 128f,
			0.38671875f,
			0f,
			0f,
			0.77734375f,
			0.88671875f,
			0f,
			0f,
			25f / 32f,
			0.07421875f,
			0f,
			0f,
			0.78515625f,
			0.57421875f,
			0f,
			0f,
			101f / 128f,
			0.32421875f,
			0f,
			0f,
			0.79296875f,
			0.82421875f,
			0f,
			0f,
			51f / 64f,
			0.19921875f,
			0f,
			0f,
			0.80078125f,
			0.69921875f,
			0f,
			0f,
			103f / 128f,
			0.44921875f,
			0f,
			0f,
			0.80859375f,
			0.94921875f,
			0f,
			0f,
			0.8125f,
			0.04296875f,
			0f,
			0f,
			0.81640625f,
			0.54296875f,
			0f,
			0f,
			105f / 128f,
			0.29296875f,
			0f,
			0f,
			0.82421875f,
			0.79296875f,
			0f,
			0f,
			53f / 64f,
			0.16796875f,
			0f,
			0f,
			0.83203125f,
			0.66796875f,
			0f,
			0f,
			107f / 128f,
			0.41796875f,
			0f,
			0f,
			0.83984375f,
			0.91796875f,
			0f,
			0f,
			27f / 32f,
			0.10546875f,
			0f,
			0f,
			0.84765625f,
			0.60546875f,
			0f,
			0f,
			109f / 128f,
			0.35546875f,
			0f,
			0f,
			0.85546875f,
			0.85546875f,
			0f,
			0f,
			55f / 64f,
			0.23046875f,
			0f,
			0f,
			0.86328125f,
			0.73046875f,
			0f,
			0f,
			111f / 128f,
			0.48046875f,
			0f,
			0f,
			0.87109375f,
			0.98046875f,
			0f,
			0f,
			0.875f,
			0.02734375f,
			0f,
			0f,
			0.87890625f,
			0.52734375f,
			0f,
			0f,
			113f / 128f,
			0.27734375f,
			0f,
			0f,
			0.88671875f,
			0.77734375f,
			0f,
			0f,
			57f / 64f,
			0.15234375f,
			0f,
			0f,
			0.89453125f,
			0.65234375f,
			0f,
			0f,
			115f / 128f,
			0.40234375f,
			0f,
			0f,
			0.90234375f,
			0.90234375f,
			0f,
			0f,
			29f / 32f,
			0.08984375f,
			0f,
			0f,
			0.91015625f,
			0.58984375f,
			0f,
			0f,
			117f / 128f,
			0.33984375f,
			0f,
			0f,
			0.91796875f,
			0.83984375f,
			0f,
			0f,
			59f / 64f,
			0.21484375f,
			0f,
			0f,
			0.92578125f,
			0.71484375f,
			0f,
			0f,
			119f / 128f,
			0.46484375f,
			0f,
			0f,
			0.93359375f,
			0.96484375f,
			0f,
			0f,
			0.9375f,
			0.05859375f,
			0f,
			0f,
			0.94140625f,
			0.55859375f,
			0f,
			0f,
			121f / 128f,
			0.30859375f,
			0f,
			0f,
			0.94921875f,
			0.80859375f,
			0f,
			0f,
			61f / 64f,
			0.18359375f,
			0f,
			0f,
			0.95703125f,
			0.68359375f,
			0f,
			0f,
			123f / 128f,
			0.43359375f,
			0f,
			0f,
			0.96484375f,
			0.93359375f,
			0f,
			0f,
			31f / 32f,
			0.12109375f,
			0f,
			0f,
			0.97265625f,
			0.62109375f,
			0f,
			0f,
			125f / 128f,
			0.37109375f,
			0f,
			0f,
			0.98046875f,
			0.87109375f,
			0f,
			0f,
			63f / 64f,
			0.24609375f,
			0f,
			0f,
			0.98828125f,
			0.74609375f,
			0f,
			0f,
			127f / 128f,
			0.49609375f,
			0f,
			0f,
			0.99609375f,
			0.99609375f,
			0f,
			0f
		};

		private static readonly int s_hammersley2DSeq16Id = Shader.PropertyToID("Hammersley2dSeq16");

		private static readonly int s_hammersley2DSeq32Id = Shader.PropertyToID("Hammersley2dSeq32");

		private static readonly int s_hammersley2DSeq64Id = Shader.PropertyToID("Hammersley2dSeq64");

		private static readonly int s_hammersley2DSeq256Id = Shader.PropertyToID("Hammersley2dSeq256");

		public unsafe static void Initialize()
		{
			Hammersley2dSeq16 data = default(Hammersley2dSeq16);
			Hammersley2dSeq32 data2 = default(Hammersley2dSeq32);
			Hammersley2dSeq64 data3 = default(Hammersley2dSeq64);
			Hammersley2dSeq256 data4 = default(Hammersley2dSeq256);
			for (int i = 0; i < k_Hammersley2dSeq16.Length; i++)
			{
				data.hammersley2dSeq16[i] = k_Hammersley2dSeq16[i];
			}
			for (int j = 0; j < k_Hammersley2dSeq32.Length; j++)
			{
				data2.hammersley2dSeq32[j] = k_Hammersley2dSeq32[j];
			}
			for (int k = 0; k < k_Hammersley2dSeq64.Length; k++)
			{
				data3.hammersley2dSeq64[k] = k_Hammersley2dSeq64[k];
			}
			for (int l = 0; l < k_Hammersley2dSeq256.Length; l++)
			{
				data4.hammersley2dSeq256[l] = k_Hammersley2dSeq256[l];
			}
			ConstantBuffer.UpdateData(in data);
			ConstantBuffer.UpdateData(in data2);
			ConstantBuffer.UpdateData(in data3);
			ConstantBuffer.UpdateData(in data4);
		}

		public static void BindConstants(CommandBuffer cmd, ComputeShader cs)
		{
			ConstantBuffer.Set<Hammersley2dSeq16>(cmd, cs, s_hammersley2DSeq16Id);
			ConstantBuffer.Set<Hammersley2dSeq32>(cmd, cs, s_hammersley2DSeq32Id);
			ConstantBuffer.Set<Hammersley2dSeq64>(cmd, cs, s_hammersley2DSeq64Id);
			ConstantBuffer.Set<Hammersley2dSeq256>(cmd, cs, s_hammersley2DSeq256Id);
		}
	}
	public class BufferedRTHandleSystem : IDisposable
	{
		private Dictionary<int, RTHandle[]> m_RTHandles = new Dictionary<int, RTHandle[]>();

		private RTHandleSystem m_RTHandleSystem = new RTHandleSystem();

		private bool m_DisposedValue;

		public int maxWidth => m_RTHandleSystem.GetMaxWidth();

		public int maxHeight => m_RTHandleSystem.GetMaxHeight();

		public RTHandleProperties rtHandleProperties => m_RTHandleSystem.rtHandleProperties;

		public RTHandle GetFrameRT(int bufferId, int frameIndex)
		{
			if (!m_RTHandles.ContainsKey(bufferId))
			{
				return null;
			}
			Assert.IsTrue(frameIndex >= 0 && frameIndex < m_RTHandles[bufferId].Length);
			return m_RTHandles[bufferId][frameIndex];
		}

		public void AllocBuffer(int bufferId, Func<RTHandleSystem, int, RTHandle> allocator, int bufferCount)
		{
			Debug.Assert(bufferCount > 0);
			RTHandle[] array = new RTHandle[bufferCount];
			m_RTHandles.Add(bufferId, array);
			array[0] = allocator(m_RTHandleSystem, 0);
			int i = 1;
			for (int num = array.Length; i < num; i++)
			{
				array[i] = allocator(m_RTHandleSystem, i);
				m_RTHandleSystem.SwitchResizeMode(array[i], RTHandleSystem.ResizeMode.OnDemand);
			}
		}

		public void ReleaseBuffer(int bufferId)
		{
			if (m_RTHandles.TryGetValue(bufferId, out var value))
			{
				RTHandle[] array = value;
				foreach (RTHandle rth in array)
				{
					m_RTHandleSystem.Release(rth);
				}
			}
			m_RTHandles.Remove(bufferId);
		}

		public void SwapAndSetReferenceSize(int width, int height)
		{
			Swap();
			m_RTHandleSystem.SetReferenceSize(width, height);
		}

		public void ResetReferenceSize(int width, int height)
		{
			m_RTHandleSystem.ResetReferenceSize(width, height);
		}

		public int GetNumFramesAllocated(int bufferId)
		{
			if (!m_RTHandles.ContainsKey(bufferId))
			{
				return 0;
			}
			return m_RTHandles[bufferId].Length;
		}

		public Vector2 CalculateRatioAgainstMaxSize(int width, int height)
		{
			return m_RTHandleSystem.CalculateRatioAgainstMaxSize(new Vector2Int(width, height));
		}

		private void Swap()
		{
			foreach (KeyValuePair<int, RTHandle[]> rTHandle2 in m_RTHandles)
			{
				if (rTHandle2.Value.Length > 1)
				{
					RTHandle rTHandle = rTHandle2.Value[rTHandle2.Value.Length - 1];
					int i = 0;
					for (int num = rTHandle2.Value.Length - 1; i < num; i++)
					{
						rTHandle2.Value[i + 1] = rTHandle2.Value[i];
					}
					rTHandle2.Value[0] = rTHandle;
					m_RTHandleSystem.SwitchResizeMode(rTHandle2.Value[0], RTHandleSystem.ResizeMode.Auto);
					m_RTHandleSystem.SwitchResizeMode(rTHandle2.Value[1], RTHandleSystem.ResizeMode.OnDemand);
				}
				else
				{
					m_RTHandleSystem.SwitchResizeMode(rTHandle2.Value[0], RTHandleSystem.ResizeMode.Auto);
				}
			}
		}

		private void Dispose(bool disposing)
		{
			if (!m_DisposedValue)
			{
				if (disposing)
				{
					ReleaseAll();
					m_RTHandleSystem.Dispose();
					m_RTHandleSystem = null;
				}
				m_DisposedValue = true;
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		public void ReleaseAll()
		{
			foreach (KeyValuePair<int, RTHandle[]> rTHandle in m_RTHandles)
			{
				int i = 0;
				for (int num = rTHandle.Value.Length; i < num; i++)
				{
					m_RTHandleSystem.Release(rTHandle.Value[i]);
				}
			}
			m_RTHandles.Clear();
		}
	}
	public enum DepthBits
	{
		None = 0,
		Depth8 = 8,
		Depth16 = 16,
		Depth24 = 24,
		Depth32 = 32
	}
	public enum MSAASamples
	{
		None = 1,
		MSAA2x = 2,
		MSAA4x = 4,
		MSAA8x = 8
	}
	public class PowerOfTwoTextureAtlas : Texture2DAtlas
	{
		private enum BlitType
		{
			Padding,
			PaddingMultiply,
			OctahedralPadding,
			OctahedralPaddingMultiply
		}

		private readonly int m_MipPadding;

		private const float k_MipmapFactorApprox = 1.33f;

		private Dictionary<int, Vector2Int> m_RequestedTextures = new Dictionary<int, Vector2Int>();

		public int mipPadding => m_MipPadding;

		public PowerOfTwoTextureAtlas(int size, int mipPadding, GraphicsFormat format, FilterMode filterMode = FilterMode.Point, string name = "", bool useMipMap = true)
			: base(size, size, format, filterMode, powerOfTwoPadding: true, name, useMipMap)
		{
			m_MipPadding = mipPadding;
			if ((size & (size - 1)) != 0)
			{
				Debug.Assert(condition: false, "Power of two atlas was constructed with non power of two size: " + size);
			}
		}

		private int GetTexturePadding()
		{
			return (int)Mathf.Pow(2f, m_MipPadding) * 2;
		}

		public Vector4 GetPayloadScaleOffset(Texture texture, in Vector4 scaleOffset)
		{
			int texturePadding = GetTexturePadding();
			Vector2 paddingSize = Vector2.one * texturePadding;
			return GetPayloadScaleOffset(GetPowerOfTwoTextureSize(texture), in paddingSize, in scaleOffset);
		}

		public static Vector4 GetPayloadScaleOffset(in Vector2 textureSize, in Vector2 paddingSize, in Vector4 scaleOffset)
		{
			Vector2 vector = new Vector2(scaleOffset.x, scaleOffset.y);
			Vector2 vector2 = new Vector2(scaleOffset.z, scaleOffset.w);
			Vector2 vector3 = (textureSize + paddingSize) / textureSize;
			Vector2 vector4 = paddingSize / 2f / (textureSize + paddingSize);
			Vector2 vector5 = vector / vector3;
			Vector2 vector6 = vector2 + vector * vector4;
			return new Vector4(vector5.x, vector5.y, vector6.x, vector6.y);
		}

		private void Blit2DTexture(CommandBuffer cmd, Vector4 scaleOffset, Texture texture, Vector4 sourceScaleOffset, bool blitMips, BlitType blitType)
		{
			int num = GetTextureMipmapCount(texture.width, texture.height);
			int texturePadding = GetTexturePadding();
			Vector2 powerOfTwoTextureSize = GetPowerOfTwoTextureSize(texture);
			bool bilinear = texture.filterMode != FilterMode.Point;
			if (!blitMips)
			{
				num = 1;
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(CoreProfileId.BlitTextureInPotAtlas)))
			{
				for (int i = 0; i < num; i++)
				{
					cmd.SetRenderTarget(m_AtlasTexture, i);
					switch (blitType)
					{
					case BlitType.Padding:
						Blitter.BlitQuadWithPadding(cmd, texture, powerOfTwoTextureSize, sourceScaleOffset, scaleOffset, i, bilinear, texturePadding);
						break;
					case BlitType.PaddingMultiply:
						Blitter.BlitQuadWithPaddingMultiply(cmd, texture, powerOfTwoTextureSize, sourceScaleOffset, scaleOffset, i, bilinear, texturePadding);
						break;
					case BlitType.OctahedralPadding:
						Blitter.BlitOctahedralWithPadding(cmd, texture, powerOfTwoTextureSize, sourceScaleOffset, scaleOffset, i, bilinear, texturePadding);
						break;
					case BlitType.OctahedralPaddingMultiply:
						Blitter.BlitOctahedralWithPaddingMultiply(cmd, texture, powerOfTwoTextureSize, sourceScaleOffset, scaleOffset, i, bilinear, texturePadding);
						break;
					}
				}
			}
		}

		public override void BlitTexture(CommandBuffer cmd, Vector4 scaleOffset, Texture texture, Vector4 sourceScaleOffset, bool blitMips = true, int overrideInstanceID = -1)
		{
			if (Is2D(texture))
			{
				Blit2DTexture(cmd, scaleOffset, texture, sourceScaleOffset, blitMips, BlitType.Padding);
				MarkGPUTextureValid((overrideInstanceID != -1) ? overrideInstanceID : texture.GetInstanceID(), blitMips);
			}
		}

		public void BlitTextureMultiply(CommandBuffer cmd, Vector4 scaleOffset, Texture texture, Vector4 sourceScaleOffset, bool blitMips = true, int overrideInstanceID = -1)
		{
			if (Is2D(texture))
			{
				Blit2DTexture(cmd, scaleOffset, texture, sourceScaleOffset, blitMips, BlitType.PaddingMultiply);
				MarkGPUTextureValid((overrideInstanceID != -1) ? overrideInstanceID : texture.GetInstanceID(), blitMips);
			}
		}

		public override void BlitOctahedralTexture(CommandBuffer cmd, Vector4 scaleOffset, Texture texture, Vector4 sourceScaleOffset, bool blitMips = true, int overrideInstanceID = -1)
		{
			if (Is2D(texture))
			{
				Blit2DTexture(cmd, scaleOffset, texture, sourceScaleOffset, blitMips, BlitType.OctahedralPadding);
				MarkGPUTextureValid((overrideInstanceID != -1) ? overrideInstanceID : texture.GetInstanceID(), blitMips);
			}
		}

		public void BlitOctahedralTextureMultiply(CommandBuffer cmd, Vector4 scaleOffset, Texture texture, Vector4 sourceScaleOffset, bool blitMips = true, int overrideInstanceID = -1)
		{
			if (Is2D(texture))
			{
				Blit2DTexture(cmd, scaleOffset, texture, sourceScaleOffset, blitMips, BlitType.OctahedralPaddingMultiply);
				MarkGPUTextureValid((overrideInstanceID != -1) ? overrideInstanceID : texture.GetInstanceID(), blitMips);
			}
		}

		private void TextureSizeToPowerOfTwo(Texture texture, ref int width, ref int height)
		{
			width = Mathf.NextPowerOfTwo(width);
			height = Mathf.NextPowerOfTwo(height);
		}

		private Vector2 GetPowerOfTwoTextureSize(Texture texture)
		{
			int width = texture.width;
			int height = texture.height;
			TextureSizeToPowerOfTwo(texture, ref width, ref height);
			return new Vector2(width, height);
		}

		public override bool AllocateTexture(CommandBuffer cmd, ref Vector4 scaleOffset, Texture texture, int width, int height, int overrideInstanceID = -1)
		{
			if (height != width)
			{
				Debug.LogError("Can't place " + texture?.ToString() + " in the atlas " + m_AtlasTexture.name + ": Only squared texture are allowed in this atlas.");
				return false;
			}
			TextureSizeToPowerOfTwo(texture, ref height, ref width);
			return base.AllocateTexture(cmd, ref scaleOffset, texture, width, height);
		}

		public void ResetRequestedTexture()
		{
			m_RequestedTextures.Clear();
		}

		public bool ReserveSpace(Texture texture)
		{
			return ReserveSpace(texture, texture.width, texture.height);
		}

		public bool ReserveSpace(Texture texture, int width, int height)
		{
			return ReserveSpace(GetTextureID(texture), width, height);
		}

		public bool ReserveSpace(Texture textureA, Texture textureB, int width, int height)
		{
			return ReserveSpace(GetTextureID(textureA, textureB), width, height);
		}

		private bool ReserveSpace(int id, int width, int height)
		{
			m_RequestedTextures[id] = new Vector2Int(width, height);
			Vector2Int cachedTextureSize = GetCachedTextureSize(id);
			if (!IsCached(out var _, id) || cachedTextureSize.x != width || cachedTextureSize.y != height)
			{
				Vector4 scaleOffset2 = Vector4.zero;
				if (!AllocateTextureWithoutBlit(id, width, height, ref scaleOffset2))
				{
					return false;
				}
			}
			return true;
		}

		public bool RelayoutEntries()
		{
			List<(int, Vector2Int)> list = new List<(int, Vector2Int)>();
			foreach (KeyValuePair<int, Vector2Int> requestedTexture in m_RequestedTextures)
			{
				list.Add((requestedTexture.Key, requestedTexture.Value));
			}
			ResetAllocator();
			list.Sort(((int instanceId, Vector2Int size) c1, (int instanceId, Vector2Int size) c2) => c2.size.magnitude.CompareTo(c1.size.magnitude));
			bool flag = true;
			Vector4 scaleOffset = Vector4.zero;
			foreach (var item3 in list)
			{
				bool num = flag;
				int item = item3.Item1;
				Vector2Int item2 = item3.Item2;
				int x = item2.x;
				item2 = item3.Item2;
				flag = num & AllocateTextureWithoutBlit(item, x, item2.y, ref scaleOffset);
			}
			return flag;
		}

		public static long GetApproxCacheSizeInByte(int nbElement, int resolution, bool hasMipmap, GraphicsFormat format)
		{
			return (long)((double)(nbElement * resolution * resolution) * (double)((hasMipmap ? 1.33f : 1f) * (float)GraphicsFormatUtility.GetBlockSize(format)));
		}

		public static int GetMaxCacheSizeForWeightInByte(int weight, bool hasMipmap, GraphicsFormat format)
		{
			float num = (float)GraphicsFormatUtility.GetBlockSize(format) * (hasMipmap ? 1.33f : 1f);
			return CoreUtils.PreviousPowerOfTwo((int)Mathf.Sqrt((float)weight / num));
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct RTHandleStaticHelpers
	{
		public static RTHandle s_RTHandleWrapper;

		public static void SetRTHandleStaticWrapper(RenderTargetIdentifier rtId)
		{
			if (s_RTHandleWrapper == null)
			{
				s_RTHandleWrapper = RTHandles.Alloc(rtId);
			}
			else
			{
				s_RTHandleWrapper.SetTexture(rtId);
			}
		}

		public static void SetRTHandleUserManagedWrapper(ref RTHandle rtWrapper, RenderTargetIdentifier rtId)
		{
			if (rtWrapper != null)
			{
				if (rtWrapper.m_RT != null)
				{
					throw new ArgumentException("Input wrapper must be a wrapper around RenderTargetIdentifier. Passed in warpper contains valid RenderTexture " + rtWrapper.m_RT.name + " and cannot be used as warpper.");
				}
				if (rtWrapper.m_ExternalTexture != null)
				{
					throw new ArgumentException("Input wrapper must be a wrapper around RenderTargetIdentifier. Passed in warpper contains valid Texture " + rtWrapper.m_ExternalTexture.name + " and cannot be used as warpper.");
				}
				rtWrapper.SetTexture(rtId);
			}
		}
	}
	public class RTHandle
	{
		internal RTHandleSystem m_Owner;

		internal RenderTexture m_RT;

		internal Texture m_ExternalTexture;

		internal RenderTargetIdentifier m_NameID;

		internal bool m_EnableMSAA;

		internal bool m_EnableRandomWrite;

		internal bool m_EnableHWDynamicScale;

		internal string m_Name;

		internal bool m_UseCustomHandleScales;

		internal RTHandleProperties m_CustomHandleProperties;

		internal ScaleFunc scaleFunc;

		public Vector2 scaleFactor { get; internal set; }

		public bool useScaling { get; internal set; }

		public Vector2Int referenceSize { get; internal set; }

		public RTHandleProperties rtHandleProperties
		{
			get
			{
				if (!m_UseCustomHandleScales)
				{
					return m_Owner.rtHandleProperties;
				}
				return m_CustomHandleProperties;
			}
		}

		public RenderTexture rt => m_RT;

		public RenderTargetIdentifier nameID => m_NameID;

		public string name => m_Name;

		public bool isMSAAEnabled => m_EnableMSAA;

		public void SetCustomHandleProperties(in RTHandleProperties properties)
		{
			m_UseCustomHandleScales = true;
			m_CustomHandleProperties = properties;
		}

		public void ClearCustomHandleProperties()
		{
			m_UseCustomHandleScales = false;
		}

		internal RTHandle(RTHandleSystem owner)
		{
			m_Owner = owner;
		}

		public static implicit operator RenderTargetIdentifier(RTHandle handle)
		{
			return handle?.nameID ?? default(RenderTargetIdentifier);
		}

		public static implicit operator Texture(RTHandle handle)
		{
			if (handle == null)
			{
				return null;
			}
			Debug.Assert(handle.m_ExternalTexture != null || handle.rt != null);
			if (!(handle.rt != null))
			{
				return handle.m_ExternalTexture;
			}
			return handle.rt;
		}

		public static implicit operator RenderTexture(RTHandle handle)
		{
			if (handle == null)
			{
				return null;
			}
			Debug.Assert(handle.rt != null, "RTHandle was created using a regular Texture and is used as a RenderTexture");
			return handle.rt;
		}

		internal void SetRenderTexture(RenderTexture rt)
		{
			m_RT = rt;
			m_ExternalTexture = null;
			m_NameID = new RenderTargetIdentifier(rt);
		}

		internal void SetTexture(Texture tex)
		{
			m_RT = null;
			m_ExternalTexture = tex;
			m_NameID = new RenderTargetIdentifier(tex);
		}

		internal void SetTexture(RenderTargetIdentifier tex)
		{
			m_RT = null;
			m_ExternalTexture = null;
			m_NameID = tex;
		}

		public int GetInstanceID()
		{
			if (m_RT != null)
			{
				return m_RT.GetInstanceID();
			}
			if (m_ExternalTexture != null)
			{
				return m_ExternalTexture.GetInstanceID();
			}
			return m_NameID.GetHashCode();
		}

		public void Release()
		{
			m_Owner.Remove(this);
			CoreUtils.Destroy(m_RT);
			m_NameID = BuiltinRenderTextureType.None;
			m_RT = null;
			m_ExternalTexture = null;
		}

		public Vector2Int GetScaledSize(Vector2Int refSize)
		{
			if (!useScaling)
			{
				return refSize;
			}
			if (scaleFunc != null)
			{
				return scaleFunc(refSize);
			}
			return new Vector2Int(Mathf.RoundToInt(scaleFactor.x * (float)refSize.x), Mathf.RoundToInt(scaleFactor.y * (float)refSize.y));
		}

		public Vector2Int GetScaledSize()
		{
			if (!useScaling)
			{
				return referenceSize;
			}
			if (scaleFunc != null)
			{
				return scaleFunc(referenceSize);
			}
			return new Vector2Int(Mathf.RoundToInt(scaleFactor.x * (float)referenceSize.x), Mathf.RoundToInt(scaleFactor.y * (float)referenceSize.y));
		}

		public void SwitchToFastMemory(CommandBuffer cmd, float residencyFraction = 1f, FastMemoryFlags flags = FastMemoryFlags.SpillTop, bool copyContents = false)
		{
			residencyFraction = Mathf.Clamp01(residencyFraction);
			cmd.SwitchIntoFastMemory(m_RT, flags, residencyFraction, copyContents);
		}

		public void CopyToFastMemory(CommandBuffer cmd, float residencyFraction = 1f, FastMemoryFlags flags = FastMemoryFlags.SpillTop)
		{
			SwitchToFastMemory(cmd, residencyFraction, flags, copyContents: true);
		}

		public void SwitchOutFastMemory(CommandBuffer cmd, bool copyContents = true)
		{
			cmd.SwitchOutOfFastMemory(m_RT, copyContents);
		}
	}
	public static class RTHandles
	{
		private static RTHandleSystem s_DefaultInstance = new RTHandleSystem();

		public static int maxWidth => s_DefaultInstance.GetMaxWidth();

		public static int maxHeight => s_DefaultInstance.GetMaxHeight();

		public static RTHandleProperties rtHandleProperties => s_DefaultInstance.rtHandleProperties;

		public static RTHandle Alloc(int width, int height, int slices = 1, DepthBits depthBufferBits = DepthBits.None, GraphicsFormat colorFormat = GraphicsFormat.R8G8B8A8_SRGB, FilterMode filterMode = FilterMode.Point, TextureWrapMode wrapMode = TextureWrapMode.Repeat, TextureDimension dimension = TextureDimension.Tex2D, bool enableRandomWrite = false, bool useMipMap = false, bool autoGenerateMips = true, bool isShadowMap = false, int anisoLevel = 1, float mipMapBias = 0f, MSAASamples msaaSamples = MSAASamples.None, bool bindTextureMS = false, bool useDynamicScale = false, RenderTextureMemoryless memoryless = RenderTextureMemoryless.None, VRTextureUsage vrUsage = VRTextureUsage.None, string name = "")
		{
			return s_DefaultInstance.Alloc(width, height, slices, depthBufferBits, colorFormat, filterMode, wrapMode, dimension, enableRandomWrite, useMipMap, autoGenerateMips, isShadowMap, anisoLevel, mipMapBias, msaaSamples, bindTextureMS, useDynamicScale, memoryless, vrUsage, name);
		}

		public static RTHandle Alloc(int width, int height, TextureWrapMode wrapModeU, TextureWrapMode wrapModeV, TextureWrapMode wrapModeW = TextureWrapMode.Repeat, int slices = 1, DepthBits depthBufferBits = DepthBits.None, GraphicsFormat colorFormat = GraphicsFormat.R8G8B8A8_SRGB, FilterMode filterMode = FilterMode.Point, TextureDimension dimension = TextureDimension.Tex2D, bool enableRandomWrite = false, bool useMipMap = false, bool autoGenerateMips = true, bool isShadowMap = false, int anisoLevel = 1, float mipMapBias = 0f, MSAASamples msaaSamples = MSAASamples.None, bool bindTextureMS = false, bool useDynamicScale = false, RenderTextureMemoryless memoryless = RenderTextureMemoryless.None, VRTextureUsage vrUsage = VRTextureUsage.None, string name = "")
		{
			return s_DefaultInstance.Alloc(width, height, wrapModeU, wrapModeV, wrapModeW, slices, depthBufferBits, colorFormat, filterMode, dimension, enableRandomWrite, useMipMap, autoGenerateMips, isShadowMap, anisoLevel, mipMapBias, msaaSamples, bindTextureMS, useDynamicScale, memoryless, vrUsage, name);
		}

		public static RTHandle Alloc(in RenderTextureDescriptor descriptor, FilterMode filterMode = FilterMode.Point, TextureWrapMode wrapMode = TextureWrapMode.Repeat, bool isShadowMap = false, int anisoLevel = 1, float mipMapBias = 0f, string name = "")
		{
			return s_DefaultInstance.Alloc(descriptor.width, descriptor.height, descriptor.volumeDepth, (DepthBits)descriptor.depthBufferBits, descriptor.graphicsFormat, filterMode, wrapMode, descriptor.dimension, descriptor.enableRandomWrite, descriptor.useMipMap, descriptor.autoGenerateMips, isShadowMap, anisoLevel, mipMapBias, (MSAASamples)descriptor.msaaSamples, descriptor.bindMS, descriptor.useDynamicScale, descriptor.memoryless, descriptor.vrUsage, name);
		}

		public static RTHandle Alloc(Vector2 scaleFactor, int slices = 1, DepthBits depthBufferBits = DepthBits.None, GraphicsFormat colorFormat = GraphicsFormat.R8G8B8A8_SRGB, FilterMode filterMode = FilterMode.Point, TextureWrapMode wrapMode = TextureWrapMode.Repeat, TextureDimension dimension = TextureDimension.Tex2D, bool enableRandomWrite = false, bool useMipMap = false, bool autoGenerateMips = true, bool isShadowMap = false, int anisoLevel = 1, float mipMapBias = 0f, MSAASamples msaaSamples = MSAASamples.None, bool bindTextureMS = false, bool useDynamicScale = false, RenderTextureMemoryless memoryless = RenderTextureMemoryless.None, VRTextureUsage vrUsage = VRTextureUsage.None, string name = "")
		{
			return s_DefaultInstance.Alloc(scaleFactor, slices, depthBufferBits, colorFormat, filterMode, wrapMode, dimension, enableRandomWrite, useMipMap, autoGenerateMips, isShadowMap, anisoLevel, mipMapBias, msaaSamples, bindTextureMS, useDynamicScale, memoryless, vrUsage, name);
		}

		public static RTHandle Alloc(Vector2 scaleFactor, in RenderTextureDescriptor descriptor, FilterMode filterMode = FilterMode.Point, TextureWrapMode wrapMode = TextureWrapMode.Repeat, bool isShadowMap = false, int anisoLevel = 1, float mipMapBias = 0f, string name = "")
		{
			return s_DefaultInstance.Alloc(scaleFactor, descriptor.volumeDepth, (DepthBits)descriptor.depthBufferBits, descriptor.graphicsFormat, filterMode, wrapMode, descriptor.dimension, descriptor.enableRandomWrite, descriptor.useMipMap, descriptor.autoGenerateMips, isShadowMap, anisoLevel, mipMapBias, (MSAASamples)descriptor.msaaSamples, descriptor.bindMS, descriptor.useDynamicScale, descriptor.memoryless, descriptor.vrUsage, name);
		}

		public static RTHandle Alloc(ScaleFunc scaleFunc, int slices = 1, DepthBits depthBufferBits = DepthBits.None, GraphicsFormat colorFormat = GraphicsFormat.R8G8B8A8_SRGB, FilterMode filterMode = FilterMode.Point, TextureWrapMode wrapMode = TextureWrapMode.Repeat, TextureDimension dimension = TextureDimension.Tex2D, bool enableRandomWrite = false, bool useMipMap = false, bool autoGenerateMips = true, bool isShadowMap = false, int anisoLevel = 1, float mipMapBias = 0f, MSAASamples msaaSamples = MSAASamples.None, bool bindTextureMS = false, bool useDynamicScale = false, RenderTextureMemoryless memoryless = RenderTextureMemoryless.None, VRTextureUsage vrUsage = VRTextureUsage.None, string name = "")
		{
			return s_DefaultInstance.Alloc(scaleFunc, slices, depthBufferBits, colorFormat, filterMode, wrapMode, dimension, enableRandomWrite, useMipMap, autoGenerateMips, isShadowMap, anisoLevel, mipMapBias, msaaSamples, bindTextureMS, useDynamicScale, memoryless, vrUsage, name);
		}

		public static RTHandle Alloc(ScaleFunc scaleFunc, in RenderTextureDescriptor descriptor, FilterMode filterMode = FilterMode.Point, TextureWrapMode wrapMode = TextureWrapMode.Repeat, bool isShadowMap = false, int anisoLevel = 1, float mipMapBias = 0f, string name = "")
		{
			return s_DefaultInstance.Alloc(scaleFunc, descriptor.volumeDepth, (DepthBits)descriptor.depthBufferBits, descriptor.graphicsFormat, filterMode, wrapMode, descriptor.dimension, descriptor.enableRandomWrite, descriptor.useMipMap, descriptor.autoGenerateMips, isShadowMap, anisoLevel, mipMapBias, (MSAASamples)descriptor.msaaSamples, descriptor.bindMS, descriptor.useDynamicScale, descriptor.memoryless, descriptor.vrUsage, name);
		}

		public static RTHandle Alloc(Texture tex)
		{
			return s_DefaultInstance.Alloc(tex);
		}

		public static RTHandle Alloc(RenderTexture tex)
		{
			return s_DefaultInstance.Alloc(tex);
		}

		public static RTHandle Alloc(RenderTargetIdentifier tex)
		{
			return s_DefaultInstance.Alloc(tex);
		}

		public static RTHandle Alloc(RenderTargetIdentifier tex, string name)
		{
			return s_DefaultInstance.Alloc(tex, name);
		}

		private static RTHandle Alloc(RTHandle tex)
		{
			Debug.LogError("Allocation a RTHandle from another one is forbidden.");
			return null;
		}

		public static void Initialize(int width, int height)
		{
			s_DefaultInstance.Initialize(width, height);
		}

		[Obsolete("useLegacyDynamicResControl is deprecated. Please use SetHardwareDynamicResolutionState() instead.")]
		public static void Initialize(int width, int height, bool useLegacyDynamicResControl = false)
		{
			s_DefaultInstance.Initialize(width, height, useLegacyDynamicResControl);
		}

		public static void Release(RTHandle rth)
		{
			s_DefaultInstance.Release(rth);
		}

		public static void SetHardwareDynamicResolutionState(bool hwDynamicResRequested)
		{
			s_DefaultInstance.SetHardwareDynamicResolutionState(hwDynamicResRequested);
		}

		public static void SetReferenceSize(int width, int height)
		{
			s_DefaultInstance.SetReferenceSize(width, height);
		}

		public static void ResetReferenceSize(int width, int height)
		{
			s_DefaultInstance.ResetReferenceSize(width, height);
		}

		public static Vector2 CalculateRatioAgainstMaxSize(int width, int height)
		{
			return s_DefaultInstance.CalculateRatioAgainstMaxSize(new Vector2Int(width, height));
		}
	}
	public delegate Vector2Int ScaleFunc(Vector2Int size);
	public struct RTHandleProperties
	{
		public Vector2Int previousViewportSize;

		public Vector2Int previousRenderTargetSize;

		public Vector2Int currentViewportSize;

		public Vector2Int currentRenderTargetSize;

		public Vector4 rtHandleScale;
	}
	public class RTHandleSystem : IDisposable
	{
		internal enum ResizeMode
		{
			Auto,
			OnDemand
		}

		private bool m_HardwareDynamicResRequested;

		private HashSet<RTHandle> m_AutoSizedRTs;

		private RTHandle[] m_AutoSizedRTsArray;

		private HashSet<RTHandle> m_ResizeOnDemandRTs;

		private RTHandleProperties m_RTHandleProperties;

		private int m_MaxWidths;

		private int m_MaxHeights;

		public RTHandleProperties rtHandleProperties => m_RTHandleProperties;

		public RTHandleSystem()
		{
			m_AutoSizedRTs = new HashSet<RTHandle>();
			m_ResizeOnDemandRTs = new HashSet<RTHandle>();
			m_MaxWidths = 1;
			m_MaxHeights = 1;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		public void Initialize(int width, int height)
		{
			if (m_AutoSizedRTs.Count != 0)
			{
				string arg = "Unreleased RTHandles:";
				foreach (RTHandle autoSizedRT in m_AutoSizedRTs)
				{
					arg = $"{arg}\n    {autoSizedRT.name}";
				}
				Debug.LogError($"RTHandle.Initialize should only be called once before allocating any Render Texture. This may be caused by an unreleased RTHandle resource.\n{arg}\n");
			}
			m_MaxWidths = width;
			m_MaxHeights = height;
			m_HardwareDynamicResRequested = DynamicResolutionHandler.instance.RequestsHardwareDynamicResolution();
		}

		[Obsolete("useLegacyDynamicResControl is deprecated. Please use SetHardwareDynamicResolutionState() instead.")]
		public void Initialize(int width, int height, bool useLegacyDynamicResControl = false)
		{
			Initialize(width, height);
			if (useLegacyDynamicResControl)
			{
				m_HardwareDynamicResRequested = true;
			}
		}

		public void Release(RTHandle rth)
		{
			if (rth != null)
			{
				Assert.AreEqual(this, rth.m_Owner);
				rth.Release();
			}
		}

		internal void Remove(RTHandle rth)
		{
			m_AutoSizedRTs.Remove(rth);
		}

		public void ResetReferenceSize(int width, int height)
		{
			m_MaxWidths = width;
			m_MaxHeights = height;
			SetReferenceSize(width, height, reset: true);
		}

		public void SetReferenceSize(int width, int height)
		{
			SetReferenceSize(width, height, reset: false);
		}

		public void SetReferenceSize(int width, int height, bool reset)
		{
			m_RTHandleProperties.previousViewportSize = m_RTHandleProperties.currentViewportSize;
			m_RTHandleProperties.previousRenderTargetSize = m_RTHandleProperties.currentRenderTargetSize;
			Vector2 vector = new Vector2(GetMaxWidth(), GetMaxHeight());
			width = Mathf.Max(width, 1);
			height = Mathf.Max(height, 1);
			bool flag = width > GetMaxWidth() || height > GetMaxHeight() || reset;
			if (flag)
			{
				Resize(width, height, flag);
			}
			m_RTHandleProperties.currentViewportSize = new Vector2Int(width, height);
			m_RTHandleProperties.currentRenderTargetSize = new Vector2Int(GetMaxWidth(), GetMaxHeight());
			if (m_RTHandleProperties.previousViewportSize.x == 0)
			{
				m_RTHandleProperties.previousViewportSize = m_RTHandleProperties.currentViewportSize;
				m_RTHandleProperties.previousRenderTargetSize = m_RTHandleProperties.currentRenderTargetSize;
				vector = new Vector2(GetMaxWidth(), GetMaxHeight());
			}
			Vector2 vector2 = CalculateRatioAgainstMaxSize(in m_RTHandleProperties.currentViewportSize);
			if (DynamicResolutionHandler.instance.HardwareDynamicResIsEnabled() && m_HardwareDynamicResRequested)
			{
				m_RTHandleProperties.rtHandleScale = new Vector4(vector2.x, vector2.y, m_RTHandleProperties.rtHandleScale.x, m_RTHandleProperties.rtHandleScale.y);
				return;
			}
			Vector2 vector3 = m_RTHandleProperties.previousViewportSize / vector;
			m_RTHandleProperties.rtHandleScale = new Vector4(vector2.x, vector2.y, vector3.x, vector3.y);
		}

		internal Vector2 CalculateRatioAgainstMaxSize(in Vector2Int viewportSize)
		{
			Vector2 vector = new Vector2(GetMaxWidth(), GetMaxHeight());
			if (DynamicResolutionHandler.instance.HardwareDynamicResIsEnabled() && m_HardwareDynamicResRequested && viewportSize != DynamicResolutionHandler.instance.finalViewport)
			{
				Vector2 scales = (Vector2)viewportSize / (Vector2)DynamicResolutionHandler.instance.finalViewport;
				vector = DynamicResolutionHandler.instance.ApplyScalesOnSize(new Vector2Int(GetMaxWidth(), GetMaxHeight()), scales);
			}
			return new Vector2((float)viewportSize.x / vector.x, (float)viewportSize.y / vector.y);
		}

		public void SetHardwareDynamicResolutionState(bool enableHWDynamicRes)
		{
			if (enableHWDynamicRes == m_HardwareDynamicResRequested)
			{
				return;
			}
			m_HardwareDynamicResRequested = enableHWDynamicRes;
			Array.Resize(ref m_AutoSizedRTsArray, m_AutoSizedRTs.Count);
			m_AutoSizedRTs.CopyTo(m_AutoSizedRTsArray);
			int i = 0;
			for (int num = m_AutoSizedRTsArray.Length; i < num; i++)
			{
				RTHandle rTHandle = m_AutoSizedRTsArray[i];
				RenderTexture rT = rTHandle.m_RT;
				if ((bool)rT)
				{
					rT.Release();
					rT.useDynamicScale = m_HardwareDynamicResRequested && rTHandle.m_EnableHWDynamicScale;
					rT.Create();
				}
			}
		}

		internal void SwitchResizeMode(RTHandle rth, ResizeMode mode)
		{
			if (!rth.useScaling)
			{
				return;
			}
			switch (mode)
			{
			case ResizeMode.OnDemand:
				m_AutoSizedRTs.Remove(rth);
				m_ResizeOnDemandRTs.Add(rth);
				break;
			case ResizeMode.Auto:
				if (m_ResizeOnDemandRTs.Contains(rth))
				{
					DemandResize(rth);
				}
				m_ResizeOnDemandRTs.Remove(rth);
				m_AutoSizedRTs.Add(rth);
				break;
			}
		}

		private void DemandResize(RTHandle rth)
		{
			Assert.IsTrue(m_ResizeOnDemandRTs.Contains(rth), "The RTHandle is not an resize on demand handle in this RTHandleSystem. Please call SwitchToResizeOnDemand(rth, true) before resizing on demand.");
			RenderTexture rT = rth.m_RT;
			rth.referenceSize = new Vector2Int(m_MaxWidths, m_MaxHeights);
			Vector2Int scaledSize = rth.GetScaledSize(rth.referenceSize);
			scaledSize = Vector2Int.Max(Vector2Int.one, scaledSize);
			if (rT.width != scaledSize.x || rT.height != scaledSize.y)
			{
				rT.Release();
				rT.width = scaledSize.x;
				rT.height = scaledSize.y;
				rT.name = CoreUtils.GetRenderTargetAutoName(rT.width, rT.height, rT.volumeDepth, rT.graphicsFormat, rT.dimension, rth.m_Name, rT.useMipMap, rth.m_EnableMSAA, (MSAASamples)rT.antiAliasing, rT.useDynamicScale);
				rT.Create();
			}
		}

		public int GetMaxWidth()
		{
			return m_MaxWidths;
		}

		public int GetMaxHeight()
		{
			return m_MaxHeights;
		}

		private void Dispose(bool disposing)
		{
			if (disposing)
			{
				Array.Resize(ref m_AutoSizedRTsArray, m_AutoSizedRTs.Count);
				m_AutoSizedRTs.CopyTo(m_AutoSizedRTsArray);
				int i = 0;
				for (int num = m_AutoSizedRTsArray.Length; i < num; i++)
				{
					RTHandle rth = m_AutoSizedRTsArray[i];
					Release(rth);
				}
				m_AutoSizedRTs.Clear();
				Array.Resize(ref m_AutoSizedRTsArray, m_ResizeOnDemandRTs.Count);
				m_ResizeOnDemandRTs.CopyTo(m_AutoSizedRTsArray);
				int j = 0;
				for (int num2 = m_AutoSizedRTsArray.Length; j < num2; j++)
				{
					RTHandle rth2 = m_AutoSizedRTsArray[j];
					Release(rth2);
				}
				m_ResizeOnDemandRTs.Clear();
				m_AutoSizedRTsArray = null;
			}
		}

		private void Resize(int width, int height, bool sizeChanged)
		{
			m_MaxWidths = Math.Max(width, m_MaxWidths);
			m_MaxHeights = Math.Max(height, m_MaxHeights);
			Vector2Int vector2Int = new Vector2Int(m_MaxWidths, m_MaxHeights);
			Array.Resize(ref m_AutoSizedRTsArray, m_AutoSizedRTs.Count);
			m_AutoSizedRTs.CopyTo(m_AutoSizedRTsArray);
			int i = 0;
			for (int num = m_AutoSizedRTsArray.Length; i < num; i++)
			{
				RTHandle rTHandle = m_AutoSizedRTsArray[i];
				rTHandle.referenceSize = vector2Int;
				RenderTexture rT = rTHandle.m_RT;
				rT.Release();
				Vector2Int scaledSize = rTHandle.GetScaledSize(vector2Int);
				rT.width = Mathf.Max(scaledSize.x, 1);
				rT.height = Mathf.Max(scaledSize.y, 1);
				rT.name = CoreUtils.GetRenderTargetAutoName(rT.width, rT.height, rT.volumeDepth, rT.graphicsFormat, rT.dimension, rTHandle.m_Name, rT.useMipMap, rTHandle.m_EnableMSAA, (MSAASamples)rT.antiAliasing, rT.useDynamicScale);
				rT.Create();
			}
		}

		public RTHandle Alloc(int width, int height, int slices = 1, DepthBits depthBufferBits = DepthBits.None, GraphicsFormat colorFormat = GraphicsFormat.R8G8B8A8_SRGB, FilterMode filterMode = FilterMode.Point, TextureWrapMode wrapMode = TextureWrapMode.Repeat, TextureDimension dimension = TextureDimension.Tex2D, bool enableRandomWrite = false, bool useMipMap = false, bool autoGenerateMips = true, bool isShadowMap = false, int anisoLevel = 1, float mipMapBias = 0f, MSAASamples msaaSamples = MSAASamples.None, bool bindTextureMS = false, bool useDynamicScale = false, RenderTextureMemoryless memoryless = RenderTextureMemoryless.None, VRTextureUsage vrUsage = VRTextureUsage.None, string name = "")
		{
			return Alloc(width, height, wrapMode, wrapMode, wrapMode, slices, depthBufferBits, colorFormat, filterMode, dimension, enableRandomWrite, useMipMap, autoGenerateMips, isShadowMap, anisoLevel, mipMapBias, msaaSamples, bindTextureMS, useDynamicScale, memoryless, vrUsage, name);
		}

		public RTHandle Alloc(int width, int height, TextureWrapMode wrapModeU, TextureWrapMode wrapModeV, TextureWrapMode wrapModeW = TextureWrapMode.Repeat, int slices = 1, DepthBits depthBufferBits = DepthBits.None, GraphicsFormat colorFormat = GraphicsFormat.R8G8B8A8_SRGB, FilterMode filterMode = FilterMode.Point, TextureDimension dimension = TextureDimension.Tex2D, bool enableRandomWrite = false, bool useMipMap = false, bool autoGenerateMips = true, bool isShadowMap = false, int anisoLevel = 1, float mipMapBias = 0f, MSAASamples msaaSamples = MSAASamples.None, bool bindTextureMS = false, bool useDynamicScale = false, RenderTextureMemoryless memoryless = RenderTextureMemoryless.None, VRTextureUsage vrUsage = VRTextureUsage.None, string name = "")
		{
			bool flag = msaaSamples != MSAASamples.None;
			if (!flag && bindTextureMS)
			{
				Debug.LogWarning("RTHandle allocated without MSAA but with bindMS set to true, forcing bindMS to false.");
				bindTextureMS = false;
			}
			RenderTexture renderTexture;
			if (isShadowMap || depthBufferBits != DepthBits.None)
			{
				RenderTextureFormat format = ((!isShadowMap) ? RenderTextureFormat.Depth : RenderTextureFormat.Shadowmap);
				GraphicsFormat stencilFormat = ((!isShadowMap && SystemInfo.IsFormatSupported(GraphicsFormat.R8_UInt, FormatUsage.StencilSampling)) ? GraphicsFormat.R8_UInt : GraphicsFormat.None);
				renderTexture = new RenderTexture(width, height, (int)depthBufferBits, format, RenderTextureReadWrite.Linear)
				{
					hideFlags = HideFlags.HideAndDontSave,
					volumeDepth = slices,
					filterMode = filterMode,
					wrapModeU = wrapModeU,
					wrapModeV = wrapModeV,
					wrapModeW = wrapModeW,
					dimension = dimension,
					enableRandomWrite = enableRandomWrite,
					useMipMap = useMipMap,
					autoGenerateMips = autoGenerateMips,
					anisoLevel = anisoLevel,
					mipMapBias = mipMapBias,
					stencilFormat = stencilFormat,
					antiAliasing = (int)msaaSamples,
					bindTextureMS = bindTextureMS,
					useDynamicScale = (m_HardwareDynamicResRequested && useDynamicScale),
					memorylessMode = memoryless,
					vrUsage = vrUsage,
					name = CoreUtils.GetRenderTargetAutoName(width, height, slices, format, name, useMipMap, flag, msaaSamples)
				};
			}
			else
			{
				renderTexture = new RenderTexture(width, height, (int)depthBufferBits, colorFormat)
				{
					hideFlags = HideFlags.HideAndDontSave,
					volumeDepth = slices,
					filterMode = filterMode,
					wrapModeU = wrapModeU,
					wrapModeV = wrapModeV,
					wrapModeW = wrapModeW,
					dimension = dimension,
					enableRandomWrite = enableRandomWrite,
					useMipMap = useMipMap,
					autoGenerateMips = autoGenerateMips,
					anisoLevel = anisoLevel,
					mipMapBias = mipMapBias,
					antiAliasing = (int)msaaSamples,
					bindTextureMS = bindTextureMS,
					useDynamicScale = (m_HardwareDynamicResRequested && useDynamicScale),
					memorylessMode = memoryless,
					vrUsage = vrUsage,
					name = CoreUtils.GetRenderTargetAutoName(width, height, slices, colorFormat, dimension, name, useMipMap, flag, msaaSamples, useDynamicScale)
				};
			}
			renderTexture.Create();
			RTHandle rTHandle = new RTHandle(this);
			rTHandle.SetRenderTexture(renderTexture);
			rTHandle.useScaling = false;
			rTHandle.m_EnableRandomWrite = enableRandomWrite;
			rTHandle.m_EnableMSAA = flag;
			rTHandle.m_EnableHWDynamicScale = useDynamicScale;
			rTHandle.m_Name = name;
			rTHandle.referenceSize = new Vector2Int(width, height);
			return rTHandle;
		}

		public RTHandle Alloc(Vector2 scaleFactor, int slices = 1, DepthBits depthBufferBits = DepthBits.None, GraphicsFormat colorFormat = GraphicsFormat.R8G8B8A8_SRGB, FilterMode filterMode = FilterMode.Point, TextureWrapMode wrapMode = TextureWrapMode.Repeat, TextureDimension dimension = TextureDimension.Tex2D, bool enableRandomWrite = false, bool useMipMap = false, bool autoGenerateMips = true, bool isShadowMap = false, int anisoLevel = 1, float mipMapBias = 0f, MSAASamples msaaSamples = MSAASamples.None, bool bindTextureMS = false, bool useDynamicScale = false, RenderTextureMemoryless memoryless = RenderTextureMemoryless.None, VRTextureUsage vrUsage = VRTextureUsage.None, string name = "")
		{
			int num = Mathf.Max(Mathf.RoundToInt(scaleFactor.x * (float)GetMaxWidth()), 1);
			int num2 = Mathf.Max(Mathf.RoundToInt(scaleFactor.y * (float)GetMaxHeight()), 1);
			RTHandle rTHandle = AllocAutoSizedRenderTexture(num, num2, slices, depthBufferBits, colorFormat, filterMode, wrapMode, dimension, enableRandomWrite, useMipMap, autoGenerateMips, isShadowMap, anisoLevel, mipMapBias, msaaSamples, bindTextureMS, useDynamicScale, memoryless, vrUsage, name);
			rTHandle.referenceSize = new Vector2Int(num, num2);
			rTHandle.scaleFactor = scaleFactor;
			return rTHandle;
		}

		public RTHandle Alloc(ScaleFunc scaleFunc, int slices = 1, DepthBits depthBufferBits = DepthBits.None, GraphicsFormat colorFormat = GraphicsFormat.R8G8B8A8_SRGB, FilterMode filterMode = FilterMode.Point, TextureWrapMode wrapMode = TextureWrapMode.Repeat, TextureDimension dimension = TextureDimension.Tex2D, bool enableRandomWrite = false, bool useMipMap = false, bool autoGenerateMips = true, bool isShadowMap = false, int anisoLevel = 1, float mipMapBias = 0f, MSAASamples msaaSamples = MSAASamples.None, bool bindTextureMS = false, bool useDynamicScale = false, RenderTextureMemoryless memoryless = RenderTextureMemoryless.None, VRTextureUsage vrUsage = VRTextureUsage.None, string name = "")
		{
			Vector2Int vector2Int = scaleFunc(new Vector2Int(GetMaxWidth(), GetMaxHeight()));
			int num = Mathf.Max(vector2Int.x, 1);
			int num2 = Mathf.Max(vector2Int.y, 1);
			RTHandle rTHandle = AllocAutoSizedRenderTexture(num, num2, slices, depthBufferBits, colorFormat, filterMode, wrapMode, dimension, enableRandomWrite, useMipMap, autoGenerateMips, isShadowMap, anisoLevel, mipMapBias, msaaSamples, bindTextureMS, useDynamicScale, memoryless, vrUsage, name);
			rTHandle.referenceSize = new Vector2Int(num, num2);
			rTHandle.scaleFunc = scaleFunc;
			return rTHandle;
		}

		private RTHandle AllocAutoSizedRenderTexture(int width, int height, int slices, DepthBits depthBufferBits, GraphicsFormat colorFormat, FilterMode filterMode, TextureWrapMode wrapMode, TextureDimension dimension, bool enableRandomWrite, bool useMipMap, bool autoGenerateMips, bool isShadowMap, int anisoLevel, float mipMapBias, MSAASamples msaaSamples, bool bindTextureMS, bool useDynamicScale, RenderTextureMemoryless memoryless, VRTextureUsage vrUsage, string name)
		{
			bool flag = msaaSamples != MSAASamples.None;
			if (!flag && bindTextureMS)
			{
				Debug.LogWarning("RTHandle allocated without MSAA but with bindMS set to true, forcing bindMS to false.");
				bindTextureMS = false;
			}
			if (flag && enableRandomWrite)
			{
				Debug.LogWarning("RTHandle that is MSAA-enabled cannot allocate MSAA RT with 'enableRandomWrite = true'.");
				enableRandomWrite = false;
			}
			RenderTexture renderTexture;
			if (isShadowMap || depthBufferBits != DepthBits.None)
			{
				RenderTextureFormat format = ((!isShadowMap) ? RenderTextureFormat.Depth : RenderTextureFormat.Shadowmap);
				GraphicsFormat stencilFormat = ((!isShadowMap && SystemInfo.IsFormatSupported(GraphicsFormat.R8_UInt, FormatUsage.StencilSampling)) ? GraphicsFormat.R8_UInt : GraphicsFormat.None);
				renderTexture = new RenderTexture(width, height, (int)depthBufferBits, format, RenderTextureReadWrite.Linear)
				{
					hideFlags = HideFlags.HideAndDontSave,
					volumeDepth = slices,
					filterMode = filterMode,
					wrapMode = wrapMode,
					dimension = dimension,
					enableRandomWrite = enableRandomWrite,
					useMipMap = useMipMap,
					autoGenerateMips = autoGenerateMips,
					anisoLevel = anisoLevel,
					mipMapBias = mipMapBias,
					antiAliasing = (int)msaaSamples,
					bindTextureMS = bindTextureMS,
					useDynamicScale = (m_HardwareDynamicResRequested && useDynamicScale),
					memorylessMode = memoryless,
					stencilFormat = stencilFormat,
					vrUsage = vrUsage,
					name = CoreUtils.GetRenderTargetAutoName(width, height, slices, colorFormat, dimension, name, useMipMap, flag, msaaSamples, useDynamicScale)
				};
			}
			else
			{
				renderTexture = new RenderTexture(width, height, (int)depthBufferBits, colorFormat)
				{
					hideFlags = HideFlags.HideAndDontSave,
					volumeDepth = slices,
					filterMode = filterMode,
					wrapMode = wrapMode,
					dimension = dimension,
					enableRandomWrite = enableRandomWrite,
					useMipMap = useMipMap,
					autoGenerateMips = autoGenerateMips,
					anisoLevel = anisoLevel,
					mipMapBias = mipMapBias,
					antiAliasing = (int)msaaSamples,
					bindTextureMS = bindTextureMS,
					useDynamicScale = (m_HardwareDynamicResRequested && useDynamicScale),
					memorylessMode = memoryless,
					vrUsage = vrUsage,
					name = CoreUtils.GetRenderTargetAutoName(width, height, slices, colorFormat, dimension, name, useMipMap, flag, msaaSamples, useDynamicScale)
				};
			}
			renderTexture.Create();
			RTHandle rTHandle = new RTHandle(this);
			rTHandle.SetRenderTexture(renderTexture);
			rTHandle.m_EnableMSAA = flag;
			rTHandle.m_EnableRandomWrite = enableRandomWrite;
			rTHandle.useScaling = true;
			rTHandle.m_EnableHWDynamicScale = useDynamicScale;
			rTHandle.m_Name = name;
			m_AutoSizedRTs.Add(rTHandle);
			return rTHandle;
		}

		public RTHandle Alloc(RenderTexture texture)
		{
			RTHandle rTHandle = new RTHandle(this);
			rTHandle.SetRenderTexture(texture);
			rTHandle.m_EnableMSAA = false;
			rTHandle.m_EnableRandomWrite = false;
			rTHandle.useScaling = false;
			rTHandle.m_EnableHWDynamicScale = false;
			rTHandle.m_Name = texture.name;
			return rTHandle;
		}

		public RTHandle Alloc(Texture texture)
		{
			RTHandle rTHandle = new RTHandle(this);
			rTHandle.SetTexture(texture);
			rTHandle.m_EnableMSAA = false;
			rTHandle.m_EnableRandomWrite = false;
			rTHandle.useScaling = false;
			rTHandle.m_EnableHWDynamicScale = false;
			rTHandle.m_Name = texture.name;
			return rTHandle;
		}

		public RTHandle Alloc(RenderTargetIdentifier texture)
		{
			return Alloc(texture, "");
		}

		public RTHandle Alloc(RenderTargetIdentifier texture, string name)
		{
			RTHandle rTHandle = new RTHandle(this);
			rTHandle.SetTexture(texture);
			rTHandle.m_EnableMSAA = false;
			rTHandle.m_EnableRandomWrite = false;
			rTHandle.useScaling = false;
			rTHandle.m_EnableHWDynamicScale = false;
			rTHandle.m_Name = name;
			return rTHandle;
		}

		private static RTHandle Alloc(RTHandle tex)
		{
			Debug.LogError("Allocation a RTHandle from another one is forbidden.");
			return null;
		}

		internal string DumpRTInfo()
		{
			string text = "";
			Array.Resize(ref m_AutoSizedRTsArray, m_AutoSizedRTs.Count);
			m_AutoSizedRTs.CopyTo(m_AutoSizedRTsArray);
			int i = 0;
			for (int num = m_AutoSizedRTsArray.Length; i < num; i++)
			{
				RenderTexture rt = m_AutoSizedRTsArray[i].rt;
				text = $"{text}\nRT ({i})\t Format: {rt.format} W: {rt.width} H {rt.height}\n";
			}
			return text;
		}
	}
	internal class AtlasAllocator
	{
		private class AtlasNode
		{
			public AtlasNode m_RightChild;

			public AtlasNode m_BottomChild;

			public Vector4 m_Rect = new Vector4(0f, 0f, 0f, 0f);

			public AtlasNode Allocate(ref ObjectPool<AtlasNode> pool, int width, int height, bool powerOfTwoPadding)
			{
				if (m_RightChild != null)
				{
					AtlasNode atlasNode = m_RightChild.Allocate(ref pool, width, height, powerOfTwoPadding);
					if (atlasNode == null)
					{
						atlasNode = m_BottomChild.Allocate(ref pool, width, height, powerOfTwoPadding);
					}
					return atlasNode;
				}
				int num = 0;
				int num2 = 0;
				if (powerOfTwoPadding)
				{
					num = (int)m_Rect.x % width;
					num2 = (int)m_Rect.y % height;
				}
				if ((float)width <= m_Rect.x - (float)num && (float)height <= m_Rect.y - (float)num2)
				{
					m_RightChild = pool.Get();
					m_BottomChild = pool.Get();
					m_Rect.z += num;
					m_Rect.w += num2;
					m_Rect.x -= num;
					m_Rect.y -= num2;
					if (width > height)
					{
						m_RightChild.m_Rect.z = m_Rect.z + (float)width;
						m_RightChild.m_Rect.w = m_Rect.w;
						m_RightChild.m_Rect.x = m_Rect.x - (float)width;
						m_RightChild.m_Rect.y = height;
						m_BottomChild.m_Rect.z = m_Rect.z;
						m_BottomChild.m_Rect.w = m_Rect.w + (float)height;
						m_BottomChild.m_Rect.x = m_Rect.x;
						m_BottomChild.m_Rect.y = m_Rect.y - (float)height;
					}
					else
					{
						m_RightChild.m_Rect.z = m_Rect.z + (float)width;
						m_RightChild.m_Rect.w = m_Rect.w;
						m_RightChild.m_Rect.x = m_Rect.x - (float)width;
						m_RightChild.m_Rect.y = m_Rect.y;
						m_BottomChild.m_Rect.z = m_Rect.z;
						m_BottomChild.m_Rect.w = m_Rect.w + (float)height;
						m_BottomChild.m_Rect.x = width;
						m_BottomChild.m_Rect.y = m_Rect.y - (float)height;
					}
					m_Rect.x = width;
					m_Rect.y = height;
					return this;
				}
				return null;
			}

			public void Release(ref ObjectPool<AtlasNode> pool)
			{
				if (m_RightChild != null)
				{
					m_RightChild.Release(ref pool);
					m_BottomChild.Release(ref pool);
					pool.Release(m_RightChild);
					pool.Release(m_BottomChild);
				}
				m_RightChild = null;
				m_BottomChild = null;
				m_Rect = Vector4.zero;
			}
		}

		private AtlasNode m_Root;

		private int m_Width;

		private int m_Height;

		private bool powerOfTwoPadding;

		private ObjectPool<AtlasNode> m_NodePool;

		public AtlasAllocator(int width, int height, bool potPadding)
		{
			m_Root = new AtlasNode();
			m_Root.m_Rect.Set(width, height, 0f, 0f);
			m_Width = width;
			m_Height = height;
			powerOfTwoPadding = potPadding;
			m_NodePool = new ObjectPool<AtlasNode>(delegate
			{
			}, delegate
			{
			});
		}

		public bool Allocate(ref Vector4 result, int width, int height)
		{
			AtlasNode atlasNode = m_Root.Allocate(ref m_NodePool, width, height, powerOfTwoPadding);
			if (atlasNode != null)
			{
				result = atlasNode.m_Rect;
				return true;
			}
			result = Vector4.zero;
			return false;
		}

		public void Reset()
		{
			m_Root.Release(ref m_NodePool);
			m_Root.m_Rect.Set(m_Width, m_Height, 0f, 0f);
		}
	}
	public class Texture2DAtlas
	{
		private enum BlitType
		{
			Default,
			CubeTo2DOctahedral,
			SingleChannel,
			CubeTo2DOctahedralSingleChannel
		}

		private protected const int kGPUTexInvalid = 0;

		private protected const int kGPUTexValidMip0 = 1;

		private protected const int kGPUTexValidMipAll = 2;

		private protected RTHandle m_AtlasTexture;

		private protected int m_Width;

		private protected int m_Height;

		private protected GraphicsFormat m_Format;

		private protected bool m_UseMipMaps;

		private bool m_IsAtlasTextureOwner;

		private AtlasAllocator m_AtlasAllocator;

		private Dictionary<int, (Vector4 scaleOffset, Vector2Int size)> m_AllocationCache = new Dictionary<int, (Vector4, Vector2Int)>();

		private Dictionary<int, int> m_IsGPUTextureUpToDate = new Dictionary<int, int>();

		private Dictionary<int, int> m_TextureHashes = new Dictionary<int, int>();

		private static readonly Vector4 fullScaleOffset = new Vector4(1f, 1f, 0f, 0f);

		private static readonly int s_MaxMipLevelPadding = 10;

		public static int maxMipLevelPadding => s_MaxMipLevelPadding;

		public RTHandle AtlasTexture => m_AtlasTexture;

		public Texture2DAtlas(int width, int height, GraphicsFormat format, FilterMode filterMode = FilterMode.Point, bool powerOfTwoPadding = false, string name = "", bool useMipMap = true)
		{
			m_Width = width;
			m_Height = height;
			m_Format = format;
			m_UseMipMaps = useMipMap;
			m_AtlasTexture = RTHandles.Alloc(m_Width, m_Height, 1, DepthBits.None, m_Format, filterMode, TextureWrapMode.Clamp, TextureDimension.Tex2D, enableRandomWrite: false, useMipMap, autoGenerateMips: false, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, name);
			m_IsAtlasTextureOwner = true;
			int num = ((!useMipMap) ? 1 : GetTextureMipmapCount(m_Width, m_Height));
			for (int i = 0; i < num; i++)
			{
				Graphics.SetRenderTarget(m_AtlasTexture, i);
				GL.Clear(clearDepth: false, clearColor: true, Color.clear);
			}
			m_AtlasAllocator = new AtlasAllocator(width, height, powerOfTwoPadding);
		}

		public void Release()
		{
			ResetAllocator();
			if (m_IsAtlasTextureOwner)
			{
				RTHandles.Release(m_AtlasTexture);
			}
		}

		public void ResetAllocator()
		{
			m_AtlasAllocator.Reset();
			m_AllocationCache.Clear();
			m_IsGPUTextureUpToDate.Clear();
		}

		public void ClearTarget(CommandBuffer cmd)
		{
			int num = ((!m_UseMipMaps) ? 1 : GetTextureMipmapCount(m_Width, m_Height));
			for (int i = 0; i < num; i++)
			{
				cmd.SetRenderTarget(m_AtlasTexture, i);
				Blitter.BlitQuad(cmd, Texture2D.blackTexture, fullScaleOffset, fullScaleOffset, i, bilinear: true);
			}
			m_IsGPUTextureUpToDate.Clear();
		}

		private protected int GetTextureMipmapCount(int width, int height)
		{
			if (!m_UseMipMaps)
			{
				return 1;
			}
			return Mathf.FloorToInt(Mathf.Log(Mathf.Max(width, height), 2f)) + 1;
		}

		private protected bool Is2D(Texture texture)
		{
			RenderTexture renderTexture = texture as RenderTexture;
			if (!(texture is Texture2D))
			{
				if ((object)renderTexture == null)
				{
					return false;
				}
				return renderTexture.dimension == TextureDimension.Tex2D;
			}
			return true;
		}

		private protected bool IsSingleChannelBlit(Texture source, Texture destination)
		{
			uint componentCount = GraphicsFormatUtility.GetComponentCount(source.graphicsFormat);
			uint componentCount2 = GraphicsFormatUtility.GetComponentCount(destination.graphicsFormat);
			if (componentCount == 1 || componentCount2 == 1)
			{
				if (componentCount != componentCount2)
				{
					return true;
				}
				int num = (1 << (int)(GraphicsFormatUtility.GetSwizzleA(source.graphicsFormat) & (FormatSwizzle)7) << 24) | (1 << (int)(GraphicsFormatUtility.GetSwizzleB(source.graphicsFormat) & (FormatSwizzle)7) << 16) | (1 << (int)(GraphicsFormatUtility.GetSwizzleG(source.graphicsFormat) & (FormatSwizzle)7) << 8) | (1 << (int)(GraphicsFormatUtility.GetSwizzleR(source.graphicsFormat) & (FormatSwizzle)7));
				int num2 = (1 << (int)(GraphicsFormatUtility.GetSwizzleA(destination.graphicsFormat) & (FormatSwizzle)7) << 24) | (1 << (int)(GraphicsFormatUtility.GetSwizzleB(destination.graphicsFormat) & (FormatSwizzle)7) << 16) | (1 << (int)(GraphicsFormatUtility.GetSwizzleG(destination.graphicsFormat) & (FormatSwizzle)7) << 8) | (1 << (int)(GraphicsFormatUtility.GetSwizzleR(destination.graphicsFormat) & (FormatSwizzle)7));
				if (num != num2)
				{
					return true;
				}
			}
			return false;
		}

		private void Blit2DTexture(CommandBuffer cmd, Vector4 scaleOffset, Texture texture, Vector4 sourceScaleOffset, bool blitMips, BlitType blitType)
		{
			int num = GetTextureMipmapCount(texture.width, texture.height);
			if (!blitMips)
			{
				num = 1;
			}
			for (int i = 0; i < num; i++)
			{
				cmd.SetRenderTarget(m_AtlasTexture, i);
				switch (blitType)
				{
				case BlitType.Default:
					Blitter.BlitQuad(cmd, texture, sourceScaleOffset, scaleOffset, i, bilinear: true);
					break;
				case BlitType.CubeTo2DOctahedral:
					Blitter.BlitCubeToOctahedral2DQuad(cmd, texture, scaleOffset, i);
					break;
				case BlitType.SingleChannel:
					Blitter.BlitQuadSingleChannel(cmd, texture, sourceScaleOffset, scaleOffset, i);
					break;
				case BlitType.CubeTo2DOctahedralSingleChannel:
					Blitter.BlitCubeToOctahedral2DQuadSingleChannel(cmd, texture, scaleOffset, i);
					break;
				}
			}
		}

		private protected void MarkGPUTextureValid(int instanceId, bool mipAreValid = false)
		{
			m_IsGPUTextureUpToDate[instanceId] = ((!mipAreValid) ? 1 : 2);
		}

		private protected void MarkGPUTextureInvalid(int instanceId)
		{
			m_IsGPUTextureUpToDate[instanceId] = 0;
		}

		public virtual void BlitTexture(CommandBuffer cmd, Vector4 scaleOffset, Texture texture, Vector4 sourceScaleOffset, bool blitMips = true, int overrideInstanceID = -1)
		{
			if (Is2D(texture))
			{
				BlitType blitType = BlitType.Default;
				if (IsSingleChannelBlit(texture, m_AtlasTexture.m_RT))
				{
					blitType = BlitType.SingleChannel;
				}
				Blit2DTexture(cmd, scaleOffset, texture, sourceScaleOffset, blitMips, blitType);
				int num = ((overrideInstanceID != -1) ? overrideInstanceID : GetTextureID(texture));
				MarkGPUTextureValid(num, blitMips);
				m_TextureHashes[num] = CoreUtils.GetTextureHash(texture);
			}
		}

		public virtual void BlitOctahedralTexture(CommandBuffer cmd, Vector4 scaleOffset, Texture texture, Vector4 sourceScaleOffset, bool blitMips = true, int overrideInstanceID = -1)
		{
			BlitTexture(cmd, scaleOffset, texture, sourceScaleOffset, blitMips, overrideInstanceID);
		}

		public virtual void BlitCubeTexture2D(CommandBuffer cmd, Vector4 scaleOffset, Texture texture, bool blitMips = true, int overrideInstanceID = -1)
		{
			Debug.Assert(texture.dimension == TextureDimension.Cube);
			if (texture.dimension == TextureDimension.Cube)
			{
				BlitType blitType = BlitType.CubeTo2DOctahedral;
				if (IsSingleChannelBlit(texture, m_AtlasTexture.m_RT))
				{
					blitType = BlitType.CubeTo2DOctahedralSingleChannel;
				}
				Blit2DTexture(cmd, scaleOffset, texture, new Vector4(1f, 1f, 0f, 0f), blitMips, blitType);
				int num = ((overrideInstanceID != -1) ? overrideInstanceID : GetTextureID(texture));
				MarkGPUTextureValid(num, blitMips);
				m_TextureHashes[num] = CoreUtils.GetTextureHash(texture);
			}
		}

		public virtual bool AllocateTexture(CommandBuffer cmd, ref Vector4 scaleOffset, Texture texture, int width, int height, int overrideInstanceID = -1)
		{
			int num = ((overrideInstanceID != -1) ? overrideInstanceID : GetTextureID(texture));
			bool num2 = AllocateTextureWithoutBlit(num, width, height, ref scaleOffset);
			if (num2)
			{
				if (Is2D(texture))
				{
					BlitTexture(cmd, scaleOffset, texture, fullScaleOffset);
				}
				else
				{
					BlitCubeTexture2D(cmd, scaleOffset, texture);
				}
				MarkGPUTextureValid(num, mipAreValid: true);
				m_TextureHashes[num] = CoreUtils.GetTextureHash(texture);
			}
			return num2;
		}

		public bool AllocateTextureWithoutBlit(Texture texture, int width, int height, ref Vector4 scaleOffset)
		{
			return AllocateTextureWithoutBlit(texture.GetInstanceID(), width, height, ref scaleOffset);
		}

		public virtual bool AllocateTextureWithoutBlit(int instanceId, int width, int height, ref Vector4 scaleOffset)
		{
			scaleOffset = Vector4.zero;
			if (m_AtlasAllocator.Allocate(ref scaleOffset, width, height))
			{
				scaleOffset.Scale(new Vector4(1f / (float)m_Width, 1f / (float)m_Height, 1f / (float)m_Width, 1f / (float)m_Height));
				m_AllocationCache[instanceId] = (scaleOffset, new Vector2Int(width, height));
				MarkGPUTextureInvalid(instanceId);
				m_TextureHashes[instanceId] = -1;
				return true;
			}
			return false;
		}

		private protected int GetTextureHash(Texture textureA, Texture textureB)
		{
			return CoreUtils.GetTextureHash(textureA) + 23 * CoreUtils.GetTextureHash(textureB);
		}

		public int GetTextureID(Texture texture)
		{
			return texture.GetInstanceID();
		}

		public int GetTextureID(Texture textureA, Texture textureB)
		{
			return GetTextureID(textureA) + 23 * GetTextureID(textureB);
		}

		public bool IsCached(out Vector4 scaleOffset, Texture textureA, Texture textureB)
		{
			return IsCached(out scaleOffset, GetTextureID(textureA, textureB));
		}

		public bool IsCached(out Vector4 scaleOffset, Texture texture)
		{
			return IsCached(out scaleOffset, GetTextureID(texture));
		}

		public bool IsCached(out Vector4 scaleOffset, int id)
		{
			(Vector4, Vector2Int) value;
			bool result = m_AllocationCache.TryGetValue(id, out value);
			(scaleOffset, _) = value;
			return result;
		}

		internal Vector2Int GetCachedTextureSize(int id)
		{
			m_AllocationCache.TryGetValue(id, out (Vector4, Vector2Int) value);
			return value.Item2;
		}

		public virtual bool NeedsUpdate(Texture texture, bool needMips = false)
		{
			RenderTexture renderTexture = texture as RenderTexture;
			int textureID = GetTextureID(texture);
			int textureHash = CoreUtils.GetTextureHash(texture);
			if (renderTexture != null)
			{
				if (m_IsGPUTextureUpToDate.TryGetValue(textureID, out var value))
				{
					if (renderTexture.updateCount != value)
					{
						m_IsGPUTextureUpToDate[textureID] = (int)renderTexture.updateCount;
						return true;
					}
				}
				else
				{
					m_IsGPUTextureUpToDate[textureID] = (int)renderTexture.updateCount;
				}
			}
			else
			{
				if (m_TextureHashes.TryGetValue(textureID, out var value2) && value2 != textureHash)
				{
					m_TextureHashes[textureID] = textureHash;
					return true;
				}
				if (m_IsGPUTextureUpToDate.TryGetValue(textureID, out var value3))
				{
					if (value3 != 0)
					{
						if (needMips)
						{
							return value3 == 1;
						}
						return false;
					}
					return true;
				}
			}
			return false;
		}

		public virtual bool NeedsUpdate(Texture textureA, Texture textureB, bool needMips = false)
		{
			RenderTexture renderTexture = textureA as RenderTexture;
			RenderTexture renderTexture2 = textureB as RenderTexture;
			int textureID = GetTextureID(textureA, textureB);
			int textureHash = GetTextureHash(textureA, textureB);
			if (renderTexture != null || renderTexture2 != null)
			{
				if (m_IsGPUTextureUpToDate.TryGetValue(textureID, out var value))
				{
					if (renderTexture != null && renderTexture2 != null && Math.Min(renderTexture.updateCount, renderTexture2.updateCount) != value)
					{
						m_IsGPUTextureUpToDate[textureID] = (int)Math.Min(renderTexture.updateCount, renderTexture2.updateCount);
						return true;
					}
					if (renderTexture != null && renderTexture.updateCount != value)
					{
						m_IsGPUTextureUpToDate[textureID] = (int)renderTexture.updateCount;
						return true;
					}
					if (renderTexture2 != null && renderTexture2.updateCount != value)
					{
						m_IsGPUTextureUpToDate[textureID] = (int)renderTexture2.updateCount;
						return true;
					}
				}
				else
				{
					m_IsGPUTextureUpToDate[textureID] = textureHash;
				}
			}
			else
			{
				if (m_TextureHashes.TryGetValue(textureID, out var value2) && value2 != textureHash)
				{
					m_TextureHashes[textureID] = textureID;
					return true;
				}
				if (m_IsGPUTextureUpToDate.TryGetValue(textureID, out var value3))
				{
					if (value3 != 0)
					{
						if (needMips)
						{
							return value3 == 1;
						}
						return false;
					}
					return true;
				}
			}
			return false;
		}

		public virtual bool AddTexture(CommandBuffer cmd, ref Vector4 scaleOffset, Texture texture)
		{
			if (IsCached(out scaleOffset, texture))
			{
				return true;
			}
			return AllocateTexture(cmd, ref scaleOffset, texture, texture.width, texture.height);
		}

		public virtual bool UpdateTexture(CommandBuffer cmd, Texture oldTexture, Texture newTexture, ref Vector4 scaleOffset, Vector4 sourceScaleOffset, bool updateIfNeeded = true, bool blitMips = true)
		{
			if (IsCached(out scaleOffset, oldTexture))
			{
				if (updateIfNeeded && NeedsUpdate(newTexture))
				{
					if (Is2D(newTexture))
					{
						BlitTexture(cmd, scaleOffset, newTexture, sourceScaleOffset, blitMips);
					}
					else
					{
						BlitCubeTexture2D(cmd, scaleOffset, newTexture, blitMips);
					}
					MarkGPUTextureValid(GetTextureID(newTexture), blitMips);
				}
				return true;
			}
			return AllocateTexture(cmd, ref scaleOffset, newTexture, newTexture.width, newTexture.height);
		}

		public virtual bool UpdateTexture(CommandBuffer cmd, Texture texture, ref Vector4 scaleOffset, bool updateIfNeeded = true, bool blitMips = true)
		{
			return UpdateTexture(cmd, texture, texture, ref scaleOffset, fullScaleOffset, updateIfNeeded, blitMips);
		}

		internal bool EnsureTextureSlot(out bool isUploadNeeded, ref Vector4 scaleBias, int key, int width, int height)
		{
			isUploadNeeded = false;
			if (m_AllocationCache.TryGetValue(key, out (Vector4, Vector2Int) value))
			{
				(scaleBias, _) = value;
				return true;
			}
			if (!m_AtlasAllocator.Allocate(ref scaleBias, width, height))
			{
				return false;
			}
			isUploadNeeded = true;
			scaleBias.Scale(new Vector4(1f / (float)m_Width, 1f / (float)m_Height, 1f / (float)m_Width, 1f / (float)m_Height));
			m_AllocationCache.Add(key, (scaleBias, new Vector2Int(width, height)));
			return true;
		}
	}
	internal class AtlasAllocatorDynamic
	{
		private class AtlasNodePool
		{
			internal AtlasNode[] m_Nodes;

			private short m_Next;

			private short m_FreelistHead;

			public AtlasNodePool(short capacity)
			{
				m_Nodes = new AtlasNode[capacity];
				m_Next = 0;
				m_FreelistHead = -1;
			}

			public void Dispose()
			{
				Clear();
				m_Nodes = null;
			}

			public void Clear()
			{
				m_Next = 0;
				m_FreelistHead = -1;
			}

			public short AtlasNodeCreate(short parent)
			{
				Debug.Assert(m_Next < m_Nodes.Length || m_FreelistHead != -1, "Error: AtlasNodePool: Out of memory. Please pre-allocate pool to larger capacity");
				if (m_FreelistHead != -1)
				{
					short freelistNext = m_Nodes[m_FreelistHead].m_FreelistNext;
					m_Nodes[m_FreelistHead] = new AtlasNode(m_FreelistHead, parent);
					short freelistHead = m_FreelistHead;
					m_FreelistHead = freelistNext;
					return freelistHead;
				}
				m_Nodes[m_Next] = new AtlasNode(m_Next, parent);
				return m_Next++;
			}

			public void AtlasNodeFree(short index)
			{
				Debug.Assert(index >= 0 && index < m_Nodes.Length, "Error: AtlasNodeFree: index out of range.");
				m_Nodes[index].m_FreelistNext = m_FreelistHead;
				m_FreelistHead = index;
			}
		}

		[StructLayout(LayoutKind.Explicit, Size = 32)]
		private struct AtlasNode
		{
			private enum AtlasNodeFlags : uint
			{
				IsOccupied = 1u
			}

			[FieldOffset(0)]
			public short m_Self;

			[FieldOffset(2)]
			public short m_Parent;

			[FieldOffset(4)]
			public short m_LeftChild;

			[FieldOffset(6)]
			public short m_RightChild;

			[FieldOffset(8)]
			public short m_FreelistNext;

			[FieldOffset(10)]
			public ushort m_Flags;

			[FieldOffset(16)]
			public Vector4 m_Rect;

			public AtlasNode(short self, short parent)
			{
				m_Self = self;
				m_Parent = parent;
				m_LeftChild = -1;
				m_RightChild = -1;
				m_Flags = 0;
				m_FreelistNext = -1;
				m_Rect = Vector4.zero;
			}

			public bool IsOccupied()
			{
				return (m_Flags & 1) > 0;
			}

			public void SetIsOccupied()
			{
				ushort num = 1;
				m_Flags |= num;
			}

			public void ClearIsOccupied()
			{
				ushort num = 1;
				m_Flags &= (ushort)(~num);
			}

			public bool IsLeafNode()
			{
				return m_LeftChild == -1;
			}

			public short Allocate(AtlasNodePool pool, int width, int height)
			{
				if (Mathf.Min(width, height) < 1)
				{
					Debug.Assert(condition: false, "Error: Texture2DAtlasDynamic: Attempted to allocate a degenerate region. Please ensure width and height are >= 1");
					return -1;
				}
				if (!IsLeafNode())
				{
					short num = pool.m_Nodes[m_LeftChild].Allocate(pool, width, height);
					if (num == -1)
					{
						num = pool.m_Nodes[m_RightChild].Allocate(pool, width, height);
					}
					return num;
				}
				if (IsOccupied())
				{
					return -1;
				}
				if ((float)width > m_Rect.x || (float)height > m_Rect.y)
				{
					return -1;
				}
				Debug.Assert(m_LeftChild == -1);
				Debug.Assert(m_RightChild == -1);
				m_LeftChild = pool.AtlasNodeCreate(m_Self);
				m_RightChild = pool.AtlasNodeCreate(m_Self);
				Debug.Assert(m_LeftChild >= 0 && m_LeftChild < pool.m_Nodes.Length);
				Debug.Assert(m_RightChild >= 0 && m_RightChild < pool.m_Nodes.Length);
				float num2 = m_Rect.x - (float)width;
				float num3 = m_Rect.y - (float)height;
				if (num2 >= num3)
				{
					pool.m_Nodes[m_LeftChild].m_Rect.x = width;
					pool.m_Nodes[m_LeftChild].m_Rect.y = m_Rect.y;
					pool.m_Nodes[m_LeftChild].m_Rect.z = m_Rect.z;
					pool.m_Nodes[m_LeftChild].m_Rect.w = m_Rect.w;
					pool.m_Nodes[m_RightChild].m_Rect.x = num2;
					pool.m_Nodes[m_RightChild].m_Rect.y = m_Rect.y;
					pool.m_Nodes[m_RightChild].m_Rect.z = m_Rect.z + (float)width;
					pool.m_Nodes[m_RightChild].m_Rect.w = m_Rect.w;
					if (num3 < 1f)
					{
						pool.m_Nodes[m_LeftChild].SetIsOccupied();
						return m_LeftChild;
					}
					short num4 = pool.m_Nodes[m_LeftChild].Allocate(pool, width, height);
					if (num4 >= 0)
					{
						pool.m_Nodes[num4].SetIsOccupied();
					}
					return num4;
				}
				pool.m_Nodes[m_LeftChild].m_Rect.x = m_Rect.x;
				pool.m_Nodes[m_LeftChild].m_Rect.y = height;
				pool.m_Nodes[m_LeftChild].m_Rect.z = m_Rect.z;
				pool.m_Nodes[m_LeftChild].m_Rect.w = m_Rect.w;
				pool.m_Nodes[m_RightChild].m_Rect.x = m_Rect.x;
				pool.m_Nodes[m_RightChild].m_Rect.y = num3;
				pool.m_Nodes[m_RightChild].m_Rect.z = m_Rect.z;
				pool.m_Nodes[m_RightChild].m_Rect.w = m_Rect.w + (float)height;
				if (num2 < 1f)
				{
					pool.m_Nodes[m_LeftChild].SetIsOccupied();
					return m_LeftChild;
				}
				short num5 = pool.m_Nodes[m_LeftChild].Allocate(pool, width, height);
				if (num5 >= 0)
				{
					pool.m_Nodes[num5].SetIsOccupied();
				}
				return num5;
			}

			public void ReleaseChildren(AtlasNodePool pool)
			{
				if (!IsLeafNode())
				{
					pool.m_Nodes[m_LeftChild].ReleaseChildren(pool);
					pool.m_Nodes[m_RightChild].ReleaseChildren(pool);
					pool.AtlasNodeFree(m_LeftChild);
					pool.AtlasNodeFree(m_RightChild);
					m_LeftChild = -1;
					m_RightChild = -1;
				}
			}

			public void ReleaseAndMerge(AtlasNodePool pool)
			{
				short num = m_Self;
				do
				{
					pool.m_Nodes[num].ReleaseChildren(pool);
					pool.m_Nodes[num].ClearIsOccupied();
					num = pool.m_Nodes[num].m_Parent;
				}
				while (num >= 0 && pool.m_Nodes[num].IsMergeNeeded(pool));
			}

			public bool IsMergeNeeded(AtlasNodePool pool)
			{
				if (pool.m_Nodes[m_LeftChild].IsLeafNode() && !pool.m_Nodes[m_LeftChild].IsOccupied() && pool.m_Nodes[m_RightChild].IsLeafNode())
				{
					return !pool.m_Nodes[m_RightChild].IsOccupied();
				}
				return false;
			}
		}

		private int m_Width;

		private int m_Height;

		private AtlasNodePool m_Pool;

		private short m_Root;

		private Dictionary<int, short> m_NodeFromID;

		public AtlasAllocatorDynamic(int width, int height, int capacityAllocations)
		{
			int num = capacityAllocations * 2;
			Debug.Assert(num < 65536, "Error: AtlasAllocatorDynamic: Attempted to allocate a capacity of " + num + ", which is greater than our 16-bit indices can support. Please request a capacity <=" + 65536);
			m_Pool = new AtlasNodePool((short)num);
			m_NodeFromID = new Dictionary<int, short>(capacityAllocations);
			short parent = -1;
			m_Root = m_Pool.AtlasNodeCreate(parent);
			m_Pool.m_Nodes[m_Root].m_Rect.Set(width, height, 0f, 0f);
			m_Width = width;
			m_Height = height;
		}

		public bool Allocate(out Vector4 result, int key, int width, int height)
		{
			short num = m_Pool.m_Nodes[m_Root].Allocate(m_Pool, width, height);
			if (num >= 0)
			{
				result = m_Pool.m_Nodes[num].m_Rect;
				m_NodeFromID.Add(key, num);
				return true;
			}
			result = Vector4.zero;
			return false;
		}

		public void Release(int key)
		{
			if (m_NodeFromID.TryGetValue(key, out var value))
			{
				Debug.Assert(value >= 0 && value < m_Pool.m_Nodes.Length);
				m_Pool.m_Nodes[value].ReleaseAndMerge(m_Pool);
				m_NodeFromID.Remove(key);
			}
		}

		public void Release()
		{
			m_Pool.Clear();
			m_Root = m_Pool.AtlasNodeCreate(-1);
			m_Pool.m_Nodes[m_Root].m_Rect.Set(m_Width, m_Height, 0f, 0f);
			m_NodeFromID.Clear();
		}

		public string DebugStringFromRoot(int depthMax = -1)
		{
			string res = "";
			DebugStringFromNode(ref res, m_Root, 0, depthMax);
			return res;
		}

		private void DebugStringFromNode(ref string res, short n, int depthCurrent = 0, int depthMax = -1)
		{
			res = res + "{[" + depthCurrent + "], isOccupied = " + (m_Pool.m_Nodes[n].IsOccupied() ? "true" : "false") + ", self = " + m_Pool.m_Nodes[n].m_Self + ", " + m_Pool.m_Nodes[n].m_Rect.x + "," + m_Pool.m_Nodes[n].m_Rect.y + ", " + m_Pool.m_Nodes[n].m_Rect.z + ", " + m_Pool.m_Nodes[n].m_Rect.w + "}\n";
			if (depthMax == -1 || depthCurrent < depthMax)
			{
				if (m_Pool.m_Nodes[n].m_LeftChild >= 0)
				{
					DebugStringFromNode(ref res, m_Pool.m_Nodes[n].m_LeftChild, depthCurrent + 1, depthMax);
				}
				if (m_Pool.m_Nodes[n].m_RightChild >= 0)
				{
					DebugStringFromNode(ref res, m_Pool.m_Nodes[n].m_RightChild, depthCurrent + 1, depthMax);
				}
			}
		}
	}
	internal class Texture2DAtlasDynamic
	{
		private RTHandle m_AtlasTexture;

		private bool isAtlasTextureOwner;

		private int m_Width;

		private int m_Height;

		private GraphicsFormat m_Format;

		private AtlasAllocatorDynamic m_AtlasAllocator;

		private Dictionary<int, Vector4> m_AllocationCache;

		public RTHandle AtlasTexture => m_AtlasTexture;

		public Texture2DAtlasDynamic(int width, int height, int capacity, GraphicsFormat format)
		{
			m_Width = width;
			m_Height = height;
			m_Format = format;
			m_AtlasTexture = RTHandles.Alloc(m_Width, m_Height, 1, DepthBits.None, m_Format, FilterMode.Point, TextureWrapMode.Clamp, TextureDimension.Tex2D, enableRandomWrite: false, useMipMap: true, autoGenerateMips: false);
			isAtlasTextureOwner = true;
			m_AtlasAllocator = new AtlasAllocatorDynamic(width, height, capacity);
			m_AllocationCache = new Dictionary<int, Vector4>(capacity);
		}

		public Texture2DAtlasDynamic(int width, int height, int capacity, RTHandle atlasTexture)
		{
			m_Width = width;
			m_Height = height;
			m_Format = atlasTexture.rt.graphicsFormat;
			m_AtlasTexture = atlasTexture;
			isAtlasTextureOwner = false;
			m_AtlasAllocator = new AtlasAllocatorDynamic(width, height, capacity);
			m_AllocationCache = new Dictionary<int, Vector4>(capacity);
		}

		public void Release()
		{
			ResetAllocator();
			if (isAtlasTextureOwner)
			{
				RTHandles.Release(m_AtlasTexture);
			}
		}

		public void ResetAllocator()
		{
			m_AtlasAllocator.Release();
			m_AllocationCache.Clear();
		}

		public bool AddTexture(CommandBuffer cmd, out Vector4 scaleOffset, Texture texture)
		{
			int instanceID = texture.GetInstanceID();
			if (!m_AllocationCache.TryGetValue(instanceID, out scaleOffset))
			{
				int width = texture.width;
				int height = texture.height;
				if (m_AtlasAllocator.Allocate(out scaleOffset, instanceID, width, height))
				{
					scaleOffset.Scale(new Vector4(1f / (float)m_Width, 1f / (float)m_Height, 1f / (float)m_Width, 1f / (float)m_Height));
					for (int i = 0; i < (texture as Texture2D).mipmapCount; i++)
					{
						cmd.SetRenderTarget(m_AtlasTexture, i);
						Blitter.BlitQuad(cmd, texture, new Vector4(1f, 1f, 0f, 0f), scaleOffset, i, bilinear: false);
					}
					m_AllocationCache.Add(instanceID, scaleOffset);
					return true;
				}
				return false;
			}
			return true;
		}

		public bool IsCached(out Vector4 scaleOffset, int key)
		{
			return m_AllocationCache.TryGetValue(key, out scaleOffset);
		}

		public bool EnsureTextureSlot(out bool isUploadNeeded, out Vector4 scaleOffset, int key, int width, int height)
		{
			isUploadNeeded = false;
			if (m_AllocationCache.TryGetValue(key, out scaleOffset))
			{
				return true;
			}
			if (!m_AtlasAllocator.Allocate(out scaleOffset, key, width, height))
			{
				return false;
			}
			isUploadNeeded = true;
			scaleOffset.Scale(new Vector4(1f / (float)m_Width, 1f / (float)m_Height, 1f / (float)m_Width, 1f / (float)m_Height));
			m_AllocationCache.Add(key, scaleOffset);
			return true;
		}

		public void ReleaseTextureSlot(int key)
		{
			m_AtlasAllocator.Release(key);
			m_AllocationCache.Remove(key);
		}
	}
	public static class TextureXR
	{
		private static int m_MaxViews = 1;

		private static Texture m_BlackUIntTexture2DArray;

		private static Texture m_BlackUIntTexture;

		private static RTHandle m_BlackUIntTexture2DArrayRTH;

		private static RTHandle m_BlackUIntTextureRTH;

		private static Texture2DArray m_ClearTexture2DArray;

		private static Texture2D m_ClearTexture;

		private static RTHandle m_ClearTexture2DArrayRTH;

		private static RTHandle m_ClearTextureRTH;

		private static Texture2DArray m_MagentaTexture2DArray;

		private static Texture2D m_MagentaTexture;

		private static RTHandle m_MagentaTexture2DArrayRTH;

		private static RTHandle m_MagentaTextureRTH;

		private static Texture2D m_BlackTexture;

		private static Texture3D m_BlackTexture3D;

		private static Texture2DArray m_BlackTexture2DArray;

		private static RTHandle m_BlackTexture2DArrayRTH;

		private static RTHandle m_BlackTextureRTH;

		private static RTHandle m_BlackTexture3DRTH;

		private static Texture2DArray m_WhiteTexture2DArray;

		private static RTHandle m_WhiteTexture2DArrayRTH;

		private static RTHandle m_WhiteTextureRTH;

		public static int maxViews
		{
			set
			{
				m_MaxViews = value;
			}
		}

		public static int slices => m_MaxViews;

		public static bool useTexArray
		{
			get
			{
				switch (SystemInfo.graphicsDeviceType)
				{
				case GraphicsDeviceType.Direct3D11:
				case GraphicsDeviceType.PlayStation4:
				case GraphicsDeviceType.Metal:
				case GraphicsDeviceType.Direct3D12:
				case GraphicsDeviceType.Vulkan:
				case GraphicsDeviceType.PlayStation5:
				case GraphicsDeviceType.PlayStation5NGGC:
					return true;
				default:
					return false;
				}
			}
		}

		public static TextureDimension dimension
		{
			get
			{
				if (!useTexArray)
				{
					return TextureDimension.Tex2D;
				}
				return TextureDimension.Tex2DArray;
			}
		}

		public static RTHandle GetBlackUIntTexture()
		{
			if (!useTexArray)
			{
				return m_BlackUIntTextureRTH;
			}
			return m_BlackUIntTexture2DArrayRTH;
		}

		public static RTHandle GetClearTexture()
		{
			if (!useTexArray)
			{
				return m_ClearTextureRTH;
			}
			return m_ClearTexture2DArrayRTH;
		}

		public static RTHandle GetMagentaTexture()
		{
			if (!useTexArray)
			{
				return m_MagentaTextureRTH;
			}
			return m_MagentaTexture2DArrayRTH;
		}

		public static RTHandle GetBlackTexture()
		{
			if (!useTexArray)
			{
				return m_BlackTextureRTH;
			}
			return m_BlackTexture2DArrayRTH;
		}

		public static RTHandle GetBlackTextureArray()
		{
			return m_BlackTexture2DArrayRTH;
		}

		public static RTHandle GetBlackTexture3D()
		{
			return m_BlackTexture3DRTH;
		}

		public static RTHandle GetWhiteTexture()
		{
			if (!useTexArray)
			{
				return m_WhiteTextureRTH;
			}
			return m_WhiteTexture2DArrayRTH;
		}

		public static void Initialize(CommandBuffer cmd, ComputeShader clearR32_UIntShader)
		{
			if (m_BlackUIntTexture2DArray == null)
			{
				RTHandles.Release(m_BlackUIntTexture2DArrayRTH);
				m_BlackUIntTexture2DArray = CreateBlackUIntTextureArray(cmd, clearR32_UIntShader);
				m_BlackUIntTexture2DArrayRTH = RTHandles.Alloc(m_BlackUIntTexture2DArray);
				RTHandles.Release(m_BlackUIntTextureRTH);
				m_BlackUIntTexture = CreateBlackUintTexture(cmd, clearR32_UIntShader);
				m_BlackUIntTextureRTH = RTHandles.Alloc(m_BlackUIntTexture);
				RTHandles.Release(m_ClearTextureRTH);
				m_ClearTexture = new Texture2D(1, 1, GraphicsFormat.R8G8B8A8_SRGB, TextureCreationFlags.None)
				{
					name = "Clear Texture"
				};
				m_ClearTexture.SetPixel(0, 0, Color.clear);
				m_ClearTexture.Apply();
				m_ClearTextureRTH = RTHandles.Alloc(m_ClearTexture);
				RTHandles.Release(m_ClearTexture2DArrayRTH);
				m_ClearTexture2DArray = CreateTexture2DArrayFromTexture2D(m_ClearTexture, "Clear Texture2DArray");
				m_ClearTexture2DArrayRTH = RTHandles.Alloc(m_ClearTexture2DArray);
				RTHandles.Release(m_MagentaTextureRTH);
				m_MagentaTexture = new Texture2D(1, 1, GraphicsFormat.R8G8B8A8_SRGB, TextureCreationFlags.None)
				{
					name = "Magenta Texture"
				};
				m_MagentaTexture.SetPixel(0, 0, Color.magenta);
				m_MagentaTexture.Apply();
				m_MagentaTextureRTH = RTHandles.Alloc(m_MagentaTexture);
				RTHandles.Release(m_MagentaTexture2DArrayRTH);
				m_MagentaTexture2DArray = CreateTexture2DArrayFromTexture2D(m_MagentaTexture, "Magenta Texture2DArray");
				m_MagentaTexture2DArrayRTH = RTHandles.Alloc(m_MagentaTexture2DArray);
				RTHandles.Release(m_BlackTextureRTH);
				m_BlackTexture = new Texture2D(1, 1, GraphicsFormat.R8G8B8A8_SRGB, TextureCreationFlags.None)
				{
					name = "Black Texture"
				};
				m_BlackTexture.SetPixel(0, 0, Color.black);
				m_BlackTexture.Apply();
				m_BlackTextureRTH = RTHandles.Alloc(m_BlackTexture);
				RTHandles.Release(m_BlackTexture2DArrayRTH);
				m_BlackTexture2DArray = CreateTexture2DArrayFromTexture2D(m_BlackTexture, "Black Texture2DArray");
				m_BlackTexture2DArrayRTH = RTHandles.Alloc(m_BlackTexture2DArray);
				RTHandles.Release(m_BlackTexture3DRTH);
				m_BlackTexture3D = CreateBlackTexture3D("Black Texture3D");
				m_BlackTexture3DRTH = RTHandles.Alloc(m_BlackTexture3D);
				RTHandles.Release(m_WhiteTextureRTH);
				m_WhiteTextureRTH = RTHandles.Alloc(Texture2D.whiteTexture);
				RTHandles.Release(m_WhiteTexture2DArrayRTH);
				m_WhiteTexture2DArray = CreateTexture2DArrayFromTexture2D(Texture2D.whiteTexture, "White Texture2DArray");
				m_WhiteTexture2DArrayRTH = RTHandles.Alloc(m_WhiteTexture2DArray);
			}
		}

		private static Texture2DArray CreateTexture2DArrayFromTexture2D(Texture2D source, string name)
		{
			Texture2DArray texture2DArray = new Texture2DArray(source.width, source.height, slices, source.format, mipChain: false)
			{
				name = name
			};
			for (int i = 0; i < slices; i++)
			{
				Graphics.CopyTexture(source, 0, 0, texture2DArray, i, 0);
			}
			return texture2DArray;
		}

		private static Texture CreateBlackUIntTextureArray(CommandBuffer cmd, ComputeShader clearR32_UIntShader)
		{
			RenderTexture renderTexture = new RenderTexture(1, 1, 0, GraphicsFormat.R32_UInt)
			{
				dimension = TextureDimension.Tex2DArray,
				volumeDepth = slices,
				useMipMap = false,
				autoGenerateMips = false,
				enableRandomWrite = true,
				name = "Black UInt Texture Array"
			};
			renderTexture.Create();
			int kernelIndex = clearR32_UIntShader.FindKernel("ClearUIntTextureArray");
			cmd.SetComputeTextureParam(clearR32_UIntShader, kernelIndex, "_TargetArray", renderTexture);
			cmd.DispatchCompute(clearR32_UIntShader, kernelIndex, 1, 1, slices);
			return renderTexture;
		}

		private static Texture CreateBlackUintTexture(CommandBuffer cmd, ComputeShader clearR32_UIntShader)
		{
			RenderTexture renderTexture = new RenderTexture(1, 1, 0, GraphicsFormat.R32_UInt)
			{
				dimension = TextureDimension.Tex2D,
				volumeDepth = 1,
				useMipMap = false,
				autoGenerateMips = false,
				enableRandomWrite = true,
				name = "Black UInt Texture"
			};
			renderTexture.Create();
			int kernelIndex = clearR32_UIntShader.FindKernel("ClearUIntTexture");
			cmd.SetComputeTextureParam(clearR32_UIntShader, kernelIndex, "_Target", renderTexture);
			cmd.DispatchCompute(clearR32_UIntShader, kernelIndex, 1, 1, 1);
			return renderTexture;
		}

		private static Texture3D CreateBlackTexture3D(string name)
		{
			Texture3D texture3D = new Texture3D(1, 1, 1, GraphicsFormat.R8G8B8A8_SRGB, TextureCreationFlags.None);
			texture3D.name = name;
			texture3D.SetPixel(0, 0, 0, Color.black, 0);
			texture3D.Apply(updateMipmaps: false);
			return texture3D;
		}
	}
	public static class ArrayExtensions
	{
		public static void ResizeArray<T>(this ref NativeArray<T> array, int capacity) where T : struct
		{
			NativeArray<T> nativeArray = new NativeArray<T>(capacity, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
			if (array.IsCreated)
			{
				NativeArray<T>.Copy(array, nativeArray, array.Length);
				array.Dispose();
			}
			array = nativeArray;
		}

		public static void ResizeArray(this ref TransformAccessArray array, int capacity)
		{
			TransformAccessArray transformAccessArray = new TransformAccessArray(capacity);
			if (array.isCreated)
			{
				for (int i = 0; i < array.length; i++)
				{
					transformAccessArray.Add(array[i]);
				}
				array.Dispose();
			}
			array = transformAccessArray;
		}

		public static void ResizeArray<T>(ref T[] array, int capacity)
		{
			if (array == null)
			{
				array = new T[capacity];
			}
			else
			{
				Array.Resize(ref array, capacity);
			}
		}
	}
	[Serializable]
	public struct SHCoefficients : IEquatable<SHCoefficients>
	{
		public Vector4 SHAr;

		public Vector4 SHAg;

		public Vector4 SHAb;

		public Vector4 SHBr;

		public Vector4 SHBg;

		public Vector4 SHBb;

		public Vector4 SHC;

		public Vector4 ProbesOcclusion;

		public SHCoefficients(SphericalHarmonicsL2 sh)
		{
			SHAr = GetSHA(sh, 0);
			SHAg = GetSHA(sh, 1);
			SHAb = GetSHA(sh, 2);
			SHBr = GetSHB(sh, 0);
			SHBg = GetSHB(sh, 1);
			SHBb = GetSHB(sh, 2);
			SHC = GetSHC(sh);
			ProbesOcclusion = Vector4.one;
		}

		public SHCoefficients(SphericalHarmonicsL2 sh, Vector4 probesOcclusion)
			: this(sh)
		{
			ProbesOcclusion = probesOcclusion;
		}

		private static Vector4 GetSHA(SphericalHarmonicsL2 sh, int i)
		{
			return new Vector4(sh[i, 3], sh[i, 1], sh[i, 2], sh[i, 0] - sh[i, 6]);
		}

		private static Vector4 GetSHB(SphericalHarmonicsL2 sh, int i)
		{
			return new Vector4(sh[i, 4], sh[i, 5], sh[i, 6] * 3f, sh[i, 7]);
		}

		private static Vector4 GetSHC(SphericalHarmonicsL2 sh)
		{
			return new Vector4(sh[0, 8], sh[1, 8], sh[2, 8], 1f);
		}

		public bool Equals(SHCoefficients other)
		{
			if (SHAr.Equals(other.SHAr) && SHAg.Equals(other.SHAg) && SHAb.Equals(other.SHAb) && SHBr.Equals(other.SHBr) && SHBg.Equals(other.SHBg) && SHBb.Equals(other.SHBb) && SHC.Equals(other.SHC))
			{
				return ProbesOcclusion.Equals(other.ProbesOcclusion);
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj is SHCoefficients other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(SHAr, SHAg, SHAb, SHBr, SHBg, SHBb, SHC, ProbesOcclusion);
		}

		public static bool operator ==(SHCoefficients left, SHCoefficients right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(SHCoefficients left, SHCoefficients right)
		{
			return !left.Equals(right);
		}
	}
	[Serializable]
	[Obsolete("BatchRendererGroupGlobals and associated cbuffer are now set automatically by Unity. Setting it manually is no longer necessary or supported.")]
	public struct BatchRendererGroupGlobals : IEquatable<BatchRendererGroupGlobals>
	{
		public const string kGlobalsPropertyName = "unity_DOTSInstanceGlobalValues";

		public static readonly int kGlobalsPropertyId = Shader.PropertyToID("unity_DOTSInstanceGlobalValues");

		public Vector4 ProbesOcclusion;

		public Vector4 SpecCube0_HDR;

		public Vector4 SpecCube1_HDR;

		public SHCoefficients SHCoefficients;

		public static BatchRendererGroupGlobals Default
		{
			get
			{
				BatchRendererGroupGlobals result = default(BatchRendererGroupGlobals);
				result.ProbesOcclusion = Vector4.one;
				result.SpecCube0_HDR = ReflectionProbe.defaultTextureHDRDecodeValues;
				result.SpecCube1_HDR = result.SpecCube0_HDR;
				result.SHCoefficients = new SHCoefficients(RenderSettings.ambientProbe);
				return result;
			}
		}

		public bool Equals(BatchRendererGroupGlobals other)
		{
			if (ProbesOcclusion.Equals(other.ProbesOcclusion) && SpecCube0_HDR.Equals(other.SpecCube0_HDR) && SpecCube1_HDR.Equals(other.SpecCube1_HDR))
			{
				return SHCoefficients.Equals(other.SHCoefficients);
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj is BatchRendererGroupGlobals other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(ProbesOcclusion, SpecCube0_HDR, SpecCube1_HDR, SHCoefficients);
		}

		public static bool operator ==(BatchRendererGroupGlobals left, BatchRendererGroupGlobals right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(BatchRendererGroupGlobals left, BatchRendererGroupGlobals right)
		{
			return !left.Equals(right);
		}
	}
	public interface IBitArray
	{
		uint capacity { get; }

		bool allFalse { get; }

		bool allTrue { get; }

		bool this[uint index] { get; set; }

		string humanizedData { get; }

		IBitArray BitAnd(IBitArray other);

		IBitArray BitOr(IBitArray other);

		IBitArray BitNot();
	}
	[Serializable]
	[DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
	public struct BitArray8 : IBitArray
	{
		[SerializeField]
		private byte data;

		public uint capacity => 8u;

		public bool allFalse => data == 0;

		public bool allTrue => data == byte.MaxValue;

		public string humanizedData => string.Format("{0, " + capacity + "}", Convert.ToString(data, 2)).Replace(' ', '0');

		public bool this[uint index]
		{
			get
			{
				return BitArrayUtilities.Get8(index, data);
			}
			set
			{
				BitArrayUtilities.Set8(index, ref data, value);
			}
		}

		public BitArray8(byte initValue)
		{
			data = initValue;
		}

		public BitArray8(IEnumerable<uint> bitIndexTrue)
		{
			data = 0;
			if (bitIndexTrue == null)
			{
				return;
			}
			for (int num = bitIndexTrue.Count() - 1; num >= 0; num--)
			{
				uint num2 = bitIndexTrue.ElementAt(num);
				if (num2 < capacity)
				{
					data |= (byte)(1 << (int)num2);
				}
			}
		}

		public static BitArray8 operator ~(BitArray8 a)
		{
			return new BitArray8((byte)(~a.data));
		}

		public static BitArray8 operator |(BitArray8 a, BitArray8 b)
		{
			return new BitArray8((byte)(a.data | b.data));
		}

		public static BitArray8 operator &(BitArray8 a, BitArray8 b)
		{
			return new BitArray8((byte)(a.data & b.data));
		}

		public IBitArray BitAnd(IBitArray other)
		{
			return this & (BitArray8)(object)other;
		}

		public IBitArray BitOr(IBitArray other)
		{
			return this | (BitArray8)(object)other;
		}

		public IBitArray BitNot()
		{
			return ~this;
		}

		public static bool operator ==(BitArray8 a, BitArray8 b)
		{
			return a.data == b.data;
		}

		public static bool operator !=(BitArray8 a, BitArray8 b)
		{
			return a.data != b.data;
		}

		public override bool Equals(object obj)
		{
			if (obj is BitArray8)
			{
				return ((BitArray8)obj).data == data;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return 1768953197 + data.GetHashCode();
		}
	}
	[Serializable]
	[DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
	public struct BitArray16 : IBitArray
	{
		[SerializeField]
		private ushort data;

		public uint capacity => 16u;

		public bool allFalse => data == 0;

		public bool allTrue => data == ushort.MaxValue;

		public string humanizedData => Regex.Replace(string.Format("{0, " + capacity + "}", Convert.ToString(data, 2)).Replace(' ', '0'), ".{8}", "$0.").TrimEnd('.');

		public bool this[uint index]
		{
			get
			{
				return BitArrayUtilities.Get16(index, data);
			}
			set
			{
				BitArrayUtilities.Set16(index, ref data, value);
			}
		}

		public BitArray16(ushort initValue)
		{
			data = initValue;
		}

		public BitArray16(IEnumerable<uint> bitIndexTrue)
		{
			data = 0;
			if (bitIndexTrue == null)
			{
				return;
			}
			for (int num = bitIndexTrue.Count() - 1; num >= 0; num--)
			{
				uint num2 = bitIndexTrue.ElementAt(num);
				if (num2 < capacity)
				{
					data |= (ushort)(1 << (int)num2);
				}
			}
		}

		public static BitArray16 operator ~(BitArray16 a)
		{
			return new BitArray16((ushort)(~a.data));
		}

		public static BitArray16 operator |(BitArray16 a, BitArray16 b)
		{
			return new BitArray16((ushort)(a.data | b.data));
		}

		public static BitArray16 operator &(BitArray16 a, BitArray16 b)
		{
			return new BitArray16((ushort)(a.data & b.data));
		}

		public IBitArray BitAnd(IBitArray other)
		{
			return this & (BitArray16)(object)other;
		}

		public IBitArray BitOr(IBitArray other)
		{
			return this | (BitArray16)(object)other;
		}

		public IBitArray BitNot()
		{
			return ~this;
		}

		public static bool operator ==(BitArray16 a, BitArray16 b)
		{
			return a.data == b.data;
		}

		public static bool operator !=(BitArray16 a, BitArray16 b)
		{
			return a.data != b.data;
		}

		public override bool Equals(object obj)
		{
			if (obj is BitArray16)
			{
				return ((BitArray16)obj).data == data;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return 1768953197 + data.GetHashCode();
		}
	}
	[Serializable]
	[DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
	public struct BitArray32 : IBitArray
	{
		[SerializeField]
		private uint data;

		public uint capacity => 32u;

		public bool allFalse => data == 0;

		public bool allTrue => data == uint.MaxValue;

		private string humanizedVersion => Convert.ToString(data, 2);

		public string humanizedData => Regex.Replace(string.Format("{0, " + capacity + "}", Convert.ToString(data, 2)).Replace(' ', '0'), ".{8}", "$0.").TrimEnd('.');

		public bool this[uint index]
		{
			get
			{
				return BitArrayUtilities.Get32(index, data);
			}
			set
			{
				BitArrayUtilities.Set32(index, ref data, value);
			}
		}

		public BitArray32(uint initValue)
		{
			data = initValue;
		}

		public BitArray32(IEnumerable<uint> bitIndexTrue)
		{
			data = 0u;
			if (bitIndexTrue == null)
			{
				return;
			}
			for (int num = bitIndexTrue.Count() - 1; num >= 0; num--)
			{
				uint num2 = bitIndexTrue.ElementAt(num);
				if (num2 < capacity)
				{
					data |= (uint)(1 << (int)num2);
				}
			}
		}

		public IBitArray BitAnd(IBitArray other)
		{
			return this & (BitArray32)(object)other;
		}

		public IBitArray BitOr(IBitArray other)
		{
			return this | (BitArray32)(object)other;
		}

		public IBitArray BitNot()
		{
			return ~this;
		}

		public static BitArray32 operator ~(BitArray32 a)
		{
			return new BitArray32(~a.data);
		}

		public static BitArray32 operator |(BitArray32 a, BitArray32 b)
		{
			return new BitArray32(a.data | b.data);
		}

		public static BitArray32 operator &(BitArray32 a, BitArray32 b)
		{
			return new BitArray32(a.data & b.data);
		}

		public static bool operator ==(BitArray32 a, BitArray32 b)
		{
			return a.data == b.data;
		}

		public static bool operator !=(BitArray32 a, BitArray32 b)
		{
			return a.data != b.data;
		}

		public override bool Equals(object obj)
		{
			if (obj is BitArray32)
			{
				return ((BitArray32)obj).data == data;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return 1768953197 + data.GetHashCode();
		}
	}
	[Serializable]
	[DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
	public struct BitArray64 : IBitArray
	{
		[SerializeField]
		private ulong data;

		public uint capacity => 64u;

		public bool allFalse => data == 0;

		public bool allTrue => data == ulong.MaxValue;

		public string humanizedData => Regex.Replace(string.Format("{0, " + capacity + "}", Convert.ToString((long)data, 2)).Replace(' ', '0'), ".{8}", "$0.").TrimEnd('.');

		public bool this[uint index]
		{
			get
			{
				return BitArrayUtilities.Get64(index, data);
			}
			set
			{
				BitArrayUtilities.Set64(index, ref data, value);
			}
		}

		public BitArray64(ulong initValue)
		{
			data = initValue;
		}

		public BitArray64(IEnumerable<uint> bitIndexTrue)
		{
			data = 0uL;
			if (bitIndexTrue == null)
			{
				return;
			}
			for (int num = bitIndexTrue.Count() - 1; num >= 0; num--)
			{
				uint num2 = bitIndexTrue.ElementAt(num);
				if (num2 < capacity)
				{
					data |= (ulong)(1L << (int)num2);
				}
			}
		}

		public static BitArray64 operator ~(BitArray64 a)
		{
			return new BitArray64(~a.data);
		}

		public static BitArray64 operator |(BitArray64 a, BitArray64 b)
		{
			return new BitArray64(a.data | b.data);
		}

		public static BitArray64 operator &(BitArray64 a, BitArray64 b)
		{
			return new BitArray64(a.data & b.data);
		}

		public IBitArray BitAnd(IBitArray other)
		{
			return this & (BitArray64)(object)other;
		}

		public IBitArray BitOr(IBitArray other)
		{
			return this | (BitArray64)(object)other;
		}

		public IBitArray BitNot()
		{
			return ~this;
		}

		public static bool operator ==(BitArray64 a, BitArray64 b)
		{
			return a.data == b.data;
		}

		public static bool operator !=(BitArray64 a, BitArray64 b)
		{
			return a.data != b.data;
		}

		public override bool Equals(object obj)
		{
			if (obj is BitArray64)
			{
				return ((BitArray64)obj).data == data;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return 1768953197 + data.GetHashCode();
		}
	}
	[Serializable]
	[DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
	public struct BitArray128 : IBitArray
	{
		[SerializeField]
		private ulong data1;

		[SerializeField]
		private ulong data2;

		public uint capacity => 128u;

		public bool allFalse
		{
			get
			{
				if (data1 == 0L)
				{
					return data2 == 0;
				}
				return false;
			}
		}

		public bool allTrue
		{
			get
			{
				if (data1 == ulong.MaxValue)
				{
					return data2 == ulong.MaxValue;
				}
				return false;
			}
		}

		public string humanizedData => Regex.Replace(string.Format("{0, " + 64u + "}", Convert.ToString((long)data2, 2)).Replace(' ', '0'), ".{8}", "$0.") + Regex.Replace(string.Format("{0, " + 64u + "}", Convert.ToString((long)data1, 2)).Replace(' ', '0'), ".{8}", "$0.").TrimEnd('.');

		public bool this[uint index]
		{
			get
			{
				return BitArrayUtilities.Get128(index, data1, data2);
			}
			set
			{
				BitArrayUtilities.Set128(index, ref data1, ref data2, value);
			}
		}

		public BitArray128(ulong initValue1, ulong initValue2)
		{
			data1 = initValue1;
			data2 = initValue2;
		}

		public BitArray128(IEnumerable<uint> bitIndexTrue)
		{
			data1 = (data2 = 0uL);
			if (bitIndexTrue == null)
			{
				return;
			}
			for (int num = bitIndexTrue.Count() - 1; num >= 0; num--)
			{
				uint num2 = bitIndexTrue.ElementAt(num);
				if (num2 < 64)
				{
					data1 |= (ulong)(1L << (int)num2);
				}
				else if (num2 < capacity)
				{
					data2 |= (ulong)(1L << (int)(num2 - 64));
				}
			}
		}

		public static BitArray128 operator ~(BitArray128 a)
		{
			return new BitArray128(~a.data1, ~a.data2);
		}

		public static BitArray128 operator |(BitArray128 a, BitArray128 b)
		{
			return new BitArray128(a.data1 | b.data1, a.data2 | b.data2);
		}

		public static BitArray128 operator &(BitArray128 a, BitArray128 b)
		{
			return new BitArray128(a.data1 & b.data1, a.data2 & b.data2);
		}

		public IBitArray BitAnd(IBitArray other)
		{
			return this & (BitArray128)(object)other;
		}

		public IBitArray BitOr(IBitArray other)
		{
			return this | (BitArray128)(object)other;
		}

		public IBitArray BitNot()
		{
			return ~this;
		}

		public static bool operator ==(BitArray128 a, BitArray128 b)
		{
			if (a.data1 == b.data1)
			{
				return a.data2 == b.data2;
			}
			return false;
		}

		public static bool operator !=(BitArray128 a, BitArray128 b)
		{
			if (a.data1 == b.data1)
			{
				return a.data2 != b.data2;
			}
			return true;
		}

		public override bool Equals(object obj)
		{
			if (obj is BitArray128 && data1.Equals(((BitArray128)obj).data1))
			{
				return data2.Equals(((BitArray128)obj).data2);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (1755735569 * -1521134295 + data1.GetHashCode()) * -1521134295 + data2.GetHashCode();
		}
	}
	[Serializable]
	[DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
	public struct BitArray256 : IBitArray
	{
		[SerializeField]
		private ulong data1;

		[SerializeField]
		private ulong data2;

		[SerializeField]
		private ulong data3;

		[SerializeField]
		private ulong data4;

		public uint capacity => 256u;

		public bool allFalse
		{
			get
			{
				if (data1 == 0L && data2 == 0L && data3 == 0L)
				{
					return data4 == 0;
				}
				return false;
			}
		}

		public bool allTrue
		{
			get
			{
				if (data1 == ulong.MaxValue && data2 == ulong.MaxValue && data3 == ulong.MaxValue)
				{
					return data4 == ulong.MaxValue;
				}
				return false;
			}
		}

		public string humanizedData => Regex.Replace(string.Format("{0, " + 64u + "}", Convert.ToString((long)data4, 2)).Replace(' ', '0'), ".{8}", "$0.") + Regex.Replace(string.Format("{0, " + 64u + "}", Convert.ToString((long)data3, 2)).Replace(' ', '0'), ".{8}", "$0.") + Regex.Replace(string.Format("{0, " + 64u + "}", Convert.ToString((long)data2, 2)).Replace(' ', '0'), ".{8}", "$0.") + Regex.Replace(string.Format("{0, " + 64u + "}", Convert.ToString((long)data1, 2)).Replace(' ', '0'), ".{8}", "$0.").TrimEnd('.');

		public bool this[uint index]
		{
			get
			{
				return BitArrayUtilities.Get256(index, data1, data2, data3, data4);
			}
			set
			{
				BitArrayUtilities.Set256(index, ref data1, ref data2, ref data3, ref data4, value);
			}
		}

		public BitArray256(ulong initValue1, ulong initValue2, ulong initValue3, ulong initValue4)
		{
			data1 = initValue1;
			data2 = initValue2;
			data3 = initValue3;
			data4 = initValue4;
		}

		public BitArray256(IEnumerable<uint> bitIndexTrue)
		{
			data1 = (data2 = (data3 = (data4 = 0uL)));
			if (bitIndexTrue == null)
			{
				return;
			}
			for (int num = bitIndexTrue.Count() - 1; num >= 0; num--)
			{
				uint num2 = bitIndexTrue.ElementAt(num);
				switch (num2)
				{
				case 0u:
				case 1u:
				case 2u:
				case 3u:
				case 4u:
				case 5u:
				case 6u:
				case 7u:
				case 8u:
				case 9u:
				case 10u:
				case 11u:
				case 12u:
				case 13u:
				case 14u:
				case 15u:
				case 16u:
				case 17u:
				case 18u:
				case 19u:
				case 20u:
				case 21u:
				case 22u:
				case 23u:
				case 24u:
				case 25u:
				case 26u:
				case 27u:
				case 28u:
				case 29u:
				case 30u:
				case 31u:
				case 32u:
				case 33u:
				case 34u:
				case 35u:
				case 36u:
				case 37u:
				case 38u:
				case 39u:
				case 40u:
				case 41u:
				case 42u:
				case 43u:
				case 44u:
				case 45u:
				case 46u:
				case 47u:
				case 48u:
				case 49u:
				case 50u:
				case 51u:
				case 52u:
				case 53u:
				case 54u:
				case 55u:
				case 56u:
				case 57u:
				case 58u:
				case 59u:
				case 60u:
				case 61u:
				case 62u:
				case 63u:
					data1 |= (ulong)(1L << (int)num2);
					break;
				case 64u:
				case 65u:
				case 66u:
				case 67u:
				case 68u:
				case 69u:
				case 70u:
				case 71u:
				case 72u:
				case 73u:
				case 74u:
				case 75u:
				case 76u:
				case 77u:
				case 78u:
				case 79u:
				case 80u:
				case 81u:
				case 82u:
				case 83u:
				case 84u:
				case 85u:
				case 86u:
				case 87u:
				case 88u:
				case 89u:
				case 90u:
				case 91u:
				case 92u:
				case 93u:
				case 94u:
				case 95u:
				case 96u:
				case 97u:
				case 98u:
				case 99u:
				case 100u:
				case 101u:
				case 102u:
				case 103u:
				case 104u:
				case 105u:
				case 106u:
				case 107u:
				case 108u:
				case 109u:
				case 110u:
				case 111u:
				case 112u:
				case 113u:
				case 114u:
				case 115u:
				case 116u:
				case 117u:
				case 118u:
				case 119u:
				case 120u:
				case 121u:
				case 122u:
				case 123u:
				case 124u:
				case 125u:
				case 126u:
				case 127u:
					data2 |= (ulong)(1L << (int)(num2 - 64));
					break;
				case 128u:
				case 129u:
				case 130u:
				case 131u:
				case 132u:
				case 133u:
				case 134u:
				case 135u:
				case 136u:
				case 137u:
				case 138u:
				case 139u:
				case 140u:
				case 141u:
				case 142u:
				case 143u:
				case 144u:
				case 145u:
				case 146u:
				case 147u:
				case 148u:
				case 149u:
				case 150u:
				case 151u:
				case 152u:
				case 153u:
				case 154u:
				case 155u:
				case 156u:
				case 157u:
				case 158u:
				case 159u:
				case 160u:
				case 161u:
				case 162u:
				case 163u:
				case 164u:
				case 165u:
				case 166u:
				case 167u:
				case 168u:
				case 169u:
				case 170u:
				case 171u:
				case 172u:
				case 173u:
				case 174u:
				case 175u:
				case 176u:
				case 177u:
				case 178u:
				case 179u:
				case 180u:
				case 181u:
				case 182u:
				case 183u:
				case 184u:
				case 185u:
				case 186u:
				case 187u:
				case 188u:
				case 189u:
				case 190u:
				case 191u:
					data3 |= (ulong)(1L << (int)(num2 - 128));
					break;
				default:
					if (num2 < capacity)
					{
						data4 |= (ulong)(1L << (int)(num2 - 192));
					}
					break;
				}
			}
		}

		public static BitArray256 operator ~(BitArray256 a)
		{
			return new BitArray256(~a.data1, ~a.data2, ~a.data3, ~a.data4);
		}

		public static BitArray256 operator |(BitArray256 a, BitArray256 b)
		{
			return new BitArray256(a.data1 | b.data1, a.data2 | b.data2, a.data3 | b.data3, a.data4 | b.data4);
		}

		public static BitArray256 operator &(BitArray256 a, BitArray256 b)
		{
			return new BitArray256(a.data1 & b.data1, a.data2 & b.data2, a.data3 & b.data3, a.data4 & b.data4);
		}

		public IBitArray BitAnd(IBitArray other)
		{
			return this & (BitArray256)(object)other;
		}

		public IBitArray BitOr(IBitArray other)
		{
			return this | (BitArray256)(object)other;
		}

		public IBitArray BitNot()
		{
			return ~this;
		}

		public static bool operator ==(BitArray256 a, BitArray256 b)
		{
			if (a.data1 == b.data1 && a.data2 == b.data2 && a.data3 == b.data3)
			{
				return a.data4 == b.data4;
			}
			return false;
		}

		public static bool operator !=(BitArray256 a, BitArray256 b)
		{
			if (a.data1 == b.data1 && a.data2 == b.data2 && a.data3 == b.data3)
			{
				return a.data4 != b.data4;
			}
			return true;
		}

		public override bool Equals(object obj)
		{
			if (obj is BitArray256 && data1.Equals(((BitArray256)obj).data1) && data2.Equals(((BitArray256)obj).data2) && data3.Equals(((BitArray256)obj).data3))
			{
				return data4.Equals(((BitArray256)obj).data4);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (((1870826326 * -1521134295 + data1.GetHashCode()) * -1521134295 + data2.GetHashCode()) * -1521134295 + data3.GetHashCode()) * -1521134295 + data4.GetHashCode();
		}
	}
	public static class BitArrayUtilities
	{
		public static bool Get8(uint index, byte data)
		{
			return (data & (1 << (int)index)) != 0;
		}

		public static bool Get16(uint index, ushort data)
		{
			return (data & (1 << (int)index)) != 0;
		}

		public static bool Get32(uint index, uint data)
		{
			return (data & (uint)(1 << (int)index)) != 0;
		}

		public static bool Get64(uint index, ulong data)
		{
			return (data & (ulong)(1L << (int)index)) != 0;
		}

		public static bool Get128(uint index, ulong data1, ulong data2)
		{
			if (index >= 64)
			{
				return (data2 & (ulong)(1L << (int)(index - 64))) != 0;
			}
			return (data1 & (ulong)(1L << (int)index)) != 0;
		}

		public static bool Get256(uint index, ulong data1, ulong data2, ulong data3, ulong data4)
		{
			switch (index)
			{
			default:
				return (data4 & (ulong)(1L << (int)(index - 192))) != 0;
			case 128u:
			case 129u:
			case 130u:
			case 131u:
			case 132u:
			case 133u:
			case 134u:
			case 135u:
			case 136u:
			case 137u:
			case 138u:
			case 139u:
			case 140u:
			case 141u:
			case 142u:
			case 143u:
			case 144u:
			case 145u:
			case 146u:
			case 147u:
			case 148u:
			case 149u:
			case 150u:
			case 151u:
			case 152u:
			case 153u:
			case 154u:
			case 155u:
			case 156u:
			case 157u:
			case 158u:
			case 159u:
			case 160u:
			case 161u:
			case 162u:
			case 163u:
			case 164u:
			case 165u:
			case 166u:
			case 167u:
			case 168u:
			case 169u:
			case 170u:
			case 171u:
			case 172u:
			case 173u:
			case 174u:
			case 175u:
			case 176u:
			case 177u:
			case 178u:
			case 179u:
			case 180u:
			case 181u:
			case 182u:
			case 183u:
			case 184u:
			case 185u:
			case 186u:
			case 187u:
			case 188u:
			case 189u:
			case 190u:
			case 191u:
				return (data3 & (ulong)(1L << (int)(index - 128))) != 0;
			case 64u:
			case 65u:
			case 66u:
			case 67u:
			case 68u:
			case 69u:
			case 70u:
			case 71u:
			case 72u:
			case 73u:
			case 74u:
			case 75u:
			case 76u:
			case 77u:
			case 78u:
			case 79u:
			case 80u:
			case 81u:
			case 82u:
			case 83u:
			case 84u:
			case 85u:
			case 86u:
			case 87u:
			case 88u:
			case 89u:
			case 90u:
			case 91u:
			case 92u:
			case 93u:
			case 94u:
			case 95u:
			case 96u:
			case 97u:
			case 98u:
			case 99u:
			case 100u:
			case 101u:
			case 102u:
			case 103u:
			case 104u:
			case 105u:
			case 106u:
			case 107u:
			case 108u:
			case 109u:
			case 110u:
			case 111u:
			case 112u:
			case 113u:
			case 114u:
			case 115u:
			case 116u:
			case 117u:
			case 118u:
			case 119u:
			case 120u:
			case 121u:
			case 122u:
			case 123u:
			case 124u:
			case 125u:
			case 126u:
			case 127u:
				return (data2 & (ulong)(1L << (int)(index - 64))) != 0;
			case 0u:
			case 1u:
			case 2u:
			case 3u:
			case 4u:
			case 5u:
			case 6u:
			case 7u:
			case 8u:
			case 9u:
			case 10u:
			case 11u:
			case 12u:
			case 13u:
			case 14u:
			case 15u:
			case 16u:
			case 17u:
			case 18u:
			case 19u:
			case 20u:
			case 21u:
			case 22u:
			case 23u:
			case 24u:
			case 25u:
			case 26u:
			case 27u:
			case 28u:
			case 29u:
			case 30u:
			case 31u:
			case 32u:
			case 33u:
			case 34u:
			case 35u:
			case 36u:
			case 37u:
			case 38u:
			case 39u:
			case 40u:
			case 41u:
			case 42u:
			case 43u:
			case 44u:
			case 45u:
			case 46u:
			case 47u:
			case 48u:
			case 49u:
			case 50u:
			case 51u:
			case 52u:
			case 53u:
			case 54u:
			case 55u:
			case 56u:
			case 57u:
			case 58u:
			case 59u:
			case 60u:
			case 61u:
			case 62u:
			case 63u:
				return (data1 & (ulong)(1L << (int)index)) != 0;
			}
		}

		public static void Set8(uint index, ref byte data, bool value)
		{
			data = (byte)(value ? (data | (1 << (int)index)) : (data & ~(1 << (int)index)));
		}

		public static void Set16(uint index, ref ushort data, bool value)
		{
			data = (ushort)(value ? (data | (1 << (int)index)) : (data & ~(1 << (int)index)));
		}

		public static void Set32(uint index, ref uint data, bool value)
		{
			data = (value ? (data | (uint)(1 << (int)index)) : (data & (uint)(~(1 << (int)index))));
		}

		public static void Set64(uint index, ref ulong data, bool value)
		{
			data = (value ? (data | (ulong)(1L << (int)index)) : (data & (ulong)(~(1L << (int)index))));
		}

		public static void Set128(uint index, ref ulong data1, ref ulong data2, bool value)
		{
			if (index < 64)
			{
				data1 = (value ? (data1 | (ulong)(1L << (int)index)) : (data1 & (ulong)(~(1L << (int)index))));
			}
			else
			{
				data2 = (value ? (data2 | (ulong)(1L << (int)(index - 64))) : (data2 & (ulong)(~(1L << (int)(index - 64)))));
			}
		}

		public static void Set256(uint index, ref ulong data1, ref ulong data2, ref ulong data3, ref ulong data4, bool value)
		{
			switch (index)
			{
			case 0u:
			case 1u:
			case 2u:
			case 3u:
			case 4u:
			case 5u:
			case 6u:
			case 7u:
			case 8u:
			case 9u:
			case 10u:
			case 11u:
			case 12u:
			case 13u:
			case 14u:
			case 15u:
			case 16u:
			case 17u:
			case 18u:
			case 19u:
			case 20u:
			case 21u:
			case 22u:
			case 23u:
			case 24u:
			case 25u:
			case 26u:
			case 27u:
			case 28u:
			case 29u:
			case 30u:
			case 31u:
			case 32u:
			case 33u:
			case 34u:
			case 35u:
			case 36u:
			case 37u:
			case 38u:
			case 39u:
			case 40u:
			case 41u:
			case 42u:
			case 43u:
			case 44u:
			case 45u:
			case 46u:
			case 47u:
			case 48u:
			case 49u:
			case 50u:
			case 51u:
			case 52u:
			case 53u:
			case 54u:
			case 55u:
			case 56u:
			case 57u:
			case 58u:
			case 59u:
			case 60u:
			case 61u:
			case 62u:
			case 63u:
				data1 = (value ? (data1 | (ulong)(1L << (int)index)) : (data1 & (ulong)(~(1L << (int)index))));
				break;
			case 64u:
			case 65u:
			case 66u:
			case 67u:
			case 68u:
			case 69u:
			case 70u:
			case 71u:
			case 72u:
			case 73u:
			case 74u:
			case 75u:
			case 76u:
			case 77u:
			case 78u:
			case 79u:
			case 80u:
			case 81u:
			case 82u:
			case 83u:
			case 84u:
			case 85u:
			case 86u:
			case 87u:
			case 88u:
			case 89u:
			case 90u:
			case 91u:
			case 92u:
			case 93u:
			case 94u:
			case 95u:
			case 96u:
			case 97u:
			case 98u:
			case 99u:
			case 100u:
			case 101u:
			case 102u:
			case 103u:
			case 104u:
			case 105u:
			case 106u:
			case 107u:
			case 108u:
			case 109u:
			case 110u:
			case 111u:
			case 112u:
			case 113u:
			case 114u:
			case 115u:
			case 116u:
			case 117u:
			case 118u:
			case 119u:
			case 120u:
			case 121u:
			case 122u:
			case 123u:
			case 124u:
			case 125u:
			case 126u:
			case 127u:
				data2 = (value ? (data2 | (ulong)(1L << (int)(index - 64))) : (data2 & (ulong)(~(1L << (int)(index - 64)))));
				break;
			case 128u:
			case 129u:
			case 130u:
			case 131u:
			case 132u:
			case 133u:
			case 134u:
			case 135u:
			case 136u:
			case 137u:
			case 138u:
			case 139u:
			case 140u:
			case 141u:
			case 142u:
			case 143u:
			case 144u:
			case 145u:
			case 146u:
			case 147u:
			case 148u:
			case 149u:
			case 150u:
			case 151u:
			case 152u:
			case 153u:
			case 154u:
			case 155u:
			case 156u:
			case 157u:
			case 158u:
			case 159u:
			case 160u:
			case 161u:
			case 162u:
			case 163u:
			case 164u:
			case 165u:
			case 166u:
			case 167u:
			case 168u:
			case 169u:
			case 170u:
			case 171u:
			case 172u:
			case 173u:
			case 174u:
			case 175u:
			case 176u:
			case 177u:
			case 178u:
			case 179u:
			case 180u:
			case 181u:
			case 182u:
			case 183u:
			case 184u:
			case 185u:
			case 186u:
			case 187u:
			case 188u:
			case 189u:
			case 190u:
			case 191u:
				data3 = (value ? (data3 | (ulong)(1L << (int)(index - 64))) : (data3 & (ulong)(~(1L << (int)(index - 128)))));
				break;
			default:
				data4 = (value ? (data4 | (ulong)(1L << (int)(index - 64))) : (data4 & (ulong)(~(1L << (int)(index - 192)))));
				break;
			}
		}
	}
	public static class Blitter
	{
		private static class BlitShaderIDs
		{
			public static readonly int _BlitTexture = Shader.PropertyToID("_BlitTexture");

			public static readonly int _BlitCubeTexture = Shader.PropertyToID("_BlitCubeTexture");

			public static readonly int _BlitScaleBias = Shader.PropertyToID("_BlitScaleBias");

			public static readonly int _BlitScaleBiasRt = Shader.PropertyToID("_BlitScaleBiasRt");

			public static readonly int _BlitMipLevel = Shader.PropertyToID("_BlitMipLevel");

			public static readonly int _BlitTextureSize = Shader.PropertyToID("_BlitTextureSize");

			public static readonly int _BlitPaddingSize = Shader.PropertyToID("_BlitPaddingSize");

			public static readonly int _BlitDecodeInstructions = Shader.PropertyToID("_BlitDecodeInstructions");

			public static readonly int _InputDepth = Shader.PropertyToID("_InputDepthTexture");
		}

		private static Material s_Blit;

		private static Material s_BlitTexArray;

		private static Material s_BlitTexArraySingleSlice;

		private static Material s_BlitColorAndDepth;

		private static MaterialPropertyBlock s_PropertyBlock = new MaterialPropertyBlock();

		private static Mesh s_TriangleMesh;

		private static Mesh s_QuadMesh;

		private static LocalKeyword s_DecodeHdrKeyword;

		public static void Initialize(Shader blitPS, Shader blitColorAndDepthPS)
		{
			if (s_Blit != null)
			{
				throw new Exception("Blitter is already initialized. Please only initialize the blitter once or you will leak engine resources. If you need to re-initialize the blitter with different shaders destroy & recreate it.");
			}
			s_Blit = CoreUtils.CreateEngineMaterial(blitPS);
			s_BlitColorAndDepth = CoreUtils.CreateEngineMaterial(blitColorAndDepthPS);
			s_DecodeHdrKeyword = new LocalKeyword(blitPS, "BLIT_DECODE_HDR");
			if (TextureXR.useTexArray)
			{
				s_Blit.EnableKeyword("DISABLE_TEXTURE2D_X_ARRAY");
				s_BlitTexArray = CoreUtils.CreateEngineMaterial(blitPS);
				s_BlitTexArraySingleSlice = CoreUtils.CreateEngineMaterial(blitPS);
				s_BlitTexArraySingleSlice.EnableKeyword("BLIT_SINGLE_SLICE");
			}
			if (SystemInfo.graphicsShaderLevel < 30)
			{
				float z = -1f;
				if (SystemInfo.usesReversedZBuffer)
				{
					z = 1f;
				}
				if (!s_TriangleMesh)
				{
					s_TriangleMesh = new Mesh();
					s_TriangleMesh.vertices = GetFullScreenTriangleVertexPosition(z);
					s_TriangleMesh.uv = GetFullScreenTriangleTexCoord();
					s_TriangleMesh.triangles = new int[3] { 0, 1, 2 };
				}
				if (!s_QuadMesh)
				{
					s_QuadMesh = new Mesh();
					s_QuadMesh.vertices = GetQuadVertexPosition(z);
					s_QuadMesh.uv = GetQuadTexCoord();
					s_QuadMesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
				}
			}
			static Vector2[] GetFullScreenTriangleTexCoord()
			{
				Vector2[] array = new Vector2[3];
				for (int i = 0; i < 3; i++)
				{
					if (SystemInfo.graphicsUVStartsAtTop)
					{
						array[i] = new Vector2((i << 1) & 2, 1f - (float)(i & 2));
					}
					else
					{
						array[i] = new Vector2((i << 1) & 2, i & 2);
					}
				}
				return array;
			}
			static Vector3[] GetFullScreenTriangleVertexPosition(float z2)
			{
				Vector3[] array = new Vector3[3];
				for (int i = 0; i < 3; i++)
				{
					Vector2 vector = new Vector2((i << 1) & 2, i & 2);
					array[i] = new Vector3(vector.x * 2f - 1f, vector.y * 2f - 1f, z2);
				}
				return array;
			}
			static Vector2[] GetQuadTexCoord()
			{
				Vector2[] array = new Vector2[4];
				for (uint num = 0u; num < 4; num++)
				{
					uint num2 = num >> 1;
					uint num3 = num & 1;
					float x = num2;
					float num4 = (num2 + num3) & 1;
					if (SystemInfo.graphicsUVStartsAtTop)
					{
						num4 = 1f - num4;
					}
					array[num] = new Vector2(x, num4);
				}
				return array;
			}
			static Vector3[] GetQuadVertexPosition(float z2)
			{
				Vector3[] array = new Vector3[4];
				for (uint num = 0u; num < 4; num++)
				{
					uint num2 = num >> 1;
					uint num3 = num & 1;
					float x = num2;
					float y = (1 - (num2 + num3)) & 1;
					array[num] = new Vector3(x, y, z2);
				}
				return array;
			}
		}

		public static void Cleanup()
		{
			CoreUtils.Destroy(s_Blit);
			s_Blit = null;
			CoreUtils.Destroy(s_BlitColorAndDepth);
			s_BlitColorAndDepth = null;
			CoreUtils.Destroy(s_BlitTexArray);
			s_BlitTexArray = null;
			CoreUtils.Destroy(s_BlitTexArraySingleSlice);
			s_BlitTexArraySingleSlice = null;
			CoreUtils.Destroy(s_TriangleMesh);
			s_TriangleMesh = null;
			CoreUtils.Destroy(s_QuadMesh);
			s_QuadMesh = null;
		}

		public static Material GetBlitMaterial(TextureDimension dimension, bool singleSlice = false)
		{
			if (dimension != TextureDimension.Tex2DArray)
			{
				return s_Blit;
			}
			if (!singleSlice)
			{
				return s_BlitTexArray;
			}
			return s_BlitTexArraySingleSlice;
		}

		private static void DrawTriangle(CommandBuffer cmd, Material material, int shaderPass)
		{
			if (SystemInfo.graphicsShaderLevel < 30)
			{
				cmd.DrawMesh(s_TriangleMesh, Matrix4x4.identity, material, 0, shaderPass, s_PropertyBlock);
			}
			else
			{
				cmd.DrawProcedural(Matrix4x4.identity, material, shaderPass, MeshTopology.Triangles, 3, 1, s_PropertyBlock);
			}
		}

		internal static void DrawQuad(CommandBuffer cmd, Material material, int shaderPass)
		{
			if (SystemInfo.graphicsShaderLevel < 30)
			{
				cmd.DrawMesh(s_QuadMesh, Matrix4x4.identity, material, 0, shaderPass, s_PropertyBlock);
			}
			else
			{
				cmd.DrawProcedural(Matrix4x4.identity, material, shaderPass, MeshTopology.Quads, 4, 1, s_PropertyBlock);
			}
		}

		public static void BlitTexture(CommandBuffer cmd, RTHandle source, Vector4 scaleBias, float mipLevel, bool bilinear)
		{
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevel);
			BlitTexture(cmd, source, scaleBias, GetBlitMaterial(TextureXR.dimension), bilinear ? 1 : 0);
		}

		public static void BlitTexture2D(CommandBuffer cmd, RTHandle source, Vector4 scaleBias, float mipLevel, bool bilinear)
		{
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevel);
			BlitTexture(cmd, source, scaleBias, GetBlitMaterial(TextureDimension.Tex2D), bilinear ? 1 : 0);
		}

		public static void BlitColorAndDepth(CommandBuffer cmd, Texture sourceColor, RenderTexture sourceDepth, Vector4 scaleBias, float mipLevel, bool blitDepth)
		{
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevel);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, scaleBias);
			s_PropertyBlock.SetTexture(BlitShaderIDs._BlitTexture, sourceColor);
			if (blitDepth)
			{
				s_PropertyBlock.SetTexture(BlitShaderIDs._InputDepth, sourceDepth, RenderTextureSubElement.Depth);
			}
			DrawTriangle(cmd, s_BlitColorAndDepth, blitDepth ? 1 : 0);
		}

		public static void BlitTexture(CommandBuffer cmd, RTHandle source, Vector4 scaleBias, Material material, int pass)
		{
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, scaleBias);
			s_PropertyBlock.SetTexture(BlitShaderIDs._BlitTexture, source);
			DrawTriangle(cmd, material, pass);
		}

		public static void BlitTexture(CommandBuffer cmd, RenderTargetIdentifier source, Vector4 scaleBias, Material material, int pass)
		{
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, scaleBias);
			cmd.SetGlobalTexture(BlitShaderIDs._BlitTexture, source);
			DrawTriangle(cmd, material, pass);
		}

		public static void BlitTexture(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material, int pass)
		{
			cmd.SetGlobalTexture(BlitShaderIDs._BlitTexture, source);
			cmd.SetRenderTarget(destination);
			DrawTriangle(cmd, material, pass);
		}

		public static void BlitTexture(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction, Material material, int pass)
		{
			cmd.SetGlobalTexture(BlitShaderIDs._BlitTexture, source);
			cmd.SetRenderTarget(destination, loadAction, storeAction);
			DrawTriangle(cmd, material, pass);
		}

		public static void BlitTexture(CommandBuffer cmd, Vector4 scaleBias, Material material, int pass)
		{
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, scaleBias);
			DrawTriangle(cmd, material, pass);
		}

		public static void BlitCameraTexture(CommandBuffer cmd, RTHandle source, RTHandle destination, float mipLevel = 0f, bool bilinear = false)
		{
			Vector2 vector = (source.useScaling ? new Vector2(source.rtHandleProperties.rtHandleScale.x, source.rtHandleProperties.rtHandleScale.y) : Vector2.one);
			CoreUtils.SetRenderTarget(cmd, destination);
			BlitTexture(cmd, source, vector, mipLevel, bilinear);
		}

		public static void BlitCameraTexture2D(CommandBuffer cmd, RTHandle source, RTHandle destination, float mipLevel = 0f, bool bilinear = false)
		{
			Vector2 vector = (source.useScaling ? new Vector2(source.rtHandleProperties.rtHandleScale.x, source.rtHandleProperties.rtHandleScale.y) : Vector2.one);
			CoreUtils.SetRenderTarget(cmd, destination);
			BlitTexture2D(cmd, source, vector, mipLevel, bilinear);
		}

		public static void BlitCameraTexture(CommandBuffer cmd, RTHandle source, RTHandle destination, Material material, int pass)
		{
			Vector2 vector = (source.useScaling ? new Vector2(source.rtHandleProperties.rtHandleScale.x, source.rtHandleProperties.rtHandleScale.y) : Vector2.one);
			CoreUtils.SetRenderTarget(cmd, destination);
			BlitTexture(cmd, source, vector, material, pass);
		}

		public static void BlitCameraTexture(CommandBuffer cmd, RTHandle source, RTHandle destination, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction, Material material, int pass)
		{
			Vector2 vector = (source.useScaling ? new Vector2(source.rtHandleProperties.rtHandleScale.x, source.rtHandleProperties.rtHandleScale.y) : Vector2.one);
			CoreUtils.SetRenderTarget(cmd, destination, loadAction, storeAction, ClearFlag.None, Color.clear);
			BlitTexture(cmd, source, vector, material, pass);
		}

		public static void BlitCameraTexture(CommandBuffer cmd, RTHandle source, RTHandle destination, Vector4 scaleBias, float mipLevel = 0f, bool bilinear = false)
		{
			CoreUtils.SetRenderTarget(cmd, destination);
			BlitTexture(cmd, source, scaleBias, mipLevel, bilinear);
		}

		public static void BlitCameraTexture(CommandBuffer cmd, RTHandle source, RTHandle destination, Rect destViewport, float mipLevel = 0f, bool bilinear = false)
		{
			Vector2 vector = (source.useScaling ? new Vector2(source.rtHandleProperties.rtHandleScale.x, source.rtHandleProperties.rtHandleScale.y) : Vector2.one);
			CoreUtils.SetRenderTarget(cmd, destination);
			cmd.SetViewport(destViewport);
			BlitTexture(cmd, source, vector, mipLevel, bilinear);
		}

		public static void BlitQuad(CommandBuffer cmd, Texture source, Vector4 scaleBiasTex, Vector4 scaleBiasRT, int mipLevelTex, bool bilinear)
		{
			s_PropertyBlock.SetTexture(BlitShaderIDs._BlitTexture, source);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, scaleBiasTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBiasRt, scaleBiasRT);
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevelTex);
			DrawQuad(cmd, GetBlitMaterial(source.dimension), bilinear ? 3 : 2);
		}

		public static void BlitQuadWithPadding(CommandBuffer cmd, Texture source, Vector2 textureSize, Vector4 scaleBiasTex, Vector4 scaleBiasRT, int mipLevelTex, bool bilinear, int paddingInPixels)
		{
			s_PropertyBlock.SetTexture(BlitShaderIDs._BlitTexture, source);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, scaleBiasTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBiasRt, scaleBiasRT);
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevelTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitTextureSize, textureSize);
			s_PropertyBlock.SetInt(BlitShaderIDs._BlitPaddingSize, paddingInPixels);
			if (source.wrapMode == TextureWrapMode.Repeat)
			{
				DrawQuad(cmd, GetBlitMaterial(source.dimension), bilinear ? 7 : 6);
			}
			else
			{
				DrawQuad(cmd, GetBlitMaterial(source.dimension), bilinear ? 5 : 4);
			}
		}

		public static void BlitQuadWithPaddingMultiply(CommandBuffer cmd, Texture source, Vector2 textureSize, Vector4 scaleBiasTex, Vector4 scaleBiasRT, int mipLevelTex, bool bilinear, int paddingInPixels)
		{
			s_PropertyBlock.SetTexture(BlitShaderIDs._BlitTexture, source);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, scaleBiasTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBiasRt, scaleBiasRT);
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevelTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitTextureSize, textureSize);
			s_PropertyBlock.SetInt(BlitShaderIDs._BlitPaddingSize, paddingInPixels);
			if (source.wrapMode == TextureWrapMode.Repeat)
			{
				DrawQuad(cmd, GetBlitMaterial(source.dimension), bilinear ? 12 : 11);
			}
			else
			{
				DrawQuad(cmd, GetBlitMaterial(source.dimension), bilinear ? 10 : 9);
			}
		}

		public static void BlitOctahedralWithPadding(CommandBuffer cmd, Texture source, Vector2 textureSize, Vector4 scaleBiasTex, Vector4 scaleBiasRT, int mipLevelTex, bool bilinear, int paddingInPixels)
		{
			s_PropertyBlock.SetTexture(BlitShaderIDs._BlitTexture, source);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, scaleBiasTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBiasRt, scaleBiasRT);
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevelTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitTextureSize, textureSize);
			s_PropertyBlock.SetInt(BlitShaderIDs._BlitPaddingSize, paddingInPixels);
			DrawQuad(cmd, GetBlitMaterial(source.dimension), 8);
		}

		public static void BlitOctahedralWithPaddingMultiply(CommandBuffer cmd, Texture source, Vector2 textureSize, Vector4 scaleBiasTex, Vector4 scaleBiasRT, int mipLevelTex, bool bilinear, int paddingInPixels)
		{
			s_PropertyBlock.SetTexture(BlitShaderIDs._BlitTexture, source);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, scaleBiasTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBiasRt, scaleBiasRT);
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevelTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitTextureSize, textureSize);
			s_PropertyBlock.SetInt(BlitShaderIDs._BlitPaddingSize, paddingInPixels);
			DrawQuad(cmd, GetBlitMaterial(source.dimension), 13);
		}

		public static void BlitCubeToOctahedral2DQuad(CommandBuffer cmd, Texture source, Vector4 scaleBiasRT, int mipLevelTex)
		{
			s_PropertyBlock.SetTexture(BlitShaderIDs._BlitCubeTexture, source);
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevelTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, new Vector4(1f, 1f, 0f, 0f));
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBiasRt, scaleBiasRT);
			DrawQuad(cmd, GetBlitMaterial(source.dimension), 14);
		}

		public static void BlitCubeToOctahedral2DQuadWithPadding(CommandBuffer cmd, Texture source, Vector2 textureSize, Vector4 scaleBiasRT, int mipLevelTex, bool bilinear, int paddingInPixels, Vector4? decodeInstructions = null)
		{
			Material blitMaterial = GetBlitMaterial(source.dimension);
			s_PropertyBlock.SetTexture(BlitShaderIDs._BlitCubeTexture, source);
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevelTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, new Vector4(1f, 1f, 0f, 0f));
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBiasRt, scaleBiasRT);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitTextureSize, textureSize);
			s_PropertyBlock.SetInt(BlitShaderIDs._BlitPaddingSize, paddingInPixels);
			cmd.SetKeyword(blitMaterial, in s_DecodeHdrKeyword, decodeInstructions.HasValue);
			if (decodeInstructions.HasValue)
			{
				s_PropertyBlock.SetVector(BlitShaderIDs._BlitDecodeInstructions, decodeInstructions.Value);
			}
			DrawQuad(cmd, blitMaterial, bilinear ? 22 : 21);
			cmd.SetKeyword(blitMaterial, in s_DecodeHdrKeyword, value: false);
		}

		public static void BlitCubeToOctahedral2DQuadSingleChannel(CommandBuffer cmd, Texture source, Vector4 scaleBiasRT, int mipLevelTex)
		{
			int shaderPass = 15;
			if (GraphicsFormatUtility.GetComponentCount(source.graphicsFormat) == 1)
			{
				if (GraphicsFormatUtility.IsAlphaOnlyFormat(source.graphicsFormat))
				{
					shaderPass = 16;
				}
				if (GraphicsFormatUtility.GetSwizzleR(source.graphicsFormat) == FormatSwizzle.FormatSwizzleR)
				{
					shaderPass = 17;
				}
			}
			s_PropertyBlock.SetTexture(BlitShaderIDs._BlitCubeTexture, source);
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevelTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, new Vector4(1f, 1f, 0f, 0f));
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBiasRt, scaleBiasRT);
			DrawQuad(cmd, GetBlitMaterial(source.dimension), shaderPass);
		}

		public static void BlitQuadSingleChannel(CommandBuffer cmd, Texture source, Vector4 scaleBiasTex, Vector4 scaleBiasRT, int mipLevelTex)
		{
			int shaderPass = 18;
			if (GraphicsFormatUtility.GetComponentCount(source.graphicsFormat) == 1)
			{
				if (GraphicsFormatUtility.IsAlphaOnlyFormat(source.graphicsFormat))
				{
					shaderPass = 19;
				}
				if (GraphicsFormatUtility.GetSwizzleR(source.graphicsFormat) == FormatSwizzle.FormatSwizzleR)
				{
					shaderPass = 20;
				}
			}
			s_PropertyBlock.SetTexture(BlitShaderIDs._BlitTexture, source);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBias, scaleBiasTex);
			s_PropertyBlock.SetVector(BlitShaderIDs._BlitScaleBiasRt, scaleBiasRT);
			s_PropertyBlock.SetFloat(BlitShaderIDs._BlitMipLevel, mipLevelTex);
			DrawQuad(cmd, GetBlitMaterial(source.dimension), shaderPass);
		}
	}
	public static class CameraCaptureBridge
	{
		private static Dictionary<Camera, HashSet<Action<RenderTargetIdentifier, CommandBuffer>>> actionDict = new Dictionary<Camera, HashSet<Action<RenderTargetIdentifier, CommandBuffer>>>();

		private static bool _enabled;

		public static bool enabled
		{
			get
			{
				return _enabled;
			}
			set
			{
				_enabled = value;
			}
		}

		public static IEnumerator<Action<RenderTargetIdentifier, CommandBuffer>> GetCaptureActions(Camera camera)
		{
			if (!actionDict.TryGetValue(camera, out var value) || value.Count == 0)
			{
				return null;
			}
			return value.GetEnumerator();
		}

		public static void AddCaptureAction(Camera camera, Action<RenderTargetIdentifier, CommandBuffer> action)
		{
			actionDict.TryGetValue(camera, out var value);
			if (value == null)
			{
				value = new HashSet<Action<RenderTargetIdentifier, CommandBuffer>>();
				actionDict.Add(camera, value);
			}
			value.Add(action);
		}

		public static void RemoveCaptureAction(Camera camera, Action<RenderTargetIdentifier, CommandBuffer> action)
		{
			if (!(camera == null) && actionDict.TryGetValue(camera, out var value))
			{
				value.Remove(action);
			}
		}
	}
	internal static class ColorSpaceUtils
	{
		public static readonly Matrix4x4 Rec709ToRec2020Mat = new Matrix4x4(new Vector4(0.627402f, 0.069095f, 0.016394f, 0f), new Vector4(0.329292f, 0.919544f, 0.088028f, 0f), new Vector4(0.043306f, 0.01136f, 0.895578f, 0f), new Vector4(0f, 0f, 0f, 0f));

		public static readonly Matrix4x4 Rec709ToP3D65Mat = new Matrix4x4(new Vector4(0.822462f, 0.033194f, 0.017083f, 0f), new Vector4(0.177538f, 0.966806f, 0.072397f, 0f), new Vector4(0f, 0f, 0.91052f, 0f), new Vector4(0f, 0f, 0f, 0f));

		public static readonly Matrix4x4 Rec2020ToRec709Mat = new Matrix4x4(new Vector4(1.660496f, -0.124547f, -0.018154f, 0f), new Vector4(-0.587656f, 1.132895f, -0.100597f, 0f), new Vector4(-0.07284f, -0.008348f, 1.118751f, 0f), new Vector4(0f, 0f, 0f, 0f));

		public static readonly Matrix4x4 Rec2020ToP3D65Mat = new Matrix4x4(new Vector4(1.343578f, -0.065298f, 0.002822f, 0f), new Vector4(-0.28218f, 1.075788f, -0.019599f, 0f), new Vector4(-0.0613986f, -0.010491f, 1.016777f, 0f), new Vector4(0f, 0f, 0f, 0f));

		public static readonly Matrix4x4 P3D65ToRec2020Mat = new Matrix4x4(new Vector4(0.753833f, 0.045744f, -0.00121f, 0f), new Vector4(0.198597f, 0.941777f, 0.017602f, 0f), new Vector4(0.04757f, 0.012479f, 0.983609f, 0f), new Vector4(0f, 0f, 0f, 0f));
	}
	public static class ColorUtils
	{
		public static float s_LightMeterCalibrationConstant = 12.5f;

		public static float s_LensAttenuation = 0.65f;

		public static float lensImperfectionExposureScale => 78f / (100f * s_LensAttenuation);

		public static float StandardIlluminantY(float x)
		{
			return 2.87f * x - 3f * x * x - 0.27509508f;
		}

		public static Vector3 CIExyToLMS(float x, float y)
		{
			float num = 1f;
			float num2 = num * x / y;
			float num3 = num * (1f - x - y) / y;
			float x2 = 0.7328f * num2 + 0.4296f * num - 0.1624f * num3;
			float y2 = -0.7036f * num2 + 1.6975f * num + 0.0061f * num3;
			float z = 0.003f * num2 + 0.0136f * num + 0.9834f * num3;
			return new Vector3(x2, y2, z);
		}

		public static Vector3 ColorBalanceToLMSCoeffs(float temperature, float tint)
		{
			float num = temperature / 65f;
			float num2 = tint / 65f;
			float x = 0.31271f - num * ((num < 0f) ? 0.1f : 0.05f);
			float y = StandardIlluminantY(x) + num2 * 0.05f;
			Vector3 vector = new Vector3(0.949237f, 1.03542f, 1.08728f);
			Vector3 vector2 = CIExyToLMS(x, y);
			return new Vector3(vector.x / vector2.x, vector.y / vector2.y, vector.z / vector2.z);
		}

		public static (Vector4, Vector4, Vector4) PrepareShadowsMidtonesHighlights(in Vector4 inShadows, in Vector4 inMidtones, in Vector4 inHighlights)
		{
			Vector4 item = inShadows;
			item.x = Mathf.GammaToLinearSpace(item.x);
			item.y = Mathf.GammaToLinearSpace(item.y);
			item.z = Mathf.GammaToLinearSpace(item.z);
			float num = item.w * ((Mathf.Sign(item.w) < 0f) ? 1f : 4f);
			item.x = Mathf.Max(item.x + num, 0f);
			item.y = Mathf.Max(item.y + num, 0f);
			item.z = Mathf.Max(item.z + num, 0f);
			item.w = 0f;
			Vector4 item2 = inMidtones;
			item2.x = Mathf.GammaToLinearSpace(item2.x);
			item2.y = Mathf.GammaToLinearSpace(item2.y);
			item2.z = Mathf.GammaToLinearSpace(item2.z);
			num = item2.w * ((Mathf.Sign(item2.w) < 0f) ? 1f : 4f);
			item2.x = Mathf.Max(item2.x + num, 0f);
			item2.y = Mathf.Max(item2.y + num, 0f);
			item2.z = Mathf.Max(item2.z + num, 0f);
			item2.w = 0f;
			Vector4 item3 = inHighlights;
			item3.x = Mathf.GammaToLinearSpace(item3.x);
			item3.y = Mathf.GammaToLinearSpace(item3.y);
			item3.z = Mathf.GammaToLinearSpace(item3.z);
			num = item3.w * ((Mathf.Sign(item3.w) < 0f) ? 1f : 4f);
			item3.x = Mathf.Max(item3.x + num, 0f);
			item3.y = Mathf.Max(item3.y + num, 0f);
			item3.z = Mathf.Max(item3.z + num, 0f);
			item3.w = 0f;
			return (item, item2, item3);
		}

		public static (Vector4, Vector4, Vector4) PrepareLiftGammaGain(in Vector4 inLift, in Vector4 inGamma, in Vector4 inGain)
		{
			Vector4 vector = inLift;
			vector.x = Mathf.GammaToLinearSpace(vector.x) * 0.15f;
			vector.y = Mathf.GammaToLinearSpace(vector.y) * 0.15f;
			vector.z = Mathf.GammaToLinearSpace(vector.z) * 0.15f;
			float num = Luminance((Color)vector);
			vector.x = vector.x - num + vector.w;
			vector.y = vector.y - num + vector.w;
			vector.z = vector.z - num + vector.w;
			vector.w = 0f;
			Vector4 vector2 = inGamma;
			vector2.x = Mathf.GammaToLinearSpace(vector2.x) * 0.8f;
			vector2.y = Mathf.GammaToLinearSpace(vector2.y) * 0.8f;
			vector2.z = Mathf.GammaToLinearSpace(vector2.z) * 0.8f;
			float num2 = Luminance((Color)vector2);
			vector2.w += 1f;
			vector2.x = 1f / Mathf.Max(vector2.x - num2 + vector2.w, 0.001f);
			vector2.y = 1f / Mathf.Max(vector2.y - num2 + vector2.w, 0.001f);
			vector2.z = 1f / Mathf.Max(vector2.z - num2 + vector2.w, 0.001f);
			vector2.w = 0f;
			Vector4 vector3 = inGain;
			vector3.x = Mathf.GammaToLinearSpace(vector3.x) * 0.8f;
			vector3.y = Mathf.GammaToLinearSpace(vector3.y) * 0.8f;
			vector3.z = Mathf.GammaToLinearSpace(vector3.z) * 0.8f;
			float num3 = Luminance((Color)vector3);
			vector3.w += 1f;
			vector3.x = vector3.x - num3 + vector3.w;
			vector3.y = vector3.y - num3 + vector3.w;
			vector3.z = vector3.z - num3 + vector3.w;
			vector3.w = 0f;
			return (vector, vector2, vector3);
		}

		public static (Vector4, Vector4) PrepareSplitToning(in Vector4 inShadows, in Vector4 inHighlights, float balance)
		{
			Vector4 item = inShadows;
			Vector4 item2 = inHighlights;
			item.w = balance / 100f;
			item2.w = 0f;
			return (item, item2);
		}

		public static float Luminance(in Color color)
		{
			return color.r * 0.2126729f + color.g * 0.7151522f + color.b * 0.072175f;
		}

		public static float ComputeEV100(float aperture, float shutterSpeed, float ISO)
		{
			return Mathf.Log(aperture * aperture / shutterSpeed * 100f / ISO, 2f);
		}

		public static float ConvertEV100ToExposure(float EV100)
		{
			float num = lensImperfectionExposureScale * Mathf.Pow(2f, EV100);
			return 1f / num;
		}

		public static float ConvertExposureToEV100(float exposure)
		{
			return Mathf.Log(1f / (lensImperfectionExposureScale * exposure), 2f);
		}

		public static float ComputeEV100FromAvgLuminance(float avgLuminance)
		{
			float num = s_LightMeterCalibrationConstant;
			return Mathf.Log(avgLuminance * 100f / num, 2f);
		}

		public static float ComputeISO(float aperture, float shutterSpeed, float targetEV100)
		{
			return aperture * aperture * 100f / (shutterSpeed * Mathf.Pow(2f, targetEV100));
		}

		public static uint ToHex(Color c)
		{
			return ((uint)(c.a * 255f) << 24) | ((uint)(c.r * 255f) << 16) | ((uint)(c.g * 255f) << 8) | (uint)(c.b * 255f);
		}

		public static Color ToRGBA(uint hex)
		{
			return new Color((float)((hex >> 16) & 0xFF) / 255f, (float)((hex >> 8) & 0xFF) / 255f, (float)(hex & 0xFF) / 255f, (float)((hex >> 24) & 0xFF) / 255f);
		}
	}
	public static class CoreMatrixUtils
	{
		public static void MatrixTimesTranslation(ref Matrix4x4 inOutMatrix, Vector3 translation)
		{
			inOutMatrix.m03 += inOutMatrix.m00 * translation.x + inOutMatrix.m01 * translation.y + inOutMatrix.m02 * translation.z;
			inOutMatrix.m13 += inOutMatrix.m10 * translation.x + inOutMatrix.m11 * translation.y + inOutMatrix.m12 * translation.z;
			inOutMatrix.m23 += inOutMatrix.m20 * translation.x + inOutMatrix.m21 * translation.y + inOutMatrix.m22 * translation.z;
		}

		public static void TranslationTimesMatrix(ref Matrix4x4 inOutMatrix, Vector3 translation)
		{
			inOutMatrix.m00 += translation.x * inOutMatrix.m30;
			inOutMatrix.m01 += translation.x * inOutMatrix.m31;
			inOutMatrix.m02 += translation.x * inOutMatrix.m32;
			inOutMatrix.m03 += translation.x * inOutMatrix.m33;
			inOutMatrix.m10 += translation.y * inOutMatrix.m30;
			inOutMatrix.m11 += translation.y * inOutMatrix.m31;
			inOutMatrix.m12 += translation.y * inOutMatrix.m32;
			inOutMatrix.m13 += translation.y * inOutMatrix.m33;
			inOutMatrix.m20 += translation.z * inOutMatrix.m30;
			inOutMatrix.m21 += translation.z * inOutMatrix.m31;
			inOutMatrix.m22 += translation.z * inOutMatrix.m32;
			inOutMatrix.m23 += translation.z * inOutMatrix.m33;
		}

		public static Matrix4x4 MultiplyPerspectiveMatrix(Matrix4x4 perspective, Matrix4x4 rhs)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.m00 = perspective.m00 * rhs.m00;
			result.m01 = perspective.m00 * rhs.m01;
			result.m02 = perspective.m00 * rhs.m02;
			result.m03 = perspective.m00 * rhs.m03;
			result.m10 = perspective.m11 * rhs.m10;
			result.m11 = perspective.m11 * rhs.m11;
			result.m12 = perspective.m11 * rhs.m12;
			result.m13 = perspective.m11 * rhs.m13;
			result.m20 = perspective.m22 * rhs.m20 + perspective.m23 * rhs.m30;
			result.m21 = perspective.m22 * rhs.m21 + perspective.m23 * rhs.m31;
			result.m22 = perspective.m22 * rhs.m22 + perspective.m23 * rhs.m32;
			result.m23 = perspective.m22 * rhs.m23 + perspective.m23 * rhs.m33;
			result.m30 = 0f - rhs.m20;
			result.m31 = 0f - rhs.m21;
			result.m32 = 0f - rhs.m22;
			result.m33 = 0f - rhs.m23;
			return result;
		}

		private static Matrix4x4 MultiplyOrthoMatrixCentered(Matrix4x4 ortho, Matrix4x4 rhs)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.m00 = ortho.m00 * rhs.m00;
			result.m01 = ortho.m00 * rhs.m01;
			result.m02 = ortho.m00 * rhs.m02;
			result.m03 = ortho.m00 * rhs.m03;
			result.m10 = ortho.m11 * rhs.m10;
			result.m11 = ortho.m11 * rhs.m11;
			result.m12 = ortho.m11 * rhs.m12;
			result.m13 = ortho.m11 * rhs.m13;
			result.m20 = ortho.m22 * rhs.m20 + ortho.m23 * rhs.m30;
			result.m21 = ortho.m22 * rhs.m21 + ortho.m23 * rhs.m31;
			result.m22 = ortho.m22 * rhs.m22 + ortho.m23 * rhs.m32;
			result.m23 = ortho.m22 * rhs.m23 + ortho.m23 * rhs.m33;
			result.m30 = rhs.m20;
			result.m31 = rhs.m21;
			result.m32 = rhs.m22;
			result.m33 = rhs.m23;
			return result;
		}

		private static Matrix4x4 MultiplyGenericOrthoMatrix(Matrix4x4 ortho, Matrix4x4 rhs)
		{
			Matrix4x4 result = default(Matrix4x4);
			result.m00 = ortho.m00 * rhs.m00 + ortho.m03 * rhs.m30;
			result.m01 = ortho.m00 * rhs.m01 + ortho.m03 * rhs.m31;
			result.m02 = ortho.m00 * rhs.m02 + ortho.m03 * rhs.m32;
			result.m03 = ortho.m00 * rhs.m03 + ortho.m03 * rhs.m33;
			result.m10 = ortho.m11 * rhs.m10 + ortho.m13 * rhs.m30;
			result.m11 = ortho.m11 * rhs.m11 + ortho.m13 * rhs.m31;
			result.m12 = ortho.m11 * rhs.m12 + ortho.m13 * rhs.m32;
			result.m13 = ortho.m11 * rhs.m13 + ortho.m13 * rhs.m33;
			result.m20 = ortho.m22 * rhs.m20 + ortho.m23 * rhs.m30;
			result.m21 = ortho.m22 * rhs.m21 + ortho.m23 * rhs.m31;
			result.m22 = ortho.m22 * rhs.m22 + ortho.m23 * rhs.m32;
			result.m23 = ortho.m22 * rhs.m23 + ortho.m23 * rhs.m33;
			result.m30 = rhs.m20;
			result.m31 = rhs.m21;
			result.m32 = rhs.m22;
			result.m33 = rhs.m23;
			return result;
		}

		public static Matrix4x4 MultiplyOrthoMatrix(Matrix4x4 ortho, Matrix4x4 rhs, bool centered)
		{
			if (!centered)
			{
				return MultiplyOrthoMatrixCentered(ortho, rhs);
			}
			return MultiplyGenericOrthoMatrix(ortho, rhs);
		}

		public static Matrix4x4 MultiplyProjectionMatrix(Matrix4x4 projMatrix, Matrix4x4 rhs, bool orthoCentered)
		{
			if (!orthoCentered)
			{
				return MultiplyPerspectiveMatrix(projMatrix, rhs);
			}
			return MultiplyOrthoMatrixCentered(projMatrix, rhs);
		}
	}
	public static class CoreUtils
	{
		public static class Sections
		{
			public const int section1 = 10000;

			public const int section2 = 20000;

			public const int section3 = 30000;

			public const int section4 = 40000;

			public const int section5 = 50000;

			public const int section6 = 60000;

			public const int section7 = 70000;

			public const int section8 = 80000;
		}

		public static class Priorities
		{
			public const int assetsCreateShaderMenuPriority = 83;

			public const int assetsCreateRenderingMenuPriority = 308;

			public const int editMenuPriority = 320;

			public const int gameObjectMenuPriority = 10;

			public const int srpLensFlareMenuPriority = 303;
		}

		public static readonly Vector3[] lookAtList = new Vector3[6]
		{
			new Vector3(1f, 0f, 0f),
			new Vector3(-1f, 0f, 0f),
			new Vector3(0f, 1f, 0f),
			new Vector3(0f, -1f, 0f),
			new Vector3(0f, 0f, 1f),
			new Vector3(0f, 0f, -1f)
		};

		public static readonly Vector3[] upVectorList = new Vector3[6]
		{
			new Vector3(0f, 1f, 0f),
			new Vector3(0f, 1f, 0f),
			new Vector3(0f, 0f, -1f),
			new Vector3(0f, 0f, 1f),
			new Vector3(0f, 1f, 0f),
			new Vector3(0f, 1f, 0f)
		};

		private const string obsoletePriorityMessage = "Use CoreUtils.Priorities instead";

		[Obsolete("Use CoreUtils.Priorities instead", false)]
		public const int editMenuPriority1 = 320;

		[Obsolete("Use CoreUtils.Priorities instead", false)]
		public const int editMenuPriority2 = 331;

		[Obsolete("Use CoreUtils.Priorities instead", false)]
		public const int editMenuPriority3 = 342;

		[Obsolete("Use CoreUtils.Priorities instead", false)]
		public const int editMenuPriority4 = 353;

		[Obsolete("Use CoreUtils.Priorities instead", false)]
		public const int assetCreateMenuPriority1 = 230;

		[Obsolete("Use CoreUtils.Priorities instead", false)]
		public const int assetCreateMenuPriority2 = 241;

		[Obsolete("Use CoreUtils.Priorities instead", false)]
		public const int assetCreateMenuPriority3 = 300;

		[Obsolete("Use CoreUtils.Priorities instead", false)]
		public const int gameObjectMenuPriority = 10;

		private static Cubemap m_BlackCubeTexture;

		private static Cubemap m_MagentaCubeTexture;

		private static CubemapArray m_MagentaCubeTextureArray;

		private static Cubemap m_WhiteCubeTexture;

		private static RenderTexture m_EmptyUAV;

		private static Texture3D m_BlackVolumeTexture;

		private static IEnumerable<Type> m_AssemblyTypes;

		public static Cubemap blackCubeTexture
		{
			get
			{
				if (m_BlackCubeTexture == null)
				{
					m_BlackCubeTexture = new Cubemap(1, GraphicsFormat.R8G8B8A8_SRGB, TextureCreationFlags.None);
					for (int i = 0; i < 6; i++)
					{
						m_BlackCubeTexture.SetPixel((CubemapFace)i, 0, 0, Color.black);
					}
					m_BlackCubeTexture.Apply();
				}
				return m_BlackCubeTexture;
			}
		}

		public static Cubemap magentaCubeTexture
		{
			get
			{
				if (m_MagentaCubeTexture == null)
				{
					m_MagentaCubeTexture = new Cubemap(1, GraphicsFormat.R8G8B8A8_SRGB, TextureCreationFlags.None);
					for (int i = 0; i < 6; i++)
					{
						m_MagentaCubeTexture.SetPixel((CubemapFace)i, 0, 0, Color.magenta);
					}
					m_MagentaCubeTexture.Apply();
				}
				return m_MagentaCubeTexture;
			}
		}

		public static CubemapArray magentaCubeTextureArray
		{
			get
			{
				if (m_MagentaCubeTextureArray == null)
				{
					m_MagentaCubeTextureArray = new CubemapArray(1, 1, GraphicsFormat.R32G32B32A32_SFloat, TextureCreationFlags.None);
					for (int i = 0; i < 6; i++)
					{
						Color[] colors = new Color[1] { Color.magenta };
						m_MagentaCubeTextureArray.SetPixels(colors, (CubemapFace)i, 0);
					}
					m_MagentaCubeTextureArray.Apply();
				}
				return m_MagentaCubeTextureArray;
			}
		}

		public static Cubemap whiteCubeTexture
		{
			get
			{
				if (m_WhiteCubeTexture == null)
				{
					m_WhiteCubeTexture = new Cubemap(1, GraphicsFormat.R8G8B8A8_SRGB, TextureCreationFlags.None);
					for (int i = 0; i < 6; i++)
					{
						m_WhiteCubeTexture.SetPixel((CubemapFace)i, 0, 0, Color.white);
					}
					m_WhiteCubeTexture.Apply();
				}
				return m_WhiteCubeTexture;
			}
		}

		public static RenderTexture emptyUAV
		{
			get
			{
				if (m_EmptyUAV == null)
				{
					m_EmptyUAV = new RenderTexture(1, 1, 0);
					m_EmptyUAV.enableRandomWrite = true;
					m_EmptyUAV.Create();
				}
				return m_EmptyUAV;
			}
		}

		public static Texture3D blackVolumeTexture
		{
			get
			{
				if (m_BlackVolumeTexture == null)
				{
					Color[] colors = new Color[1] { Color.black };
					m_BlackVolumeTexture = new Texture3D(1, 1, 1, GraphicsFormat.R8G8B8A8_SRGB, TextureCreationFlags.None);
					m_BlackVolumeTexture.SetPixels(colors, 0);
					m_BlackVolumeTexture.Apply();
				}
				return m_BlackVolumeTexture;
			}
		}

		public static void ClearRenderTarget(CommandBuffer cmd, ClearFlag clearFlag, Color clearColor)
		{
			if (clearFlag != ClearFlag.None)
			{
				cmd.ClearRenderTarget((RTClearFlags)clearFlag, clearColor, 1f, 0u);
			}
		}

		private static int FixupDepthSlice(int depthSlice, RTHandle buffer)
		{
			if (depthSlice == -1)
			{
				RenderTexture rt = buffer.rt;
				if ((object)rt != null && rt.dimension == TextureDimension.Cube)
				{
					depthSlice = 0;
				}
			}
			return depthSlice;
		}

		private static int FixupDepthSlice(int depthSlice, CubemapFace cubemapFace)
		{
			if (depthSlice == -1 && cubemapFace != CubemapFace.Unknown)
			{
				depthSlice = 0;
			}
			return depthSlice;
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier buffer, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			depthSlice = FixupDepthSlice(depthSlice, cubemapFace);
			cmd.SetRenderTarget(buffer, miplevel, cubemapFace, depthSlice);
			ClearRenderTarget(cmd, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier buffer, ClearFlag clearFlag = ClearFlag.None, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			SetRenderTarget(cmd, buffer, clearFlag, Color.clear, miplevel, cubemapFace, depthSlice);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderTargetIdentifier depthBuffer, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			SetRenderTarget(cmd, colorBuffer, depthBuffer, ClearFlag.None, Color.clear, miplevel, cubemapFace, depthSlice);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderTargetIdentifier depthBuffer, ClearFlag clearFlag, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			SetRenderTarget(cmd, colorBuffer, depthBuffer, clearFlag, Color.clear, miplevel, cubemapFace, depthSlice);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderTargetIdentifier depthBuffer, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			depthSlice = FixupDepthSlice(depthSlice, cubemapFace);
			cmd.SetRenderTarget(colorBuffer, depthBuffer, miplevel, cubemapFace, depthSlice);
			ClearRenderTarget(cmd, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RenderTargetIdentifier depthBuffer)
		{
			SetRenderTarget(cmd, colorBuffers, depthBuffer, ClearFlag.None, Color.clear);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RenderTargetIdentifier depthBuffer, ClearFlag clearFlag = ClearFlag.None)
		{
			SetRenderTarget(cmd, colorBuffers, depthBuffer, clearFlag, Color.clear);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RenderTargetIdentifier depthBuffer, ClearFlag clearFlag, Color clearColor)
		{
			cmd.SetRenderTarget(colorBuffers, depthBuffer, 0, CubemapFace.Unknown, -1);
			ClearRenderTarget(cmd, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier buffer, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction, ClearFlag clearFlag, Color clearColor)
		{
			cmd.SetRenderTarget(buffer, loadAction, storeAction);
			ClearRenderTarget(cmd, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier buffer, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			depthSlice = FixupDepthSlice(depthSlice, cubemapFace);
			buffer = new RenderTargetIdentifier(buffer, miplevel, cubemapFace, depthSlice);
			cmd.SetRenderTarget(buffer, loadAction, storeAction);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier buffer, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			depthSlice = FixupDepthSlice(depthSlice, cubemapFace);
			buffer = new RenderTargetIdentifier(buffer, miplevel, cubemapFace, depthSlice);
			SetRenderTarget(cmd, buffer, loadAction, storeAction, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier buffer, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction, ClearFlag clearFlag)
		{
			SetRenderTarget(cmd, buffer, loadAction, storeAction, clearFlag, Color.clear);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depthBuffer, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, ClearFlag clearFlag, Color clearColor)
		{
			cmd.SetRenderTarget(colorBuffer, colorLoadAction, colorStoreAction, depthBuffer, depthLoadAction, depthStoreAction);
			ClearRenderTarget(cmd, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depthBuffer, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			depthSlice = FixupDepthSlice(depthSlice, cubemapFace);
			colorBuffer = new RenderTargetIdentifier(colorBuffer, miplevel, cubemapFace, depthSlice);
			depthBuffer = new RenderTargetIdentifier(depthBuffer, miplevel, cubemapFace, depthSlice);
			cmd.SetRenderTarget(colorBuffer, colorLoadAction, colorStoreAction, depthBuffer, depthLoadAction, depthStoreAction);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depthBuffer, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			depthSlice = FixupDepthSlice(depthSlice, cubemapFace);
			colorBuffer = new RenderTargetIdentifier(colorBuffer, miplevel, cubemapFace, depthSlice);
			depthBuffer = new RenderTargetIdentifier(depthBuffer, miplevel, cubemapFace, depthSlice);
			SetRenderTarget(cmd, colorBuffer, colorLoadAction, colorStoreAction, depthBuffer, depthLoadAction, depthStoreAction, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier buffer, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, ClearFlag clearFlag, Color clearColor)
		{
			cmd.SetRenderTarget(buffer, colorLoadAction, colorStoreAction, depthLoadAction, depthStoreAction);
			ClearRenderTarget(cmd, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depthBuffer, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, ClearFlag clearFlag)
		{
			SetRenderTarget(cmd, colorBuffer, colorLoadAction, colorStoreAction, depthBuffer, depthLoadAction, depthStoreAction, clearFlag, Color.clear);
		}

		private static void SetViewportAndClear(CommandBuffer cmd, RTHandle buffer, ClearFlag clearFlag, Color clearColor)
		{
			SetViewport(cmd, buffer);
			ClearRenderTarget(cmd, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RTHandle buffer, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			depthSlice = FixupDepthSlice(depthSlice, buffer);
			cmd.SetRenderTarget(buffer.nameID, miplevel, cubemapFace, depthSlice);
			SetViewportAndClear(cmd, buffer, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RTHandle buffer, ClearFlag clearFlag = ClearFlag.None, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			SetRenderTarget(cmd, buffer, clearFlag, Color.clear, miplevel, cubemapFace, depthSlice);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RTHandle colorBuffer, RTHandle depthBuffer, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			if (colorBuffer.rt != null && depthBuffer.rt != null)
			{
				int width = colorBuffer.rt.width;
				int height = colorBuffer.rt.height;
				int width2 = depthBuffer.rt.width;
				int height2 = depthBuffer.rt.height;
				Debug.Assert(width == width2 && height == height2);
			}
			SetRenderTarget(cmd, colorBuffer, depthBuffer, ClearFlag.None, Color.clear, miplevel, cubemapFace, depthSlice);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RTHandle colorBuffer, RTHandle depthBuffer, ClearFlag clearFlag, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			if (colorBuffer.rt != null && depthBuffer.rt != null)
			{
				int width = colorBuffer.rt.width;
				int height = colorBuffer.rt.height;
				int width2 = depthBuffer.rt.width;
				int height2 = depthBuffer.rt.height;
				Debug.Assert(width == width2 && height == height2);
			}
			SetRenderTarget(cmd, colorBuffer, depthBuffer, clearFlag, Color.clear, miplevel, cubemapFace, depthSlice);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RTHandle colorBuffer, RTHandle depthBuffer, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			if (colorBuffer.rt != null && depthBuffer.rt != null)
			{
				int width = colorBuffer.rt.width;
				int height = colorBuffer.rt.height;
				int width2 = depthBuffer.rt.width;
				int height2 = depthBuffer.rt.height;
				Debug.Assert(width == width2 && height == height2);
			}
			SetRenderTarget(cmd, colorBuffer.nameID, depthBuffer.nameID, miplevel, cubemapFace, depthSlice);
			SetViewportAndClear(cmd, colorBuffer, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RTHandle buffer, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			SetRenderTarget(cmd, buffer.nameID, loadAction, storeAction, miplevel, cubemapFace, depthSlice);
			SetViewportAndClear(cmd, buffer, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RTHandle colorBuffer, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RTHandle depthBuffer, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = CubemapFace.Unknown, int depthSlice = -1)
		{
			if (colorBuffer.rt != null && depthBuffer.rt != null)
			{
				int width = colorBuffer.rt.width;
				int height = colorBuffer.rt.height;
				int width2 = depthBuffer.rt.width;
				int height2 = depthBuffer.rt.height;
				Debug.Assert(width == width2 && height == height2);
			}
			SetRenderTarget(cmd, colorBuffer.nameID, colorLoadAction, colorStoreAction, depthBuffer.nameID, depthLoadAction, depthStoreAction, miplevel, cubemapFace, depthSlice);
			SetViewportAndClear(cmd, colorBuffer, clearFlag, clearColor);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RTHandle depthBuffer)
		{
			SetRenderTarget(cmd, colorBuffers, depthBuffer.nameID, ClearFlag.None, Color.clear);
			SetViewport(cmd, depthBuffer);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RTHandle depthBuffer, ClearFlag clearFlag = ClearFlag.None)
		{
			SetRenderTarget(cmd, colorBuffers, depthBuffer.nameID);
			SetViewportAndClear(cmd, depthBuffer, clearFlag, Color.clear);
		}

		public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RTHandle depthBuffer, ClearFlag clearFlag, Color clearColor)
		{
			cmd.SetRenderTarget(colorBuffers, depthBuffer.nameID, 0, CubemapFace.Unknown, -1);
			SetViewportAndClear(cmd, depthBuffer, clearFlag, clearColor);
		}

		public static void SetViewport(CommandBuffer cmd, RTHandle target)
		{
			if (target.useScaling)
			{
				Vector2Int scaledSize = target.GetScaledSize(target.rtHandleProperties.currentViewportSize);
				cmd.SetViewport(new Rect(0f, 0f, scaledSize.x, scaledSize.y));
			}
		}

		public static string GetRenderTargetAutoName(int width, int height, int depth, RenderTextureFormat format, string name, bool mips = false, bool enableMSAA = false, MSAASamples msaaSamples = MSAASamples.None)
		{
			return GetRenderTargetAutoName(width, height, depth, format.ToString(), TextureDimension.None, name, mips, enableMSAA, msaaSamples, dynamicRes: false);
		}

		public static string GetRenderTargetAutoName(int width, int height, int depth, GraphicsFormat format, string name, bool mips = false, bool enableMSAA = false, MSAASamples msaaSamples = MSAASamples.None)
		{
			return GetRenderTargetAutoName(width, height, depth, format.ToString(), TextureDimension.None, name, mips, enableMSAA, msaaSamples, dynamicRes: false);
		}

		public static string GetRenderTargetAutoName(int width, int height, int depth, GraphicsFormat format, TextureDimension dim, string name, bool mips = false, bool enableMSAA = false, MSAASamples msaaSamples = MSAASamples.None, bool dynamicRes = false)
		{
			return GetRenderTargetAutoName(width, height, depth, format.ToString(), dim, name, mips, enableMSAA, msaaSamples, dynamicRes);
		}

		private static string GetRenderTargetAutoName(int width, int height, int depth, string format, TextureDimension dim, string name, bool mips, bool enableMSAA, MSAASamples msaaSamples, bool dynamicRes)
		{
			string arg = $"{name}_{width}x{height}";
			if (depth > 1)
			{
				arg = $"{arg}x{depth}";
			}
			if (mips)
			{
				arg = string.Format("{0}_{1}", arg, "Mips");
			}
			arg = $"{arg}_{format}";
			if (dim != TextureDimension.None)
			{
				arg = $"{arg}_{dim}";
			}
			if (enableMSAA)
			{
				arg = $"{arg}_{msaaSamples.ToString()}";
			}
			if (dynamicRes)
			{
				arg = string.Format("{0}_{1}", arg, "dynamic");
			}
			return arg;
		}

		public static string GetTextureAutoName(int width, int height, TextureFormat format, TextureDimension dim = TextureDimension.None, string name = "", bool mips = false, int depth = 0)
		{
			return GetTextureAutoName(width, height, format.ToString(), dim, name, mips, depth);
		}

		public static string GetTextureAutoName(int width, int height, GraphicsFormat format, TextureDimension dim = TextureDimension.None, string name = "", bool mips = false, int depth = 0)
		{
			return GetTextureAutoName(width, height, format.ToString(), dim, name, mips, depth);
		}

		private static string GetTextureAutoName(int width, int height, string format, TextureDimension dim = TextureDimension.None, string name = "", bool mips = false, int depth = 0)
		{
			return string.Format(arg2: (depth != 0) ? string.Format("{0}x{1}x{2}{3}_{4}", width, height, depth, mips ? "_Mips" : "", format) : string.Format("{0}x{1}{2}_{3}", width, height, mips ? "_Mips" : "", format), format: "{0}_{1}_{2}", arg0: (name == "") ? "Texture" : name, arg1: (dim == TextureDimension.None) ? "" : dim.ToString());
		}

		public static void ClearCubemap(CommandBuffer cmd, RenderTexture renderTexture, Color clearColor, bool clearMips = false)
		{
			int num = 1;
			if (renderTexture.useMipMap && clearMips)
			{
				num = (int)Mathf.Log(renderTexture.width, 2f) + 1;
			}
			for (int i = 0; i < 6; i++)
			{
				for (int j = 0; j < num; j++)
				{
					SetRenderTarget(cmd, new RenderTargetIdentifier(renderTexture), ClearFlag.Color, clearColor, j, (CubemapFace)i);
				}
			}
		}

		public static void DrawFullScreen(CommandBuffer commandBuffer, Material material, MaterialPropertyBlock properties = null, int shaderPassId = 0)
		{
			commandBuffer.DrawProcedural(Matrix4x4.identity, material, shaderPassId, MeshTopology.Triangles, 3, 1, properties);
		}

		public static void DrawFullScreen(CommandBuffer commandBuffer, Material material, RenderTargetIdentifier colorBuffer, MaterialPropertyBlock properties = null, int shaderPassId = 0)
		{
			commandBuffer.SetRenderTarget(colorBuffer, 0, CubemapFace.Unknown, -1);
			commandBuffer.DrawProcedural(Matrix4x4.identity, material, shaderPassId, MeshTopology.Triangles, 3, 1, properties);
		}

		public static void DrawFullScreen(CommandBuffer commandBuffer, Material material, RenderTargetIdentifier colorBuffer, RenderTargetIdentifier depthStencilBuffer, MaterialPropertyBlock properties = null, int shaderPassId = 0)
		{
			commandBuffer.SetRenderTarget(colorBuffer, depthStencilBuffer, 0, CubemapFace.Unknown, -1);
			commandBuffer.DrawProcedural(Matrix4x4.identity, material, shaderPassId, MeshTopology.Triangles, 3, 1, properties);
		}

		public static void DrawFullScreen(CommandBuffer commandBuffer, Material material, RenderTargetIdentifier[] colorBuffers, RenderTargetIdentifier depthStencilBuffer, MaterialPropertyBlock properties = null, int shaderPassId = 0)
		{
			commandBuffer.SetRenderTarget(colorBuffers, depthStencilBuffer, 0, CubemapFace.Unknown, -1);
			commandBuffer.DrawProcedural(Matrix4x4.identity, material, shaderPassId, MeshTopology.Triangles, 3, 1, properties);
		}

		public static void DrawFullScreen(CommandBuffer commandBuffer, Material material, RenderTargetIdentifier[] colorBuffers, MaterialPropertyBlock properties = null, int shaderPassId = 0)
		{
			DrawFullScreen(commandBuffer, material, colorBuffers, colorBuffers[0], properties, shaderPassId);
		}

		public static Color ConvertSRGBToActiveColorSpace(Color color)
		{
			if (QualitySettings.activeColorSpace != ColorSpace.Linear)
			{
				return color;
			}
			return color.linear;
		}

		public static Color ConvertLinearToActiveColorSpace(Color color)
		{
			if (QualitySettings.activeColorSpace != ColorSpace.Linear)
			{
				return color.gamma;
			}
			return color;
		}

		public static Material CreateEngineMaterial(string shaderPath)
		{
			Shader shader = Shader.Find(shaderPath);
			if (shader == null)
			{
				Debug.LogError("Cannot create required material because shader " + shaderPath + " could not be found");
				return null;
			}
			return new Material(shader)
			{
				hideFlags = HideFlags.HideAndDontSave
			};
		}

		public static Material CreateEngineMaterial(Shader shader)
		{
			if (shader == null)
			{
				Debug.LogError("Cannot create required material because shader is null");
				return null;
			}
			return new Material(shader)
			{
				hideFlags = HideFlags.HideAndDontSave
			};
		}

		public static bool HasFlag<T>(T mask, T flag) where T : IConvertible
		{
			return (mask.ToUInt32(null) & flag.ToUInt32(null)) != 0;
		}

		public static void Swap<T>(ref T a, ref T b)
		{
			T val = a;
			a = b;
			b = val;
		}

		public static void SetKeyword(CommandBuffer cmd, string keyword, bool state)
		{
			if (state)
			{
				cmd.EnableShaderKeyword(keyword);
			}
			else
			{
				cmd.DisableShaderKeyword(keyword);
			}
		}

		public static void SetKeyword(Material material, string keyword, bool state)
		{
			if (state)
			{
				material.EnableKeyword(keyword);
			}
			else
			{
				material.DisableKeyword(keyword);
			}
		}

		public static void SetKeyword(ComputeShader cs, string keyword, bool state)
		{
			if (state)
			{
				cs.EnableKeyword(keyword);
			}
			else
			{
				cs.DisableKeyword(keyword);
			}
		}

		public static void Destroy(Object obj)
		{
			if (obj != null)
			{
				Object.Destroy(obj);
			}
		}

		public static IEnumerable<Type> GetAllAssemblyTypes()
		{
			if (m_AssemblyTypes == null)
			{
				m_AssemblyTypes = AppDomain.CurrentDomain.GetAssemblies().SelectMany(delegate(Assembly t)
				{
					Type[] result = new Type[0];
					try
					{
						result = t.GetTypes();
					}
					catch
					{
					}
					return result;
				});
			}
			return m_AssemblyTypes;
		}

		public static IEnumerable<Type> GetAllTypesDerivedFrom<T>()
		{
			return from t in GetAllAssemblyTypes()
				where t.IsSubclassOf(typeof(T))
				select t;
		}

		public static void SafeRelease(GraphicsBuffer buffer)
		{
			buffer?.Release();
		}

		public static void SafeRelease(ComputeBuffer buffer)
		{
			buffer?.Release();
		}

		public static Mesh CreateCubeMesh(Vector3 min, Vector3 max)
		{
			return new Mesh
			{
				vertices = new Vector3[8]
				{
					new Vector3(min.x, min.y, min.z),
					new Vector3(max.x, min.y, min.z),
					new Vector3(max.x, max.y, min.z),
					new Vector3(min.x, max.y, min.z),
					new Vector3(min.x, min.y, max.z),
					new Vector3(max.x, min.y, max.z),
					new Vector3(max.x, max.y, max.z),
					new Vector3(min.x, max.y, max.z)
				},
				triangles = new int[36]
				{
					0, 2, 1, 0, 3, 2, 1, 6, 5, 1,
					2, 6, 5, 7, 4, 5, 6, 7, 4, 3,
					0, 4, 7, 3, 3, 6, 2, 3, 7, 6,
					4, 1, 5, 4, 0, 1
				}
			};
		}

		public static bool ArePostProcessesEnabled(Camera camera)
		{
			return true;
		}

		public static bool AreAnimatedMaterialsEnabled(Camera camera)
		{
			return true;
		}

		public static bool IsSceneLightingDisabled(Camera camera)
		{
			return false;
		}

		public static bool IsLightOverlapDebugEnabled(Camera camera)
		{
			return false;
		}

		public static bool IsSceneViewFogEnabled(Camera camera)
		{
			return true;
		}

		public static bool IsSceneFilteringEnabled()
		{
			return false;
		}

		public static bool IsSceneViewPrefabStageContextHidden()
		{
			return false;
		}

		public static void DrawRendererList(ScriptableRenderContext renderContext, CommandBuffer cmd, RendererList rendererList)
		{
			if (!rendererList.isValid)
			{
				throw new ArgumentException("Invalid renderer list provided to DrawRendererList");
			}
			cmd.DrawRendererList(rendererList);
		}

		public static int GetTextureHash(Texture texture)
		{
			int hashCode = texture.GetHashCode();
			hashCode = 23 * hashCode + texture.GetInstanceID().GetHashCode();
			hashCode = 23 * hashCode + texture.graphicsFormat.GetHashCode();
			hashCode = 23 * hashCode + texture.wrapMode.GetHashCode();
			hashCode = 23 * hashCode + texture.width.GetHashCode();
			hashCode = 23 * hashCode + texture.height.GetHashCode();
			hashCode = 23 * hashCode + texture.filterMode.GetHashCode();
			hashCode = 23 * hashCode + texture.anisoLevel.GetHashCode();
			hashCode = 23 * hashCode + texture.mipmapCount.GetHashCode();
			return 23 * hashCode + texture.updateCount.GetHashCode();
		}

		public static int PreviousPowerOfTwo(int size)
		{
			if (size <= 0)
			{
				return 0;
			}
			size |= size >> 1;
			size |= size >> 2;
			size |= size >> 4;
			size |= size >> 8;
			size |= size >> 16;
			return size - (size >> 1);
		}

		public static T GetLastEnumValue<T>() where T : Enum
		{
			return typeof(T).GetEnumValues().Cast<T>().Last();
		}

		internal static string GetCorePath()
		{
			return "Packages/com.unity.render-pipelines.core/";
		}
	}
	public static class DelegateUtility
	{
		public static Delegate Cast(Delegate source, Type type)
		{
			if ((object)source == null)
			{
				return null;
			}
			Delegate[] invocationList = source.GetInvocationList();
			if (invocationList.Length == 1)
			{
				return Delegate.CreateDelegate(type, invocationList[0].Target, invocationList[0].Method);
			}
			Delegate[] array = new Delegate[invocationList.Length];
			for (int i = 0; i < invocationList.Length; i++)
			{
				array[i] = Delegate.CreateDelegate(type, invocationList[i].Target, invocationList[i].Method);
			}
			return Delegate.Combine(array);
		}
	}
	public static class FSRUtils
	{
		private static class ShaderConstants
		{
			public static readonly int _FsrEasuConstants0 = Shader.PropertyToID("_FsrEasuConstants0");

			public static readonly int _FsrEasuConstants1 = Shader.PropertyToID("_FsrEasuConstants1");

			public static readonly int _FsrEasuConstants2 = Shader.PropertyToID("_FsrEasuConstants2");

			public static readonly int _FsrEasuConstants3 = Shader.PropertyToID("_FsrEasuConstants3");

			public static readonly int _FsrRcasConstants = Shader.PropertyToID("_FsrRcasConstants");
		}

		internal const float kMaxSharpnessStops = 2.5f;

		public const float kDefaultSharpnessStops = 0.2f;

		public const float kDefaultSharpnessLinear = 0.92f;

		public static void SetEasuConstants(CommandBuffer cmd, Vector2 inputViewportSizeInPixels, Vector2 inputImageSizeInPixels, Vector2 outputImageSizeInPixels)
		{
			Vector4 value = default(Vector4);
			value.x = inputViewportSizeInPixels.x / outputImageSizeInPixels.x;
			value.y = inputViewportSizeInPixels.y / outputImageSizeInPixels.y;
			value.z = 0.5f * inputViewportSizeInPixels.x / outputImageSizeInPixels.x - 0.5f;
			value.w = 0.5f * inputViewportSizeInPixels.y / outputImageSizeInPixels.y - 0.5f;
			Vector4 value2 = default(Vector4);
			value2.x = 1f / inputImageSizeInPixels.x;
			value2.y = 1f / inputImageSizeInPixels.y;
			value2.z = 1f / inputImageSizeInPixels.x;
			value2.w = -1f / inputImageSizeInPixels.y;
			Vector4 value3 = default(Vector4);
			value3.x = -1f / inputImageSizeInPixels.x;
			value3.y = 2f / inputImageSizeInPixels.y;
			value3.z = 1f / inputImageSizeInPixels.x;
			value3.w = 2f / inputImageSizeInPixels.y;
			Vector4 value4 = default(Vector4);
			value4.x = 0f / inputImageSizeInPixels.x;
			value4.y = 4f / inputImageSizeInPixels.y;
			value4.z = 0f;
			value4.w = 0f;
			cmd.SetGlobalVector(ShaderConstants._FsrEasuConstants0, value);
			cmd.SetGlobalVector(ShaderConstants._FsrEasuConstants1, value2);
			cmd.SetGlobalVector(ShaderConstants._FsrEasuConstants2, value3);
			cmd.SetGlobalVector(ShaderConstants._FsrEasuConstants3, value4);
		}

		public static void SetRcasConstants(CommandBuffer cmd, float sharpnessStops = 0.2f)
		{
			float num = Mathf.Pow(2f, 0f - sharpnessStops);
			ushort num2 = Mathf.FloatToHalf(num);
			float y = BitConverter.Int32BitsToSingle(num2 | (num2 << 16));
			Vector4 value = default(Vector4);
			value.x = num;
			value.y = y;
			value.z = 0f;
			value.w = 0f;
			cmd.SetGlobalVector(ShaderConstants._FsrRcasConstants, value);
		}

		public static void SetRcasConstantsLinear(CommandBuffer cmd, float sharpnessLinear = 0.92f)
		{
			Assert.IsTrue(sharpnessLinear >= 0f && sharpnessLinear <= 1f);
			float sharpnessStops = (1f - sharpnessLinear) * 2.5f;
			SetRcasConstants(cmd, sharpnessStops);
		}

		public static bool IsSupported()
		{
			return SystemInfo.graphicsShaderLevel >= 45;
		}
	}
	public class HableCurve
	{
		public class Segment
		{
			public float offsetX;

			public float offsetY;

			public float scaleX;

			public float scaleY;

			public float lnA;

			public float B;

			public float Eval(float x)
			{
				float num = (x - offsetX) * scaleX;
				float num2 = 0f;
				if (num > 0f)
				{
					num2 = Mathf.Exp(lnA + B * Mathf.Log(num));
				}
				return num2 * scaleY + offsetY;
			}
		}

		private struct DirectParams
		{
			internal float x0;

			internal float y0;

			internal float x1;

			internal float y1;

			internal float W;

			internal float overshootX;

			internal float overshootY;

			internal float gamma;
		}

		public class Uniforms
		{
			private HableCurve parent;

			public Vector4 curve => new Vector4(parent.inverseWhitePoint, parent.x0, parent.x1, 0f);

			public Vector4 toeSegmentA => new Vector4(parent.segments[0].offsetX, parent.segments[0].offsetY, parent.segments[0].scaleX, parent.segments[0].scaleY);

			public Vector4 toeSegmentB => new Vector4(parent.segments[0].lnA, parent.segments[0].B, 0f, 0f);

			public Vector4 midSegmentA => new Vector4(parent.segments[1].offsetX, parent.segments[1].offsetY, parent.segments[1].scaleX, parent.segments[1].scaleY);

			public Vector4 midSegmentB => new Vector4(parent.segments[1].lnA, parent.segments[1].B, 0f, 0f);

			public Vector4 shoSegmentA => new Vector4(parent.segments[2].offsetX, parent.segments[2].offsetY, parent.segments[2].scaleX, parent.segments[2].scaleY);

			public Vector4 shoSegmentB => new Vector4(parent.segments[2].lnA, parent.segments[2].B, 0f, 0f);

			internal Uniforms(HableCurve parent)
			{
				this.parent = parent;
			}
		}

		public readonly Segment[] segments = new Segment[3];

		public readonly Uniforms uniforms;

		public float whitePoint { get; private set; }

		public float inverseWhitePoint { get; private set; }

		public float x0 { get; private set; }

		public float x1 { get; private set; }

		public HableCurve()
		{
			for (int i = 0; i < 3; i++)
			{
				segments[i] = new Segment();
			}
			uniforms = new Uniforms(this);
		}

		public float Eval(float x)
		{
			float num = x * inverseWhitePoint;
			int num2 = ((!(num < x0)) ? ((num < x1) ? 1 : 2) : 0);
			return segments[num2].Eval(num);
		}

		public void Init(float toeStrength, float toeLength, float shoulderStrength, float shoulderLength, float shoulderAngle, float gamma)
		{
			DirectParams srcParams = default(DirectParams);
			toeLength = Mathf.Pow(Mathf.Clamp01(toeLength), 2.2f);
			toeStrength = Mathf.Clamp01(toeStrength);
			shoulderAngle = Mathf.Clamp01(shoulderAngle);
			shoulderStrength = Mathf.Clamp(shoulderStrength, 1E-05f, 0.99999f);
			shoulderLength = Mathf.Max(0f, shoulderLength);
			gamma = Mathf.Max(1E-05f, gamma);
			float num = toeLength * 0.5f;
			float num2 = (1f - toeStrength) * num;
			float num3 = 1f - num2;
			float num4 = num + num3;
			float num5 = (1f - shoulderStrength) * num3;
			float num6 = num + num5;
			float y = num2 + num5;
			float num7 = Mathf.Pow(2f, shoulderLength) - 1f;
			float w = num4 + num7;
			srcParams.x0 = num;
			srcParams.y0 = num2;
			srcParams.x1 = num6;
			srcParams.y1 = y;
			srcParams.W = w;
			srcParams.gamma = gamma;
			srcParams.overshootX = srcParams.W * 2f * shoulderAngle * shoulderLength;
			srcParams.overshootY = 0.5f * shoulderAngle * shoulderLength;
			InitSegments(srcParams);
		}

		private void InitSegments(DirectParams srcParams)
		{
			DirectParams directParams = srcParams;
			whitePoint = srcParams.W;
			inverseWhitePoint = 1f / srcParams.W;
			directParams.W = 1f;
			directParams.x0 /= srcParams.W;
			directParams.x1 /= srcParams.W;
			directParams.overshootX = srcParams.overshootX / srcParams.W;
			float num = 0f;
			float num2 = 0f;
			AsSlopeIntercept(out var m, out var b, directParams.x0, directParams.x1, directParams.y0, directParams.y1);
			float gamma = srcParams.gamma;
			Segment obj = segments[1];
			obj.offsetX = 0f - b / m;
			obj.offsetY = 0f;
			obj.scaleX = 1f;
			obj.scaleY = 1f;
			obj.lnA = gamma * Mathf.Log(m);
			obj.B = gamma;
			num = EvalDerivativeLinearGamma(m, b, gamma, directParams.x0);
			num2 = EvalDerivativeLinearGamma(m, b, gamma, directParams.x1);
			directParams.y0 = Mathf.Max(1E-05f, Mathf.Pow(directParams.y0, directParams.gamma));
			directParams.y1 = Mathf.Max(1E-05f, Mathf.Pow(directParams.y1, directParams.gamma));
			directParams.overshootY = Mathf.Pow(1f + directParams.overshootY, directParams.gamma) - 1f;
			x0 = directParams.x0;
			x1 = directParams.x1;
			Segment obj2 = segments[0];
			obj2.offsetX = 0f;
			obj2.offsetY = 0f;
			obj2.scaleX = 1f;
			obj2.scaleY = 1f;
			SolveAB(out var lnA, out var B, directParams.x0, directParams.y0, num);
			obj2.lnA = lnA;
			obj2.B = B;
			Segment obj3 = segments[2];
			float num3 = 1f + directParams.overshootX - directParams.x1;
			float y = 1f + directParams.overshootY - directParams.y1;
			SolveAB(out var lnA2, out var B2, num3, y, num2);
			obj3.offsetX = 1f + directParams.overshootX;
			obj3.offsetY = 1f + directParams.overshootY;
			obj3.scaleX = -1f;
			obj3.scaleY = -1f;
			obj3.lnA = lnA2;
			obj3.B = B2;
			float num4 = segments[2].Eval(1f);
			float num5 = 1f / num4;
			segments[0].offsetY *= num5;
			segments[0].scaleY *= num5;
			segments[1].offsetY *= num5;
			segments[1].scaleY *= num5;
			segments[2].offsetY *= num5;
			segments[2].scaleY *= num5;
		}

		private void SolveAB(out float lnA, out float B, float x0, float y0, float m)
		{
			B = m * x0 / y0;
			lnA = Mathf.Log(y0) - B * Mathf.Log(x0);
		}

		private void AsSlopeIntercept(out float m, out float b, float x0, float x1, float y0, float y1)
		{
			float num = y1 - y0;
			float num2 = x1 - x0;
			if (num2 == 0f)
			{
				m = 1f;
			}
			else
			{
				m = num / num2;
			}
			b = y0 - x0 * m;
		}

		private float EvalDerivativeLinearGamma(float m, float b, float g, float x)
		{
			return g * m * Mathf.Pow(m * x + b, g - 1f);
		}
	}
	public static class HaltonSequence
	{
		public static float Get(int index, int radix)
		{
			float num = 0f;
			float num2 = 1f / (float)radix;
			while (index > 0)
			{
				num += (float)(index % radix) * num2;
				index /= radix;
				num2 /= (float)radix;
			}
			return num;
		}
	}
	public static class HDROutputUtils
	{
		[Flags]
		public enum Operation
		{
			None = 0,
			ColorConversion = 1,
			ColorEncoding = 2
		}

		public struct HDRDisplayInformation
		{
			public int maxFullFrameToneMapLuminance;

			public int maxToneMapLuminance;

			public int minToneMapLuminance;

			public float paperWhiteNits;

			public HDRDisplayInformation(int maxFullFrameToneMapLuminance, int maxToneMapLuminance, int minToneMapLuminance, float hdrPaperWhiteNits)
			{
				this.maxFullFrameToneMapLuminance = maxFullFrameToneMapLuminance;
				this.maxToneMapLuminance = maxToneMapLuminance;
				this.minToneMapLuminance = minToneMapLuminance;
				paperWhiteNits = hdrPaperWhiteNits;
			}
		}

		public static class ShaderKeywords
		{
			public const string HDR_COLORSPACE_CONVERSION = "HDR_COLORSPACE_CONVERSION";

			public const string HDR_ENCODING = "HDR_ENCODING";

			public const string HDR_COLORSPACE_CONVERSION_AND_ENCODING = "HDR_COLORSPACE_CONVERSION_AND_ENCODING";

			public const string HDR_INPUT = "HDR_INPUT";

			internal static readonly ShaderKeyword HDRColorSpaceConversion = new ShaderKeyword("HDR_COLORSPACE_CONVERSION");

			internal static readonly ShaderKeyword HDREncoding = new ShaderKeyword("HDR_ENCODING");

			internal static readonly ShaderKeyword HDRColorSpaceConversionAndEncoding = new ShaderKeyword("HDR_COLORSPACE_CONVERSION_AND_ENCODING");

			internal static readonly ShaderKeyword HDRInput = new ShaderKeyword("HDR_INPUT");
		}

		private static class ShaderPropertyId
		{
			public static readonly int hdrColorSpace = Shader.PropertyToID("_HDRColorspace");

			public static readonly int hdrEncoding = Shader.PropertyToID("_HDREncoding");
		}

		public static bool GetColorSpaceForGamut(ColorGamut gamut, out int colorspace)
		{
			if (ColorGamutUtility.GetWhitePoint(gamut) != WhitePoint.D65)
			{
				Debug.LogWarningFormat("{0} white point is currently unsupported for outputting to HDR.", gamut.ToString());
				colorspace = -1;
				return false;
			}
			switch (ColorGamutUtility.GetColorPrimaries(gamut))
			{
			case ColorPrimaries.Rec709:
				colorspace = 0;
				return true;
			case ColorPrimaries.Rec2020:
				colorspace = 1;
				return true;
			case ColorPrimaries.P3:
				colorspace = 2;
				return true;
			default:
				Debug.LogWarningFormat("{0} color space is currently unsupported for outputting to HDR.", gamut.ToString());
				colorspace = -1;
				return false;
			}
		}

		public static bool GetColorEncodingForGamut(ColorGamut gamut, out int encoding)
		{
			switch (ColorGamutUtility.GetTransferFunction(gamut))
			{
			case TransferFunction.Linear:
				encoding = 3;
				return true;
			case TransferFunction.PQ:
				encoding = 2;
				return true;
			case TransferFunction.Gamma22:
				encoding = 4;
				return true;
			case TransferFunction.sRGB:
				encoding = 0;
				return true;
			default:
				Debug.LogWarningFormat("{0} color encoding is currently unsupported for outputting to HDR.", gamut.ToString());
				encoding = -1;
				return false;
			}
		}

		public static void ConfigureHDROutput(Material material, ColorGamut gamut, Operation operations)
		{
			if (GetColorSpaceForGamut(gamut, out var colorspace) && GetColorEncodingForGamut(gamut, out var encoding))
			{
				material.SetInteger(ShaderPropertyId.hdrColorSpace, colorspace);
				material.SetInteger(ShaderPropertyId.hdrEncoding, encoding);
				CoreUtils.SetKeyword(material, ShaderKeywords.HDRColorSpaceConversionAndEncoding.name, operations.HasFlag(Operation.ColorConversion) && operations.HasFlag(Operation.ColorEncoding));
				CoreUtils.SetKeyword(material, ShaderKeywords.HDREncoding.name, operations.HasFlag(Operation.ColorEncoding) && !operations.HasFlag(Operation.ColorConversion));
				CoreUtils.SetKeyword(material, ShaderKeywords.HDRColorSpaceConversion.name, operations.HasFlag(Operation.ColorConversion) && !operations.HasFlag(Operation.ColorEncoding));
				CoreUtils.SetKeyword(material, ShaderKeywords.HDRInput.name, operations == Operation.None);
			}
		}

		public static void ConfigureHDROutput(MaterialPropertyBlock properties, ColorGamut gamut)
		{
			if (GetColorSpaceForGamut(gamut, out var colorspace) && GetColorEncodingForGamut(gamut, out var encoding))
			{
				properties.SetInteger(ShaderPropertyId.hdrColorSpace, colorspace);
				properties.SetInteger(ShaderPropertyId.hdrEncoding, encoding);
			}
		}

		public static void ConfigureHDROutput(Material material, Operation operations)
		{
			CoreUtils.SetKeyword(material, ShaderKeywords.HDRColorSpaceConversionAndEncoding.name, operations.HasFlag(Operation.ColorConversion) && operations.HasFlag(Operation.ColorEncoding));
			CoreUtils.SetKeyword(material, ShaderKeywords.HDREncoding.name, operations.HasFlag(Operation.ColorEncoding) && !operations.HasFlag(Operation.ColorConversion));
			CoreUtils.SetKeyword(material, ShaderKeywords.HDRColorSpaceConversion.name, operations.HasFlag(Operation.ColorConversion) && !operations.HasFlag(Operation.ColorEncoding));
			CoreUtils.SetKeyword(material, ShaderKeywords.HDRInput.name, operations == Operation.None);
		}

		public static void ConfigureHDROutput(ComputeShader computeShader, ColorGamut gamut, Operation operations)
		{
			if (GetColorSpaceForGamut(gamut, out var colorspace) && GetColorEncodingForGamut(gamut, out var encoding))
			{
				computeShader.SetInt(ShaderPropertyId.hdrColorSpace, colorspace);
				computeShader.SetInt(ShaderPropertyId.hdrEncoding, encoding);
				CoreUtils.SetKeyword(computeShader, ShaderKeywords.HDRColorSpaceConversionAndEncoding.name, operations.HasFlag(Operation.ColorConversion) && operations.HasFlag(Operation.ColorEncoding));
				CoreUtils.SetKeyword(computeShader, ShaderKeywords.HDREncoding.name, operations.HasFlag(Operation.ColorEncoding) && !operations.HasFlag(Operation.ColorConversion));
				CoreUtils.SetKeyword(computeShader, ShaderKeywords.HDRColorSpaceConversion.name, operations.HasFlag(Operation.ColorConversion) && !operations.HasFlag(Operation.ColorEncoding));
				CoreUtils.SetKeyword(computeShader, ShaderKeywords.HDRInput.name, operations == Operation.None);
			}
		}

		public static bool IsShaderVariantValid(ShaderKeywordSet shaderKeywordSet, bool isHDREnabled)
		{
			bool flag = shaderKeywordSet.IsEnabled(ShaderKeywords.HDREncoding) || shaderKeywordSet.IsEnabled(ShaderKeywords.HDRColorSpaceConversion) || shaderKeywordSet.IsEnabled(ShaderKeywords.HDRColorSpaceConversionAndEncoding) || shaderKeywordSet.IsEnabled(ShaderKeywords.HDRInput);
			if (!isHDREnabled && flag)
			{
				return false;
			}
			return true;
		}
	}
	[Flags]
	[MovedFrom("Utilities")]
	public enum MaterialQuality
	{
		Low = 1,
		Medium = 2,
		High = 4
	}
	[MovedFrom("Utilities")]
	public static class MaterialQualityUtilities
	{
		public static string[] KeywordNames = new string[3] { "MATERIAL_QUALITY_LOW", "MATERIAL_QUALITY_MEDIUM", "MATERIAL_QUALITY_HIGH" };

		public static string[] EnumNames = Enum.GetNames(typeof(MaterialQuality));

		public static ShaderKeyword[] Keywords = new ShaderKeyword[3]
		{
			new ShaderKeyword(KeywordNames[0]),
			new ShaderKeyword(KeywordNames[1]),
			new ShaderKeyword(KeywordNames[2])
		};

		public static MaterialQuality GetHighestQuality(this MaterialQuality levels)
		{
			for (int num = Keywords.Length - 1; num >= 0; num--)
			{
				MaterialQuality materialQuality = (MaterialQuality)(1 << num);
				if ((levels & materialQuality) != 0)
				{
					return materialQuality;
				}
			}
			return (MaterialQuality)0;
		}

		public static MaterialQuality GetClosestQuality(this MaterialQuality availableLevels, MaterialQuality requestedLevel)
		{
			if (availableLevels == (MaterialQuality)0)
			{
				return MaterialQuality.Low;
			}
			int num = requestedLevel.ToFirstIndex();
			MaterialQuality materialQuality = (MaterialQuality)0;
			for (int num2 = num; num2 >= 0; num2--)
			{
				MaterialQuality materialQuality2 = FromIndex(num2);
				if ((materialQuality2 & availableLevels) != 0)
				{
					materialQuality = materialQuality2;
					break;
				}
			}
			if (materialQuality != 0)
			{
				return materialQuality;
			}
			for (int i = num + 1; i < Keywords.Length; i++)
			{
				MaterialQuality materialQuality3 = FromIndex(i);
				Math.Abs(requestedLevel - materialQuality3);
				if ((materialQuality3 & availableLevels) != 0)
				{
					materialQuality = materialQuality3;
					break;
				}
			}
			Debug.Assert(materialQuality != (MaterialQuality)0);
			return materialQuality;
		}

		public static void SetGlobalShaderKeywords(this MaterialQuality level)
		{
			for (int i = 0; i < KeywordNames.Length; i++)
			{
				if (((uint)level & (uint)(1 << i)) != 0)
				{
					Shader.EnableKeyword(KeywordNames[i]);
				}
				else
				{
					Shader.DisableKeyword(KeywordNames[i]);
				}
			}
		}

		public static void SetGlobalShaderKeywords(this MaterialQuality level, CommandBuffer cmd)
		{
			for (int i = 0; i < KeywordNames.Length; i++)
			{
				if (((uint)level & (uint)(1 << i)) != 0)
				{
					cmd.EnableShaderKeyword(KeywordNames[i]);
				}
				else
				{
					cmd.DisableShaderKeyword(KeywordNames[i]);
				}
			}
		}

		public static int ToFirstIndex(this MaterialQuality level)
		{
			for (int i = 0; i < KeywordNames.Length; i++)
			{
				if (((uint)level & (uint)(1 << i)) != 0)
				{
					return i;
				}
			}
			return -1;
		}

		public static MaterialQuality FromIndex(int index)
		{
			return (MaterialQuality)(1 << index);
		}
	}
	internal class MeshGizmo : IDisposable
	{
		public static readonly int vertexCountPerCube = 24;

		public Mesh mesh;

		private List<Vector3> vertices;

		private List<int> indices;

		private List<Color> colors;

		private Material wireMaterial;

		private Material dottedWireMaterial;

		private Material solidMaterial;

		public MeshGizmo(int capacity = 0)
		{
			vertices = new List<Vector3>(capacity);
			indices = new List<int>(capacity);
			colors = new List<Color>(capacity);
			mesh = new Mesh
			{
				indexFormat = IndexFormat.UInt32,
				hideFlags = HideFlags.HideAndDontSave
			};
		}

		public void Clear()
		{
			vertices.Clear();
			indices.Clear();
			colors.Clear();
		}

		public void AddWireCube(Vector3 center, Vector3 size, Color color)
		{
			Vector3 vector = size / 2f;
			Vector3 vector2 = new Vector3(vector.x, vector.y, vector.z);
			Vector3 vector3 = new Vector3(0f - vector.x, vector.y, vector.z);
			Vector3 vector4 = new Vector3(0f - vector.x, 0f - vector.y, vector.z);
			Vector3 vector5 = new Vector3(vector.x, 0f - vector.y, vector.z);
			Vector3 vector6 = new Vector3(vector.x, vector.y, 0f - vector.z);
			Vector3 vector7 = new Vector3(0f - vector.x, vector.y, 0f - vector.z);
			Vector3 vector8 = new Vector3(0f - vector.x, 0f - vector.y, 0f - vector.z);
			Vector3 vector9 = new Vector3(vector.x, 0f - vector.y, 0f - vector.z);
			AddEdge(center + vector2, center + vector3);
			AddEdge(center + vector3, center + vector4);
			AddEdge(center + vector4, center + vector5);
			AddEdge(center + vector5, center + vector2);
			AddEdge(center + vector6, center + vector7);
			AddEdge(center + vector7, center + vector8);
			AddEdge(center + vector8, center + vector9);
			AddEdge(center + vector9, center + vector6);
			AddEdge(center + vector2, center + vector6);
			AddEdge(center + vector3, center + vector7);
			AddEdge(center + vector4, center + vector8);
			AddEdge(center + vector5, center + vector9);
			void AddEdge(Vector3 p1, Vector3 p2)
			{
				vertices.Add(p1);
				vertices.Add(p2);
				indices.Add(indices.Count);
				indices.Add(indices.Count);
				colors.Add(color);
				colors.Add(color);
			}
		}

		private void DrawMesh(Matrix4x4 trs, Material mat, MeshTopology topology, CompareFunction depthTest, string gizmoName)
		{
			mesh.Clear();
			mesh.SetVertices(vertices);
			mesh.SetColors(colors);
			mesh.SetIndices(indices, topology, 0);
			mat.SetFloat("_HandleZTest", (float)depthTest);
			CommandBuffer commandBuffer = CommandBufferPool.Get(gizmoName ?? "Mesh Gizmo Rendering");
			commandBuffer.DrawMesh(mesh, trs, mat, 0, 0);
			Graphics.ExecuteCommandBuffer(commandBuffer);
		}

		public void RenderWireframe(Matrix4x4 trs, CompareFunction depthTest = CompareFunction.LessEqual, string gizmoName = null)
		{
			DrawMesh(trs, wireMaterial, MeshTopology.Lines, depthTest, gizmoName);
		}

		public void Dispose()
		{
			CoreUtils.Destroy(mesh);
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	public sealed class ReloadAttribute : Attribute
	{
		public enum Package
		{
			Builtin,
			Root,
			BuiltinExtra
		}

		public ReloadAttribute(string[] paths, Package package = Package.Root)
		{
		}

		public ReloadAttribute(string path, Package package = Package.Root)
			: this(new string[1] { path }, package)
		{
		}

		public ReloadAttribute(string pathFormat, int rangeMin, int rangeMax, Package package = Package.Root)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class ReloadGroupAttribute : Attribute
	{
	}
	public class SceneRenderPipeline : MonoBehaviour
	{
	}
	[Serializable]
	public class TextureCurve : IDisposable
	{
		private const int k_Precision = 128;

		private const float k_Step = 1f / 128f;

		[SerializeField]
		private bool m_Loop;

		[SerializeField]
		private float m_ZeroValue;

		[SerializeField]
		private float m_Range;

		[SerializeField]
		private AnimationCurve m_Curve;

		private AnimationCurve m_LoopingCurve;

		private Texture2D m_Texture;

		private bool m_IsCurveDirty;

		private bool m_IsTextureDirty;

		[field: SerializeField]
		public int length { get; private set; }

		public Keyframe this[int index] => m_Curve[index];

		public TextureCurve(AnimationCurve baseCurve, float zeroValue, bool loop, in Vector2 bounds)
			: this(baseCurve.keys, zeroValue, loop, in bounds)
		{
		}

		public TextureCurve(Keyframe[] keys, float zeroValue, bool loop, in Vector2 bounds)
		{
			m_Curve = new AnimationCurve(keys);
			m_ZeroValue = zeroValue;
			m_Loop = loop;
			m_Range = bounds.magnitude;
			length = keys.Length;
			SetDirty();
		}

		~TextureCurve()
		{
		}

		[Obsolete("Please use Release() instead.")]
		public void Dispose()
		{
		}

		public void Release()
		{
			CoreUtils.Destroy(m_Texture);
			m_Texture = null;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void SetDirty()
		{
			m_IsCurveDirty = true;
			m_IsTextureDirty = true;
		}

		private static GraphicsFormat GetTextureFormat()
		{
			if (SystemInfo.IsFormatSupported(GraphicsFormat.R16_SFloat, FormatUsage.SetPixels))
			{
				return GraphicsFormat.R16_SFloat;
			}
			if (SystemInfo.IsFormatSupported(GraphicsFormat.R8_UNorm, FormatUsage.SetPixels))
			{
				return GraphicsFormat.R8_UNorm;
			}
			return GraphicsFormat.R8G8B8A8_UNorm;
		}

		public Texture2D GetTexture()
		{
			if (m_Texture == null)
			{
				m_Texture = new Texture2D(128, 1, GetTextureFormat(), TextureCreationFlags.None);
				m_Texture.name = "CurveTexture";
				m_Texture.hideFlags = HideFlags.HideAndDontSave;
				m_Texture.filterMode = FilterMode.Bilinear;
				m_Texture.wrapMode = TextureWrapMode.Clamp;
				m_Texture.anisoLevel = 0;
				m_IsTextureDirty = true;
			}
			if (m_IsTextureDirty)
			{
				Color[] array = new Color[128];
				for (int i = 0; i < array.Length; i++)
				{
					array[i].r = Evaluate((float)i * (1f / 128f));
				}
				m_Texture.SetPixels(array);
				m_Texture.Apply(updateMipmaps: false, makeNoLongerReadable: false);
				m_IsTextureDirty = false;
			}
			return m_Texture;
		}

		public float Evaluate(float time)
		{
			if (m_IsCurveDirty)
			{
				length = m_Curve.length;
			}
			if (length == 0)
			{
				return m_ZeroValue;
			}
			if (!m_Loop || length == 1)
			{
				return m_Curve.Evaluate(time);
			}
			if (m_IsCurveDirty)
			{
				if (m_LoopingCurve == null)
				{
					m_LoopingCurve = new AnimationCurve();
				}
				Keyframe key = m_Curve[length - 1];
				key.time -= m_Range;
				Keyframe key2 = m_Curve[0];
				key2.time += m_Range;
				m_LoopingCurve.keys = m_Curve.keys;
				m_LoopingCurve.AddKey(key);
				m_LoopingCurve.AddKey(key2);
				m_IsCurveDirty = false;
			}
			return m_LoopingCurve.Evaluate(time);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public int AddKey(float time, float value)
		{
			int num = m_Curve.AddKey(time, value);
			if (num > -1)
			{
				SetDirty();
			}
			return num;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public int MoveKey(int index, in Keyframe key)
		{
			int result = m_Curve.MoveKey(index, key);
			SetDirty();
			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void RemoveKey(int index)
		{
			m_Curve.RemoveKey(index);
			SetDirty();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void SmoothTangents(int index, float weight)
		{
			m_Curve.SmoothTangents(index, weight);
			SetDirty();
		}
	}
	[Serializable]
	public class TextureCurveParameter : VolumeParameter<TextureCurve>
	{
		public TextureCurveParameter(TextureCurve value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override void Release()
		{
			m_Value.Release();
		}
	}
	public static class TileLayoutUtils
	{
		public static bool TryLayoutByTiles(RectInt src, uint tileSize, out RectInt main, out RectInt topRow, out RectInt rightCol, out RectInt topRight)
		{
			if (src.width < tileSize || src.height < tileSize)
			{
				main = new RectInt(0, 0, 0, 0);
				topRow = new RectInt(0, 0, 0, 0);
				rightCol = new RectInt(0, 0, 0, 0);
				topRight = new RectInt(0, 0, 0, 0);
				return false;
			}
			int num = src.height / (int)tileSize;
			int num2 = src.width / (int)tileSize * (int)tileSize;
			int num3 = num * (int)tileSize;
			main = new RectInt
			{
				x = src.x,
				y = src.y,
				width = num2,
				height = num3
			};
			topRow = new RectInt
			{
				x = src.x,
				y = src.y + num3,
				width = num2,
				height = src.height - num3
			};
			rightCol = new RectInt
			{
				x = src.x + num2,
				y = src.y,
				width = src.width - num2,
				height = num3
			};
			topRight = new RectInt
			{
				x = src.x + num2,
				y = src.y + num3,
				width = src.width - num2,
				height = src.height - num3
			};
			return true;
		}

		public static bool TryLayoutByRow(RectInt src, uint tileSize, out RectInt main, out RectInt other)
		{
			if (src.height < tileSize)
			{
				main = new RectInt(0, 0, 0, 0);
				other = new RectInt(0, 0, 0, 0);
				return false;
			}
			int num = src.height / (int)tileSize * (int)tileSize;
			main = new RectInt
			{
				x = src.x,
				y = src.y,
				width = src.width,
				height = num
			};
			other = new RectInt
			{
				x = src.x,
				y = src.y + num,
				width = src.width,
				height = src.height - num
			};
			return true;
		}

		public static bool TryLayoutByCol(RectInt src, uint tileSize, out RectInt main, out RectInt other)
		{
			if (src.width < tileSize)
			{
				main = new RectInt(0, 0, 0, 0);
				other = new RectInt(0, 0, 0, 0);
				return false;
			}
			int num = src.width / (int)tileSize * (int)tileSize;
			main = new RectInt
			{
				x = src.x,
				y = src.y,
				width = num,
				height = src.height
			};
			other = new RectInt
			{
				x = src.x + num,
				y = src.y,
				width = src.width - num,
				height = src.height
			};
			return true;
		}
	}
	public static class XRUtils
	{
		public static void DrawOcclusionMesh(CommandBuffer cmd, Camera camera, bool stereoEnabled = true)
		{
			if (XRGraphics.enabled && camera.stereoEnabled && stereoEnabled)
			{
				RectInt normalizedCamViewport = new RectInt(0, 0, camera.pixelWidth, camera.pixelHeight);
				cmd.DrawOcclusionMesh(normalizedCamViewport);
			}
		}
	}
	public interface IVolume
	{
		bool isGlobal { get; set; }

		List<Collider> colliders { get; }
	}
	public class KeyframeUtility
	{
		public static void ResetAnimationCurve(AnimationCurve curve)
		{
			curve.ClearKeys();
		}

		private static Keyframe LerpSingleKeyframe(Keyframe lhs, Keyframe rhs, float t)
		{
			return new Keyframe
			{
				time = Mathf.Lerp(lhs.time, rhs.time, t),
				value = Mathf.Lerp(lhs.value, rhs.value, t),
				inTangent = Mathf.Lerp(lhs.inTangent, rhs.inTangent, t),
				outTangent = Mathf.Lerp(lhs.outTangent, rhs.outTangent, t),
				inWeight = Mathf.Lerp(lhs.inWeight, rhs.inWeight, t),
				outWeight = Mathf.Lerp(lhs.outWeight, rhs.outWeight, t),
				weightedMode = lhs.weightedMode
			};
		}

		private static Keyframe GetKeyframeAndClampEdge([DisallowNull] NativeArray<Keyframe> keys, int index)
		{
			int num = keys.Length - 1;
			if (index < 0 || index > num)
			{
				Debug.LogWarning("Invalid index in GetKeyframeAndClampEdge. This is likely a bug.");
				return default(Keyframe);
			}
			Keyframe result = keys[index];
			if (index == 0)
			{
				result.inTangent = 0f;
			}
			if (index == num)
			{
				result.outTangent = 0f;
			}
			return result;
		}

		private static Keyframe FetchKeyFromIndexClampEdge([DisallowNull] NativeArray<Keyframe> keys, int index, float segmentStartTime, float segmentEndTime)
		{
			float time = Mathf.Min(segmentStartTime, keys[0].time);
			float time2 = Mathf.Max(segmentEndTime, keys[keys.Length - 1].time);
			float value = keys[0].value;
			float value2 = keys[keys.Length - 1].value;
			Keyframe result;
			if (index < 0)
			{
				result = new Keyframe(time, value, 0f, 0f);
			}
			else
			{
				if (index < keys.Length)
				{
					return GetKeyframeAndClampEdge(keys, index);
				}
				_ = keys[keys.Length - 1];
				result = new Keyframe(time2, value2, 0f, 0f);
			}
			return result;
		}

		private static void EvalCurveSegmentAndDeriv(out float dstValue, out float dstDeriv, Keyframe lhsKey, Keyframe rhsKey, float desiredTime)
		{
			float num = Mathf.Clamp(desiredTime, lhsKey.time, rhsKey.time);
			float num2 = Mathf.Max(rhsKey.time - lhsKey.time, 0.0001f);
			float num3 = rhsKey.value - lhsKey.value;
			float num4 = 1f / num2;
			float num5 = num4 * num4;
			float outTangent = lhsKey.outTangent;
			float inTangent = rhsKey.inTangent;
			float num6 = outTangent * num2;
			float num7 = inTangent * num2;
			float num8 = (num6 + num7 - num3 - num3) * num5 * num4;
			float num9 = (num3 + num3 + num3 - num6 - num6 - num7) * num5;
			float num10 = outTangent;
			float value = lhsKey.value;
			float num11 = Mathf.Clamp(num - lhsKey.time, 0f, num2);
			dstValue = num11 * (num11 * (num11 * num8 + num9) + num10) + value;
			dstDeriv = num11 * (3f * num11 * num8 + 2f * num9) + num10;
		}

		private static Keyframe EvalKeyAtTime([DisallowNull] NativeArray<Keyframe> keys, int lhsIndex, int rhsIndex, float startTime, float endTime, float currTime)
		{
			Keyframe lhsKey = FetchKeyFromIndexClampEdge(keys, lhsIndex, startTime, endTime);
			Keyframe rhsKey = FetchKeyFromIndexClampEdge(keys, rhsIndex, startTime, endTime);
			EvalCurveSegmentAndDeriv(out var dstValue, out var dstDeriv, lhsKey, rhsKey, currTime);
			return new Keyframe(currTime, dstValue, dstDeriv, dstDeriv);
		}

		public static void InterpAnimationCurve(ref AnimationCurve lhsAndResultCurve, [DisallowNull] AnimationCurve rhsCurve, float t)
		{
			if (t <= 0f || rhsCurve.length == 0)
			{
				return;
			}
			if (t >= 1f || lhsAndResultCurve.length == 0)
			{
				lhsAndResultCurve.CopyFrom(rhsCurve);
				return;
			}
			NativeArray<Keyframe> keys = new NativeArray<Keyframe>(lhsAndResultCurve.length, Allocator.Temp);
			NativeArray<Keyframe> keys2 = new NativeArray<Keyframe>(rhsCurve.length, Allocator.Temp);
			for (int i = 0; i < lhsAndResultCurve.length; i++)
			{
				keys[i] = lhsAndResultCurve[i];
			}
			for (int j = 0; j < rhsCurve.length; j++)
			{
				keys2[j] = rhsCurve[j];
			}
			float startTime = Mathf.Min(keys[0].time, keys2[0].time);
			float endTime = Mathf.Max(keys[lhsAndResultCurve.length - 1].time, keys2[rhsCurve.length - 1].time);
			int length = lhsAndResultCurve.length + rhsCurve.length;
			int num = 0;
			NativeArray<Keyframe> nativeArray = new NativeArray<Keyframe>(length, Allocator.Temp);
			int num2 = 0;
			int num3 = 0;
			while (num2 < keys.Length || num3 < keys2.Length)
			{
				bool flag = num2 < keys.Length;
				bool flag2 = num3 < keys2.Length;
				Keyframe keyframe = default(Keyframe);
				Keyframe keyframe2 = default(Keyframe);
				if (flag && flag2)
				{
					keyframe = GetKeyframeAndClampEdge(keys, num2);
					keyframe2 = GetKeyframeAndClampEdge(keys2, num3);
					if (keyframe.time == keyframe2.time)
					{
						num2++;
						num3++;
					}
					else if (keyframe.time < keyframe2.time)
					{
						keyframe2 = EvalKeyAtTime(keys2, num3 - 1, num3, startTime, endTime, keyframe.time);
						num2++;
					}
					else
					{
						Assert.IsTrue(keyframe.time > keyframe2.time);
						keyframe = EvalKeyAtTime(keys, num2 - 1, num2, startTime, endTime, keyframe2.time);
						num3++;
					}
				}
				else if (flag)
				{
					keyframe = GetKeyframeAndClampEdge(keys, num2);
					keyframe2 = EvalKeyAtTime(keys2, num3 - 1, num3, startTime, endTime, keyframe.time);
					num2++;
				}
				else
				{
					Assert.IsTrue(flag2);
					keyframe2 = GetKeyframeAndClampEdge(keys2, num3);
					keyframe = EvalKeyAtTime(keys, num2 - 1, num2, startTime, endTime, keyframe2.time);
					num3++;
				}
				Keyframe value = LerpSingleKeyframe(keyframe, keyframe2, t);
				nativeArray[num] = value;
				num++;
			}
			ResetAnimationCurve(lhsAndResultCurve);
			for (int k = 0; k < num; k++)
			{
				lhsAndResultCurve.AddKey(nativeArray[k]);
			}
			nativeArray.Dispose();
		}
	}
	[ExecuteAlways]
	[AddComponentMenu("Miscellaneous/Volume")]
	public class Volume : MonoBehaviour, IVolume
	{
		[SerializeField]
		[FormerlySerializedAs("isGlobal")]
		private bool m_IsGlobal = true;

		[Tooltip("A value which determines which Volume is being used when Volumes have an equal amount of influence on the Scene. Volumes with a higher priority will override lower ones.")]
		[Delayed]
		public float priority;

		[Tooltip("Sets the outer distance to start blending from. A value of 0 means no blending and Unity applies the Volume overrides immediately upon entry.")]
		public float blendDistance;

		[Range(0f, 1f)]
		[Tooltip("Sets the total weight of this Volume in the Scene. 0 means no effect and 1 means full effect.")]
		public float weight = 1f;

		public VolumeProfile sharedProfile;

		internal List<Collider> m_Colliders = new List<Collider>();

		private int m_PreviousLayer;

		private float m_PreviousPriority;

		private VolumeProfile m_InternalProfile;

		[Tooltip("When enabled, the Volume is applied to the entire Scene.")]
		public bool isGlobal
		{
			get
			{
				return m_IsGlobal;
			}
			set
			{
				m_IsGlobal = value;
			}
		}

		public VolumeProfile profile
		{
			get
			{
				if (m_InternalProfile == null)
				{
					m_InternalProfile = ScriptableObject.CreateInstance<VolumeProfile>();
					if (sharedProfile != null)
					{
						m_InternalProfile.name = sharedProfile.name;
						foreach (VolumeComponent component in sharedProfile.components)
						{
							VolumeComponent item = Object.Instantiate(component);
							m_InternalProfile.components.Add(item);
						}
					}
				}
				return m_InternalProfile;
			}
			set
			{
				m_InternalProfile = value;
			}
		}

		public List<Collider> colliders => m_Colliders;

		internal VolumeProfile profileRef
		{
			get
			{
				if (!(m_InternalProfile == null))
				{
					return m_InternalProfile;
				}
				return sharedProfile;
			}
		}

		public bool HasInstantiatedProfile()
		{
			return m_InternalProfile != null;
		}

		private void OnEnable()
		{
			m_PreviousLayer = base.gameObject.layer;
			VolumeManager.instance.Register(this, m_PreviousLayer);
			GetComponents(m_Colliders);
		}

		private void OnDisable()
		{
			VolumeManager.instance.Unregister(this, base.gameObject.layer);
		}

		private void Update()
		{
			UpdateLayer();
			if (priority != m_PreviousPriority)
			{
				VolumeManager.instance.SetLayerDirty(base.gameObject.layer);
				m_PreviousPriority = priority;
			}
		}

		internal void UpdateLayer()
		{
			int layer = base.gameObject.layer;
			if (layer != m_PreviousLayer)
			{
				VolumeManager.instance.UpdateVolumeLayer(this, m_PreviousLayer, layer);
				m_PreviousLayer = layer;
			}
		}
	}
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
	public class VolumeComponentMenu : Attribute
	{
		public readonly string menu;

		public VolumeComponentMenu(string menu)
		{
			this.menu = menu;
		}
	}
	public class VolumeComponentMenuForRenderPipeline : VolumeComponentMenu
	{
		public Type[] pipelineTypes { get; }

		public VolumeComponentMenuForRenderPipeline(string menu, params Type[] pipelineTypes)
			: base(menu)
		{
			if (pipelineTypes == null)
			{
				throw new Exception("Specify a list of supported pipeline");
			}
			foreach (Type type in pipelineTypes)
			{
				if (!typeof(RenderPipeline).IsAssignableFrom(type))
				{
					throw new Exception($"You can only specify types that inherit from {typeof(RenderPipeline)}, please check {type}");
				}
			}
			this.pipelineTypes = pipelineTypes;
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	[Obsolete("VolumeComponentDeprecated has been deprecated (UnityUpgradable) -> [UnityEngine] UnityEngine.HideInInspector", false)]
	public sealed class VolumeComponentDeprecated : Attribute
	{
	}
	[Serializable]
	public class VolumeComponent : ScriptableObject
	{
		public sealed class Indent : PropertyAttribute
		{
			public readonly int relativeAmount;

			public Indent(int relativeAmount = 1)
			{
				this.relativeAmount = relativeAmount;
			}
		}

		public bool active = true;

		internal readonly List<VolumeParameter> parameterList = new List<VolumeParameter>();

		private ReadOnlyCollection<VolumeParameter> m_ParameterReadOnlyCollection;

		public string displayName { get; protected set; } = "";

		public ReadOnlyCollection<VolumeParameter> parameters
		{
			get
			{
				if (m_ParameterReadOnlyCollection == null)
				{
					m_ParameterReadOnlyCollection = parameterList.AsReadOnly();
				}
				return m_ParameterReadOnlyCollection;
			}
		}

		internal static void FindParameters(object o, List<VolumeParameter> parameters, Func<FieldInfo, bool> filter = null)
		{
			if (o == null)
			{
				return;
			}
			foreach (FieldInfo item2 in from t in o.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
				orderby t.MetadataToken
				select t)
			{
				if (item2.FieldType.IsSubclassOf(typeof(VolumeParameter)))
				{
					if (filter == null || filter(item2))
					{
						VolumeParameter item = (VolumeParameter)item2.GetValue(o);
						parameters.Add(item);
					}
				}
				else if (!item2.FieldType.IsArray && item2.FieldType.IsClass)
				{
					FindParameters(item2.GetValue(o), parameters, filter);
				}
			}
		}

		protected virtual void OnEnable()
		{
			parameterList.Clear();
			FindParameters(this, parameterList);
			foreach (VolumeParameter parameter in parameterList)
			{
				if (parameter != null)
				{
					parameter.OnEnable();
				}
				else
				{
					Debug.LogWarning("Volume Component " + GetType().Name + " contains a null parameter; please make sure all parameters are initialized to a default value. Until this is fixed the null parameters will not be considered by the system.");
				}
			}
		}

		protected virtual void OnDisable()
		{
			foreach (VolumeParameter parameter in parameterList)
			{
				parameter?.OnDisable();
			}
		}

		public virtual void Override(VolumeComponent state, float interpFactor)
		{
			int count = parameterList.Count;
			for (int i = 0; i < count; i++)
			{
				VolumeParameter volumeParameter = state.parameterList[i];
				VolumeParameter volumeParameter2 = parameterList[i];
				if (volumeParameter2.overrideState)
				{
					volumeParameter.overrideState = volumeParameter2.overrideState;
					volumeParameter.Interp(volumeParameter, volumeParameter2, interpFactor);
				}
			}
		}

		public void SetAllOverridesTo(bool state)
		{
			SetOverridesTo(parameterList, state);
		}

		internal void SetOverridesTo(IEnumerable<VolumeParameter> enumerable, bool state)
		{
			foreach (VolumeParameter item in enumerable)
			{
				item.overrideState = state;
				Type type = item.GetType();
				if (VolumeParameter.IsObjectParameter(type))
				{
					ReadOnlyCollection<VolumeParameter> readOnlyCollection = (ReadOnlyCollection<VolumeParameter>)type.GetProperty("parameters", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(item, null);
					if (readOnlyCollection != null)
					{
						SetOverridesTo(readOnlyCollection, state);
					}
				}
			}
		}

		public override int GetHashCode()
		{
			int num = 17;
			for (int i = 0; i < parameterList.Count; i++)
			{
				num = num * 23 + parameterList[i].GetHashCode();
			}
			return num;
		}

		public bool AnyPropertiesIsOverridden()
		{
			for (int i = 0; i < parameterList.Count; i++)
			{
				if (parameterList[i].overrideState)
				{
					return true;
				}
			}
			return false;
		}

		protected virtual void OnDestroy()
		{
			Release();
		}

		public void Release()
		{
			if (parameterList == null)
			{
				return;
			}
			for (int i = 0; i < parameterList.Count; i++)
			{
				if (parameterList[i] != null)
				{
					parameterList[i].Release();
				}
			}
		}
	}
	public sealed class VolumeManager
	{
		private static readonly Lazy<VolumeManager> s_Instance = new Lazy<VolumeManager>(() => new VolumeManager());

		private static readonly Dictionary<Type, List<(string, Type)>> s_SupportedVolumeComponentsForRenderPipeline = new Dictionary<Type, List<(string, Type)>>();

		private const int k_MaxLayerCount = 32;

		private readonly Dictionary<int, List<Volume>> m_SortedVolumes;

		private readonly List<Volume> m_Volumes;

		private readonly Dictionary<int, bool> m_SortNeeded;

		private readonly List<VolumeComponent> m_ComponentsDefaultState;

		private readonly List<Collider> m_TempColliders;

		private VolumeStack m_DefaultStack;

		public static VolumeManager instance => s_Instance.Value;

		public VolumeStack stack { get; set; }

		[Obsolete("Please use baseComponentTypeArray instead.")]
		public IEnumerable<Type> baseComponentTypes
		{
			get
			{
				return baseComponentTypeArray;
			}
			private set
			{
				baseComponentTypeArray = value.ToArray();
			}
		}

		public Type[] baseComponentTypeArray { get; private set; }

		internal static List<(string, Type)> GetSupportedVolumeComponents(Type currentPipelineType)
		{
			if (s_SupportedVolumeComponentsForRenderPipeline.TryGetValue(currentPipelineType, out var value))
			{
				return value;
			}
			value = FilterVolumeComponentTypes(instance.baseComponentTypeArray, currentPipelineType);
			s_SupportedVolumeComponentsForRenderPipeline[currentPipelineType] = value;
			return value;
		}

		private static List<(string, Type)> FilterVolumeComponentTypes(Type[] types, Type currentPipelineType)
		{
			List<(string, Type)> list = new List<(string, Type)>();
			foreach (Type type in types)
			{
				string text = string.Empty;
				object[] customAttributes = type.GetCustomAttributes(inherit: false);
				bool flag = false;
				object[] array = customAttributes;
				foreach (object obj in array)
				{
					if (!(obj is VolumeComponentMenu volumeComponentMenu))
					{
						if (obj is HideInInspector || obj is ObsoleteAttribute)
						{
							flag = true;
						}
						continue;
					}
					text = volumeComponentMenu.menu;
					if (volumeComponentMenu is VolumeComponentMenuForRenderPipeline volumeComponentMenuForRenderPipeline)
					{
						flag |= !volumeComponentMenuForRenderPipeline.pipelineTypes.Contains(currentPipelineType);
					}
				}
				if (!flag)
				{
					if (string.IsNullOrEmpty(text))
					{
						text = type.Name;
					}
					list.Add((text, type));
				}
			}
			return list.OrderBy(((string, Type) tuple) => tuple.Item1).ToList();
		}

		internal VolumeComponent GetDefaultVolumeComponent(Type volumeComponentType)
		{
			foreach (VolumeComponent item in m_ComponentsDefaultState)
			{
				if (item.GetType() == volumeComponentType)
				{
					return item;
				}
			}
			return null;
		}

		private VolumeManager()
		{
			m_SortedVolumes = new Dictionary<int, List<Volume>>();
			m_Volumes = new List<Volume>();
			m_SortNeeded = new Dictionary<int, bool>();
			m_TempColliders = new List<Collider>(8);
			m_ComponentsDefaultState = new List<VolumeComponent>();
			ReloadBaseTypes();
			m_DefaultStack = CreateStack();
			stack = m_DefaultStack;
		}

		public VolumeStack CreateStack()
		{
			VolumeStack volumeStack = new VolumeStack();
			volumeStack.Reload(m_ComponentsDefaultState);
			return volumeStack;
		}

		public void ResetMainStack()
		{
			stack = m_DefaultStack;
		}

		public void DestroyStack(VolumeStack stack)
		{
			stack.Dispose();
		}

		private void ReloadBaseTypes()
		{
			m_ComponentsDefaultState.Clear();
			baseComponentTypeArray = (from t in CoreUtils.GetAllTypesDerivedFrom<VolumeComponent>()
				where !t.IsAbstract
				select t).ToArray();
			BindingFlags bindingAttr = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
			Type[] array = baseComponentTypeArray;
			foreach (Type obj in array)
			{
				obj.GetMethod("Init", bindingAttr)?.Invoke(null, null);
				VolumeComponent item = (VolumeComponent)ScriptableObject.CreateInstance(obj);
				m_ComponentsDefaultState.Add(item);
			}
		}

		public void Register(Volume volume, int layer)
		{
			if (m_Volumes.Contains(volume))
			{
				return;
			}
			m_Volumes.Add(volume);
			foreach (KeyValuePair<int, List<Volume>> sortedVolume in m_SortedVolumes)
			{
				if ((sortedVolume.Key & (1 << layer)) != 0 && !sortedVolume.Value.Contains(volume))
				{
					sortedVolume.Value.Add(volume);
				}
			}
			SetLayerDirty(layer);
		}

		public void Unregister(Volume volume, int layer)
		{
			if (!m_Volumes.Remove(volume))
			{
				return;
			}
			foreach (KeyValuePair<int, List<Volume>> sortedVolume in m_SortedVolumes)
			{
				if ((sortedVolume.Key & (1 << layer)) != 0)
				{
					sortedVolume.Value.Remove(volume);
				}
			}
		}

		public bool IsComponentActiveInMask<T>(LayerMask layerMask) where T : VolumeComponent
		{
			int value = layerMask.value;
			foreach (KeyValuePair<int, List<Volume>> sortedVolume in m_SortedVolumes)
			{
				if (sortedVolume.Key != value)
				{
					continue;
				}
				foreach (Volume item in sortedVolume.Value)
				{
					if (item.enabled && !(item.profileRef == null) && item.profileRef.TryGet<T>(out var component) && component.active)
					{
						return true;
					}
				}
			}
			return false;
		}

		internal void SetLayerDirty(int layer)
		{
			Assert.IsTrue(layer >= 0 && layer <= 32, "Invalid layer bit");
			foreach (KeyValuePair<int, List<Volume>> sortedVolume in m_SortedVolumes)
			{
				int key = sortedVolume.Key;
				if ((key & (1 << layer)) != 0)
				{
					m_SortNeeded[key] = true;
				}
			}
		}

		internal void UpdateVolumeLayer(Volume volume, int prevLayer, int newLayer)
		{
			Assert.IsTrue(prevLayer >= 0 && prevLayer <= 32, "Invalid layer bit");
			Unregister(volume, prevLayer);
			Register(volume, newLayer);
		}

		private void OverrideData(VolumeStack stack, List<VolumeComponent> components, float interpFactor)
		{
			int count = components.Count;
			for (int i = 0; i < count; i++)
			{
				VolumeComponent volumeComponent = components[i];
				if (volumeComponent.active)
				{
					VolumeComponent component = stack.GetComponent(volumeComponent.GetType());
					volumeComponent.Override(component, interpFactor);
				}
			}
		}

		internal void ReplaceData(VolumeStack stack)
		{
			(VolumeParameter, VolumeParameter)[] defaultParameters = stack.defaultParameters;
			int num = defaultParameters.Length;
			for (int i = 0; i < num; i++)
			{
				(VolumeParameter, VolumeParameter) tuple = defaultParameters[i];
				VolumeParameter item = tuple.Item1;
				item.overrideState = false;
				item.SetValue(tuple.Item2);
			}
		}

		[Conditional("UNITY_EDITOR")]
		public void CheckBaseTypes()
		{
			if (m_ComponentsDefaultState == null || (m_ComponentsDefaultState.Count > 0 && m_ComponentsDefaultState[0] == null))
			{
				ReloadBaseTypes();
			}
		}

		[Conditional("UNITY_EDITOR")]
		public void CheckStack(VolumeStack stack)
		{
			Dictionary<Type, VolumeComponent> components = stack.components;
			if (components == null)
			{
				stack.Reload(m_ComponentsDefaultState);
				return;
			}
			foreach (KeyValuePair<Type, VolumeComponent> item in components)
			{
				if (item.Key == null || item.Value == null)
				{
					stack.Reload(m_ComponentsDefaultState);
					break;
				}
			}
		}

		private bool CheckUpdateRequired(VolumeStack stack)
		{
			if (m_Volumes.Count == 0)
			{
				if (stack.requiresReset)
				{
					stack.requiresReset = false;
					return true;
				}
				return false;
			}
			stack.requiresReset = true;
			return true;
		}

		public void Update(Transform trigger, LayerMask layerMask)
		{
			Update(stack, trigger, layerMask);
		}

		public void Update(VolumeStack stack, Transform trigger, LayerMask layerMask)
		{
			Assert.IsNotNull(stack);
			if (!CheckUpdateRequired(stack))
			{
				return;
			}
			ReplaceData(stack);
			bool flag = trigger == null;
			Vector3 vector = (flag ? Vector3.zero : trigger.position);
			List<Volume> list = GrabVolumes(layerMask);
			Camera component = null;
			if (!flag)
			{
				trigger.TryGetComponent<Camera>(out component);
			}
			int count = list.Count;
			for (int i = 0; i < count; i++)
			{
				Volume volume = list[i];
				if (volume == null || !volume.enabled || volume.profileRef == null || volume.weight <= 0f)
				{
					continue;
				}
				if (volume.isGlobal)
				{
					OverrideData(stack, volume.profileRef.components, Mathf.Clamp01(volume.weight));
				}
				else
				{
					if (flag)
					{
						continue;
					}
					List<Collider> tempColliders = m_TempColliders;
					volume.GetComponents(tempColliders);
					if (tempColliders.Count == 0)
					{
						continue;
					}
					float num = float.PositiveInfinity;
					int count2 = tempColliders.Count;
					for (int j = 0; j < count2; j++)
					{
						Collider collider = tempColliders[j];
						if (collider.enabled)
						{
							float sqrMagnitude = (collider.ClosestPoint(vector) - vector).sqrMagnitude;
							if (sqrMagnitude < num)
							{
								num = sqrMagnitude;
							}
						}
					}
					tempColliders.Clear();
					float num2 = volume.blendDistance * volume.blendDistance;
					if (!(num > num2))
					{
						float num3 = 1f;
						if (num2 > 0f)
						{
							num3 = 1f - num / num2;
						}
						OverrideData(stack, volume.profileRef.components, num3 * Mathf.Clamp01(volume.weight));
					}
				}
			}
		}

		public Volume[] GetVolumes(LayerMask layerMask)
		{
			List<Volume> list = GrabVolumes(layerMask);
			list.RemoveAll((Volume v) => v == null);
			return list.ToArray();
		}

		private List<Volume> GrabVolumes(LayerMask mask)
		{
			if (!m_SortedVolumes.TryGetValue(mask, out var value))
			{
				value = new List<Volume>();
				int count = m_Volumes.Count;
				for (int i = 0; i < count; i++)
				{
					Volume volume = m_Volumes[i];
					if (((int)mask & (1 << volume.gameObject.layer)) != 0)
					{
						value.Add(volume);
						m_SortNeeded[mask] = true;
					}
				}
				m_SortedVolumes.Add(mask, value);
			}
			if (m_SortNeeded.TryGetValue(mask, out var value2) && value2)
			{
				m_SortNeeded[mask] = false;
				SortByPriority(value);
			}
			return value;
		}

		private static void SortByPriority(List<Volume> volumes)
		{
			Assert.IsNotNull(volumes, "Trying to sort volumes of non-initialized layer");
			for (int i = 1; i < volumes.Count; i++)
			{
				Volume volume = volumes[i];
				int num = i - 1;
				while (num >= 0 && volumes[num].priority > volume.priority)
				{
					volumes[num + 1] = volumes[num];
					num--;
				}
				volumes[num + 1] = volume;
			}
		}

		private static bool IsVolumeRenderedByCamera(Volume volume, Camera camera)
		{
			return true;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[Obsolete("VolumeIsolationScope is deprecated, it does not have any effect anymore.")]
	public struct VolumeIsolationScope : IDisposable
	{
		public VolumeIsolationScope(bool unused)
		{
		}

		void IDisposable.Dispose()
		{
		}
	}
	public abstract class VolumeParameter : ICloneable
	{
		public const string k_DebuggerDisplay = "{m_Value} ({m_OverrideState})";

		[SerializeField]
		protected bool m_OverrideState;

		public virtual bool overrideState
		{
			get
			{
				return m_OverrideState;
			}
			set
			{
				m_OverrideState = value;
			}
		}

		internal abstract void Interp(VolumeParameter from, VolumeParameter to, float t);

		public T GetValue<T>()
		{
			return ((VolumeParameter<T>)this).value;
		}

		public abstract void SetValue(VolumeParameter parameter);

		protected internal virtual void OnEnable()
		{
		}

		protected internal virtual void OnDisable()
		{
		}

		public static bool IsObjectParameter(Type type)
		{
			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(ObjectParameter<>))
			{
				return true;
			}
			if (type.BaseType != null)
			{
				return IsObjectParameter(type.BaseType);
			}
			return false;
		}

		public virtual void Release()
		{
		}

		public abstract object Clone();
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class VolumeParameter<T> : VolumeParameter, IEquatable<VolumeParameter<T>>
	{
		[SerializeField]
		protected T m_Value;

		public virtual T value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = value;
			}
		}

		public VolumeParameter()
			: this(default(T), overrideState: false)
		{
		}

		protected VolumeParameter(T value, bool overrideState)
		{
			m_Value = value;
			this.overrideState = overrideState;
		}

		internal override void Interp(VolumeParameter from, VolumeParameter to, float t)
		{
			Interp((from as VolumeParameter<T>).value, (to as VolumeParameter<T>).value, t);
		}

		public virtual void Interp(T from, T to, float t)
		{
			m_Value = ((t > 0f) ? to : from);
		}

		public void Override(T x)
		{
			overrideState = true;
			m_Value = x;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public override void SetValue(VolumeParameter parameter)
		{
			m_Value = ((VolumeParameter<T>)parameter).m_Value;
		}

		public override int GetHashCode()
		{
			int num = 17;
			num = num * 23 + overrideState.GetHashCode();
			if (!EqualityComparer<T>.Default.Equals(value, default(T)))
			{
				num = num * 23 + value.GetHashCode();
			}
			return num;
		}

		public override string ToString()
		{
			return $"{value} ({overrideState})";
		}

		public static bool operator ==(VolumeParameter<T> lhs, T rhs)
		{
			if (lhs != null && lhs.value != null)
			{
				return lhs.value.Equals(rhs);
			}
			return false;
		}

		public static bool operator !=(VolumeParameter<T> lhs, T rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(VolumeParameter<T> other)
		{
			if (other == null)
			{
				return false;
			}
			if (this == other)
			{
				return true;
			}
			return EqualityComparer<T>.Default.Equals(m_Value, other.m_Value);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (this == obj)
			{
				return true;
			}
			if (obj.GetType() != GetType())
			{
				return false;
			}
			return Equals((VolumeParameter<T>)obj);
		}

		public override object Clone()
		{
			return new VolumeParameter<T>(GetValue<T>(), overrideState);
		}

		public static explicit operator T(VolumeParameter<T> prop)
		{
			return prop.m_Value;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class BoolParameter : VolumeParameter<bool>
	{
		public enum DisplayType
		{
			Checkbox,
			EnumPopup
		}

		[NonSerialized]
		public DisplayType displayType;

		public BoolParameter(bool value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public BoolParameter(bool value, DisplayType displayType, bool overrideState = false)
			: base(value, overrideState)
		{
			this.displayType = displayType;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class LayerMaskParameter : VolumeParameter<LayerMask>
	{
		public LayerMaskParameter(LayerMask value, bool overrideState = false)
			: base(value, overrideState)
		{
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class IntParameter : VolumeParameter<int>
	{
		public IntParameter(int value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public sealed override void Interp(int from, int to, float t)
		{
			m_Value = (int)((float)from + (float)(to - from) * t);
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpIntParameter : VolumeParameter<int>
	{
		public NoInterpIntParameter(int value, bool overrideState = false)
			: base(value, overrideState)
		{
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class MinIntParameter : IntParameter
	{
		[NonSerialized]
		public int min;

		public override int value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Max(value, min);
			}
		}

		public MinIntParameter(int value, int min, bool overrideState = false)
			: base(value, overrideState)
		{
			this.min = min;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpMinIntParameter : VolumeParameter<int>
	{
		[NonSerialized]
		public int min;

		public override int value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Max(value, min);
			}
		}

		public NoInterpMinIntParameter(int value, int min, bool overrideState = false)
			: base(value, overrideState)
		{
			this.min = min;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class MaxIntParameter : IntParameter
	{
		[NonSerialized]
		public int max;

		public override int value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Min(value, max);
			}
		}

		public MaxIntParameter(int value, int max, bool overrideState = false)
			: base(value, overrideState)
		{
			this.max = max;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpMaxIntParameter : VolumeParameter<int>
	{
		[NonSerialized]
		public int max;

		public override int value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Min(value, max);
			}
		}

		public NoInterpMaxIntParameter(int value, int max, bool overrideState = false)
			: base(value, overrideState)
		{
			this.max = max;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class ClampedIntParameter : IntParameter
	{
		[NonSerialized]
		public int min;

		[NonSerialized]
		public int max;

		public override int value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Clamp(value, min, max);
			}
		}

		public ClampedIntParameter(int value, int min, int max, bool overrideState = false)
			: base(value, overrideState)
		{
			this.min = min;
			this.max = max;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpClampedIntParameter : VolumeParameter<int>
	{
		[NonSerialized]
		public int min;

		[NonSerialized]
		public int max;

		public override int value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Clamp(value, min, max);
			}
		}

		public NoInterpClampedIntParameter(int value, int min, int max, bool overrideState = false)
			: base(value, overrideState)
		{
			this.min = min;
			this.max = max;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class FloatParameter : VolumeParameter<float>
	{
		public FloatParameter(float value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public sealed override void Interp(float from, float to, float t)
		{
			m_Value = from + (to - from) * t;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpFloatParameter : VolumeParameter<float>
	{
		public NoInterpFloatParameter(float value, bool overrideState = false)
			: base(value, overrideState)
		{
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class MinFloatParameter : FloatParameter
	{
		[NonSerialized]
		public float min;

		public override float value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Max(value, min);
			}
		}

		public MinFloatParameter(float value, float min, bool overrideState = false)
			: base(value, overrideState)
		{
			this.min = min;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpMinFloatParameter : VolumeParameter<float>
	{
		[NonSerialized]
		public float min;

		public override float value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Max(value, min);
			}
		}

		public NoInterpMinFloatParameter(float value, float min, bool overrideState = false)
			: base(value, overrideState)
		{
			this.min = min;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class MaxFloatParameter : FloatParameter
	{
		[NonSerialized]
		public float max;

		public override float value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Min(value, max);
			}
		}

		public MaxFloatParameter(float value, float max, bool overrideState = false)
			: base(value, overrideState)
		{
			this.max = max;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpMaxFloatParameter : VolumeParameter<float>
	{
		[NonSerialized]
		public float max;

		public override float value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Min(value, max);
			}
		}

		public NoInterpMaxFloatParameter(float value, float max, bool overrideState = false)
			: base(value, overrideState)
		{
			this.max = max;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class ClampedFloatParameter : FloatParameter
	{
		[NonSerialized]
		public float min;

		[NonSerialized]
		public float max;

		public override float value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Clamp(value, min, max);
			}
		}

		public ClampedFloatParameter(float value, float min, float max, bool overrideState = false)
			: base(value, overrideState)
		{
			this.min = min;
			this.max = max;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpClampedFloatParameter : VolumeParameter<float>
	{
		[NonSerialized]
		public float min;

		[NonSerialized]
		public float max;

		public override float value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Clamp(value, min, max);
			}
		}

		public NoInterpClampedFloatParameter(float value, float min, float max, bool overrideState = false)
			: base(value, overrideState)
		{
			this.min = min;
			this.max = max;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class FloatRangeParameter : VolumeParameter<Vector2>
	{
		[NonSerialized]
		public float min;

		[NonSerialized]
		public float max;

		public override Vector2 value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value.x = Mathf.Max(value.x, min);
				m_Value.y = Mathf.Min(value.y, max);
			}
		}

		public FloatRangeParameter(Vector2 value, float min, float max, bool overrideState = false)
			: base(value, overrideState)
		{
			this.min = min;
			this.max = max;
		}

		public override void Interp(Vector2 from, Vector2 to, float t)
		{
			m_Value.x = from.x + (to.x - from.x) * t;
			m_Value.y = from.y + (to.y - from.y) * t;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpFloatRangeParameter : VolumeParameter<Vector2>
	{
		[NonSerialized]
		public float min;

		[NonSerialized]
		public float max;

		public override Vector2 value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value.x = Mathf.Max(value.x, min);
				m_Value.y = Mathf.Min(value.y, max);
			}
		}

		public NoInterpFloatRangeParameter(Vector2 value, float min, float max, bool overrideState = false)
			: base(value, overrideState)
		{
			this.min = min;
			this.max = max;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class ColorParameter : VolumeParameter<Color>
	{
		[NonSerialized]
		public bool hdr;

		[NonSerialized]
		public bool showAlpha = true;

		[NonSerialized]
		public bool showEyeDropper = true;

		public ColorParameter(Color value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public ColorParameter(Color value, bool hdr, bool showAlpha, bool showEyeDropper, bool overrideState = false)
			: base(value, overrideState)
		{
			this.hdr = hdr;
			this.showAlpha = showAlpha;
			this.showEyeDropper = showEyeDropper;
			this.overrideState = overrideState;
		}

		public override void Interp(Color from, Color to, float t)
		{
			m_Value.r = from.r + (to.r - from.r) * t;
			m_Value.g = from.g + (to.g - from.g) * t;
			m_Value.b = from.b + (to.b - from.b) * t;
			m_Value.a = from.a + (to.a - from.a) * t;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpColorParameter : VolumeParameter<Color>
	{
		public bool hdr;

		[NonSerialized]
		public bool showAlpha = true;

		[NonSerialized]
		public bool showEyeDropper = true;

		public NoInterpColorParameter(Color value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public NoInterpColorParameter(Color value, bool hdr, bool showAlpha, bool showEyeDropper, bool overrideState = false)
			: base(value, overrideState)
		{
			this.hdr = hdr;
			this.showAlpha = showAlpha;
			this.showEyeDropper = showEyeDropper;
			this.overrideState = overrideState;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class Vector2Parameter : VolumeParameter<Vector2>
	{
		public Vector2Parameter(Vector2 value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override void Interp(Vector2 from, Vector2 to, float t)
		{
			m_Value.x = from.x + (to.x - from.x) * t;
			m_Value.y = from.y + (to.y - from.y) * t;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpVector2Parameter : VolumeParameter<Vector2>
	{
		public NoInterpVector2Parameter(Vector2 value, bool overrideState = false)
			: base(value, overrideState)
		{
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class Vector3Parameter : VolumeParameter<Vector3>
	{
		public Vector3Parameter(Vector3 value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override void Interp(Vector3 from, Vector3 to, float t)
		{
			m_Value.x = from.x + (to.x - from.x) * t;
			m_Value.y = from.y + (to.y - from.y) * t;
			m_Value.z = from.z + (to.z - from.z) * t;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpVector3Parameter : VolumeParameter<Vector3>
	{
		public NoInterpVector3Parameter(Vector3 value, bool overrideState = false)
			: base(value, overrideState)
		{
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class Vector4Parameter : VolumeParameter<Vector4>
	{
		public Vector4Parameter(Vector4 value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override void Interp(Vector4 from, Vector4 to, float t)
		{
			m_Value.x = from.x + (to.x - from.x) * t;
			m_Value.y = from.y + (to.y - from.y) * t;
			m_Value.z = from.z + (to.z - from.z) * t;
			m_Value.w = from.w + (to.w - from.w) * t;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpVector4Parameter : VolumeParameter<Vector4>
	{
		public NoInterpVector4Parameter(Vector4 value, bool overrideState = false)
			: base(value, overrideState)
		{
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class TextureParameter : VolumeParameter<Texture>
	{
		public TextureDimension dimension;

		public TextureParameter(Texture value, bool overrideState = false)
			: this(value, TextureDimension.Any, overrideState)
		{
		}

		public TextureParameter(Texture value, TextureDimension dimension, bool overrideState = false)
			: base(value, overrideState)
		{
			this.dimension = dimension;
		}

		public override int GetHashCode()
		{
			int result = base.GetHashCode();
			if (value != null)
			{
				result = 23 * CoreUtils.GetTextureHash(value);
			}
			return result;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpTextureParameter : VolumeParameter<Texture>
	{
		public NoInterpTextureParameter(Texture value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override int GetHashCode()
		{
			int result = base.GetHashCode();
			if (value != null)
			{
				result = 23 * CoreUtils.GetTextureHash(value);
			}
			return result;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class Texture2DParameter : VolumeParameter<Texture>
	{
		public Texture2DParameter(Texture value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override int GetHashCode()
		{
			int result = base.GetHashCode();
			if (value != null)
			{
				result = 23 * CoreUtils.GetTextureHash(value);
			}
			return result;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class Texture3DParameter : VolumeParameter<Texture>
	{
		public Texture3DParameter(Texture value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override int GetHashCode()
		{
			int result = base.GetHashCode();
			if (value != null)
			{
				result = 23 * CoreUtils.GetTextureHash(value);
			}
			return result;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class RenderTextureParameter : VolumeParameter<RenderTexture>
	{
		public RenderTextureParameter(RenderTexture value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override int GetHashCode()
		{
			int result = base.GetHashCode();
			if (value != null)
			{
				result = 23 * CoreUtils.GetTextureHash(value);
			}
			return result;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpRenderTextureParameter : VolumeParameter<RenderTexture>
	{
		public NoInterpRenderTextureParameter(RenderTexture value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override int GetHashCode()
		{
			int result = base.GetHashCode();
			if (value != null)
			{
				result = 23 * CoreUtils.GetTextureHash(value);
			}
			return result;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class CubemapParameter : VolumeParameter<Texture>
	{
		public CubemapParameter(Texture value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override int GetHashCode()
		{
			int result = base.GetHashCode();
			if (value != null)
			{
				result = 23 * CoreUtils.GetTextureHash(value);
			}
			return result;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class NoInterpCubemapParameter : VolumeParameter<Cubemap>
	{
		public NoInterpCubemapParameter(Cubemap value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override int GetHashCode()
		{
			int result = base.GetHashCode();
			if (value != null)
			{
				result = 23 * CoreUtils.GetTextureHash(value);
			}
			return result;
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class ObjectParameter<T> : VolumeParameter<T>
	{
		internal ReadOnlyCollection<VolumeParameter> parameters { get; private set; }

		public sealed override bool overrideState
		{
			get
			{
				return true;
			}
			set
			{
				m_OverrideState = true;
			}
		}

		public sealed override T value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = value;
				if (m_Value == null)
				{
					parameters = null;
					return;
				}
				parameters = (from t in m_Value.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public)
					where t.FieldType.IsSubclassOf(typeof(VolumeParameter))
					orderby t.MetadataToken
					select (VolumeParameter)t.GetValue(m_Value)).ToList().AsReadOnly();
			}
		}

		public ObjectParameter(T value)
		{
			m_OverrideState = true;
			this.value = value;
		}

		internal override void Interp(VolumeParameter from, VolumeParameter to, float t)
		{
			if (m_Value == null)
			{
				return;
			}
			ReadOnlyCollection<VolumeParameter> readOnlyCollection = parameters;
			ReadOnlyCollection<VolumeParameter> readOnlyCollection2 = ((ObjectParameter<T>)from).parameters;
			ReadOnlyCollection<VolumeParameter> readOnlyCollection3 = ((ObjectParameter<T>)to).parameters;
			for (int i = 0; i < readOnlyCollection2.Count; i++)
			{
				readOnlyCollection[i].overrideState = readOnlyCollection3[i].overrideState;
				if (readOnlyCollection3[i].overrideState)
				{
					readOnlyCollection[i].Interp(readOnlyCollection2[i], readOnlyCollection3[i], t);
				}
			}
		}
	}
	[Serializable]
	public class AnimationCurveParameter : VolumeParameter<AnimationCurve>
	{
		public AnimationCurveParameter(AnimationCurve value, bool overrideState = false)
			: base(value, overrideState)
		{
		}

		public override void Interp(AnimationCurve lhsCurve, AnimationCurve rhsCurve, float t)
		{
			m_Value = lhsCurve;
			KeyframeUtility.InterpAnimationCurve(ref m_Value, rhsCurve, t);
		}

		public override void SetValue(VolumeParameter parameter)
		{
			m_Value.CopyFrom(((AnimationCurveParameter)parameter).m_Value);
		}

		public override object Clone()
		{
			return new AnimationCurveParameter(new AnimationCurve(GetValue<AnimationCurve>().keys), overrideState);
		}

		public override int GetHashCode()
		{
			return overrideState.GetHashCode() * 23 + value.GetHashCode();
		}
	}
	[Serializable]
	[DebuggerDisplay("{m_Value} ({m_OverrideState})")]
	public class MaterialParameter : VolumeParameter<Material>
	{
		public MaterialParameter(Material value, bool overrideState = false)
			: base(value, overrideState)
		{
		}
	}
	public sealed class VolumeProfile : ScriptableObject
	{
		public List<VolumeComponent> components = new List<VolumeComponent>();

		[NonSerialized]
		public bool isDirty = true;

		private void OnEnable()
		{
			components.RemoveAll((VolumeComponent x) => x == null);
		}

		internal void OnDisable()
		{
			if (components == null)
			{
				return;
			}
			for (int i = 0; i < components.Count; i++)
			{
				if (components[i] != null)
				{
					components[i].Release();
				}
			}
		}

		public void Reset()
		{
			isDirty = true;
		}

		public T Add<T>(bool overrides = false) where T : VolumeComponent
		{
			return (T)Add(typeof(T), overrides);
		}

		public VolumeComponent Add(Type type, bool overrides = false)
		{
			if (Has(type))
			{
				throw new InvalidOperationException("Component already exists in the volume");
			}
			VolumeComponent volumeComponent = (VolumeComponent)ScriptableObject.CreateInstance(type);
			volumeComponent.SetAllOverridesTo(overrides);
			components.Add(volumeComponent);
			isDirty = true;
			return volumeComponent;
		}

		public void Remove<T>() where T : VolumeComponent
		{
			Remove(typeof(T));
		}

		public void Remove(Type type)
		{
			int num = -1;
			for (int i = 0; i < components.Count; i++)
			{
				if (components[i].GetType() == type)
				{
					num = i;
					break;
				}
			}
			if (num >= 0)
			{
				components.RemoveAt(num);
				isDirty = true;
			}
		}

		public bool Has<T>() where T : VolumeComponent
		{
			return Has(typeof(T));
		}

		public bool Has(Type type)
		{
			foreach (VolumeComponent component in components)
			{
				if (component.GetType() == type)
				{
					return true;
				}
			}
			return false;
		}

		public bool HasSubclassOf(Type type)
		{
			foreach (VolumeComponent component in components)
			{
				if (component.GetType().IsSubclassOf(type))
				{
					return true;
				}
			}
			return false;
		}

		public bool TryGet<T>(out T component) where T : VolumeComponent
		{
			return TryGet<T>(typeof(T), out component);
		}

		public bool TryGet<T>(Type type, out T component) where T : VolumeComponent
		{
			component = null;
			foreach (VolumeComponent component2 in components)
			{
				if (component2.GetType() == type)
				{
					component = (T)component2;
					return true;
				}
			}
			return false;
		}

		public bool TryGetSubclassOf<T>(Type type, out T component) where T : VolumeComponent
		{
			component = null;
			foreach (VolumeComponent component2 in components)
			{
				if (component2.GetType().IsSubclassOf(type))
				{
					component = (T)component2;
					return true;
				}
			}
			return false;
		}

		public bool TryGetAllSubclassOf<T>(Type type, List<T> result) where T : VolumeComponent
		{
			Assert.IsNotNull(components);
			int count = result.Count;
			foreach (VolumeComponent component in components)
			{
				if (component.GetType().IsSubclassOf(type))
				{
					result.Add((T)component);
				}
			}
			return count != result.Count;
		}

		public override int GetHashCode()
		{
			int num = 17;
			for (int i = 0; i < components.Count; i++)
			{
				num = num * 23 + components[i].GetHashCode();
			}
			return num;
		}

		internal int GetComponentListHashCode()
		{
			int num = 17;
			for (int i = 0; i < components.Count; i++)
			{
				num = num * 23 + components[i].GetType().GetHashCode();
			}
			return num;
		}

		internal void Sanitize()
		{
			for (int num = components.Count - 1; num >= 0; num--)
			{
				if (components[num] == null)
				{
					components.RemoveAt(num);
				}
			}
		}
	}
	public sealed class VolumeStack : IDisposable
	{
		internal readonly Dictionary<Type, VolumeComponent> components = new Dictionary<Type, VolumeComponent>();

		internal (VolumeParameter parameter, VolumeParameter defaultValue)[] defaultParameters;

		internal bool requiresReset = true;

		internal VolumeStack()
		{
		}

		internal void Clear()
		{
			foreach (KeyValuePair<Type, VolumeComponent> component in components)
			{
				CoreUtils.Destroy(component.Value);
			}
			components.Clear();
			if (defaultParameters != null)
			{
				(VolumeParameter, VolumeParameter)[] array = defaultParameters;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].Item2?.Release();
				}
				defaultParameters = null;
			}
		}

		internal void Reload(List<VolumeComponent> componentDefaultStates)
		{
			Clear();
			requiresReset = true;
			List<(VolumeParameter, VolumeParameter)> list = new List<(VolumeParameter, VolumeParameter)>();
			foreach (VolumeComponent componentDefaultState in componentDefaultStates)
			{
				Type type = componentDefaultState.GetType();
				VolumeComponent volumeComponent = (VolumeComponent)ScriptableObject.CreateInstance(type);
				components.Add(type, volumeComponent);
				for (int i = 0; i < volumeComponent.parameterList.Count; i++)
				{
					list.Add(new(VolumeParameter, VolumeParameter)
					{
						Item1 = volumeComponent.parameters[i],
						Item2 = (componentDefaultState.parameterList[i].Clone() as VolumeParameter)
					});
				}
			}
			defaultParameters = list.ToArray();
		}

		public T GetComponent<T>() where T : VolumeComponent
		{
			return (T)GetComponent(typeof(T));
		}

		public VolumeComponent GetComponent(Type type)
		{
			components.TryGetValue(type, out var value);
			return value;
		}

		public void Dispose()
		{
			Clear();
		}
	}
	public static class XRGraphicsAutomatedTests
	{
		public static bool running = false;

		private static bool activatedFromCommandLine => false;

		public static bool enabled { get; } = activatedFromCommandLine;

		internal static void OverrideLayout(XRLayout layout, Camera camera)
		{
		}
	}
}
namespace UnityEngine.Rendering.LookDev
{
	public interface IDataProvider
	{
		IEnumerable<string> supportedDebugModes { get; }

		void FirstInitScene(StageRuntimeInterface stage);

		void UpdateSky(Camera camera, Sky sky, StageRuntimeInterface stage);

		void UpdateDebugMode(int debugIndex);

		void GetShadowMask(ref RenderTexture output, StageRuntimeInterface stage);

		void OnBeginRendering(StageRuntimeInterface stage);

		void OnEndRendering(StageRuntimeInterface stage);

		void Cleanup(StageRuntimeInterface SRI);
	}
	public struct Sky
	{
		public Cubemap cubemap;

		public float longitudeOffset;

		public float exposure;
	}
	public class StageRuntimeInterface
	{
		private Func<bool, GameObject> m_AddGameObject;

		private Func<Camera> m_GetCamera;

		private Func<Light> m_GetSunLight;

		public object SRPData;

		public Camera camera => m_GetCamera?.Invoke();

		public Light sunLight => m_GetSunLight?.Invoke();

		public StageRuntimeInterface(Func<bool, GameObject> AddGameObject, Func<Camera> GetCamera, Func<Light> GetSunLight)
		{
			m_AddGameObject = AddGameObject;
			m_GetCamera = GetCamera;
			m_GetSunLight = GetSunLight;
		}

		public GameObject AddGameObject(bool persistent = false)
		{
			return m_AddGameObject?.Invoke(persistent);
		}
	}
}
namespace UnityEngine.Rendering.UI
{
	public class DebugUIHandlerBitField : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public UIFoldout valueToggle;

		public List<DebugUIHandlerIndirectToggle> toggles;

		private DebugUI.BitField m_Field;

		private DebugUIHandlerContainer m_Container;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.BitField>();
			m_Container = GetComponent<DebugUIHandlerContainer>();
			nameLabel.text = m_Field.displayName;
			int i = 0;
			GUIContent[] enumNames = m_Field.enumNames;
			foreach (GUIContent gUIContent in enumNames)
			{
				if (i < toggles.Count)
				{
					DebugUIHandlerIndirectToggle debugUIHandlerIndirectToggle = toggles[i];
					debugUIHandlerIndirectToggle.getter = GetValue;
					debugUIHandlerIndirectToggle.setter = SetValue;
					debugUIHandlerIndirectToggle.nextUIHandler = ((i < m_Field.enumNames.Length - 1) ? toggles[i + 1] : null);
					debugUIHandlerIndirectToggle.previousUIHandler = ((i > 0) ? toggles[i - 1] : null);
					debugUIHandlerIndirectToggle.parentUIHandler = this;
					debugUIHandlerIndirectToggle.index = i;
					debugUIHandlerIndirectToggle.nameLabel.text = gUIContent.text;
					debugUIHandlerIndirectToggle.Init();
					i++;
				}
			}
			for (; i < toggles.Count; i++)
			{
				CoreUtils.Destroy(toggles[i].gameObject);
				toggles[i] = null;
			}
		}

		private bool GetValue(int index)
		{
			if (index == 0)
			{
				return false;
			}
			index--;
			return (Convert.ToInt32(m_Field.GetValue()) & (1 << index)) != 0;
		}

		private void SetValue(int index, bool value)
		{
			if (index == 0)
			{
				m_Field.SetValue(Enum.ToObject(m_Field.enumType, 0));
				{
					foreach (DebugUIHandlerIndirectToggle toggle in toggles)
					{
						if ((object)toggle != null && toggle.getter != null)
						{
							toggle.UpdateValueLabel();
						}
					}
					return;
				}
			}
			int num = Convert.ToInt32(m_Field.GetValue());
			num = ((!value) ? (num & ~m_Field.enumValues[index]) : (num | m_Field.enumValues[index]));
			m_Field.SetValue(Enum.ToObject(m_Field.enumType, num));
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			if (fromNext || !valueToggle.isOn)
			{
				nameLabel.color = colorSelected;
			}
			else if (valueToggle.isOn)
			{
				if (m_Container.IsDirectChild(previous))
				{
					nameLabel.color = colorSelected;
				}
				else
				{
					DebugUIHandlerWidget lastItem = m_Container.GetLastItem();
					DebugManager.instance.ChangeSelection(lastItem, fromNext: false);
				}
			}
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
		}

		public override void OnIncrement(bool fast)
		{
			valueToggle.isOn = true;
		}

		public override void OnDecrement(bool fast)
		{
			valueToggle.isOn = false;
		}

		public override void OnAction()
		{
			valueToggle.isOn = !valueToggle.isOn;
		}

		public override DebugUIHandlerWidget Next()
		{
			if (!valueToggle.isOn || m_Container == null)
			{
				return base.Next();
			}
			DebugUIHandlerWidget firstItem = m_Container.GetFirstItem();
			if (firstItem == null)
			{
				return base.Next();
			}
			return firstItem;
		}
	}
	public class DebugUIHandlerButton : DebugUIHandlerWidget
	{
		public Text nameLabel;

		private DebugUI.Button m_Field;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.Button>();
			nameLabel.text = m_Field.displayName;
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			nameLabel.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
		}

		public override void OnAction()
		{
			if (m_Field.action != null)
			{
				m_Field.action();
			}
		}
	}
	[Serializable]
	public class DebugUIPrefabBundle
	{
		public string type;

		public RectTransform prefab;
	}
	public class DebugUIHandlerCanvas : MonoBehaviour
	{
		private int m_DebugTreeState;

		private Dictionary<Type, Transform> m_PrefabsMap;

		public Transform panelPrefab;

		public List<DebugUIPrefabBundle> prefabs;

		private List<DebugUIHandlerPanel> m_UIPanels;

		private int m_SelectedPanel;

		private DebugUIHandlerWidget m_SelectedWidget;

		private string m_CurrentQueryPath;

		private void OnEnable()
		{
			if (prefabs == null)
			{
				prefabs = new List<DebugUIPrefabBundle>();
			}
			if (m_PrefabsMap == null)
			{
				m_PrefabsMap = new Dictionary<Type, Transform>();
			}
			if (m_UIPanels == null)
			{
				m_UIPanels = new List<DebugUIHandlerPanel>();
			}
			DebugManager.instance.RegisterRootCanvas(this);
		}

		private void Update()
		{
			int state = DebugManager.instance.GetState();
			if (m_DebugTreeState != state)
			{
				ResetAllHierarchy();
			}
			HandleInput();
			if (m_UIPanels != null && m_SelectedPanel < m_UIPanels.Count && m_UIPanels[m_SelectedPanel] != null)
			{
				m_UIPanels[m_SelectedPanel].UpdateScroll();
			}
		}

		internal void RequestHierarchyReset()
		{
			m_DebugTreeState = -1;
		}

		private void ResetAllHierarchy()
		{
			foreach (Transform item in base.transform)
			{
				CoreUtils.Destroy(item.gameObject);
			}
			Rebuild();
		}

		private void Rebuild()
		{
			m_PrefabsMap.Clear();
			foreach (DebugUIPrefabBundle prefab in prefabs)
			{
				Type type = Type.GetType(prefab.type);
				if (type != null && prefab.prefab != null)
				{
					m_PrefabsMap.Add(type, prefab.prefab);
				}
			}
			m_UIPanels.Clear();
			m_DebugTreeState = DebugManager.instance.GetState();
			ReadOnlyCollection<DebugUI.Panel> panels = DebugManager.instance.panels;
			DebugUIHandlerWidget selectedWidget = null;
			foreach (DebugUI.Panel item in panels)
			{
				if (!item.isEditorOnly && item.children.Count((DebugUI.Widget x) => !x.isEditorOnly && !x.isHidden) != 0)
				{
					GameObject obj = Object.Instantiate(panelPrefab, base.transform, worldPositionStays: false).gameObject;
					obj.name = item.displayName;
					DebugUIHandlerPanel component = obj.GetComponent<DebugUIHandlerPanel>();
					component.SetPanel(item);
					component.Canvas = this;
					m_UIPanels.Add(component);
					DebugUIHandlerContainer component2 = obj.GetComponent<DebugUIHandlerContainer>();
					DebugUIHandlerWidget selectedHandler = null;
					Traverse(item, component2.contentHolder, null, ref selectedHandler);
					if (selectedHandler != null && selectedHandler.GetWidget().queryPath.Contains(item.queryPath))
					{
						selectedWidget = selectedHandler;
					}
				}
			}
			ActivatePanel(m_SelectedPanel, selectedWidget);
		}

		private void Traverse(DebugUI.IContainer container, Transform parentTransform, DebugUIHandlerWidget parentUIHandler, ref DebugUIHandlerWidget selectedHandler)
		{
			DebugUIHandlerWidget debugUIHandlerWidget = null;
			for (int i = 0; i < container.children.Count; i++)
			{
				DebugUI.Widget widget = container.children[i];
				if (widget.isEditorOnly || widget.isHidden)
				{
					continue;
				}
				if (!m_PrefabsMap.TryGetValue(widget.GetType(), out var value))
				{
					Debug.LogWarning("DebugUI widget doesn't have a prefab: " + widget.GetType());
					continue;
				}
				GameObject gameObject = Object.Instantiate(value, parentTransform, worldPositionStays: false).gameObject;
				gameObject.name = widget.displayName;
				DebugUIHandlerWidget component = gameObject.GetComponent<DebugUIHandlerWidget>();
				if (component == null)
				{
					Debug.LogWarning("DebugUI prefab is missing a DebugUIHandler for: " + widget.GetType());
					continue;
				}
				if (!string.IsNullOrEmpty(m_CurrentQueryPath) && widget.queryPath.Equals(m_CurrentQueryPath))
				{
					selectedHandler = component;
				}
				if (debugUIHandlerWidget != null)
				{
					debugUIHandlerWidget.nextUIHandler = component;
				}
				component.previousUIHandler = debugUIHandlerWidget;
				debugUIHandlerWidget = component;
				component.parentUIHandler = parentUIHandler;
				component.SetWidget(widget);
				DebugUIHandlerContainer component2 = gameObject.GetComponent<DebugUIHandlerContainer>();
				if (component2 != null && widget is DebugUI.IContainer container2)
				{
					Traverse(container2, component2.contentHolder, component, ref selectedHandler);
				}
			}
		}

		private DebugUIHandlerWidget GetWidgetFromPath(string queryPath)
		{
			if (string.IsNullOrEmpty(queryPath))
			{
				return null;
			}
			return m_UIPanels[m_SelectedPanel].GetComponentsInChildren<DebugUIHandlerWidget>().FirstOrDefault((DebugUIHandlerWidget w) => w.GetWidget().queryPath == queryPath);
		}

		private void ActivatePanel(int index, DebugUIHandlerWidget selectedWidget = null)
		{
			if (m_UIPanels.Count != 0)
			{
				if (index >= m_UIPanels.Count)
				{
					index = m_UIPanels.Count - 1;
				}
				m_UIPanels.ForEach(delegate(DebugUIHandlerPanel p)
				{
					p.gameObject.SetActive(value: false);
				});
				m_UIPanels[index].gameObject.SetActive(value: true);
				m_SelectedPanel = index;
				if (selectedWidget == null)
				{
					selectedWidget = m_UIPanels[index].GetFirstItem();
				}
				ChangeSelection(selectedWidget, fromNext: true);
			}
		}

		internal void ChangeSelection(DebugUIHandlerWidget widget, bool fromNext)
		{
			if (widget == null)
			{
				return;
			}
			if (m_SelectedWidget != null)
			{
				m_SelectedWidget.OnDeselection();
			}
			DebugUIHandlerWidget selectedWidget = m_SelectedWidget;
			m_SelectedWidget = widget;
			SetScrollTarget(widget);
			if (!m_SelectedWidget.OnSelection(fromNext, selectedWidget))
			{
				if (fromNext)
				{
					SelectNextItem();
				}
				else
				{
					SelectPreviousItem();
				}
			}
			else if (m_SelectedWidget == null || m_SelectedWidget.GetWidget() == null)
			{
				m_CurrentQueryPath = string.Empty;
			}
			else
			{
				m_CurrentQueryPath = m_SelectedWidget.GetWidget().queryPath;
			}
		}

		internal void SelectPreviousItem()
		{
			if (!(m_SelectedWidget == null))
			{
				DebugUIHandlerWidget debugUIHandlerWidget = m_SelectedWidget.Previous();
				if (debugUIHandlerWidget != null)
				{
					ChangeSelection(debugUIHandlerWidget, fromNext: false);
				}
			}
		}

		internal void SelectNextPanel()
		{
			int num = m_SelectedPanel + 1;
			if (num >= m_UIPanels.Count)
			{
				num = 0;
			}
			num = Mathf.Clamp(num, 0, m_UIPanels.Count - 1);
			ActivatePanel(num);
		}

		internal void SelectPreviousPanel()
		{
			int num = m_SelectedPanel - 1;
			if (num < 0)
			{
				num = m_UIPanels.Count - 1;
			}
			num = Mathf.Clamp(num, 0, m_UIPanels.Count - 1);
			ActivatePanel(num);
		}

		internal void SelectNextItem()
		{
			if (!(m_SelectedWidget == null))
			{
				DebugUIHandlerWidget debugUIHandlerWidget = m_SelectedWidget.Next();
				if (debugUIHandlerWidget != null)
				{
					ChangeSelection(debugUIHandlerWidget, fromNext: true);
				}
			}
		}

		private void ChangeSelectionValue(float multiplier)
		{
			if (!(m_SelectedWidget == null))
			{
				bool fast = DebugManager.instance.GetAction(DebugAction.Multiplier) != 0f;
				if (multiplier < 0f)
				{
					m_SelectedWidget.OnDecrement(fast);
				}
				else
				{
					m_SelectedWidget.OnIncrement(fast);
				}
			}
		}

		private void ActivateSelection()
		{
			if (!(m_SelectedWidget == null))
			{
				m_SelectedWidget.OnAction();
			}
		}

		private void HandleInput()
		{
			if (DebugManager.instance.GetAction(DebugAction.PreviousDebugPanel) != 0f)
			{
				SelectPreviousPanel();
			}
			if (DebugManager.instance.GetAction(DebugAction.NextDebugPanel) != 0f)
			{
				SelectNextPanel();
			}
			if (DebugManager.instance.GetAction(DebugAction.Action) != 0f)
			{
				ActivateSelection();
			}
			if (DebugManager.instance.GetAction(DebugAction.MakePersistent) != 0f && m_SelectedWidget != null)
			{
				DebugManager.instance.TogglePersistent(m_SelectedWidget.GetWidget());
			}
			float action = DebugManager.instance.GetAction(DebugAction.MoveHorizontal);
			if (action != 0f)
			{
				ChangeSelectionValue(action);
			}
			float action2 = DebugManager.instance.GetAction(DebugAction.MoveVertical);
			if (action2 != 0f)
			{
				if (action2 < 0f)
				{
					SelectNextItem();
				}
				else
				{
					SelectPreviousItem();
				}
			}
		}

		internal void SetScrollTarget(DebugUIHandlerWidget widget)
		{
			if (m_UIPanels != null && m_SelectedPanel < m_UIPanels.Count && m_UIPanels[m_SelectedPanel] != null)
			{
				m_UIPanels[m_SelectedPanel].SetScrollTarget(widget);
			}
		}
	}
	public class DebugUIHandlerColor : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public UIFoldout valueToggle;

		public Image colorImage;

		public DebugUIHandlerIndirectFloatField fieldR;

		public DebugUIHandlerIndirectFloatField fieldG;

		public DebugUIHandlerIndirectFloatField fieldB;

		public DebugUIHandlerIndirectFloatField fieldA;

		private DebugUI.ColorField m_Field;

		private DebugUIHandlerContainer m_Container;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.ColorField>();
			m_Container = GetComponent<DebugUIHandlerContainer>();
			nameLabel.text = m_Field.displayName;
			fieldR.getter = () => m_Field.GetValue().r;
			fieldR.setter = delegate(float x)
			{
				SetValue(x, r: true);
			};
			fieldR.nextUIHandler = fieldG;
			SetupSettings(fieldR);
			fieldG.getter = () => m_Field.GetValue().g;
			fieldG.setter = delegate(float x)
			{
				SetValue(x, r: false, g: true);
			};
			fieldG.previousUIHandler = fieldR;
			fieldG.nextUIHandler = fieldB;
			SetupSettings(fieldG);
			fieldB.getter = () => m_Field.GetValue().b;
			fieldB.setter = delegate(float x)
			{
				SetValue(x, r: false, g: false, b: true);
			};
			fieldB.previousUIHandler = fieldG;
			fieldB.nextUIHandler = (m_Field.showAlpha ? fieldA : null);
			SetupSettings(fieldB);
			fieldA.gameObject.SetActive(m_Field.showAlpha);
			fieldA.getter = () => m_Field.GetValue().a;
			fieldA.setter = delegate(float x)
			{
				SetValue(x, r: false, g: false, b: false, a: true);
			};
			fieldA.previousUIHandler = fieldB;
			SetupSettings(fieldA);
			UpdateColor();
		}

		private void SetValue(float x, bool r = false, bool g = false, bool b = false, bool a = false)
		{
			Color value = m_Field.GetValue();
			if (r)
			{
				value.r = x;
			}
			if (g)
			{
				value.g = x;
			}
			if (b)
			{
				value.b = x;
			}
			if (a)
			{
				value.a = x;
			}
			m_Field.SetValue(value);
			UpdateColor();
		}

		private void SetupSettings(DebugUIHandlerIndirectFloatField field)
		{
			field.parentUIHandler = this;
			field.incStepGetter = () => m_Field.incStep;
			field.incStepMultGetter = () => m_Field.incStepMult;
			field.decimalsGetter = () => m_Field.decimals;
			field.Init();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			if (fromNext || !valueToggle.isOn)
			{
				nameLabel.color = colorSelected;
			}
			else if (valueToggle.isOn)
			{
				if (m_Container.IsDirectChild(previous))
				{
					nameLabel.color = colorSelected;
				}
				else
				{
					DebugUIHandlerWidget lastItem = m_Container.GetLastItem();
					DebugManager.instance.ChangeSelection(lastItem, fromNext: false);
				}
			}
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
		}

		public override void OnIncrement(bool fast)
		{
			valueToggle.isOn = true;
		}

		public override void OnDecrement(bool fast)
		{
			valueToggle.isOn = false;
		}

		public override void OnAction()
		{
			valueToggle.isOn = !valueToggle.isOn;
		}

		internal void UpdateColor()
		{
			if (colorImage != null)
			{
				colorImage.color = m_Field.GetValue();
			}
		}

		public override DebugUIHandlerWidget Next()
		{
			if (!valueToggle.isOn || m_Container == null)
			{
				return base.Next();
			}
			DebugUIHandlerWidget firstItem = m_Container.GetFirstItem();
			if (firstItem == null)
			{
				return base.Next();
			}
			return firstItem;
		}
	}
	public class DebugUIHandlerContainer : MonoBehaviour
	{
		[SerializeField]
		public RectTransform contentHolder;

		internal DebugUIHandlerWidget GetFirstItem()
		{
			if (contentHolder.childCount == 0)
			{
				return null;
			}
			List<DebugUIHandlerWidget> activeChildren = GetActiveChildren();
			if (activeChildren.Count == 0)
			{
				return null;
			}
			return activeChildren[0];
		}

		internal DebugUIHandlerWidget GetLastItem()
		{
			if (contentHolder.childCount == 0)
			{
				return null;
			}
			List<DebugUIHandlerWidget> activeChildren = GetActiveChildren();
			if (activeChildren.Count == 0)
			{
				return null;
			}
			return activeChildren[activeChildren.Count - 1];
		}

		internal bool IsDirectChild(DebugUIHandlerWidget widget)
		{
			if (contentHolder.childCount == 0)
			{
				return false;
			}
			return GetActiveChildren().Count((DebugUIHandlerWidget x) => x == widget) > 0;
		}

		private List<DebugUIHandlerWidget> GetActiveChildren()
		{
			List<DebugUIHandlerWidget> list = new List<DebugUIHandlerWidget>();
			foreach (Transform item in contentHolder)
			{
				if (item.gameObject.activeInHierarchy)
				{
					DebugUIHandlerWidget component = item.GetComponent<DebugUIHandlerWidget>();
					if (component != null)
					{
						list.Add(component);
					}
				}
			}
			return list;
		}
	}
	public class DebugUIHandlerEnumField : DebugUIHandlerField<DebugUI.EnumField>
	{
		public override void OnIncrement(bool fast)
		{
			if (m_Field.enumValues.Length == 0)
			{
				return;
			}
			int[] enumValues = m_Field.enumValues;
			int currentIndex = m_Field.currentIndex;
			if (currentIndex == enumValues.Length - 1)
			{
				currentIndex = 0;
			}
			else if (fast)
			{
				int[] quickSeparators = m_Field.quickSeparators;
				if (quickSeparators == null)
				{
					m_Field.InitQuickSeparators();
					quickSeparators = m_Field.quickSeparators;
				}
				int i;
				for (i = 0; i < quickSeparators.Length && currentIndex + 1 > quickSeparators[i]; i++)
				{
				}
				currentIndex = ((i != quickSeparators.Length) ? quickSeparators[i] : 0);
			}
			else
			{
				currentIndex++;
			}
			m_Field.SetValue(enumValues[currentIndex]);
			m_Field.currentIndex = currentIndex;
			UpdateValueLabel();
		}

		public override void OnDecrement(bool fast)
		{
			if (m_Field.enumValues.Length == 0)
			{
				return;
			}
			int[] enumValues = m_Field.enumValues;
			int currentIndex = m_Field.currentIndex;
			if (currentIndex == 0)
			{
				if (fast)
				{
					int[] quickSeparators = m_Field.quickSeparators;
					if (quickSeparators == null)
					{
						m_Field.InitQuickSeparators();
						quickSeparators = m_Field.quickSeparators;
					}
					currentIndex = quickSeparators[^1];
				}
				else
				{
					currentIndex = enumValues.Length - 1;
				}
			}
			else if (fast)
			{
				int[] quickSeparators2 = m_Field.quickSeparators;
				if (quickSeparators2 == null)
				{
					m_Field.InitQuickSeparators();
					quickSeparators2 = m_Field.quickSeparators;
				}
				int num = quickSeparators2.Length - 1;
				while (num > 0 && currentIndex <= quickSeparators2[num])
				{
					num--;
				}
				currentIndex = quickSeparators2[num];
			}
			else
			{
				currentIndex--;
			}
			m_Field.SetValue(enumValues[currentIndex]);
			m_Field.currentIndex = currentIndex;
			UpdateValueLabel();
		}

		public override void UpdateValueLabel()
		{
			int num = m_Field.currentIndex;
			if (num < 0)
			{
				num = 0;
			}
			SetLabelText(m_Field.enumNames[num].text);
		}
	}
	public class DebugUIHandlerEnumHistory : DebugUIHandlerEnumField
	{
		private Text[] historyValues;

		private const float k_XOffset = 230f;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			int num = (widget as DebugUI.HistoryEnumField)?.historyDepth ?? 0;
			historyValues = new Text[num];
			float num2 = ((num > 0) ? (230f / (float)num) : 0f);
			for (int i = 0; i < num; i++)
			{
				Text text = Object.Instantiate(valueLabel, base.transform);
				Vector3 position = text.transform.position;
				position.x += (float)(i + 1) * num2;
				text.transform.position = position;
				Text component = text.GetComponent<Text>();
				component.color = new Color32(110, 110, 110, byte.MaxValue);
				historyValues[i] = component;
			}
			base.SetWidget(widget);
		}

		public override void UpdateValueLabel()
		{
			int num = m_Field.currentIndex;
			if (num < 0)
			{
				num = 0;
			}
			valueLabel.text = m_Field.enumNames[num].text;
			DebugUI.HistoryEnumField historyEnumField = m_Field as DebugUI.HistoryEnumField;
			int num2 = historyEnumField?.historyDepth ?? 0;
			for (int i = 0; i < num2; i++)
			{
				if (i < historyValues.Length && historyValues[i] != null)
				{
					historyValues[i].text = historyEnumField.enumNames[historyEnumField.GetHistoryValue(i)].text;
				}
			}
			if (base.isActiveAndEnabled)
			{
				StartCoroutine(RefreshAfterSanitization());
			}
		}

		private IEnumerator RefreshAfterSanitization()
		{
			yield return null;
			m_Field.currentIndex = m_Field.getIndex();
			valueLabel.text = m_Field.enumNames[m_Field.currentIndex].text;
		}
	}
	public abstract class DebugUIHandlerField<T> : DebugUIHandlerWidget where T : DebugUI.Widget
	{
		public Text nextButtonText;

		public Text previousButtonText;

		public Text nameLabel;

		public Text valueLabel;

		protected internal T m_Field;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<T>();
			nameLabel.text = m_Field.displayName;
			UpdateValueLabel();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			if (nextButtonText != null)
			{
				nextButtonText.color = colorSelected;
			}
			if (previousButtonText != null)
			{
				previousButtonText.color = colorSelected;
			}
			nameLabel.color = colorSelected;
			valueLabel.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			if (nextButtonText != null)
			{
				nextButtonText.color = colorDefault;
			}
			if (previousButtonText != null)
			{
				previousButtonText.color = colorDefault;
			}
			nameLabel.color = colorDefault;
			valueLabel.color = colorDefault;
		}

		public override void OnAction()
		{
			OnIncrement(fast: false);
		}

		public abstract void UpdateValueLabel();

		protected void SetLabelText(string text)
		{
			if (text.Length > 26)
			{
				text = text.Substring(0, 23) + "...";
			}
			valueLabel.text = text;
		}
	}
	public class DebugUIHandlerFloatField : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public Text valueLabel;

		private DebugUI.FloatField m_Field;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.FloatField>();
			nameLabel.text = m_Field.displayName;
			UpdateValueLabel();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			nameLabel.color = colorSelected;
			valueLabel.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
			valueLabel.color = colorDefault;
		}

		public override void OnIncrement(bool fast)
		{
			ChangeValue(fast, 1f);
		}

		public override void OnDecrement(bool fast)
		{
			ChangeValue(fast, -1f);
		}

		private void ChangeValue(bool fast, float multiplier)
		{
			float value = m_Field.GetValue();
			value += m_Field.incStep * (fast ? m_Field.incStepMult : 1f) * multiplier;
			m_Field.SetValue(value);
			UpdateValueLabel();
		}

		private void UpdateValueLabel()
		{
			valueLabel.text = m_Field.GetValue().ToString("N" + m_Field.decimals);
		}
	}
	public class DebugUIHandlerFoldout : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public UIFoldout valueToggle;

		private DebugUI.Foldout m_Field;

		private DebugUIHandlerContainer m_Container;

		private const float k_FoldoutXOffset = 215f;

		private const float k_XOffset = 230f;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.Foldout>();
			m_Container = GetComponent<DebugUIHandlerContainer>();
			nameLabel.text = m_Field.displayName;
			string[] columnLabels = m_Field.columnLabels;
			int num = ((columnLabels != null) ? columnLabels.Length : 0);
			float num2 = ((num > 0) ? (230f / (float)num) : 0f);
			for (int i = 0; i < num; i++)
			{
				GameObject obj = Object.Instantiate(nameLabel.gameObject, GetComponent<DebugUIHandlerContainer>().contentHolder);
				obj.AddComponent<LayoutElement>().ignoreLayout = true;
				RectTransform obj2 = obj.transform as RectTransform;
				RectTransform rectTransform = nameLabel.transform as RectTransform;
				Vector2 anchorMax = (obj2.anchorMin = new Vector2(0f, 1f));
				obj2.anchorMax = anchorMax;
				obj2.sizeDelta = new Vector2(100f, 26f);
				Vector3 vector2 = rectTransform.anchoredPosition;
				vector2.x += (float)(i + 1) * num2 + 215f;
				obj2.anchoredPosition = vector2;
				obj2.pivot = new Vector2(0f, 0.5f);
				obj2.eulerAngles = new Vector3(0f, 0f, 13f);
				Text component = obj.GetComponent<Text>();
				component.fontSize = 15;
				component.text = m_Field.columnLabels[i];
			}
			UpdateValue();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			if (fromNext || !valueToggle.isOn)
			{
				nameLabel.color = colorSelected;
			}
			else if (valueToggle.isOn)
			{
				if (m_Container.IsDirectChild(previous))
				{
					nameLabel.color = colorSelected;
				}
				else
				{
					DebugUIHandlerWidget lastItem = m_Container.GetLastItem();
					DebugManager.instance.ChangeSelection(lastItem, fromNext: false);
				}
			}
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
		}

		public override void OnIncrement(bool fast)
		{
			m_Field.SetValue(value: true);
			UpdateValue();
		}

		public override void OnDecrement(bool fast)
		{
			m_Field.SetValue(value: false);
			UpdateValue();
		}

		public override void OnAction()
		{
			bool value = !m_Field.GetValue();
			m_Field.SetValue(value);
			UpdateValue();
		}

		private void UpdateValue()
		{
			valueToggle.isOn = m_Field.GetValue();
		}

		public override DebugUIHandlerWidget Next()
		{
			if (!m_Field.GetValue() || m_Container == null)
			{
				return base.Next();
			}
			DebugUIHandlerWidget firstItem = m_Container.GetFirstItem();
			if (firstItem == null)
			{
				return base.Next();
			}
			return firstItem;
		}
	}
	public class DebugUIHandlerGroup : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public Transform header;

		private DebugUI.Container m_Field;

		private DebugUIHandlerContainer m_Container;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.Container>();
			m_Container = GetComponent<DebugUIHandlerContainer>();
			if (m_Field.hideDisplayName)
			{
				header.gameObject.SetActive(value: false);
			}
			else
			{
				nameLabel.text = m_Field.displayName;
			}
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			if (!fromNext && !m_Container.IsDirectChild(previous))
			{
				DebugUIHandlerWidget lastItem = m_Container.GetLastItem();
				DebugManager.instance.ChangeSelection(lastItem, fromNext: false);
				return true;
			}
			return false;
		}

		public override DebugUIHandlerWidget Next()
		{
			if (m_Container == null)
			{
				return base.Next();
			}
			DebugUIHandlerWidget firstItem = m_Container.GetFirstItem();
			if (firstItem == null)
			{
				return base.Next();
			}
			return firstItem;
		}
	}
	public class DebugUIHandlerHBox : DebugUIHandlerWidget
	{
		private DebugUIHandlerContainer m_Container;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Container = GetComponent<DebugUIHandlerContainer>();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			if (!fromNext && !m_Container.IsDirectChild(previous))
			{
				DebugUIHandlerWidget lastItem = m_Container.GetLastItem();
				DebugManager.instance.ChangeSelection(lastItem, fromNext: false);
				return true;
			}
			return false;
		}

		public override DebugUIHandlerWidget Next()
		{
			if (m_Container == null)
			{
				return base.Next();
			}
			DebugUIHandlerWidget firstItem = m_Container.GetFirstItem();
			if (firstItem == null)
			{
				return base.Next();
			}
			return firstItem;
		}
	}
	public class DebugUIHandlerIndirectFloatField : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public Text valueLabel;

		public Func<float> getter;

		public Action<float> setter;

		public Func<float> incStepGetter;

		public Func<float> incStepMultGetter;

		public Func<float> decimalsGetter;

		public void Init()
		{
			UpdateValueLabel();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			nameLabel.color = colorSelected;
			valueLabel.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
			valueLabel.color = colorDefault;
		}

		public override void OnIncrement(bool fast)
		{
			ChangeValue(fast, 1f);
		}

		public override void OnDecrement(bool fast)
		{
			ChangeValue(fast, -1f);
		}

		private void ChangeValue(bool fast, float multiplier)
		{
			float num = getter();
			num += incStepGetter() * (fast ? incStepMultGetter() : 1f) * multiplier;
			setter(num);
			UpdateValueLabel();
		}

		private void UpdateValueLabel()
		{
			if (valueLabel != null)
			{
				valueLabel.text = getter().ToString("N" + decimalsGetter());
			}
		}
	}
	public class DebugUIHandlerIndirectToggle : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public Toggle valueToggle;

		public Image checkmarkImage;

		public Func<int, bool> getter;

		public Action<int, bool> setter;

		internal int index;

		public void Init()
		{
			UpdateValueLabel();
			valueToggle.onValueChanged.AddListener(OnToggleValueChanged);
		}

		private void OnToggleValueChanged(bool value)
		{
			setter(index, value);
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			nameLabel.color = colorSelected;
			checkmarkImage.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
			checkmarkImage.color = colorDefault;
		}

		public override void OnAction()
		{
			bool arg = !getter(index);
			setter(index, arg);
			UpdateValueLabel();
		}

		internal void UpdateValueLabel()
		{
			if (valueToggle != null)
			{
				valueToggle.isOn = getter(index);
			}
		}
	}
	public class DebugUIHandlerIntField : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public Text valueLabel;

		private DebugUI.IntField m_Field;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.IntField>();
			nameLabel.text = m_Field.displayName;
			UpdateValueLabel();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			nameLabel.color = colorSelected;
			valueLabel.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
			valueLabel.color = colorDefault;
		}

		public override void OnIncrement(bool fast)
		{
			ChangeValue(fast, 1);
		}

		public override void OnDecrement(bool fast)
		{
			ChangeValue(fast, -1);
		}

		private void ChangeValue(bool fast, int multiplier)
		{
			int value = m_Field.GetValue();
			value += m_Field.incStep * ((!fast) ? 1 : m_Field.intStepMult) * multiplier;
			m_Field.SetValue(value);
			UpdateValueLabel();
		}

		private void UpdateValueLabel()
		{
			if (valueLabel != null)
			{
				valueLabel.text = m_Field.GetValue().ToString("N0");
			}
		}
	}
	public class DebugUIHandlerMessageBox : DebugUIHandlerWidget
	{
		public Text nameLabel;

		private DebugUI.MessageBox m_Field;

		private static Color32 k_WarningBackgroundColor = new Color32(231, 180, 3, 30);

		private static Color32 k_WarningTextColor = new Color32(231, 180, 3, byte.MaxValue);

		private static Color32 k_ErrorBackgroundColor = new Color32(231, 75, 3, 30);

		private static Color32 k_ErrorTextColor = new Color32(231, 75, 3, byte.MaxValue);

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.MessageBox>();
			nameLabel.text = m_Field.displayName;
			Image component = GetComponent<Image>();
			switch (m_Field.style)
			{
			case DebugUI.MessageBox.Style.Warning:
				component.color = k_WarningBackgroundColor;
				break;
			case DebugUI.MessageBox.Style.Error:
				component.color = k_ErrorBackgroundColor;
				break;
			}
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			return false;
		}
	}
	public class DebugUIHandlerObject : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public Text valueLabel;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			DebugUI.ObjectField objectField = CastWidget<DebugUI.ObjectField>();
			nameLabel.text = objectField.displayName;
			valueLabel.text = objectField.GetValue().name;
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			nameLabel.color = colorSelected;
			valueLabel.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
			valueLabel.color = colorDefault;
		}
	}
	public class DebugUIHandlerObjectList : DebugUIHandlerField<DebugUI.ObjectListField>
	{
		private int m_Index;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Index = 0;
		}

		public override void OnIncrement(bool fast)
		{
			m_Index++;
			UpdateValueLabel();
		}

		public override void OnDecrement(bool fast)
		{
			m_Index--;
			UpdateValueLabel();
		}

		public override void UpdateValueLabel()
		{
			string labelText = "Empty";
			Object[] value = m_Field.GetValue();
			if (value != null)
			{
				m_Index = Math.Clamp(m_Index, 0, value.Length - 1);
				labelText = value[m_Index].name;
			}
			SetLabelText(labelText);
		}
	}
	public class DebugUIHandlerObjectPopupField : DebugUIHandlerField<DebugUI.ObjectPopupField>
	{
		private int m_Index;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Index = 0;
		}

		private void ChangeSelectedObject()
		{
			if (m_Field == null)
			{
				return;
			}
			IEnumerable<Object> enumerable = m_Field.getObjects();
			if (enumerable != null)
			{
				Object[] array = enumerable.ToArray();
				int num = array.Count();
				if (m_Index >= num)
				{
					m_Index = 0;
				}
				else if (m_Index < 0)
				{
					m_Index = num - 1;
				}
				Object value = array[m_Index];
				m_Field.SetValue(value);
				UpdateValueLabel();
			}
		}

		public override void OnIncrement(bool fast)
		{
			m_Index++;
			ChangeSelectedObject();
		}

		public override void OnDecrement(bool fast)
		{
			m_Index--;
			ChangeSelectedObject();
		}

		public override void UpdateValueLabel()
		{
			Object value = m_Field.GetValue();
			string labelText = ((value != null) ? value.name : "Empty");
			SetLabelText(labelText);
		}
	}
	public class DebugUIHandlerPanel : MonoBehaviour
	{
		public Text nameLabel;

		public ScrollRect scrollRect;

		public RectTransform viewport;

		public DebugUIHandlerCanvas Canvas;

		private RectTransform m_ScrollTransform;

		private RectTransform m_ContentTransform;

		private RectTransform m_MaskTransform;

		private DebugUIHandlerWidget m_ScrollTarget;

		protected internal DebugUI.Panel m_Panel;

		private void OnEnable()
		{
			m_ScrollTransform = scrollRect.GetComponent<RectTransform>();
			m_ContentTransform = GetComponent<DebugUIHandlerContainer>().contentHolder;
			m_MaskTransform = GetComponentInChildren<Mask>(includeInactive: true).rectTransform;
		}

		internal void SetPanel(DebugUI.Panel panel)
		{
			m_Panel = panel;
			nameLabel.text = panel.displayName;
		}

		internal DebugUI.Panel GetPanel()
		{
			return m_Panel;
		}

		public void SelectNextItem()
		{
			Canvas.SelectNextPanel();
		}

		public void SelectPreviousItem()
		{
			Canvas.SelectPreviousPanel();
		}

		public void OnScrollbarClicked()
		{
			DebugManager.instance.SetScrollTarget(null);
		}

		internal void SetScrollTarget(DebugUIHandlerWidget target)
		{
			m_ScrollTarget = target;
		}

		internal void UpdateScroll()
		{
			if (!(m_ScrollTarget == null))
			{
				RectTransform component = m_ScrollTarget.GetComponent<RectTransform>();
				float yPosInScroll = GetYPosInScroll(component);
				float num = (GetYPosInScroll(m_MaskTransform) - yPosInScroll) / (m_ContentTransform.rect.size.y - m_ScrollTransform.rect.size.y);
				float value = scrollRect.verticalNormalizedPosition - num;
				value = Mathf.Clamp01(value);
				scrollRect.verticalNormalizedPosition = Mathf.Lerp(scrollRect.verticalNormalizedPosition, value, Time.deltaTime * 10f);
			}
		}

		private float GetYPosInScroll(RectTransform target)
		{
			Vector3 vector = new Vector3((0.5f - target.pivot.x) * target.rect.size.x, (0.5f - target.pivot.y) * target.rect.size.y, 0f);
			Vector3 position = target.localPosition + vector;
			Vector3 position2 = target.parent.TransformPoint(position);
			return m_ScrollTransform.TransformPoint(position2).y;
		}

		internal DebugUIHandlerWidget GetFirstItem()
		{
			return GetComponent<DebugUIHandlerContainer>().GetFirstItem();
		}

		public void ResetDebugManager()
		{
			DebugManager.instance.Reset();
		}
	}
	internal class DebugUIHandlerPersistentCanvas : MonoBehaviour
	{
		public RectTransform panel;

		public RectTransform valuePrefab;

		private List<DebugUIHandlerValue> m_Items = new List<DebugUIHandlerValue>();

		private List<DebugUI.ValueTuple> m_ValueTupleWidgets = new List<DebugUI.ValueTuple>();

		internal void Toggle(DebugUI.Value widget, string displayName = null)
		{
			int num = m_Items.FindIndex((DebugUIHandlerValue x) => x.GetWidget() == widget);
			if (num > -1)
			{
				CoreUtils.Destroy(m_Items[num].gameObject);
				m_Items.RemoveAt(num);
				return;
			}
			DebugUIHandlerValue component = Object.Instantiate(valuePrefab, panel, worldPositionStays: false).gameObject.GetComponent<DebugUIHandlerValue>();
			component.SetWidget(widget);
			component.nameLabel.text = (string.IsNullOrEmpty(displayName) ? widget.displayName : displayName);
			m_Items.Add(component);
		}

		internal void Toggle(DebugUI.ValueTuple widget, int? forceTupleIndex = null)
		{
			DebugUI.ValueTuple valueTuple = m_ValueTupleWidgets.Find((DebugUI.ValueTuple x) => x == widget);
			int num = valueTuple?.pinnedElementIndex ?? (-1);
			if (valueTuple != null)
			{
				m_ValueTupleWidgets.Remove(valueTuple);
				Toggle(widget.values[num]);
			}
			if (forceTupleIndex.HasValue)
			{
				num = forceTupleIndex.Value;
			}
			if (num + 1 < widget.numElements)
			{
				widget.pinnedElementIndex = num + 1;
				string text = widget.displayName;
				if (widget.parent is DebugUI.Foldout)
				{
					string[] columnLabels = (widget.parent as DebugUI.Foldout).columnLabels;
					if (columnLabels != null && widget.pinnedElementIndex < columnLabels.Length)
					{
						text = text + " (" + columnLabels[widget.pinnedElementIndex] + ")";
					}
				}
				Toggle(widget.values[widget.pinnedElementIndex], text);
				m_ValueTupleWidgets.Add(widget);
			}
			else
			{
				widget.pinnedElementIndex = -1;
			}
		}

		internal bool IsEmpty()
		{
			return m_Items.Count == 0;
		}

		internal void Clear()
		{
			foreach (DebugUIHandlerValue item in m_Items)
			{
				CoreUtils.Destroy(item.gameObject);
			}
			m_Items.Clear();
		}
	}
	public class DebugUIHandlerProgressBar : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public Text valueLabel;

		public RectTransform progressBarRect;

		private DebugUI.ProgressBarValue m_Value;

		private float m_Timer;

		protected override void OnEnable()
		{
			m_Timer = 0f;
		}

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Value = CastWidget<DebugUI.ProgressBarValue>();
			nameLabel.text = m_Value.displayName;
			UpdateValue();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			nameLabel.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
		}

		private void Update()
		{
			if (m_Timer >= m_Value.refreshRate)
			{
				UpdateValue();
				m_Timer -= m_Value.refreshRate;
			}
			m_Timer += Time.deltaTime;
		}

		private void UpdateValue()
		{
			float num = (float)m_Value.GetValue();
			valueLabel.text = m_Value.FormatString(num);
			Vector3 localScale = progressBarRect.localScale;
			localScale.x = num;
			progressBarRect.localScale = localScale;
		}
	}
	public class DebugUIHandlerRow : DebugUIHandlerFoldout
	{
		private float m_Timer;

		protected override void OnEnable()
		{
			m_Timer = 0f;
		}

		private GameObject GetChild(int index)
		{
			if (index < 0)
			{
				return null;
			}
			if (base.gameObject.transform != null)
			{
				Transform child = base.gameObject.transform.GetChild(1);
				if (child != null && child.childCount > index)
				{
					return child.GetChild(index).gameObject;
				}
			}
			return null;
		}

		private bool TryGetChild(int index, out GameObject child)
		{
			child = GetChild(index);
			return child != null;
		}

		private bool IsActive(DebugUI.Table table, int index, GameObject child)
		{
			if (!table.GetColumnVisibility(index))
			{
				return false;
			}
			Transform transform = child.transform.Find("Value");
			if (transform != null && transform.TryGetComponent<Text>(out var component))
			{
				return !string.IsNullOrEmpty(component.text);
			}
			return true;
		}

		protected void Update()
		{
			DebugUI.Table.Row row = CastWidget<DebugUI.Table.Row>();
			DebugUI.Table table = row.parent as DebugUI.Table;
			float num = 0.1f;
			bool flag = m_Timer >= num;
			if (flag)
			{
				m_Timer -= num;
			}
			m_Timer += Time.deltaTime;
			for (int i = 0; i < row.children.Count; i++)
			{
				if (!TryGetChild(i, out var child))
				{
					continue;
				}
				bool flag2 = IsActive(table, i, child);
				if (child != null)
				{
					child.SetActive(flag2);
				}
				if (flag2 && flag)
				{
					if (child.TryGetComponent<DebugUIHandlerColor>(out var component))
					{
						component.UpdateColor();
					}
					if (child.TryGetComponent<DebugUIHandlerToggle>(out var component2))
					{
						component2.UpdateValueLabel();
					}
					if (child.TryGetComponent<DebugUIHandlerObjectList>(out var component3))
					{
						component3.UpdateValueLabel();
					}
				}
			}
			DebugUIHandlerWidget debugUIHandlerWidget = GetChild(0).GetComponent<DebugUIHandlerWidget>();
			DebugUIHandlerWidget debugUIHandlerWidget2 = null;
			for (int j = 0; j < row.children.Count; j++)
			{
				debugUIHandlerWidget.previousUIHandler = debugUIHandlerWidget2;
				if (!TryGetChild(j, out var child2))
				{
					continue;
				}
				if (IsActive(table, j, child2))
				{
					debugUIHandlerWidget2 = debugUIHandlerWidget;
				}
				bool flag3 = false;
				for (int k = j + 1; k < row.children.Count; k++)
				{
					if (TryGetChild(k, out var child3) && IsActive(table, k, child3))
					{
						DebugUIHandlerWidget debugUIHandlerWidget3 = (debugUIHandlerWidget.nextUIHandler = child2.GetComponent<DebugUIHandlerWidget>());
						debugUIHandlerWidget = debugUIHandlerWidget3;
						j = k - 1;
						flag3 = true;
						break;
					}
				}
				if (!flag3)
				{
					debugUIHandlerWidget.nextUIHandler = null;
					break;
				}
			}
		}
	}
	public class DebugUIHandlerToggle : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public Toggle valueToggle;

		public Image checkmarkImage;

		protected internal DebugUI.BoolField m_Field;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.BoolField>();
			nameLabel.text = m_Field.displayName;
			UpdateValueLabel();
			valueToggle.onValueChanged.AddListener(OnToggleValueChanged);
		}

		private void OnToggleValueChanged(bool value)
		{
			m_Field.SetValue(value);
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			nameLabel.color = colorSelected;
			checkmarkImage.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
			checkmarkImage.color = colorDefault;
		}

		public override void OnAction()
		{
			bool value = !m_Field.GetValue();
			m_Field.SetValue(value);
			UpdateValueLabel();
		}

		protected internal virtual void UpdateValueLabel()
		{
			if (valueToggle != null)
			{
				valueToggle.isOn = m_Field.GetValue();
			}
		}
	}
	public class DebugUIHandlerToggleHistory : DebugUIHandlerToggle
	{
		private Toggle[] historyToggles;

		private const float k_XOffset = 230f;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			int num = (widget as DebugUI.HistoryBoolField)?.historyDepth ?? 0;
			historyToggles = new Toggle[num];
			float num2 = ((num > 0) ? (230f / (float)num) : 0f);
			for (int i = 0; i < num; i++)
			{
				Toggle toggle = Object.Instantiate(valueToggle, base.transform);
				Vector3 position = toggle.transform.position;
				position.x += (float)(i + 1) * num2;
				toggle.transform.position = position;
				Image component = toggle.transform.GetChild(0).GetComponent<Image>();
				component.sprite = Sprite.Create(Texture2D.whiteTexture, new Rect(-1f, -1f, 2f, 2f), Vector2.zero);
				component.color = new Color32(50, 50, 50, 120);
				component.transform.GetChild(0).GetComponent<Image>().color = new Color32(110, 110, 110, byte.MaxValue);
				historyToggles[i] = toggle.GetComponent<Toggle>();
			}
			base.SetWidget(widget);
		}

		protected internal override void UpdateValueLabel()
		{
			base.UpdateValueLabel();
			DebugUI.HistoryBoolField historyBoolField = m_Field as DebugUI.HistoryBoolField;
			int num = historyBoolField?.historyDepth ?? 0;
			for (int i = 0; i < num; i++)
			{
				if (i < historyToggles.Length && historyToggles[i] != null)
				{
					historyToggles[i].isOn = historyBoolField.GetHistoryValue(i);
				}
			}
			if (base.isActiveAndEnabled)
			{
				StartCoroutine(RefreshAfterSanitization());
			}
		}

		private IEnumerator RefreshAfterSanitization()
		{
			yield return null;
			valueToggle.isOn = m_Field.getter();
		}
	}
	public class DebugUIHandlerUIntField : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public Text valueLabel;

		private DebugUI.UIntField m_Field;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.UIntField>();
			nameLabel.text = m_Field.displayName;
			UpdateValueLabel();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			nameLabel.color = colorSelected;
			valueLabel.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
			valueLabel.color = colorDefault;
		}

		public override void OnIncrement(bool fast)
		{
			ChangeValue(fast, 1);
		}

		public override void OnDecrement(bool fast)
		{
			ChangeValue(fast, -1);
		}

		private void ChangeValue(bool fast, int multiplier)
		{
			long num = m_Field.GetValue();
			if (num != 0L || multiplier >= 0)
			{
				num += m_Field.incStep * ((!fast) ? 1 : m_Field.intStepMult) * multiplier;
				m_Field.SetValue((uint)num);
				UpdateValueLabel();
			}
		}

		private void UpdateValueLabel()
		{
			if (valueLabel != null)
			{
				valueLabel.text = m_Field.GetValue().ToString("N0");
			}
		}
	}
	public class DebugUIHandlerValue : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public Text valueLabel;

		private DebugUI.Value m_Field;

		protected internal float m_Timer;

		private static readonly Color k_ZeroColor = Color.gray;

		protected override void OnEnable()
		{
			m_Timer = 0f;
		}

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.Value>();
			nameLabel.text = m_Field.displayName;
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			nameLabel.color = colorSelected;
			valueLabel.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
			valueLabel.color = colorDefault;
		}

		private void Update()
		{
			if (m_Timer >= m_Field.refreshRate)
			{
				object value = m_Field.GetValue();
				valueLabel.text = m_Field.FormatString(value);
				if (value is float)
				{
					valueLabel.color = (((float)value == 0f) ? k_ZeroColor : colorDefault);
				}
				m_Timer -= m_Field.refreshRate;
			}
			m_Timer += Time.deltaTime;
		}
	}
	public class DebugUIHandlerValueTuple : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public Text valueLabel;

		protected internal DebugUI.ValueTuple m_Field;

		protected internal Text[] valueElements;

		private const float k_XOffset = 230f;

		private float m_Timer;

		private static readonly Color k_ZeroColor = Color.gray;

		protected override void OnEnable()
		{
			m_Timer = 0f;
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			nameLabel.color = colorSelected;
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
		}

		internal override void SetWidget(DebugUI.Widget widget)
		{
			m_Widget = widget;
			m_Field = CastWidget<DebugUI.ValueTuple>();
			nameLabel.text = m_Field.displayName;
			Debug.Assert(m_Field.numElements > 0);
			int numElements = m_Field.numElements;
			valueElements = new Text[numElements];
			valueElements[0] = valueLabel;
			float num = 230f / (float)numElements;
			for (int i = 1; i < numElements; i++)
			{
				GameObject gameObject = Object.Instantiate(valueLabel.gameObject, base.transform);
				gameObject.AddComponent<LayoutElement>().ignoreLayout = true;
				RectTransform obj = gameObject.transform as RectTransform;
				RectTransform rectTransform = nameLabel.transform as RectTransform;
				Vector2 anchorMax = (obj.anchorMin = new Vector2(0f, 1f));
				obj.anchorMax = anchorMax;
				obj.sizeDelta = new Vector2(100f, 26f);
				Vector3 vector2 = rectTransform.anchoredPosition;
				vector2.x += (float)(i + 1) * num + 200f;
				obj.anchoredPosition = vector2;
				obj.pivot = new Vector2(0f, 1f);
				valueElements[i] = gameObject.GetComponent<Text>();
			}
		}

		internal virtual void UpdateValueLabels()
		{
			for (int i = 0; i < m_Field.numElements; i++)
			{
				if (i < valueElements.Length && valueElements[i] != null)
				{
					object value = m_Field.values[i].GetValue();
					valueElements[i].text = m_Field.values[i].FormatString(value);
					if (value is float)
					{
						valueElements[i].color = (((float)value == 0f) ? k_ZeroColor : colorDefault);
					}
				}
			}
		}

		private void Update()
		{
			if (m_Field != null && m_Timer >= m_Field.refreshRate)
			{
				UpdateValueLabels();
				m_Timer -= m_Field.refreshRate;
			}
			m_Timer += Time.deltaTime;
		}
	}
	public class DebugUIHandlerVBox : DebugUIHandlerWidget
	{
		private DebugUIHandlerContainer m_Container;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Container = GetComponent<DebugUIHandlerContainer>();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			if (!fromNext && !m_Container.IsDirectChild(previous))
			{
				DebugUIHandlerWidget lastItem = m_Container.GetLastItem();
				DebugManager.instance.ChangeSelection(lastItem, fromNext: false);
				return true;
			}
			return false;
		}

		public override DebugUIHandlerWidget Next()
		{
			if (m_Container == null)
			{
				return base.Next();
			}
			DebugUIHandlerWidget firstItem = m_Container.GetFirstItem();
			if (firstItem == null)
			{
				return base.Next();
			}
			return firstItem;
		}
	}
	public class DebugUIHandlerVector2 : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public UIFoldout valueToggle;

		public DebugUIHandlerIndirectFloatField fieldX;

		public DebugUIHandlerIndirectFloatField fieldY;

		private DebugUI.Vector2Field m_Field;

		private DebugUIHandlerContainer m_Container;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.Vector2Field>();
			m_Container = GetComponent<DebugUIHandlerContainer>();
			nameLabel.text = m_Field.displayName;
			fieldX.getter = () => m_Field.GetValue().x;
			fieldX.setter = delegate(float x)
			{
				SetValue(x, x: true);
			};
			fieldX.nextUIHandler = fieldY;
			SetupSettings(fieldX);
			fieldY.getter = () => m_Field.GetValue().y;
			fieldY.setter = delegate(float x)
			{
				SetValue(x, x: false, y: true);
			};
			fieldY.previousUIHandler = fieldX;
			SetupSettings(fieldY);
		}

		private void SetValue(float v, bool x = false, bool y = false)
		{
			Vector2 value = m_Field.GetValue();
			if (x)
			{
				value.x = v;
			}
			if (y)
			{
				value.y = v;
			}
			m_Field.SetValue(value);
		}

		private void SetupSettings(DebugUIHandlerIndirectFloatField field)
		{
			field.parentUIHandler = this;
			field.incStepGetter = () => m_Field.incStep;
			field.incStepMultGetter = () => m_Field.incStepMult;
			field.decimalsGetter = () => m_Field.decimals;
			field.Init();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			if (fromNext || !valueToggle.isOn)
			{
				nameLabel.color = colorSelected;
			}
			else if (valueToggle.isOn)
			{
				if (m_Container.IsDirectChild(previous))
				{
					nameLabel.color = colorSelected;
				}
				else
				{
					DebugUIHandlerWidget lastItem = m_Container.GetLastItem();
					DebugManager.instance.ChangeSelection(lastItem, fromNext: false);
				}
			}
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
		}

		public override void OnIncrement(bool fast)
		{
			valueToggle.isOn = true;
		}

		public override void OnDecrement(bool fast)
		{
			valueToggle.isOn = false;
		}

		public override void OnAction()
		{
			valueToggle.isOn = !valueToggle.isOn;
		}

		public override DebugUIHandlerWidget Next()
		{
			if (!valueToggle.isOn || m_Container == null)
			{
				return base.Next();
			}
			DebugUIHandlerWidget firstItem = m_Container.GetFirstItem();
			if (firstItem == null)
			{
				return base.Next();
			}
			return firstItem;
		}
	}
	public class DebugUIHandlerVector3 : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public UIFoldout valueToggle;

		public DebugUIHandlerIndirectFloatField fieldX;

		public DebugUIHandlerIndirectFloatField fieldY;

		public DebugUIHandlerIndirectFloatField fieldZ;

		private DebugUI.Vector3Field m_Field;

		private DebugUIHandlerContainer m_Container;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.Vector3Field>();
			m_Container = GetComponent<DebugUIHandlerContainer>();
			nameLabel.text = m_Field.displayName;
			fieldX.getter = () => m_Field.GetValue().x;
			fieldX.setter = delegate(float v)
			{
				SetValue(v, x: true);
			};
			fieldX.nextUIHandler = fieldY;
			SetupSettings(fieldX);
			fieldY.getter = () => m_Field.GetValue().y;
			fieldY.setter = delegate(float v)
			{
				SetValue(v, x: false, y: true);
			};
			fieldY.previousUIHandler = fieldX;
			fieldY.nextUIHandler = fieldZ;
			SetupSettings(fieldY);
			fieldZ.getter = () => m_Field.GetValue().z;
			fieldZ.setter = delegate(float v)
			{
				SetValue(v, x: false, y: false, z: true);
			};
			fieldZ.previousUIHandler = fieldY;
			SetupSettings(fieldZ);
		}

		private void SetValue(float v, bool x = false, bool y = false, bool z = false)
		{
			Vector3 value = m_Field.GetValue();
			if (x)
			{
				value.x = v;
			}
			if (y)
			{
				value.y = v;
			}
			if (z)
			{
				value.z = v;
			}
			m_Field.SetValue(value);
		}

		private void SetupSettings(DebugUIHandlerIndirectFloatField field)
		{
			field.parentUIHandler = this;
			field.incStepGetter = () => m_Field.incStep;
			field.incStepMultGetter = () => m_Field.incStepMult;
			field.decimalsGetter = () => m_Field.decimals;
			field.Init();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			if (fromNext || !valueToggle.isOn)
			{
				nameLabel.color = colorSelected;
			}
			else if (valueToggle.isOn)
			{
				if (m_Container.IsDirectChild(previous))
				{
					nameLabel.color = colorSelected;
				}
				else
				{
					DebugUIHandlerWidget lastItem = m_Container.GetLastItem();
					DebugManager.instance.ChangeSelection(lastItem, fromNext: false);
				}
			}
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
		}

		public override void OnIncrement(bool fast)
		{
			valueToggle.isOn = true;
		}

		public override void OnDecrement(bool fast)
		{
			valueToggle.isOn = false;
		}

		public override void OnAction()
		{
			valueToggle.isOn = !valueToggle.isOn;
		}

		public override DebugUIHandlerWidget Next()
		{
			if (!valueToggle.isOn || m_Container == null)
			{
				return base.Next();
			}
			DebugUIHandlerWidget firstItem = m_Container.GetFirstItem();
			if (firstItem == null)
			{
				return base.Next();
			}
			return firstItem;
		}
	}
	public class DebugUIHandlerVector4 : DebugUIHandlerWidget
	{
		public Text nameLabel;

		public UIFoldout valueToggle;

		public DebugUIHandlerIndirectFloatField fieldX;

		public DebugUIHandlerIndirectFloatField fieldY;

		public DebugUIHandlerIndirectFloatField fieldZ;

		public DebugUIHandlerIndirectFloatField fieldW;

		private DebugUI.Vector4Field m_Field;

		private DebugUIHandlerContainer m_Container;

		internal override void SetWidget(DebugUI.Widget widget)
		{
			base.SetWidget(widget);
			m_Field = CastWidget<DebugUI.Vector4Field>();
			m_Container = GetComponent<DebugUIHandlerContainer>();
			nameLabel.text = m_Field.displayName;
			fieldX.getter = () => m_Field.GetValue().x;
			fieldX.setter = delegate(float x)
			{
				SetValue(x, x: true);
			};
			fieldX.nextUIHandler = fieldY;
			SetupSettings(fieldX);
			fieldY.getter = () => m_Field.GetValue().y;
			fieldY.setter = delegate(float x)
			{
				SetValue(x, x: false, y: true);
			};
			fieldY.previousUIHandler = fieldX;
			fieldY.nextUIHandler = fieldZ;
			SetupSettings(fieldY);
			fieldZ.getter = () => m_Field.GetValue().z;
			fieldZ.setter = delegate(float x)
			{
				SetValue(x, x: false, y: false, z: true);
			};
			fieldZ.previousUIHandler = fieldY;
			fieldZ.nextUIHandler = fieldW;
			SetupSettings(fieldZ);
			fieldW.getter = () => m_Field.GetValue().w;
			fieldW.setter = delegate(float x)
			{
				SetValue(x, x: false, y: false, z: false, w: true);
			};
			fieldW.previousUIHandler = fieldZ;
			SetupSettings(fieldW);
		}

		private void SetValue(float v, bool x = false, bool y = false, bool z = false, bool w = false)
		{
			Vector4 value = m_Field.GetValue();
			if (x)
			{
				value.x = v;
			}
			if (y)
			{
				value.y = v;
			}
			if (z)
			{
				value.z = v;
			}
			if (w)
			{
				value.w = v;
			}
			m_Field.SetValue(value);
		}

		private void SetupSettings(DebugUIHandlerIndirectFloatField field)
		{
			field.parentUIHandler = this;
			field.incStepGetter = () => m_Field.incStep;
			field.incStepMultGetter = () => m_Field.incStepMult;
			field.decimalsGetter = () => m_Field.decimals;
			field.Init();
		}

		public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			if (fromNext || !valueToggle.isOn)
			{
				nameLabel.color = colorSelected;
			}
			else if (valueToggle.isOn)
			{
				if (m_Container.IsDirectChild(previous))
				{
					nameLabel.color = colorSelected;
				}
				else
				{
					DebugUIHandlerWidget lastItem = m_Container.GetLastItem();
					DebugManager.instance.ChangeSelection(lastItem, fromNext: false);
				}
			}
			return true;
		}

		public override void OnDeselection()
		{
			nameLabel.color = colorDefault;
		}

		public override void OnIncrement(bool fast)
		{
			valueToggle.isOn = true;
		}

		public override void OnDecrement(bool fast)
		{
			valueToggle.isOn = false;
		}

		public override void OnAction()
		{
			valueToggle.isOn = !valueToggle.isOn;
		}

		public override DebugUIHandlerWidget Next()
		{
			if (!valueToggle.isOn || m_Container == null)
			{
				return base.Next();
			}
			DebugUIHandlerWidget firstItem = m_Container.GetFirstItem();
			if (firstItem == null)
			{
				return base.Next();
			}
			return firstItem;
		}
	}
	public class DebugUIHandlerWidget : MonoBehaviour
	{
		[HideInInspector]
		public Color colorDefault = new Color(0.8f, 0.8f, 0.8f, 1f);

		[HideInInspector]
		public Color colorSelected = new Color(0.25f, 0.65f, 0.8f, 1f);

		protected DebugUI.Widget m_Widget;

		public DebugUIHandlerWidget parentUIHandler { get; set; }

		public DebugUIHandlerWidget previousUIHandler { get; set; }

		public DebugUIHandlerWidget nextUIHandler { get; set; }

		protected virtual void OnEnable()
		{
		}

		internal virtual void SetWidget(DebugUI.Widget widget)
		{
			m_Widget = widget;
		}

		internal DebugUI.Widget GetWidget()
		{
			return m_Widget;
		}

		protected T CastWidget<T>() where T : DebugUI.Widget
		{
			T obj = m_Widget as T;
			string text = ((m_Widget == null) ? "null" : m_Widget.GetType().ToString());
			if (obj == null)
			{
				throw new InvalidOperationException("Can't cast " + text + " to " + typeof(T));
			}
			return obj;
		}

		public virtual bool OnSelection(bool fromNext, DebugUIHandlerWidget previous)
		{
			return true;
		}

		public virtual void OnDeselection()
		{
		}

		public virtual void OnAction()
		{
		}

		public virtual void OnIncrement(bool fast)
		{
		}

		public virtual void OnDecrement(bool fast)
		{
		}

		public virtual DebugUIHandlerWidget Previous()
		{
			if (previousUIHandler != null)
			{
				return previousUIHandler;
			}
			if (parentUIHandler != null)
			{
				return parentUIHandler;
			}
			return null;
		}

		public virtual DebugUIHandlerWidget Next()
		{
			if (nextUIHandler != null)
			{
				return nextUIHandler;
			}
			if (parentUIHandler != null)
			{
				DebugUIHandlerWidget debugUIHandlerWidget = parentUIHandler;
				while (debugUIHandlerWidget != null)
				{
					DebugUIHandlerWidget debugUIHandlerWidget2 = debugUIHandlerWidget.nextUIHandler;
					if (debugUIHandlerWidget2 != null)
					{
						return debugUIHandlerWidget2;
					}
					debugUIHandlerWidget = debugUIHandlerWidget.parentUIHandler;
				}
			}
			return null;
		}
	}
	[ExecuteAlways]
	public class UIFoldout : Toggle
	{
		public GameObject content;

		public GameObject arrowOpened;

		public GameObject arrowClosed;

		protected override void Start()
		{
			base.Start();
			onValueChanged.AddListener(SetState);
			SetState(base.isOn);
		}

		private void OnValidate()
		{
			SetState(base.isOn, rebuildLayout: false);
		}

		public void SetState(bool state)
		{
			SetState(state, rebuildLayout: true);
		}

		public void SetState(bool state, bool rebuildLayout)
		{
			if (!(arrowOpened == null) && !(arrowClosed == null) && !(content == null))
			{
				if (arrowOpened.activeSelf != state)
				{
					arrowOpened.SetActive(state);
				}
				if (arrowClosed.activeSelf == state)
				{
					arrowClosed.SetActive(!state);
				}
				if (content.activeSelf != state)
				{
					content.SetActive(state);
				}
				if (rebuildLayout)
				{
					LayoutRebuilder.ForceRebuildLayoutImmediate(base.transform.parent as RectTransform);
				}
			}
		}
	}
}
