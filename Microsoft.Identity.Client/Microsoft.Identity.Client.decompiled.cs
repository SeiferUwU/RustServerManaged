#define TRACE
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Data;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Metrics;
using System.Diagnostics.Tracing;
using System.Dynamic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Net.Sockets;
using System.Numerics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.Identity.Client.Advanced;
using Microsoft.Identity.Client.ApiConfig.Executors;
using Microsoft.Identity.Client.ApiConfig.Parameters;
using Microsoft.Identity.Client.AppConfig;
using Microsoft.Identity.Client.AuthScheme;
using Microsoft.Identity.Client.AuthScheme.Bearer;
using Microsoft.Identity.Client.AuthScheme.PoP;
using Microsoft.Identity.Client.AuthScheme.SSHCertificates;
using Microsoft.Identity.Client.Cache;
using Microsoft.Identity.Client.Cache.Items;
using Microsoft.Identity.Client.Cache.Keys;
using Microsoft.Identity.Client.Core;
using Microsoft.Identity.Client.Extensibility;
using Microsoft.Identity.Client.Http;
using Microsoft.Identity.Client.Instance;
using Microsoft.Identity.Client.Instance.Discovery;
using Microsoft.Identity.Client.Instance.Oidc;
using Microsoft.Identity.Client.Instance.Validation;
using Microsoft.Identity.Client.Internal;
using Microsoft.Identity.Client.Internal.Broker;
using Microsoft.Identity.Client.Internal.ClientCredential;
using Microsoft.Identity.Client.Internal.Logger;
using Microsoft.Identity.Client.Internal.Requests;
using Microsoft.Identity.Client.Internal.Requests.Silent;
using Microsoft.Identity.Client.Kerberos;
using Microsoft.Identity.Client.ManagedIdentity;
using Microsoft.Identity.Client.OAuth2;
using Microsoft.Identity.Client.OAuth2.Throttling;
using Microsoft.Identity.Client.Platforms.Features.DesktopOs;
using Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos;
using Microsoft.Identity.Client.Platforms.Features.OpenTelemetry;
using Microsoft.Identity.Client.Platforms.Shared.DefaultOSBrowser;
using Microsoft.Identity.Client.Platforms.Shared.Desktop.OsBrowser;
using Microsoft.Identity.Client.Platforms.Shared.NetStdCore;
using Microsoft.Identity.Client.Platforms.netcore;
using Microsoft.Identity.Client.Platforms.netstandard;
using Microsoft.Identity.Client.PlatformsCommon.Factories;
using Microsoft.Identity.Client.PlatformsCommon.Interfaces;
using Microsoft.Identity.Client.PlatformsCommon.Shared;
using Microsoft.Identity.Client.Region;
using Microsoft.Identity.Client.TelemetryCore;
using Microsoft.Identity.Client.TelemetryCore.Http;
using Microsoft.Identity.Client.TelemetryCore.Internal.Events;
using Microsoft.Identity.Client.TelemetryCore.OpenTelemetry;
using Microsoft.Identity.Client.TelemetryCore.TelemetryClient;
using Microsoft.Identity.Client.UI;
using Microsoft.Identity.Client.Utils;
using Microsoft.Identity.Client.WsTrust;
using Microsoft.Identity.Json;
using Microsoft.Identity.Json.Bson;
using Microsoft.Identity.Json.Converters;
using Microsoft.Identity.Json.Linq;
using Microsoft.Identity.Json.Linq.JsonPath;
using Microsoft.Identity.Json.Schema;
using Microsoft.Identity.Json.Serialization;
using Microsoft.Identity.Json.Utilities;
using Microsoft.IdentityModel.Abstractions;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyMetadata("Serviceable", "True")]
[assembly: ComVisible(false)]
[assembly: CLSCompliant(true)]
[assembly: InternalsVisibleTo("Microsoft.Identity.Client.Desktop, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("Microsoft.Identity.Client.Broker, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("Microsoft.Identity.Test.Unit, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("Microsoft.Identity.Test.Common, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("Microsoft.Identity.Test.SideBySide, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("Microsoft.Identity.Test.Integration.NetCore, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("Microsoft.Identity.Test.Integration.NetFx, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("Microsoft.Identity.Test.Performance, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("CommonCache.Test.Common, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("CommonCache.Test.Unit, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("DynamicProxyGenAssembly2, PublicKey=0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7")]
[assembly: InternalsVisibleTo("Microsoft.Identity.Client.Extensions.Msal, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("Microsoft.Identity.Client.Extensions.Web, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("Microsoft.Identity.Client.Extensions.Web.UnitTests, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("XForms, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("WebApi, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("NetFxConsoleApp, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("NetCoreWinFormsWAM, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: InternalsVisibleTo("DesktopTestApp, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad")]
[assembly: TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName = "")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyConfiguration("Release")]
[assembly: AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")]
[assembly: AssemblyDescription("\r\n      This package contains the binaries of the Microsoft Authentication Library for .NET (MSAL.NET).\r\n      MSAL.NET makes it easy to obtain tokens from the Microsoft identity platform for developers (formerly Azure AD v2.0) signing-in users with work & school accounts, Microsoft personal accounts, and social identities via Azure AD B2C. These tokens provide access to Microsoft Cloud API and any other API secured by the Microsoft identity platform. This version supports adding authentication functionality to your .NET based clients - .NET, .NET Framework, .NET MAUI \r\n    ")]
[assembly: AssemblyFileVersion("4.61.3.0")]
[assembly: AssemblyInformationalVersion("4.61.3+88df64013795d4e3716e1f677600f8164ffdb542")]
[assembly: AssemblyProduct("Microsoft Authentication Library")]
[assembly: AssemblyTitle("Microsoft.Identity.Client")]
[assembly: AssemblyMetadata("RepositoryUrl", "https://github.com/AzureAD/microsoft-authentication-library-for-dotnet")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("4.61.3.0")]
[module: UnverifiableCode]
[module: RefSafetyRules(11)]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsReadOnlyAttribute : Attribute
	{
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableAttribute : Attribute
	{
		public readonly byte[] NullableFlags;

		public NullableAttribute(byte P_0)
		{
			NullableFlags = new byte[1] { P_0 };
		}

		public NullableAttribute(byte[] P_0)
		{
			NullableFlags = P_0;
		}
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Interface | AttributeTargets.Delegate, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableContextAttribute : Attribute
	{
		public readonly byte Flag;

		public NullableContextAttribute(byte P_0)
		{
			Flag = P_0;
		}
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Module, AllowMultiple = false, Inherited = false)]
	internal sealed class RefSafetyRulesAttribute : Attribute
	{
		public readonly int Version;

		public RefSafetyRulesAttribute(int P_0)
		{
			Version = P_0;
		}
	}
}
namespace System.Diagnostics.CodeAnalysis
{
	[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = true)]
	internal sealed class NotNullAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]
	internal sealed class NotNullWhenAttribute : Attribute
	{
		public bool ReturnValue { get; }

		public NotNullWhenAttribute(bool returnValue)
		{
			ReturnValue = returnValue;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, Inherited = false)]
	internal sealed class MaybeNullAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, Inherited = false)]
	internal sealed class AllowNullAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
	internal class DoesNotReturnIfAttribute : Attribute
	{
		public bool ParameterValue { get; }

		public DoesNotReturnIfAttribute(bool parameterValue)
		{
			ParameterValue = parameterValue;
		}
	}
}
namespace Microsoft.Identity.Json
{
	internal enum ConstructorHandling
	{
		Default,
		AllowNonPublicDefaultConstructor
	}
	internal enum DateFormatHandling
	{
		IsoDateFormat,
		MicrosoftDateFormat
	}
	internal enum DateParseHandling
	{
		None,
		DateTime,
		DateTimeOffset
	}
	internal enum DateTimeZoneHandling
	{
		Local,
		Utc,
		Unspecified,
		RoundtripKind
	}
	internal class DefaultJsonNameTable : JsonNameTable
	{
		private class Entry
		{
			internal readonly string Value;

			internal readonly int HashCode;

			internal Entry Next;

			internal Entry(string value, int hashCode, Entry next)
			{
				Value = value;
				HashCode = hashCode;
				Next = next;
			}
		}

		private static readonly int HashCodeRandomizer;

		private int _count;

		private Entry[] _entries;

		private int _mask = 31;

		static DefaultJsonNameTable()
		{
			HashCodeRandomizer = Environment.TickCount;
		}

		public DefaultJsonNameTable()
		{
			_entries = new Entry[_mask + 1];
		}

		public override string? Get(char[] key, int start, int length)
		{
			if (length == 0)
			{
				return string.Empty;
			}
			int num = length + HashCodeRandomizer;
			num += (num << 7) ^ key[start];
			int num2 = start + length;
			for (int i = start + 1; i < num2; i++)
			{
				num += (num << 7) ^ key[i];
			}
			num -= num >> 17;
			num -= num >> 11;
			num -= num >> 5;
			int num3 = num & _mask;
			for (Entry entry = _entries[num3]; entry != null; entry = entry.Next)
			{
				if (entry.HashCode == num && TextEquals(entry.Value, key, start, length))
				{
					return entry.Value;
				}
			}
			return null;
		}

		public string Add(string key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			int length = key.Length;
			if (length == 0)
			{
				return string.Empty;
			}
			int num = length + HashCodeRandomizer;
			for (int i = 0; i < key.Length; i++)
			{
				num += (num << 7) ^ key[i];
			}
			num -= num >> 17;
			num -= num >> 11;
			num -= num >> 5;
			for (Entry entry = _entries[num & _mask]; entry != null; entry = entry.Next)
			{
				if (entry.HashCode == num && entry.Value.Equals(key, StringComparison.Ordinal))
				{
					return entry.Value;
				}
			}
			return AddEntry(key, num);
		}

		private string AddEntry(string str, int hashCode)
		{
			int num = hashCode & _mask;
			Entry entry = new Entry(str, hashCode, _entries[num]);
			_entries[num] = entry;
			if (_count++ == _mask)
			{
				Grow();
			}
			return entry.Value;
		}

		private void Grow()
		{
			Entry[] entries = _entries;
			int num = _mask * 2 + 1;
			Entry[] array = new Entry[num + 1];
			for (int i = 0; i < entries.Length; i++)
			{
				Entry entry = entries[i];
				while (entry != null)
				{
					int num2 = entry.HashCode & num;
					Entry next = entry.Next;
					entry.Next = array[num2];
					array[num2] = entry;
					entry = next;
				}
			}
			_entries = array;
			_mask = num;
		}

		private static bool TextEquals(string str1, char[] str2, int str2Start, int str2Length)
		{
			if (str1.Length != str2Length)
			{
				return false;
			}
			for (int i = 0; i < str1.Length; i++)
			{
				if (str1[i] != str2[str2Start + i])
				{
					return false;
				}
			}
			return true;
		}
	}
	[Flags]
	internal enum DefaultValueHandling
	{
		Include = 0,
		Ignore = 1,
		Populate = 2,
		IgnoreAndPopulate = 3
	}
	internal enum FloatFormatHandling
	{
		String,
		Symbol,
		DefaultValue
	}
	internal enum FloatParseHandling
	{
		Double,
		Decimal
	}
	internal enum Formatting
	{
		None,
		Indented
	}
	internal interface IArrayPool<T>
	{
		T[] Rent(int minimumLength);

		void Return(T[]? array);
	}
	internal interface IJsonLineInfo
	{
		int LineNumber { get; }

		int LinePosition { get; }

		bool HasLineInfo();
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
	internal sealed class JsonArrayAttribute : JsonContainerAttribute
	{
		private bool _allowNullItems;

		public bool AllowNullItems
		{
			get
			{
				return _allowNullItems;
			}
			set
			{
				_allowNullItems = value;
			}
		}

		public JsonArrayAttribute()
		{
		}

		public JsonArrayAttribute(bool allowNullItems)
		{
			_allowNullItems = allowNullItems;
		}

		public JsonArrayAttribute(string id)
			: base(id)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false)]
	internal sealed class JsonConstructorAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
	internal abstract class JsonContainerAttribute : Attribute
	{
		internal bool? _isReference;

		internal bool? _itemIsReference;

		internal ReferenceLoopHandling? _itemReferenceLoopHandling;

		internal TypeNameHandling? _itemTypeNameHandling;

		private Type? _namingStrategyType;

		private object[]? _namingStrategyParameters;

		public string? Id { get; set; }

		public string? Title { get; set; }

		public string? Description { get; set; }

		public Type? ItemConverterType { get; set; }

		public object[]? ItemConverterParameters { get; set; }

		public Type? NamingStrategyType
		{
			get
			{
				return _namingStrategyType;
			}
			set
			{
				_namingStrategyType = value;
				NamingStrategyInstance = null;
			}
		}

		public object[]? NamingStrategyParameters
		{
			get
			{
				return _namingStrategyParameters;
			}
			set
			{
				_namingStrategyParameters = value;
				NamingStrategyInstance = null;
			}
		}

		internal NamingStrategy? NamingStrategyInstance { get; set; }

		public bool IsReference
		{
			get
			{
				return _isReference == true;
			}
			set
			{
				_isReference = value;
			}
		}

		public bool ItemIsReference
		{
			get
			{
				return _itemIsReference == true;
			}
			set
			{
				_itemIsReference = value;
			}
		}

		public ReferenceLoopHandling ItemReferenceLoopHandling
		{
			get
			{
				return _itemReferenceLoopHandling.GetValueOrDefault();
			}
			set
			{
				_itemReferenceLoopHandling = value;
			}
		}

		public TypeNameHandling ItemTypeNameHandling
		{
			get
			{
				return _itemTypeNameHandling.GetValueOrDefault();
			}
			set
			{
				_itemTypeNameHandling = value;
			}
		}

		protected JsonContainerAttribute()
		{
		}

		protected JsonContainerAttribute(string id)
		{
			Id = id;
		}
	}
	internal static class JsonConvert
	{
		public static readonly string True = "true";

		public static readonly string False = "false";

		public static readonly string Null = "null";

		public static readonly string Undefined = "undefined";

		public static readonly string PositiveInfinity = "Infinity";

		public static readonly string NegativeInfinity = "-Infinity";

		public static readonly string NaN = "NaN";

		public static Func<JsonSerializerSettings>? DefaultSettings { get; set; }

		public static string ToString(DateTime value)
		{
			return ToString(value, DateFormatHandling.IsoDateFormat, DateTimeZoneHandling.RoundtripKind);
		}

		public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling)
		{
			DateTime value2 = DateTimeUtils.EnsureDateTime(value, timeZoneHandling);
			using StringWriter stringWriter = StringUtils.CreateStringWriter(64);
			stringWriter.Write('"');
			DateTimeUtils.WriteDateTimeString(stringWriter, value2, format, null, CultureInfo.InvariantCulture);
			stringWriter.Write('"');
			return stringWriter.ToString();
		}

		public static string ToString(DateTimeOffset value)
		{
			return ToString(value, DateFormatHandling.IsoDateFormat);
		}

		public static string ToString(DateTimeOffset value, DateFormatHandling format)
		{
			using StringWriter stringWriter = StringUtils.CreateStringWriter(64);
			stringWriter.Write('"');
			DateTimeUtils.WriteDateTimeOffsetString(stringWriter, value, format, null, CultureInfo.InvariantCulture);
			stringWriter.Write('"');
			return stringWriter.ToString();
		}

		public static string ToString(bool value)
		{
			if (!value)
			{
				return False;
			}
			return True;
		}

		public static string ToString(char value)
		{
			return ToString(char.ToString(value));
		}

		public static string ToString(Enum value)
		{
			return value.ToString("D");
		}

		public static string ToString(int value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(short value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static string ToString(ushort value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static string ToString(uint value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(long value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		private static string ToStringInternal(BigInteger value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static string ToString(ulong value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(float value)
		{
			return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
		}

		internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
		{
			return EnsureFloatFormat(value, EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture)), floatFormatHandling, quoteChar, nullable);
		}

		private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
		{
			if (floatFormatHandling == FloatFormatHandling.Symbol || (!double.IsInfinity(value) && !double.IsNaN(value)))
			{
				return text;
			}
			if (floatFormatHandling == FloatFormatHandling.DefaultValue)
			{
				if (nullable)
				{
					return Null;
				}
				return "0.0";
			}
			return quoteChar + text + quoteChar;
		}

		public static string ToString(double value)
		{
			return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
		}

		internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
		{
			return EnsureFloatFormat(value, EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture)), floatFormatHandling, quoteChar, nullable);
		}

		private static string EnsureDecimalPlace(double value, string text)
		{
			if (double.IsNaN(value) || double.IsInfinity(value) || text.IndexOf('.') != -1 || text.IndexOf('E') != -1 || text.IndexOf('e') != -1)
			{
				return text;
			}
			return text + ".0";
		}

		private static string EnsureDecimalPlace(string text)
		{
			if (text.IndexOf('.') != -1)
			{
				return text;
			}
			return text + ".0";
		}

		public static string ToString(byte value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static string ToString(sbyte value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(decimal value)
		{
			return EnsureDecimalPlace(value.ToString(null, CultureInfo.InvariantCulture));
		}

		public static string ToString(Guid value)
		{
			return ToString(value, '"');
		}

		internal static string ToString(Guid value, char quoteChar)
		{
			string text = value.ToString("D", CultureInfo.InvariantCulture);
			string text2 = quoteChar.ToString(CultureInfo.InvariantCulture);
			return text2 + text + text2;
		}

		public static string ToString(TimeSpan value)
		{
			return ToString(value, '"');
		}

		internal static string ToString(TimeSpan value, char quoteChar)
		{
			return ToString(value.ToString(), quoteChar);
		}

		public static string ToString(Uri? value)
		{
			if (value == null)
			{
				return Null;
			}
			return ToString(value, '"');
		}

		internal static string ToString(Uri value, char quoteChar)
		{
			return ToString(value.OriginalString, quoteChar);
		}

		public static string ToString(string? value)
		{
			return ToString(value, '"');
		}

		public static string ToString(string? value, char delimiter)
		{
			return ToString(value, delimiter, StringEscapeHandling.Default);
		}

		public static string ToString(string? value, char delimiter, StringEscapeHandling stringEscapeHandling)
		{
			if (delimiter != '"' && delimiter != '\'')
			{
				throw new ArgumentException("Delimiter must be a single or double quote.", "delimiter");
			}
			return JavaScriptUtils.ToEscapedJavaScriptString(value, delimiter, appendDelimiters: true, stringEscapeHandling);
		}

		public static string ToString(object? value)
		{
			if (value == null)
			{
				return Null;
			}
			return ConvertUtils.GetTypeCode(value.GetType()) switch
			{
				PrimitiveTypeCode.String => ToString((string)value), 
				PrimitiveTypeCode.Char => ToString((char)value), 
				PrimitiveTypeCode.Boolean => ToString((bool)value), 
				PrimitiveTypeCode.SByte => ToString((sbyte)value), 
				PrimitiveTypeCode.Int16 => ToString((short)value), 
				PrimitiveTypeCode.UInt16 => ToString((ushort)value), 
				PrimitiveTypeCode.Int32 => ToString((int)value), 
				PrimitiveTypeCode.Byte => ToString((byte)value), 
				PrimitiveTypeCode.UInt32 => ToString((uint)value), 
				PrimitiveTypeCode.Int64 => ToString((long)value), 
				PrimitiveTypeCode.UInt64 => ToString((ulong)value), 
				PrimitiveTypeCode.Single => ToString((float)value), 
				PrimitiveTypeCode.Double => ToString((double)value), 
				PrimitiveTypeCode.DateTime => ToString((DateTime)value), 
				PrimitiveTypeCode.Decimal => ToString((decimal)value), 
				PrimitiveTypeCode.DBNull => Null, 
				PrimitiveTypeCode.DateTimeOffset => ToString((DateTimeOffset)value), 
				PrimitiveTypeCode.Guid => ToString((Guid)value), 
				PrimitiveTypeCode.Uri => ToString((Uri)value), 
				PrimitiveTypeCode.TimeSpan => ToString((TimeSpan)value), 
				PrimitiveTypeCode.BigInteger => ToStringInternal((BigInteger)value), 
				_ => throw new ArgumentException("Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture, value.GetType())), 
			};
		}

		[DebuggerStepThrough]
		public static string SerializeObject(object? value)
		{
			return SerializeObject(value, (Type?)null, (JsonSerializerSettings?)null);
		}

		[DebuggerStepThrough]
		public static string SerializeObject(object? value, Formatting formatting)
		{
			return SerializeObject(value, formatting, (JsonSerializerSettings?)null);
		}

		[DebuggerStepThrough]
		public static string SerializeObject(object? value, params JsonConverter[] converters)
		{
			JsonSerializerSettings settings = ((converters != null && converters.Length != 0) ? new JsonSerializerSettings
			{
				Converters = converters
			} : null);
			return SerializeObject(value, null, settings);
		}

		[DebuggerStepThrough]
		public static string SerializeObject(object? value, Formatting formatting, params JsonConverter[] converters)
		{
			JsonSerializerSettings settings = ((converters != null && converters.Length != 0) ? new JsonSerializerSettings
			{
				Converters = converters
			} : null);
			return SerializeObject(value, null, formatting, settings);
		}

		[DebuggerStepThrough]
		public static string SerializeObject(object? value, JsonSerializerSettings? settings)
		{
			return SerializeObject(value, null, settings);
		}

		[DebuggerStepThrough]
		public static string SerializeObject(object? value, Type? type, JsonSerializerSettings? settings)
		{
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			return SerializeObjectInternal(value, type, jsonSerializer);
		}

		[DebuggerStepThrough]
		public static string SerializeObject(object? value, Formatting formatting, JsonSerializerSettings? settings)
		{
			return SerializeObject(value, null, formatting, settings);
		}

		[DebuggerStepThrough]
		public static string SerializeObject(object? value, Type? type, Formatting formatting, JsonSerializerSettings? settings)
		{
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			jsonSerializer.Formatting = formatting;
			return SerializeObjectInternal(value, type, jsonSerializer);
		}

		private static string SerializeObjectInternal(object? value, Type? type, JsonSerializer jsonSerializer)
		{
			StringWriter stringWriter = new StringWriter(new StringBuilder(256), CultureInfo.InvariantCulture);
			using (JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter))
			{
				jsonTextWriter.Formatting = jsonSerializer.Formatting;
				jsonSerializer.Serialize(jsonTextWriter, value, type);
			}
			return stringWriter.ToString();
		}

		[DebuggerStepThrough]
		public static object? DeserializeObject(string value)
		{
			return DeserializeObject(value, (Type?)null, (JsonSerializerSettings?)null);
		}

		[DebuggerStepThrough]
		public static object? DeserializeObject(string value, JsonSerializerSettings settings)
		{
			return DeserializeObject(value, null, settings);
		}

		[DebuggerStepThrough]
		public static object? DeserializeObject(string value, Type type)
		{
			return DeserializeObject(value, type, (JsonSerializerSettings?)null);
		}

		[DebuggerStepThrough]
		public static T? DeserializeObject<T>(string value)
		{
			return JsonConvert.DeserializeObject<T>(value, (JsonSerializerSettings?)null);
		}

		[DebuggerStepThrough]
		public static T? DeserializeAnonymousType<T>(string value, T anonymousTypeObject)
		{
			return DeserializeObject<T>(value);
		}

		[DebuggerStepThrough]
		public static T? DeserializeAnonymousType<T>(string value, T anonymousTypeObject, JsonSerializerSettings settings)
		{
			return DeserializeObject<T>(value, settings);
		}

		[DebuggerStepThrough]
		public static T? DeserializeObject<T>(string value, params JsonConverter[] converters)
		{
			return (T)DeserializeObject(value, typeof(T), converters);
		}

		[DebuggerStepThrough]
		public static T? DeserializeObject<T>(string value, JsonSerializerSettings? settings)
		{
			return (T)DeserializeObject(value, typeof(T), settings);
		}

		[DebuggerStepThrough]
		public static object? DeserializeObject(string value, Type type, params JsonConverter[] converters)
		{
			JsonSerializerSettings settings = ((converters != null && converters.Length != 0) ? new JsonSerializerSettings
			{
				Converters = converters
			} : null);
			return DeserializeObject(value, type, settings);
		}

		public static object? DeserializeObject(string value, Type? type, JsonSerializerSettings? settings)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			if (!jsonSerializer.IsCheckAdditionalContentSet())
			{
				jsonSerializer.CheckAdditionalContent = true;
			}
			using JsonTextReader reader = new JsonTextReader(new StringReader(value));
			return jsonSerializer.Deserialize(reader, type);
		}

		[DebuggerStepThrough]
		public static void PopulateObject(string value, object target)
		{
			PopulateObject(value, target, null);
		}

		public static void PopulateObject(string value, object target, JsonSerializerSettings? settings)
		{
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			using JsonReader jsonReader = new JsonTextReader(new StringReader(value));
			jsonSerializer.Populate(jsonReader, target);
			if (settings == null || !settings.CheckAdditionalContent)
			{
				return;
			}
			while (jsonReader.Read())
			{
				if (jsonReader.TokenType != JsonToken.Comment)
				{
					throw JsonSerializationException.Create(jsonReader, "Additional text found in JSON string after finishing deserializing object.");
				}
			}
		}

		public static string SerializeXmlNode(XmlNode? node)
		{
			return SerializeXmlNode(node, Formatting.None);
		}

		public static string SerializeXmlNode(XmlNode? node, Formatting formatting)
		{
			XmlNodeConverter xmlNodeConverter = new XmlNodeConverter();
			return SerializeObject(node, formatting, xmlNodeConverter);
		}

		public static string SerializeXmlNode(XmlNode? node, Formatting formatting, bool omitRootObject)
		{
			XmlNodeConverter xmlNodeConverter = new XmlNodeConverter
			{
				OmitRootObject = omitRootObject
			};
			return SerializeObject(node, formatting, xmlNodeConverter);
		}

		public static XmlDocument? DeserializeXmlNode(string value)
		{
			return DeserializeXmlNode(value, null);
		}

		public static XmlDocument? DeserializeXmlNode(string value, string? deserializeRootElementName)
		{
			return DeserializeXmlNode(value, deserializeRootElementName, writeArrayAttribute: false);
		}

		public static XmlDocument? DeserializeXmlNode(string value, string? deserializeRootElementName, bool writeArrayAttribute)
		{
			return DeserializeXmlNode(value, deserializeRootElementName, writeArrayAttribute, encodeSpecialCharacters: false);
		}

		public static XmlDocument? DeserializeXmlNode(string value, string? deserializeRootElementName, bool writeArrayAttribute, bool encodeSpecialCharacters)
		{
			XmlNodeConverter xmlNodeConverter = new XmlNodeConverter();
			xmlNodeConverter.DeserializeRootElementName = deserializeRootElementName;
			xmlNodeConverter.WriteArrayAttribute = writeArrayAttribute;
			xmlNodeConverter.EncodeSpecialCharacters = encodeSpecialCharacters;
			return (XmlDocument)DeserializeObject(value, typeof(XmlDocument), xmlNodeConverter);
		}

		public static string SerializeXNode(XObject? node)
		{
			return SerializeXNode(node, Formatting.None);
		}

		public static string SerializeXNode(XObject? node, Formatting formatting)
		{
			return SerializeXNode(node, formatting, omitRootObject: false);
		}

		public static string SerializeXNode(XObject? node, Formatting formatting, bool omitRootObject)
		{
			XmlNodeConverter xmlNodeConverter = new XmlNodeConverter
			{
				OmitRootObject = omitRootObject
			};
			return SerializeObject(node, formatting, xmlNodeConverter);
		}

		public static XDocument? DeserializeXNode(string value)
		{
			return DeserializeXNode(value, null);
		}

		public static XDocument? DeserializeXNode(string value, string? deserializeRootElementName)
		{
			return DeserializeXNode(value, deserializeRootElementName, writeArrayAttribute: false);
		}

		public static XDocument? DeserializeXNode(string value, string? deserializeRootElementName, bool writeArrayAttribute)
		{
			return DeserializeXNode(value, deserializeRootElementName, writeArrayAttribute, encodeSpecialCharacters: false);
		}

		public static XDocument? DeserializeXNode(string value, string? deserializeRootElementName, bool writeArrayAttribute, bool encodeSpecialCharacters)
		{
			XmlNodeConverter xmlNodeConverter = new XmlNodeConverter();
			xmlNodeConverter.DeserializeRootElementName = deserializeRootElementName;
			xmlNodeConverter.WriteArrayAttribute = writeArrayAttribute;
			xmlNodeConverter.EncodeSpecialCharacters = encodeSpecialCharacters;
			return (XDocument)DeserializeObject(value, typeof(XDocument), xmlNodeConverter);
		}
	}
	internal abstract class JsonConverter
	{
		public virtual bool CanRead => true;

		public virtual bool CanWrite => true;

		public abstract void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer);

		public abstract object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer);

		public abstract bool CanConvert(Type objectType);
	}
	internal abstract class JsonConverter<T> : JsonConverter
	{
		public sealed override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			if (!((value != null) ? (value is T) : ReflectionUtils.IsNullable(typeof(T))))
			{
				throw new JsonSerializationException("Converter cannot write specified value to JSON. {0} is required.".FormatWith(CultureInfo.InvariantCulture, typeof(T)));
			}
			WriteJson(writer, (T)value, serializer);
		}

		public abstract void WriteJson(JsonWriter writer, T? value, JsonSerializer serializer);

		public sealed override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			bool flag = existingValue == null;
			if (!flag && !(existingValue is T))
			{
				throw new JsonSerializationException("Converter cannot read JSON with the specified existing value. {0} is required.".FormatWith(CultureInfo.InvariantCulture, typeof(T)));
			}
			return ReadJson(reader, objectType, flag ? default(T) : ((T)existingValue), !flag, serializer);
		}

		public abstract T? ReadJson(JsonReader reader, Type objectType, T? existingValue, bool hasExistingValue, JsonSerializer serializer);

		public sealed override bool CanConvert(Type objectType)
		{
			return typeof(T).IsAssignableFrom(objectType);
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface | AttributeTargets.Parameter, AllowMultiple = false)]
	internal sealed class JsonConverterAttribute : Attribute
	{
		private readonly Type _converterType;

		public Type ConverterType => _converterType;

		public object[]? ConverterParameters { get; }

		public JsonConverterAttribute(Type converterType)
		{
			if (converterType == null)
			{
				throw new ArgumentNullException("converterType");
			}
			_converterType = converterType;
		}

		public JsonConverterAttribute(Type converterType, params object[] converterParameters)
			: this(converterType)
		{
			ConverterParameters = converterParameters;
		}
	}
	internal class JsonConverterCollection : Collection<JsonConverter>
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
	internal sealed class JsonDictionaryAttribute : JsonContainerAttribute
	{
		public JsonDictionaryAttribute()
		{
		}

		public JsonDictionaryAttribute(string id)
			: base(id)
		{
		}
	}
	[Serializable]
	internal class JsonException : Exception
	{
		public JsonException()
		{
		}

		public JsonException(string message)
			: base(message)
		{
		}

		public JsonException(string message, Exception? innerException)
			: base(message, innerException)
		{
		}

		public JsonException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message)
		{
			message = JsonPosition.FormatMessage(lineInfo, path, message);
			return new JsonException(message);
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	internal class JsonExtensionDataAttribute : Attribute
	{
		public bool WriteData { get; set; }

		public bool ReadData { get; set; }

		public JsonExtensionDataAttribute()
		{
			WriteData = true;
			ReadData = true;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	internal sealed class JsonIgnoreAttribute : Attribute
	{
	}
	internal abstract class JsonNameTable
	{
		public abstract string? Get(char[] key, int start, int length);
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, AllowMultiple = false)]
	internal sealed class JsonObjectAttribute : JsonContainerAttribute
	{
		private MemberSerialization _memberSerialization;

		internal MissingMemberHandling? _missingMemberHandling;

		internal Required? _itemRequired;

		internal NullValueHandling? _itemNullValueHandling;

		public MemberSerialization MemberSerialization
		{
			get
			{
				return _memberSerialization;
			}
			set
			{
				_memberSerialization = value;
			}
		}

		public MissingMemberHandling MissingMemberHandling
		{
			get
			{
				return _missingMemberHandling.GetValueOrDefault();
			}
			set
			{
				_missingMemberHandling = value;
			}
		}

		public NullValueHandling ItemNullValueHandling
		{
			get
			{
				return _itemNullValueHandling.GetValueOrDefault();
			}
			set
			{
				_itemNullValueHandling = value;
			}
		}

		public Required ItemRequired
		{
			get
			{
				return _itemRequired.GetValueOrDefault();
			}
			set
			{
				_itemRequired = value;
			}
		}

		public JsonObjectAttribute()
		{
		}

		public JsonObjectAttribute(MemberSerialization memberSerialization)
		{
			MemberSerialization = memberSerialization;
		}

		public JsonObjectAttribute(string id)
			: base(id)
		{
		}
	}
	internal enum JsonContainerType
	{
		None,
		Object,
		Array,
		Constructor
	}
	internal struct JsonPosition
	{
		private static readonly char[] SpecialCharacters = new char[18]
		{
			'.', ' ', '\'', '/', '"', '[', ']', '(', ')', '\t',
			'\n', '\r', '\f', '\b', '\\', '\u0085', '\u2028', '\u2029'
		};

		internal JsonContainerType Type;

		internal int Position;

		internal string? PropertyName;

		internal bool HasIndex;

		public JsonPosition(JsonContainerType type)
		{
			Type = type;
			HasIndex = TypeHasIndex(type);
			Position = -1;
			PropertyName = null;
		}

		internal int CalculateLength()
		{
			switch (Type)
			{
			case JsonContainerType.Object:
				return PropertyName.Length + 5;
			case JsonContainerType.Array:
			case JsonContainerType.Constructor:
				return MathUtils.IntLength((ulong)Position) + 2;
			default:
				throw new ArgumentOutOfRangeException("Type");
			}
		}

		internal void WriteTo(StringBuilder sb, ref StringWriter? writer, ref char[]? buffer)
		{
			switch (Type)
			{
			case JsonContainerType.Object:
			{
				string propertyName = PropertyName;
				if (propertyName.IndexOfAny(SpecialCharacters) != -1)
				{
					sb.Append("['");
					if (writer == null)
					{
						writer = new StringWriter(sb);
					}
					JavaScriptUtils.WriteEscapedJavaScriptString(writer, propertyName, '\'', appendDelimiters: false, JavaScriptUtils.SingleQuoteCharEscapeFlags, StringEscapeHandling.Default, null, ref buffer);
					sb.Append("']");
				}
				else
				{
					if (sb.Length > 0)
					{
						sb.Append('.');
					}
					sb.Append(propertyName);
				}
				break;
			}
			case JsonContainerType.Array:
			case JsonContainerType.Constructor:
				sb.Append('[');
				sb.Append(Position);
				sb.Append(']');
				break;
			}
		}

		internal static bool TypeHasIndex(JsonContainerType type)
		{
			if (type != JsonContainerType.Array)
			{
				return type == JsonContainerType.Constructor;
			}
			return true;
		}

		internal static string BuildPath(List<JsonPosition> positions, JsonPosition? currentPosition)
		{
			int num = 0;
			if (positions != null)
			{
				for (int i = 0; i < positions.Count; i++)
				{
					num += positions[i].CalculateLength();
				}
			}
			if (currentPosition.HasValue)
			{
				num += currentPosition.GetValueOrDefault().CalculateLength();
			}
			StringBuilder stringBuilder = new StringBuilder(num);
			StringWriter writer = null;
			char[] buffer = null;
			if (positions != null)
			{
				foreach (JsonPosition position in positions)
				{
					position.WriteTo(stringBuilder, ref writer, ref buffer);
				}
			}
			currentPosition?.WriteTo(stringBuilder, ref writer, ref buffer);
			return stringBuilder.ToString();
		}

		internal static string FormatMessage(IJsonLineInfo? lineInfo, string path, string message)
		{
			if (!message.EndsWith(Environment.NewLine, StringComparison.Ordinal))
			{
				message = message.Trim();
				if (!StringUtils.EndsWith(message, '.'))
				{
					message += ".";
				}
				message += " ";
			}
			message += "Path '{0}'".FormatWith(CultureInfo.InvariantCulture, path);
			if (lineInfo != null && lineInfo.HasLineInfo())
			{
				message += ", line {0}, position {1}".FormatWith(CultureInfo.InvariantCulture, lineInfo.LineNumber, lineInfo.LinePosition);
			}
			message += ".";
			return message;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
	internal sealed class JsonPropertyAttribute : Attribute
	{
		internal NullValueHandling? _nullValueHandling;

		internal DefaultValueHandling? _defaultValueHandling;

		internal ReferenceLoopHandling? _referenceLoopHandling;

		internal ObjectCreationHandling? _objectCreationHandling;

		internal TypeNameHandling? _typeNameHandling;

		internal bool? _isReference;

		internal int? _order;

		internal Required? _required;

		internal bool? _itemIsReference;

		internal ReferenceLoopHandling? _itemReferenceLoopHandling;

		internal TypeNameHandling? _itemTypeNameHandling;

		public Type? ItemConverterType { get; set; }

		public object[]? ItemConverterParameters { get; set; }

		public Type? NamingStrategyType { get; set; }

		public object[]? NamingStrategyParameters { get; set; }

		public NullValueHandling NullValueHandling
		{
			get
			{
				return _nullValueHandling.GetValueOrDefault();
			}
			set
			{
				_nullValueHandling = value;
			}
		}

		public DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _defaultValueHandling.GetValueOrDefault();
			}
			set
			{
				_defaultValueHandling = value;
			}
		}

		public ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _referenceLoopHandling.GetValueOrDefault();
			}
			set
			{
				_referenceLoopHandling = value;
			}
		}

		public ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _objectCreationHandling.GetValueOrDefault();
			}
			set
			{
				_objectCreationHandling = value;
			}
		}

		public TypeNameHandling TypeNameHandling
		{
			get
			{
				return _typeNameHandling.GetValueOrDefault();
			}
			set
			{
				_typeNameHandling = value;
			}
		}

		public bool IsReference
		{
			get
			{
				return _isReference == true;
			}
			set
			{
				_isReference = value;
			}
		}

		public int Order
		{
			get
			{
				return _order.GetValueOrDefault();
			}
			set
			{
				_order = value;
			}
		}

		public Required Required
		{
			get
			{
				return _required.GetValueOrDefault();
			}
			set
			{
				_required = value;
			}
		}

		public string? PropertyName { get; set; }

		public ReferenceLoopHandling ItemReferenceLoopHandling
		{
			get
			{
				return _itemReferenceLoopHandling.GetValueOrDefault();
			}
			set
			{
				_itemReferenceLoopHandling = value;
			}
		}

		public TypeNameHandling ItemTypeNameHandling
		{
			get
			{
				return _itemTypeNameHandling.GetValueOrDefault();
			}
			set
			{
				_itemTypeNameHandling = value;
			}
		}

		public bool ItemIsReference
		{
			get
			{
				return _itemIsReference == true;
			}
			set
			{
				_itemIsReference = value;
			}
		}

		public JsonPropertyAttribute()
		{
		}

		public JsonPropertyAttribute(string propertyName)
		{
			PropertyName = propertyName;
		}
	}
	internal abstract class JsonReader : IDisposable
	{
		protected internal enum State
		{
			Start,
			Complete,
			Property,
			ObjectStart,
			Object,
			ArrayStart,
			Array,
			Closed,
			PostValue,
			ConstructorStart,
			Constructor,
			Error,
			Finished
		}

		private JsonToken _tokenType;

		private object? _value;

		internal char _quoteChar;

		internal State _currentState;

		private JsonPosition _currentPosition;

		private CultureInfo? _culture;

		private DateTimeZoneHandling _dateTimeZoneHandling;

		private int? _maxDepth;

		private bool _hasExceededMaxDepth;

		internal DateParseHandling _dateParseHandling;

		internal FloatParseHandling _floatParseHandling;

		private string? _dateFormatString;

		private List<JsonPosition>? _stack;

		protected State CurrentState => _currentState;

		public bool CloseInput { get; set; }

		public bool SupportMultipleContent { get; set; }

		public virtual char QuoteChar
		{
			get
			{
				return _quoteChar;
			}
			protected internal set
			{
				_quoteChar = value;
			}
		}

		public DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _dateTimeZoneHandling;
			}
			set
			{
				if (value < DateTimeZoneHandling.Local || value > DateTimeZoneHandling.RoundtripKind)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dateTimeZoneHandling = value;
			}
		}

		public DateParseHandling DateParseHandling
		{
			get
			{
				return _dateParseHandling;
			}
			set
			{
				if (value < DateParseHandling.None || value > DateParseHandling.DateTimeOffset)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dateParseHandling = value;
			}
		}

		public FloatParseHandling FloatParseHandling
		{
			get
			{
				return _floatParseHandling;
			}
			set
			{
				if (value < FloatParseHandling.Double || value > FloatParseHandling.Decimal)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_floatParseHandling = value;
			}
		}

		public string? DateFormatString
		{
			get
			{
				return _dateFormatString;
			}
			set
			{
				_dateFormatString = value;
			}
		}

		public int? MaxDepth
		{
			get
			{
				return _maxDepth;
			}
			set
			{
				if (value <= 0)
				{
					throw new ArgumentException("Value must be positive.", "value");
				}
				_maxDepth = value;
			}
		}

		public virtual JsonToken TokenType => _tokenType;

		public virtual object? Value => _value;

		public virtual Type? ValueType => _value?.GetType();

		public virtual int Depth
		{
			get
			{
				int num = _stack?.Count ?? 0;
				if (JsonTokenUtils.IsStartToken(TokenType) || _currentPosition.Type == JsonContainerType.None)
				{
					return num;
				}
				return num + 1;
			}
		}

		public virtual string Path
		{
			get
			{
				if (_currentPosition.Type == JsonContainerType.None)
				{
					return string.Empty;
				}
				JsonPosition? currentPosition = ((_currentState != State.ArrayStart && _currentState != State.ConstructorStart && _currentState != State.ObjectStart) ? new JsonPosition?(_currentPosition) : ((JsonPosition?)null));
				return JsonPosition.BuildPath(_stack, currentPosition);
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? CultureInfo.InvariantCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public virtual Task<bool> ReadAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return cancellationToken.CancelIfRequestedAsync<bool>() ?? Read().ToAsync();
		}

		public async Task SkipAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (TokenType == JsonToken.PropertyName)
			{
				await ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			if (JsonTokenUtils.IsStartToken(TokenType))
			{
				int depth = Depth;
				while (await ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false) && depth < Depth)
				{
				}
			}
		}

		internal async Task ReaderReadAndAssertAsync(CancellationToken cancellationToken)
		{
			if (!(await ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
			{
				throw CreateUnexpectedEndException();
			}
		}

		public virtual Task<bool?> ReadAsBooleanAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return cancellationToken.CancelIfRequestedAsync<bool?>() ?? Task.FromResult(ReadAsBoolean());
		}

		public virtual Task<byte[]?> ReadAsBytesAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return cancellationToken.CancelIfRequestedAsync<byte[]>() ?? Task.FromResult(ReadAsBytes());
		}

		internal async Task<byte[]?> ReadArrayIntoByteArrayAsync(CancellationToken cancellationToken)
		{
			List<byte> buffer = new List<byte>();
			do
			{
				if (!(await ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
				{
					SetToken(JsonToken.None);
				}
			}
			while (!ReadArrayElementIntoByteArrayReportDone(buffer));
			byte[] array = buffer.ToArray();
			SetToken(JsonToken.Bytes, array, updateIndex: false);
			return array;
		}

		public virtual Task<DateTime?> ReadAsDateTimeAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return cancellationToken.CancelIfRequestedAsync<DateTime?>() ?? Task.FromResult(ReadAsDateTime());
		}

		public virtual Task<DateTimeOffset?> ReadAsDateTimeOffsetAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return cancellationToken.CancelIfRequestedAsync<DateTimeOffset?>() ?? Task.FromResult(ReadAsDateTimeOffset());
		}

		public virtual Task<decimal?> ReadAsDecimalAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return cancellationToken.CancelIfRequestedAsync<decimal?>() ?? Task.FromResult(ReadAsDecimal());
		}

		public virtual Task<double?> ReadAsDoubleAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return Task.FromResult(ReadAsDouble());
		}

		public virtual Task<int?> ReadAsInt32Async(CancellationToken cancellationToken = default(CancellationToken))
		{
			return cancellationToken.CancelIfRequestedAsync<int?>() ?? Task.FromResult(ReadAsInt32());
		}

		public virtual Task<string?> ReadAsStringAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return cancellationToken.CancelIfRequestedAsync<string>() ?? Task.FromResult(ReadAsString());
		}

		internal async Task<bool> ReadAndMoveToContentAsync(CancellationToken cancellationToken)
		{
			bool flag = await ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (flag)
			{
				flag = await MoveToContentAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return flag;
		}

		internal Task<bool> MoveToContentAsync(CancellationToken cancellationToken)
		{
			JsonToken tokenType = TokenType;
			if (tokenType == JsonToken.None || tokenType == JsonToken.Comment)
			{
				return MoveToContentFromNonContentAsync(cancellationToken);
			}
			return AsyncUtils.True;
		}

		private async Task<bool> MoveToContentFromNonContentAsync(CancellationToken cancellationToken)
		{
			JsonToken tokenType;
			do
			{
				if (!(await ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
				{
					return false;
				}
				tokenType = TokenType;
			}
			while (tokenType == JsonToken.None || tokenType == JsonToken.Comment);
			return true;
		}

		internal JsonPosition GetPosition(int depth)
		{
			if (_stack != null && depth < _stack.Count)
			{
				return _stack[depth];
			}
			return _currentPosition;
		}

		protected JsonReader()
		{
			_currentState = State.Start;
			_dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
			_dateParseHandling = DateParseHandling.DateTime;
			_floatParseHandling = FloatParseHandling.Double;
			_maxDepth = 64;
			CloseInput = true;
		}

		private void Push(JsonContainerType value)
		{
			UpdateScopeWithFinishedValue();
			if (_currentPosition.Type == JsonContainerType.None)
			{
				_currentPosition = new JsonPosition(value);
				return;
			}
			if (_stack == null)
			{
				_stack = new List<JsonPosition>();
			}
			_stack.Add(_currentPosition);
			_currentPosition = new JsonPosition(value);
			if (!_maxDepth.HasValue || !(Depth + 1 > _maxDepth) || _hasExceededMaxDepth)
			{
				return;
			}
			_hasExceededMaxDepth = true;
			throw JsonReaderException.Create(this, "The reader's MaxDepth of {0} has been exceeded.".FormatWith(CultureInfo.InvariantCulture, _maxDepth));
		}

		private JsonContainerType Pop()
		{
			JsonPosition currentPosition;
			if (_stack != null && _stack.Count > 0)
			{
				currentPosition = _currentPosition;
				_currentPosition = _stack[_stack.Count - 1];
				_stack.RemoveAt(_stack.Count - 1);
			}
			else
			{
				currentPosition = _currentPosition;
				_currentPosition = default(JsonPosition);
			}
			if (_maxDepth.HasValue && Depth <= _maxDepth)
			{
				_hasExceededMaxDepth = false;
			}
			return currentPosition.Type;
		}

		private JsonContainerType Peek()
		{
			return _currentPosition.Type;
		}

		public abstract bool Read();

		public virtual int? ReadAsInt32()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Integer:
			case JsonToken.Float:
			{
				object value = Value;
				if (value is int)
				{
					return (int)value;
				}
				int num;
				if (value is BigInteger bigInteger)
				{
					num = (int)bigInteger;
				}
				else
				{
					try
					{
						num = Convert.ToInt32(value, CultureInfo.InvariantCulture);
					}
					catch (Exception ex)
					{
						throw JsonReaderException.Create(this, "Could not convert to integer: {0}.".FormatWith(CultureInfo.InvariantCulture, value), ex);
					}
				}
				SetToken(JsonToken.Integer, num, updateIndex: false);
				return num;
			}
			case JsonToken.String:
			{
				string s = (string)Value;
				return ReadInt32String(s);
			}
			default:
				throw JsonReaderException.Create(this, "Error reading integer. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal int? ReadInt32String(string? s)
		{
			if (StringUtils.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (int.TryParse(s, NumberStyles.Integer, Culture, out var result))
			{
				SetToken(JsonToken.Integer, result, updateIndex: false);
				return result;
			}
			SetToken(JsonToken.String, s, updateIndex: false);
			throw JsonReaderException.Create(this, "Could not convert string to integer: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		public virtual string? ReadAsString()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.String:
				return (string)Value;
			default:
				if (JsonTokenUtils.IsPrimitiveToken(contentToken))
				{
					object value = Value;
					if (value != null)
					{
						string text = ((!(value is IFormattable formattable)) ? ((value is Uri uri) ? uri.OriginalString : value.ToString()) : formattable.ToString(null, Culture));
						SetToken(JsonToken.String, text, updateIndex: false);
						return text;
					}
				}
				throw JsonReaderException.Create(this, "Error reading string. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		public virtual byte[]? ReadAsBytes()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.StartObject:
			{
				ReadIntoWrappedTypeObject();
				byte[] array2 = ReadAsBytes();
				ReaderReadAndAssert();
				if (TokenType != JsonToken.EndObject)
				{
					throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
				}
				SetToken(JsonToken.Bytes, array2, updateIndex: false);
				return array2;
			}
			case JsonToken.String:
			{
				string text = (string)Value;
				Guid g;
				byte[] array3 = ((text.Length == 0) ? CollectionUtils.ArrayEmpty<byte>() : ((!ConvertUtils.TryConvertGuid(text, out g)) ? Convert.FromBase64String(text) : g.ToByteArray()));
				SetToken(JsonToken.Bytes, array3, updateIndex: false);
				return array3;
			}
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Bytes:
				if (Value is Guid guid)
				{
					byte[] array = guid.ToByteArray();
					SetToken(JsonToken.Bytes, array, updateIndex: false);
					return array;
				}
				return (byte[])Value;
			case JsonToken.StartArray:
				return ReadArrayIntoByteArray();
			default:
				throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal byte[] ReadArrayIntoByteArray()
		{
			List<byte> list = new List<byte>();
			do
			{
				if (!Read())
				{
					SetToken(JsonToken.None);
				}
			}
			while (!ReadArrayElementIntoByteArrayReportDone(list));
			byte[] array = list.ToArray();
			SetToken(JsonToken.Bytes, array, updateIndex: false);
			return array;
		}

		private bool ReadArrayElementIntoByteArrayReportDone(List<byte> buffer)
		{
			switch (TokenType)
			{
			case JsonToken.None:
				throw JsonReaderException.Create(this, "Unexpected end when reading bytes.");
			case JsonToken.Integer:
				buffer.Add(Convert.ToByte(Value, CultureInfo.InvariantCulture));
				return false;
			case JsonToken.EndArray:
				return true;
			case JsonToken.Comment:
				return false;
			default:
				throw JsonReaderException.Create(this, "Unexpected token when reading bytes: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
			}
		}

		public virtual double? ReadAsDouble()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Integer:
			case JsonToken.Float:
			{
				object value = Value;
				if (value is double)
				{
					return (double)value;
				}
				double num = ((!(value is BigInteger bigInteger)) ? Convert.ToDouble(value, CultureInfo.InvariantCulture) : ((double)bigInteger));
				SetToken(JsonToken.Float, num, updateIndex: false);
				return num;
			}
			case JsonToken.String:
				return ReadDoubleString((string)Value);
			default:
				throw JsonReaderException.Create(this, "Error reading double. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal double? ReadDoubleString(string? s)
		{
			if (StringUtils.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (double.TryParse(s, NumberStyles.Float | NumberStyles.AllowThousands, Culture, out var result))
			{
				SetToken(JsonToken.Float, result, updateIndex: false);
				return result;
			}
			SetToken(JsonToken.String, s, updateIndex: false);
			throw JsonReaderException.Create(this, "Could not convert string to double: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		public virtual bool? ReadAsBoolean()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Integer:
			case JsonToken.Float:
			{
				bool flag = ((!(Value is BigInteger bigInteger)) ? Convert.ToBoolean(Value, CultureInfo.InvariantCulture) : (bigInteger != 0L));
				SetToken(JsonToken.Boolean, flag, updateIndex: false);
				return flag;
			}
			case JsonToken.String:
				return ReadBooleanString((string)Value);
			case JsonToken.Boolean:
				return (bool)Value;
			default:
				throw JsonReaderException.Create(this, "Error reading boolean. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal bool? ReadBooleanString(string? s)
		{
			if (StringUtils.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (bool.TryParse(s, out var result))
			{
				SetToken(JsonToken.Boolean, result, updateIndex: false);
				return result;
			}
			SetToken(JsonToken.String, s, updateIndex: false);
			throw JsonReaderException.Create(this, "Could not convert string to boolean: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		public virtual decimal? ReadAsDecimal()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Integer:
			case JsonToken.Float:
			{
				object value = Value;
				if (value is decimal)
				{
					return (decimal)value;
				}
				decimal num;
				if (value is BigInteger bigInteger)
				{
					num = (decimal)bigInteger;
				}
				else
				{
					try
					{
						num = Convert.ToDecimal(value, CultureInfo.InvariantCulture);
					}
					catch (Exception ex)
					{
						throw JsonReaderException.Create(this, "Could not convert to decimal: {0}.".FormatWith(CultureInfo.InvariantCulture, value), ex);
					}
				}
				SetToken(JsonToken.Float, num, updateIndex: false);
				return num;
			}
			case JsonToken.String:
				return ReadDecimalString((string)Value);
			default:
				throw JsonReaderException.Create(this, "Error reading decimal. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal decimal? ReadDecimalString(string? s)
		{
			if (StringUtils.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (decimal.TryParse(s, NumberStyles.Number, Culture, out var result))
			{
				SetToken(JsonToken.Float, result, updateIndex: false);
				return result;
			}
			if (ConvertUtils.DecimalTryParse(s.ToCharArray(), 0, s.Length, out result) == ParseResult.Success)
			{
				SetToken(JsonToken.Float, result, updateIndex: false);
				return result;
			}
			SetToken(JsonToken.String, s, updateIndex: false);
			throw JsonReaderException.Create(this, "Could not convert string to decimal: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		public virtual DateTime? ReadAsDateTime()
		{
			switch (GetContentToken())
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Date:
				if (Value is DateTimeOffset dateTimeOffset)
				{
					SetToken(JsonToken.Date, dateTimeOffset.DateTime, updateIndex: false);
				}
				return (DateTime)Value;
			case JsonToken.String:
				return ReadDateTimeString((string)Value);
			default:
				throw JsonReaderException.Create(this, "Error reading date. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
			}
		}

		internal DateTime? ReadDateTimeString(string? s)
		{
			if (StringUtils.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (DateTimeUtils.TryParseDateTime(s, DateTimeZoneHandling, _dateFormatString, Culture, out var dt))
			{
				dt = DateTimeUtils.EnsureDateTime(dt, DateTimeZoneHandling);
				SetToken(JsonToken.Date, dt, updateIndex: false);
				return dt;
			}
			if (DateTime.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))
			{
				dt = DateTimeUtils.EnsureDateTime(dt, DateTimeZoneHandling);
				SetToken(JsonToken.Date, dt, updateIndex: false);
				return dt;
			}
			throw JsonReaderException.Create(this, "Could not convert string to DateTime: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		public virtual DateTimeOffset? ReadAsDateTimeOffset()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Date:
				if (Value is DateTime dateTime)
				{
					SetToken(JsonToken.Date, new DateTimeOffset(dateTime), updateIndex: false);
				}
				return (DateTimeOffset)Value;
			case JsonToken.String:
			{
				string s = (string)Value;
				return ReadDateTimeOffsetString(s);
			}
			default:
				throw JsonReaderException.Create(this, "Error reading date. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal DateTimeOffset? ReadDateTimeOffsetString(string? s)
		{
			if (StringUtils.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (DateTimeUtils.TryParseDateTimeOffset(s, _dateFormatString, Culture, out var dt))
			{
				SetToken(JsonToken.Date, dt, updateIndex: false);
				return dt;
			}
			if (DateTimeOffset.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))
			{
				SetToken(JsonToken.Date, dt, updateIndex: false);
				return dt;
			}
			SetToken(JsonToken.String, s, updateIndex: false);
			throw JsonReaderException.Create(this, "Could not convert string to DateTimeOffset: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		internal void ReaderReadAndAssert()
		{
			if (!Read())
			{
				throw CreateUnexpectedEndException();
			}
		}

		internal JsonReaderException CreateUnexpectedEndException()
		{
			return JsonReaderException.Create(this, "Unexpected end when reading JSON.");
		}

		internal void ReadIntoWrappedTypeObject()
		{
			ReaderReadAndAssert();
			if (Value != null && Value.ToString() == "$type")
			{
				ReaderReadAndAssert();
				if (Value != null && Value.ToString().StartsWith("System.Byte[]", StringComparison.Ordinal))
				{
					ReaderReadAndAssert();
					if (Value.ToString() == "$value")
					{
						return;
					}
				}
			}
			throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, JsonToken.StartObject));
		}

		public void Skip()
		{
			if (TokenType == JsonToken.PropertyName)
			{
				Read();
			}
			if (JsonTokenUtils.IsStartToken(TokenType))
			{
				int depth = Depth;
				while (Read() && depth < Depth)
				{
				}
			}
		}

		protected void SetToken(JsonToken newToken)
		{
			SetToken(newToken, null, updateIndex: true);
		}

		protected void SetToken(JsonToken newToken, object? value)
		{
			SetToken(newToken, value, updateIndex: true);
		}

		protected void SetToken(JsonToken newToken, object? value, bool updateIndex)
		{
			_tokenType = newToken;
			_value = value;
			switch (newToken)
			{
			case JsonToken.StartObject:
				_currentState = State.ObjectStart;
				Push(JsonContainerType.Object);
				break;
			case JsonToken.StartArray:
				_currentState = State.ArrayStart;
				Push(JsonContainerType.Array);
				break;
			case JsonToken.StartConstructor:
				_currentState = State.ConstructorStart;
				Push(JsonContainerType.Constructor);
				break;
			case JsonToken.EndObject:
				ValidateEnd(JsonToken.EndObject);
				break;
			case JsonToken.EndArray:
				ValidateEnd(JsonToken.EndArray);
				break;
			case JsonToken.EndConstructor:
				ValidateEnd(JsonToken.EndConstructor);
				break;
			case JsonToken.PropertyName:
				_currentState = State.Property;
				_currentPosition.PropertyName = (string)value;
				break;
			case JsonToken.Raw:
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				SetPostValueState(updateIndex);
				break;
			case JsonToken.Comment:
				break;
			}
		}

		internal void SetPostValueState(bool updateIndex)
		{
			if (Peek() != JsonContainerType.None || SupportMultipleContent)
			{
				_currentState = State.PostValue;
			}
			else
			{
				SetFinished();
			}
			if (updateIndex)
			{
				UpdateScopeWithFinishedValue();
			}
		}

		private void UpdateScopeWithFinishedValue()
		{
			if (_currentPosition.HasIndex)
			{
				_currentPosition.Position++;
			}
		}

		private void ValidateEnd(JsonToken endToken)
		{
			JsonContainerType jsonContainerType = Pop();
			if (GetTypeForCloseToken(endToken) != jsonContainerType)
			{
				throw JsonReaderException.Create(this, "JsonToken {0} is not valid for closing JsonType {1}.".FormatWith(CultureInfo.InvariantCulture, endToken, jsonContainerType));
			}
			if (Peek() != JsonContainerType.None || SupportMultipleContent)
			{
				_currentState = State.PostValue;
			}
			else
			{
				SetFinished();
			}
		}

		protected void SetStateBasedOnCurrent()
		{
			JsonContainerType jsonContainerType = Peek();
			switch (jsonContainerType)
			{
			case JsonContainerType.Object:
				_currentState = State.Object;
				break;
			case JsonContainerType.Array:
				_currentState = State.Array;
				break;
			case JsonContainerType.Constructor:
				_currentState = State.Constructor;
				break;
			case JsonContainerType.None:
				SetFinished();
				break;
			default:
				throw JsonReaderException.Create(this, "While setting the reader state back to current object an unexpected JsonType was encountered: {0}".FormatWith(CultureInfo.InvariantCulture, jsonContainerType));
			}
		}

		private void SetFinished()
		{
			_currentState = ((!SupportMultipleContent) ? State.Finished : State.Start);
		}

		private JsonContainerType GetTypeForCloseToken(JsonToken token)
		{
			return token switch
			{
				JsonToken.EndObject => JsonContainerType.Object, 
				JsonToken.EndArray => JsonContainerType.Array, 
				JsonToken.EndConstructor => JsonContainerType.Constructor, 
				_ => throw JsonReaderException.Create(this, "Not a valid close JsonToken: {0}".FormatWith(CultureInfo.InvariantCulture, token)), 
			};
		}

		void IDisposable.Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (_currentState != State.Closed && disposing)
			{
				Close();
			}
		}

		public virtual void Close()
		{
			_currentState = State.Closed;
			_tokenType = JsonToken.None;
			_value = null;
		}

		internal void ReadAndAssert()
		{
			if (!Read())
			{
				throw JsonSerializationException.Create(this, "Unexpected end when reading JSON.");
			}
		}

		internal void ReadForTypeAndAssert(JsonContract? contract, bool hasConverter)
		{
			if (!ReadForType(contract, hasConverter))
			{
				throw JsonSerializationException.Create(this, "Unexpected end when reading JSON.");
			}
		}

		internal bool ReadForType(JsonContract? contract, bool hasConverter)
		{
			if (hasConverter)
			{
				return Read();
			}
			switch (contract?.InternalReadType ?? ReadType.Read)
			{
			case ReadType.Read:
				return ReadAndMoveToContent();
			case ReadType.ReadAsInt32:
				ReadAsInt32();
				break;
			case ReadType.ReadAsInt64:
			{
				bool result = ReadAndMoveToContent();
				if (TokenType == JsonToken.Undefined)
				{
					throw JsonReaderException.Create(this, "An undefined token is not a valid {0}.".FormatWith(CultureInfo.InvariantCulture, contract?.UnderlyingType ?? typeof(long)));
				}
				return result;
			}
			case ReadType.ReadAsDecimal:
				ReadAsDecimal();
				break;
			case ReadType.ReadAsDouble:
				ReadAsDouble();
				break;
			case ReadType.ReadAsBytes:
				ReadAsBytes();
				break;
			case ReadType.ReadAsBoolean:
				ReadAsBoolean();
				break;
			case ReadType.ReadAsString:
				ReadAsString();
				break;
			case ReadType.ReadAsDateTime:
				ReadAsDateTime();
				break;
			case ReadType.ReadAsDateTimeOffset:
				ReadAsDateTimeOffset();
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
			return TokenType != JsonToken.None;
		}

		internal bool ReadAndMoveToContent()
		{
			if (Read())
			{
				return MoveToContent();
			}
			return false;
		}

		internal bool MoveToContent()
		{
			JsonToken tokenType = TokenType;
			while (tokenType == JsonToken.None || tokenType == JsonToken.Comment)
			{
				if (!Read())
				{
					return false;
				}
				tokenType = TokenType;
			}
			return true;
		}

		private JsonToken GetContentToken()
		{
			JsonToken tokenType;
			do
			{
				if (!Read())
				{
					SetToken(JsonToken.None);
					return JsonToken.None;
				}
				tokenType = TokenType;
			}
			while (tokenType == JsonToken.Comment);
			return tokenType;
		}
	}
	[Serializable]
	internal class JsonReaderException : JsonException
	{
		public int LineNumber { get; }

		public int LinePosition { get; }

		public string? Path { get; }

		public JsonReaderException()
		{
		}

		public JsonReaderException(string message)
			: base(message)
		{
		}

		public JsonReaderException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonReaderException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		public JsonReaderException(string message, string path, int lineNumber, int linePosition, Exception? innerException)
			: base(message, innerException)
		{
			Path = path;
			LineNumber = lineNumber;
			LinePosition = linePosition;
		}

		internal static JsonReaderException Create(JsonReader reader, string message)
		{
			return Create(reader, message, null);
		}

		internal static JsonReaderException Create(JsonReader reader, string message, Exception? ex)
		{
			return Create(reader as IJsonLineInfo, reader.Path, message, ex);
		}

		internal static JsonReaderException Create(IJsonLineInfo? lineInfo, string path, string message, Exception? ex)
		{
			message = JsonPosition.FormatMessage(lineInfo, path, message);
			int lineNumber;
			int linePosition;
			if (lineInfo != null && lineInfo.HasLineInfo())
			{
				lineNumber = lineInfo.LineNumber;
				linePosition = lineInfo.LinePosition;
			}
			else
			{
				lineNumber = 0;
				linePosition = 0;
			}
			return new JsonReaderException(message, path, lineNumber, linePosition, ex);
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	internal sealed class JsonRequiredAttribute : Attribute
	{
	}
	[Serializable]
	internal class JsonSerializationException : JsonException
	{
		public int LineNumber { get; }

		public int LinePosition { get; }

		public string? Path { get; }

		public JsonSerializationException()
		{
		}

		public JsonSerializationException(string message)
			: base(message)
		{
		}

		public JsonSerializationException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonSerializationException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		public JsonSerializationException(string message, string path, int lineNumber, int linePosition, Exception? innerException)
			: base(message, innerException)
		{
			Path = path;
			LineNumber = lineNumber;
			LinePosition = linePosition;
		}

		internal static JsonSerializationException Create(JsonReader reader, string message)
		{
			return Create(reader, message, null);
		}

		internal static JsonSerializationException Create(JsonReader reader, string message, Exception? ex)
		{
			return Create(reader as IJsonLineInfo, reader.Path, message, ex);
		}

		internal static JsonSerializationException Create(IJsonLineInfo? lineInfo, string path, string message, Exception? ex)
		{
			message = JsonPosition.FormatMessage(lineInfo, path, message);
			int lineNumber;
			int linePosition;
			if (lineInfo != null && lineInfo.HasLineInfo())
			{
				lineNumber = lineInfo.LineNumber;
				linePosition = lineInfo.LinePosition;
			}
			else
			{
				lineNumber = 0;
				linePosition = 0;
			}
			return new JsonSerializationException(message, path, lineNumber, linePosition, ex);
		}
	}
	internal class JsonSerializer
	{
		internal TypeNameHandling _typeNameHandling;

		internal TypeNameAssemblyFormatHandling _typeNameAssemblyFormatHandling;

		internal PreserveReferencesHandling _preserveReferencesHandling;

		internal ReferenceLoopHandling _referenceLoopHandling;

		internal MissingMemberHandling _missingMemberHandling;

		internal ObjectCreationHandling _objectCreationHandling;

		internal NullValueHandling _nullValueHandling;

		internal DefaultValueHandling _defaultValueHandling;

		internal ConstructorHandling _constructorHandling;

		internal MetadataPropertyHandling _metadataPropertyHandling;

		internal JsonConverterCollection? _converters;

		internal IContractResolver _contractResolver;

		internal ITraceWriter? _traceWriter;

		internal IEqualityComparer? _equalityComparer;

		internal ISerializationBinder _serializationBinder;

		internal StreamingContext _context;

		private IReferenceResolver? _referenceResolver;

		private Formatting? _formatting;

		private DateFormatHandling? _dateFormatHandling;

		private DateTimeZoneHandling? _dateTimeZoneHandling;

		private DateParseHandling? _dateParseHandling;

		private FloatFormatHandling? _floatFormatHandling;

		private FloatParseHandling? _floatParseHandling;

		private StringEscapeHandling? _stringEscapeHandling;

		private CultureInfo _culture;

		private int? _maxDepth;

		private bool _maxDepthSet;

		private bool? _checkAdditionalContent;

		private string? _dateFormatString;

		private bool _dateFormatStringSet;

		public virtual IReferenceResolver? ReferenceResolver
		{
			get
			{
				return GetReferenceResolver();
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value", "Reference resolver cannot be null.");
				}
				_referenceResolver = value;
			}
		}

		[Obsolete("Binder is obsolete. Use SerializationBinder instead.")]
		public virtual SerializationBinder Binder
		{
			get
			{
				if (_serializationBinder is SerializationBinder result)
				{
					return result;
				}
				if (_serializationBinder is SerializationBinderAdapter serializationBinderAdapter)
				{
					return serializationBinderAdapter.SerializationBinder;
				}
				throw new InvalidOperationException("Cannot get SerializationBinder because an ISerializationBinder was previously set.");
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value", "Serialization binder cannot be null.");
				}
				_serializationBinder = (value as ISerializationBinder) ?? new SerializationBinderAdapter(value);
			}
		}

		public virtual ISerializationBinder SerializationBinder
		{
			get
			{
				return _serializationBinder;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value", "Serialization binder cannot be null.");
				}
				_serializationBinder = value;
			}
		}

		public virtual ITraceWriter? TraceWriter
		{
			get
			{
				return _traceWriter;
			}
			set
			{
				_traceWriter = value;
			}
		}

		public virtual IEqualityComparer? EqualityComparer
		{
			get
			{
				return _equalityComparer;
			}
			set
			{
				_equalityComparer = value;
			}
		}

		public virtual TypeNameHandling TypeNameHandling
		{
			get
			{
				return _typeNameHandling;
			}
			set
			{
				if (value < TypeNameHandling.None || value > TypeNameHandling.Auto)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_typeNameHandling = value;
			}
		}

		[Obsolete("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
		public virtual FormatterAssemblyStyle TypeNameAssemblyFormat
		{
			get
			{
				return (FormatterAssemblyStyle)_typeNameAssemblyFormatHandling;
			}
			set
			{
				if (value < FormatterAssemblyStyle.Simple || value > FormatterAssemblyStyle.Full)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_typeNameAssemblyFormatHandling = (TypeNameAssemblyFormatHandling)value;
			}
		}

		public virtual TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling
		{
			get
			{
				return _typeNameAssemblyFormatHandling;
			}
			set
			{
				if (value < TypeNameAssemblyFormatHandling.Simple || value > TypeNameAssemblyFormatHandling.Full)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_typeNameAssemblyFormatHandling = value;
			}
		}

		public virtual PreserveReferencesHandling PreserveReferencesHandling
		{
			get
			{
				return _preserveReferencesHandling;
			}
			set
			{
				if (value < PreserveReferencesHandling.None || value > PreserveReferencesHandling.All)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_preserveReferencesHandling = value;
			}
		}

		public virtual ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _referenceLoopHandling;
			}
			set
			{
				if (value < ReferenceLoopHandling.Error || value > ReferenceLoopHandling.Serialize)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_referenceLoopHandling = value;
			}
		}

		public virtual MissingMemberHandling MissingMemberHandling
		{
			get
			{
				return _missingMemberHandling;
			}
			set
			{
				if (value < MissingMemberHandling.Ignore || value > MissingMemberHandling.Error)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_missingMemberHandling = value;
			}
		}

		public virtual NullValueHandling NullValueHandling
		{
			get
			{
				return _nullValueHandling;
			}
			set
			{
				if (value < NullValueHandling.Include || value > NullValueHandling.Ignore)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_nullValueHandling = value;
			}
		}

		public virtual DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _defaultValueHandling;
			}
			set
			{
				if (value < DefaultValueHandling.Include || value > DefaultValueHandling.IgnoreAndPopulate)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_defaultValueHandling = value;
			}
		}

		public virtual ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _objectCreationHandling;
			}
			set
			{
				if (value < ObjectCreationHandling.Auto || value > ObjectCreationHandling.Replace)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_objectCreationHandling = value;
			}
		}

		public virtual ConstructorHandling ConstructorHandling
		{
			get
			{
				return _constructorHandling;
			}
			set
			{
				if (value < ConstructorHandling.Default || value > ConstructorHandling.AllowNonPublicDefaultConstructor)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_constructorHandling = value;
			}
		}

		public virtual MetadataPropertyHandling MetadataPropertyHandling
		{
			get
			{
				return _metadataPropertyHandling;
			}
			set
			{
				if (value < MetadataPropertyHandling.Default || value > MetadataPropertyHandling.Ignore)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_metadataPropertyHandling = value;
			}
		}

		public virtual JsonConverterCollection Converters
		{
			get
			{
				if (_converters == null)
				{
					_converters = new JsonConverterCollection();
				}
				return _converters;
			}
		}

		public virtual IContractResolver ContractResolver
		{
			get
			{
				return _contractResolver;
			}
			set
			{
				_contractResolver = value ?? DefaultContractResolver.Instance;
			}
		}

		public virtual StreamingContext Context
		{
			get
			{
				return _context;
			}
			set
			{
				_context = value;
			}
		}

		public virtual Formatting Formatting
		{
			get
			{
				return _formatting.GetValueOrDefault();
			}
			set
			{
				_formatting = value;
			}
		}

		public virtual DateFormatHandling DateFormatHandling
		{
			get
			{
				return _dateFormatHandling.GetValueOrDefault();
			}
			set
			{
				_dateFormatHandling = value;
			}
		}

		public virtual DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _dateTimeZoneHandling ?? DateTimeZoneHandling.RoundtripKind;
			}
			set
			{
				_dateTimeZoneHandling = value;
			}
		}

		public virtual DateParseHandling DateParseHandling
		{
			get
			{
				return _dateParseHandling ?? DateParseHandling.DateTime;
			}
			set
			{
				_dateParseHandling = value;
			}
		}

		public virtual FloatParseHandling FloatParseHandling
		{
			get
			{
				return _floatParseHandling.GetValueOrDefault();
			}
			set
			{
				_floatParseHandling = value;
			}
		}

		public virtual FloatFormatHandling FloatFormatHandling
		{
			get
			{
				return _floatFormatHandling.GetValueOrDefault();
			}
			set
			{
				_floatFormatHandling = value;
			}
		}

		public virtual StringEscapeHandling StringEscapeHandling
		{
			get
			{
				return _stringEscapeHandling.GetValueOrDefault();
			}
			set
			{
				_stringEscapeHandling = value;
			}
		}

		public virtual string DateFormatString
		{
			get
			{
				return _dateFormatString ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
			}
			set
			{
				_dateFormatString = value;
				_dateFormatStringSet = true;
			}
		}

		public virtual CultureInfo Culture
		{
			get
			{
				return _culture ?? JsonSerializerSettings.DefaultCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public virtual int? MaxDepth
		{
			get
			{
				return _maxDepth;
			}
			set
			{
				if (value <= 0)
				{
					throw new ArgumentException("Value must be positive.", "value");
				}
				_maxDepth = value;
				_maxDepthSet = true;
			}
		}

		public virtual bool CheckAdditionalContent
		{
			get
			{
				return _checkAdditionalContent == true;
			}
			set
			{
				_checkAdditionalContent = value;
			}
		}

		public virtual event EventHandler<Microsoft.Identity.Json.Serialization.ErrorEventArgs>? Error;

		internal bool IsCheckAdditionalContentSet()
		{
			return _checkAdditionalContent.HasValue;
		}

		public JsonSerializer()
		{
			_referenceLoopHandling = ReferenceLoopHandling.Error;
			_missingMemberHandling = MissingMemberHandling.Ignore;
			_nullValueHandling = NullValueHandling.Include;
			_defaultValueHandling = DefaultValueHandling.Include;
			_objectCreationHandling = ObjectCreationHandling.Auto;
			_preserveReferencesHandling = PreserveReferencesHandling.None;
			_constructorHandling = ConstructorHandling.Default;
			_typeNameHandling = TypeNameHandling.None;
			_metadataPropertyHandling = MetadataPropertyHandling.Default;
			_context = JsonSerializerSettings.DefaultContext;
			_serializationBinder = DefaultSerializationBinder.Instance;
			_culture = JsonSerializerSettings.DefaultCulture;
			_contractResolver = DefaultContractResolver.Instance;
		}

		public static JsonSerializer Create()
		{
			return new JsonSerializer();
		}

		public static JsonSerializer Create(JsonSerializerSettings? settings)
		{
			JsonSerializer jsonSerializer = Create();
			if (settings != null)
			{
				ApplySerializerSettings(jsonSerializer, settings);
			}
			return jsonSerializer;
		}

		public static JsonSerializer CreateDefault()
		{
			return Create(JsonConvert.DefaultSettings?.Invoke());
		}

		public static JsonSerializer CreateDefault(JsonSerializerSettings? settings)
		{
			JsonSerializer jsonSerializer = CreateDefault();
			if (settings != null)
			{
				ApplySerializerSettings(jsonSerializer, settings);
			}
			return jsonSerializer;
		}

		private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings)
		{
			if (!CollectionUtils.IsNullOrEmpty(settings.Converters))
			{
				for (int i = 0; i < settings.Converters.Count; i++)
				{
					serializer.Converters.Insert(i, settings.Converters[i]);
				}
			}
			if (settings._typeNameHandling.HasValue)
			{
				serializer.TypeNameHandling = settings.TypeNameHandling;
			}
			if (settings._metadataPropertyHandling.HasValue)
			{
				serializer.MetadataPropertyHandling = settings.MetadataPropertyHandling;
			}
			if (settings._typeNameAssemblyFormatHandling.HasValue)
			{
				serializer.TypeNameAssemblyFormatHandling = settings.TypeNameAssemblyFormatHandling;
			}
			if (settings._preserveReferencesHandling.HasValue)
			{
				serializer.PreserveReferencesHandling = settings.PreserveReferencesHandling;
			}
			if (settings._referenceLoopHandling.HasValue)
			{
				serializer.ReferenceLoopHandling = settings.ReferenceLoopHandling;
			}
			if (settings._missingMemberHandling.HasValue)
			{
				serializer.MissingMemberHandling = settings.MissingMemberHandling;
			}
			if (settings._objectCreationHandling.HasValue)
			{
				serializer.ObjectCreationHandling = settings.ObjectCreationHandling;
			}
			if (settings._nullValueHandling.HasValue)
			{
				serializer.NullValueHandling = settings.NullValueHandling;
			}
			if (settings._defaultValueHandling.HasValue)
			{
				serializer.DefaultValueHandling = settings.DefaultValueHandling;
			}
			if (settings._constructorHandling.HasValue)
			{
				serializer.ConstructorHandling = settings.ConstructorHandling;
			}
			if (settings._context.HasValue)
			{
				serializer.Context = settings.Context;
			}
			if (settings._checkAdditionalContent.HasValue)
			{
				serializer._checkAdditionalContent = settings._checkAdditionalContent;
			}
			if (settings.Error != null)
			{
				serializer.Error += settings.Error;
			}
			if (settings.ContractResolver != null)
			{
				serializer.ContractResolver = settings.ContractResolver;
			}
			if (settings.ReferenceResolverProvider != null)
			{
				serializer.ReferenceResolver = settings.ReferenceResolverProvider();
			}
			if (settings.TraceWriter != null)
			{
				serializer.TraceWriter = settings.TraceWriter;
			}
			if (settings.EqualityComparer != null)
			{
				serializer.EqualityComparer = settings.EqualityComparer;
			}
			if (settings.SerializationBinder != null)
			{
				serializer.SerializationBinder = settings.SerializationBinder;
			}
			if (settings._formatting.HasValue)
			{
				serializer._formatting = settings._formatting;
			}
			if (settings._dateFormatHandling.HasValue)
			{
				serializer._dateFormatHandling = settings._dateFormatHandling;
			}
			if (settings._dateTimeZoneHandling.HasValue)
			{
				serializer._dateTimeZoneHandling = settings._dateTimeZoneHandling;
			}
			if (settings._dateParseHandling.HasValue)
			{
				serializer._dateParseHandling = settings._dateParseHandling;
			}
			if (settings._dateFormatStringSet)
			{
				serializer._dateFormatString = settings._dateFormatString;
				serializer._dateFormatStringSet = settings._dateFormatStringSet;
			}
			if (settings._floatFormatHandling.HasValue)
			{
				serializer._floatFormatHandling = settings._floatFormatHandling;
			}
			if (settings._floatParseHandling.HasValue)
			{
				serializer._floatParseHandling = settings._floatParseHandling;
			}
			if (settings._stringEscapeHandling.HasValue)
			{
				serializer._stringEscapeHandling = settings._stringEscapeHandling;
			}
			if (settings._culture != null)
			{
				serializer._culture = settings._culture;
			}
			if (settings._maxDepthSet)
			{
				serializer._maxDepth = settings._maxDepth;
				serializer._maxDepthSet = settings._maxDepthSet;
			}
		}

		[DebuggerStepThrough]
		public void Populate(TextReader reader, object target)
		{
			Populate(new JsonTextReader(reader), target);
		}

		[DebuggerStepThrough]
		public void Populate(JsonReader reader, object target)
		{
			PopulateInternal(reader, target);
		}

		internal virtual void PopulateInternal(JsonReader reader, object target)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			ValidationUtils.ArgumentNotNull(target, "target");
			SetupReader(reader, out CultureInfo previousCulture, out DateTimeZoneHandling? previousDateTimeZoneHandling, out DateParseHandling? previousDateParseHandling, out FloatParseHandling? previousFloatParseHandling, out int? previousMaxDepth, out string previousDateFormatString);
			TraceJsonReader traceJsonReader = ((TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose) ? CreateTraceJsonReader(reader) : null);
			new JsonSerializerInternalReader(this).Populate(traceJsonReader ?? reader, target);
			if (traceJsonReader != null)
			{
				TraceWriter.Trace(TraceLevel.Verbose, traceJsonReader.GetDeserializedJsonMessage(), null);
			}
			ResetReader(reader, previousCulture, previousDateTimeZoneHandling, previousDateParseHandling, previousFloatParseHandling, previousMaxDepth, previousDateFormatString);
		}

		[DebuggerStepThrough]
		public object? Deserialize(JsonReader reader)
		{
			return Deserialize(reader, null);
		}

		[DebuggerStepThrough]
		public object? Deserialize(TextReader reader, Type objectType)
		{
			return Deserialize(new JsonTextReader(reader), objectType);
		}

		[DebuggerStepThrough]
		public T? Deserialize<T>(JsonReader reader)
		{
			return (T)Deserialize(reader, typeof(T));
		}

		[DebuggerStepThrough]
		public object? Deserialize(JsonReader reader, Type? objectType)
		{
			return DeserializeInternal(reader, objectType);
		}

		internal virtual object? DeserializeInternal(JsonReader reader, Type? objectType)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			SetupReader(reader, out CultureInfo previousCulture, out DateTimeZoneHandling? previousDateTimeZoneHandling, out DateParseHandling? previousDateParseHandling, out FloatParseHandling? previousFloatParseHandling, out int? previousMaxDepth, out string previousDateFormatString);
			TraceJsonReader traceJsonReader = ((TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose) ? CreateTraceJsonReader(reader) : null);
			object? result = new JsonSerializerInternalReader(this).Deserialize(traceJsonReader ?? reader, objectType, CheckAdditionalContent);
			if (traceJsonReader != null)
			{
				TraceWriter.Trace(TraceLevel.Verbose, traceJsonReader.GetDeserializedJsonMessage(), null);
			}
			ResetReader(reader, previousCulture, previousDateTimeZoneHandling, previousDateParseHandling, previousFloatParseHandling, previousMaxDepth, previousDateFormatString);
			return result;
		}

		private void SetupReader(JsonReader reader, out CultureInfo? previousCulture, out DateTimeZoneHandling? previousDateTimeZoneHandling, out DateParseHandling? previousDateParseHandling, out FloatParseHandling? previousFloatParseHandling, out int? previousMaxDepth, out string? previousDateFormatString)
		{
			if (_culture != null && !_culture.Equals(reader.Culture))
			{
				previousCulture = reader.Culture;
				reader.Culture = _culture;
			}
			else
			{
				previousCulture = null;
			}
			if (_dateTimeZoneHandling.HasValue && reader.DateTimeZoneHandling != _dateTimeZoneHandling)
			{
				previousDateTimeZoneHandling = reader.DateTimeZoneHandling;
				reader.DateTimeZoneHandling = _dateTimeZoneHandling.GetValueOrDefault();
			}
			else
			{
				previousDateTimeZoneHandling = null;
			}
			if (_dateParseHandling.HasValue && reader.DateParseHandling != _dateParseHandling)
			{
				previousDateParseHandling = reader.DateParseHandling;
				reader.DateParseHandling = _dateParseHandling.GetValueOrDefault();
			}
			else
			{
				previousDateParseHandling = null;
			}
			if (_floatParseHandling.HasValue && reader.FloatParseHandling != _floatParseHandling)
			{
				previousFloatParseHandling = reader.FloatParseHandling;
				reader.FloatParseHandling = _floatParseHandling.GetValueOrDefault();
			}
			else
			{
				previousFloatParseHandling = null;
			}
			if (_maxDepthSet && reader.MaxDepth != _maxDepth)
			{
				previousMaxDepth = reader.MaxDepth;
				reader.MaxDepth = _maxDepth;
			}
			else
			{
				previousMaxDepth = null;
			}
			if (_dateFormatStringSet && reader.DateFormatString != _dateFormatString)
			{
				previousDateFormatString = reader.DateFormatString;
				reader.DateFormatString = _dateFormatString;
			}
			else
			{
				previousDateFormatString = null;
			}
			if (reader is JsonTextReader { PropertyNameTable: null } jsonTextReader && _contractResolver is DefaultContractResolver defaultContractResolver)
			{
				jsonTextReader.PropertyNameTable = defaultContractResolver.GetNameTable();
			}
		}

		private void ResetReader(JsonReader reader, CultureInfo? previousCulture, DateTimeZoneHandling? previousDateTimeZoneHandling, DateParseHandling? previousDateParseHandling, FloatParseHandling? previousFloatParseHandling, int? previousMaxDepth, string? previousDateFormatString)
		{
			if (previousCulture != null)
			{
				reader.Culture = previousCulture;
			}
			if (previousDateTimeZoneHandling.HasValue)
			{
				reader.DateTimeZoneHandling = previousDateTimeZoneHandling.GetValueOrDefault();
			}
			if (previousDateParseHandling.HasValue)
			{
				reader.DateParseHandling = previousDateParseHandling.GetValueOrDefault();
			}
			if (previousFloatParseHandling.HasValue)
			{
				reader.FloatParseHandling = previousFloatParseHandling.GetValueOrDefault();
			}
			if (_maxDepthSet)
			{
				reader.MaxDepth = previousMaxDepth;
			}
			if (_dateFormatStringSet)
			{
				reader.DateFormatString = previousDateFormatString;
			}
			if (reader is JsonTextReader { PropertyNameTable: not null } jsonTextReader && _contractResolver is DefaultContractResolver defaultContractResolver && jsonTextReader.PropertyNameTable == defaultContractResolver.GetNameTable())
			{
				jsonTextReader.PropertyNameTable = null;
			}
		}

		public void Serialize(TextWriter textWriter, object? value)
		{
			Serialize(new JsonTextWriter(textWriter), value);
		}

		public void Serialize(JsonWriter jsonWriter, object? value, Type? objectType)
		{
			SerializeInternal(jsonWriter, value, objectType);
		}

		public void Serialize(TextWriter textWriter, object? value, Type objectType)
		{
			Serialize(new JsonTextWriter(textWriter), value, objectType);
		}

		public void Serialize(JsonWriter jsonWriter, object? value)
		{
			SerializeInternal(jsonWriter, value, null);
		}

		private TraceJsonReader CreateTraceJsonReader(JsonReader reader)
		{
			TraceJsonReader traceJsonReader = new TraceJsonReader(reader);
			if (reader.TokenType != JsonToken.None)
			{
				traceJsonReader.WriteCurrentToken();
			}
			return traceJsonReader;
		}

		internal virtual void SerializeInternal(JsonWriter jsonWriter, object? value, Type? objectType)
		{
			ValidationUtils.ArgumentNotNull(jsonWriter, "jsonWriter");
			Formatting? formatting = null;
			if (_formatting.HasValue && jsonWriter.Formatting != _formatting)
			{
				formatting = jsonWriter.Formatting;
				jsonWriter.Formatting = _formatting.GetValueOrDefault();
			}
			DateFormatHandling? dateFormatHandling = null;
			if (_dateFormatHandling.HasValue && jsonWriter.DateFormatHandling != _dateFormatHandling)
			{
				dateFormatHandling = jsonWriter.DateFormatHandling;
				jsonWriter.DateFormatHandling = _dateFormatHandling.GetValueOrDefault();
			}
			DateTimeZoneHandling? dateTimeZoneHandling = null;
			if (_dateTimeZoneHandling.HasValue && jsonWriter.DateTimeZoneHandling != _dateTimeZoneHandling)
			{
				dateTimeZoneHandling = jsonWriter.DateTimeZoneHandling;
				jsonWriter.DateTimeZoneHandling = _dateTimeZoneHandling.GetValueOrDefault();
			}
			FloatFormatHandling? floatFormatHandling = null;
			if (_floatFormatHandling.HasValue && jsonWriter.FloatFormatHandling != _floatFormatHandling)
			{
				floatFormatHandling = jsonWriter.FloatFormatHandling;
				jsonWriter.FloatFormatHandling = _floatFormatHandling.GetValueOrDefault();
			}
			StringEscapeHandling? stringEscapeHandling = null;
			if (_stringEscapeHandling.HasValue && jsonWriter.StringEscapeHandling != _stringEscapeHandling)
			{
				stringEscapeHandling = jsonWriter.StringEscapeHandling;
				jsonWriter.StringEscapeHandling = _stringEscapeHandling.GetValueOrDefault();
			}
			CultureInfo cultureInfo = null;
			if (_culture != null && !_culture.Equals(jsonWriter.Culture))
			{
				cultureInfo = jsonWriter.Culture;
				jsonWriter.Culture = _culture;
			}
			string dateFormatString = null;
			if (_dateFormatStringSet && jsonWriter.DateFormatString != _dateFormatString)
			{
				dateFormatString = jsonWriter.DateFormatString;
				jsonWriter.DateFormatString = _dateFormatString;
			}
			TraceJsonWriter traceJsonWriter = ((TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose) ? new TraceJsonWriter(jsonWriter) : null);
			new JsonSerializerInternalWriter(this).Serialize(traceJsonWriter ?? jsonWriter, value, objectType);
			if (traceJsonWriter != null)
			{
				TraceWriter.Trace(TraceLevel.Verbose, traceJsonWriter.GetSerializedJsonMessage(), null);
			}
			if (formatting.HasValue)
			{
				jsonWriter.Formatting = formatting.GetValueOrDefault();
			}
			if (dateFormatHandling.HasValue)
			{
				jsonWriter.DateFormatHandling = dateFormatHandling.GetValueOrDefault();
			}
			if (dateTimeZoneHandling.HasValue)
			{
				jsonWriter.DateTimeZoneHandling = dateTimeZoneHandling.GetValueOrDefault();
			}
			if (floatFormatHandling.HasValue)
			{
				jsonWriter.FloatFormatHandling = floatFormatHandling.GetValueOrDefault();
			}
			if (stringEscapeHandling.HasValue)
			{
				jsonWriter.StringEscapeHandling = stringEscapeHandling.GetValueOrDefault();
			}
			if (_dateFormatStringSet)
			{
				jsonWriter.DateFormatString = dateFormatString;
			}
			if (cultureInfo != null)
			{
				jsonWriter.Culture = cultureInfo;
			}
		}

		internal IReferenceResolver GetReferenceResolver()
		{
			if (_referenceResolver == null)
			{
				_referenceResolver = new DefaultReferenceResolver();
			}
			return _referenceResolver;
		}

		internal JsonConverter? GetMatchingConverter(Type type)
		{
			return GetMatchingConverter(_converters, type);
		}

		internal static JsonConverter? GetMatchingConverter(IList<JsonConverter>? converters, Type objectType)
		{
			if (converters != null)
			{
				for (int i = 0; i < converters.Count; i++)
				{
					JsonConverter jsonConverter = converters[i];
					if (jsonConverter.CanConvert(objectType))
					{
						return jsonConverter;
					}
				}
			}
			return null;
		}

		internal void OnError(Microsoft.Identity.Json.Serialization.ErrorEventArgs e)
		{
			this.Error?.Invoke(this, e);
		}
	}
	internal class JsonSerializerSettings
	{
		internal const ReferenceLoopHandling DefaultReferenceLoopHandling = ReferenceLoopHandling.Error;

		internal const MissingMemberHandling DefaultMissingMemberHandling = MissingMemberHandling.Ignore;

		internal const NullValueHandling DefaultNullValueHandling = NullValueHandling.Include;

		internal const DefaultValueHandling DefaultDefaultValueHandling = DefaultValueHandling.Include;

		internal const ObjectCreationHandling DefaultObjectCreationHandling = ObjectCreationHandling.Auto;

		internal const PreserveReferencesHandling DefaultPreserveReferencesHandling = PreserveReferencesHandling.None;

		internal const ConstructorHandling DefaultConstructorHandling = ConstructorHandling.Default;

		internal const TypeNameHandling DefaultTypeNameHandling = TypeNameHandling.None;

		internal const MetadataPropertyHandling DefaultMetadataPropertyHandling = MetadataPropertyHandling.Default;

		internal static readonly StreamingContext DefaultContext;

		internal const Formatting DefaultFormatting = Formatting.None;

		internal const DateFormatHandling DefaultDateFormatHandling = DateFormatHandling.IsoDateFormat;

		internal const DateTimeZoneHandling DefaultDateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;

		internal const DateParseHandling DefaultDateParseHandling = DateParseHandling.DateTime;

		internal const FloatParseHandling DefaultFloatParseHandling = FloatParseHandling.Double;

		internal const FloatFormatHandling DefaultFloatFormatHandling = FloatFormatHandling.String;

		internal const StringEscapeHandling DefaultStringEscapeHandling = StringEscapeHandling.Default;

		internal const TypeNameAssemblyFormatHandling DefaultTypeNameAssemblyFormatHandling = TypeNameAssemblyFormatHandling.Simple;

		internal static readonly CultureInfo DefaultCulture;

		internal const bool DefaultCheckAdditionalContent = false;

		internal const string DefaultDateFormatString = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

		internal const int DefaultMaxDepth = 64;

		internal Formatting? _formatting;

		internal DateFormatHandling? _dateFormatHandling;

		internal DateTimeZoneHandling? _dateTimeZoneHandling;

		internal DateParseHandling? _dateParseHandling;

		internal FloatFormatHandling? _floatFormatHandling;

		internal FloatParseHandling? _floatParseHandling;

		internal StringEscapeHandling? _stringEscapeHandling;

		internal CultureInfo? _culture;

		internal bool? _checkAdditionalContent;

		internal int? _maxDepth;

		internal bool _maxDepthSet;

		internal string? _dateFormatString;

		internal bool _dateFormatStringSet;

		internal TypeNameAssemblyFormatHandling? _typeNameAssemblyFormatHandling;

		internal DefaultValueHandling? _defaultValueHandling;

		internal PreserveReferencesHandling? _preserveReferencesHandling;

		internal NullValueHandling? _nullValueHandling;

		internal ObjectCreationHandling? _objectCreationHandling;

		internal MissingMemberHandling? _missingMemberHandling;

		internal ReferenceLoopHandling? _referenceLoopHandling;

		internal StreamingContext? _context;

		internal ConstructorHandling? _constructorHandling;

		internal TypeNameHandling? _typeNameHandling;

		internal MetadataPropertyHandling? _metadataPropertyHandling;

		public ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _referenceLoopHandling.GetValueOrDefault();
			}
			set
			{
				_referenceLoopHandling = value;
			}
		}

		public MissingMemberHandling MissingMemberHandling
		{
			get
			{
				return _missingMemberHandling.GetValueOrDefault();
			}
			set
			{
				_missingMemberHandling = value;
			}
		}

		public ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _objectCreationHandling.GetValueOrDefault();
			}
			set
			{
				_objectCreationHandling = value;
			}
		}

		public NullValueHandling NullValueHandling
		{
			get
			{
				return _nullValueHandling.GetValueOrDefault();
			}
			set
			{
				_nullValueHandling = value;
			}
		}

		public DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _defaultValueHandling.GetValueOrDefault();
			}
			set
			{
				_defaultValueHandling = value;
			}
		}

		public IList<JsonConverter> Converters { get; set; }

		public PreserveReferencesHandling PreserveReferencesHandling
		{
			get
			{
				return _preserveReferencesHandling.GetValueOrDefault();
			}
			set
			{
				_preserveReferencesHandling = value;
			}
		}

		public TypeNameHandling TypeNameHandling
		{
			get
			{
				return _typeNameHandling.GetValueOrDefault();
			}
			set
			{
				_typeNameHandling = value;
			}
		}

		public MetadataPropertyHandling MetadataPropertyHandling
		{
			get
			{
				return _metadataPropertyHandling.GetValueOrDefault();
			}
			set
			{
				_metadataPropertyHandling = value;
			}
		}

		[Obsolete("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
		public FormatterAssemblyStyle TypeNameAssemblyFormat
		{
			get
			{
				return (FormatterAssemblyStyle)TypeNameAssemblyFormatHandling;
			}
			set
			{
				TypeNameAssemblyFormatHandling = (TypeNameAssemblyFormatHandling)value;
			}
		}

		public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling
		{
			get
			{
				return _typeNameAssemblyFormatHandling.GetValueOrDefault();
			}
			set
			{
				_typeNameAssemblyFormatHandling = value;
			}
		}

		public ConstructorHandling ConstructorHandling
		{
			get
			{
				return _constructorHandling.GetValueOrDefault();
			}
			set
			{
				_constructorHandling = value;
			}
		}

		public IContractResolver? ContractResolver { get; set; }

		public IEqualityComparer? EqualityComparer { get; set; }

		[Obsolete("ReferenceResolver property is obsolete. Use the ReferenceResolverProvider property to set the IReferenceResolver: settings.ReferenceResolverProvider = () => resolver")]
		public IReferenceResolver? ReferenceResolver
		{
			get
			{
				return ReferenceResolverProvider?.Invoke();
			}
			set
			{
				ReferenceResolverProvider = ((value != null) ? ((Func<IReferenceResolver>)(() => value)) : null);
			}
		}

		public Func<IReferenceResolver?>? ReferenceResolverProvider { get; set; }

		public ITraceWriter? TraceWriter { get; set; }

		[Obsolete("Binder is obsolete. Use SerializationBinder instead.")]
		public SerializationBinder? Binder
		{
			get
			{
				if (SerializationBinder == null)
				{
					return null;
				}
				if (SerializationBinder is SerializationBinderAdapter serializationBinderAdapter)
				{
					return serializationBinderAdapter.SerializationBinder;
				}
				throw new InvalidOperationException("Cannot get SerializationBinder because an ISerializationBinder was previously set.");
			}
			set
			{
				SerializationBinder = ((value == null) ? null : new SerializationBinderAdapter(value));
			}
		}

		public ISerializationBinder? SerializationBinder { get; set; }

		public EventHandler<Microsoft.Identity.Json.Serialization.ErrorEventArgs>? Error { get; set; }

		public StreamingContext Context
		{
			get
			{
				return _context ?? DefaultContext;
			}
			set
			{
				_context = value;
			}
		}

		public string DateFormatString
		{
			get
			{
				return _dateFormatString ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
			}
			set
			{
				_dateFormatString = value;
				_dateFormatStringSet = true;
			}
		}

		public int? MaxDepth
		{
			get
			{
				if (!_maxDepthSet)
				{
					return 64;
				}
				return _maxDepth;
			}
			set
			{
				if (value <= 0)
				{
					throw new ArgumentException("Value must be positive.", "value");
				}
				_maxDepth = value;
				_maxDepthSet = true;
			}
		}

		public Formatting Formatting
		{
			get
			{
				return _formatting.GetValueOrDefault();
			}
			set
			{
				_formatting = value;
			}
		}

		public DateFormatHandling DateFormatHandling
		{
			get
			{
				return _dateFormatHandling.GetValueOrDefault();
			}
			set
			{
				_dateFormatHandling = value;
			}
		}

		public DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _dateTimeZoneHandling ?? DateTimeZoneHandling.RoundtripKind;
			}
			set
			{
				_dateTimeZoneHandling = value;
			}
		}

		public DateParseHandling DateParseHandling
		{
			get
			{
				return _dateParseHandling ?? DateParseHandling.DateTime;
			}
			set
			{
				_dateParseHandling = value;
			}
		}

		public FloatFormatHandling FloatFormatHandling
		{
			get
			{
				return _floatFormatHandling.GetValueOrDefault();
			}
			set
			{
				_floatFormatHandling = value;
			}
		}

		public FloatParseHandling FloatParseHandling
		{
			get
			{
				return _floatParseHandling.GetValueOrDefault();
			}
			set
			{
				_floatParseHandling = value;
			}
		}

		public StringEscapeHandling StringEscapeHandling
		{
			get
			{
				return _stringEscapeHandling.GetValueOrDefault();
			}
			set
			{
				_stringEscapeHandling = value;
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? DefaultCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public bool CheckAdditionalContent
		{
			get
			{
				return _checkAdditionalContent == true;
			}
			set
			{
				_checkAdditionalContent = value;
			}
		}

		static JsonSerializerSettings()
		{
			DefaultContext = default(StreamingContext);
			DefaultCulture = CultureInfo.InvariantCulture;
		}

		[DebuggerStepThrough]
		public JsonSerializerSettings()
		{
			Converters = new List<JsonConverter>();
		}
	}
	internal class JsonTextReader : JsonReader, IJsonLineInfo
	{
		private readonly bool _safeAsync;

		private const char UnicodeReplacementChar = '\ufffd';

		private const int MaximumJavascriptIntegerCharacterLength = 380;

		private const int LargeBufferLength = 1073741823;

		private readonly TextReader _reader;

		private char[]? _chars;

		private int _charsUsed;

		private int _charPos;

		private int _lineStartPos;

		private int _lineNumber;

		private bool _isEndOfFile;

		private StringBuffer _stringBuffer;

		private StringReference _stringReference;

		private IArrayPool<char>? _arrayPool;

		public JsonNameTable? PropertyNameTable { get; set; }

		public IArrayPool<char>? ArrayPool
		{
			get
			{
				return _arrayPool;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				_arrayPool = value;
			}
		}

		public int LineNumber
		{
			get
			{
				if (base.CurrentState == State.Start && LinePosition == 0 && TokenType != JsonToken.Comment)
				{
					return 0;
				}
				return _lineNumber;
			}
		}

		public int LinePosition => _charPos - _lineStartPos;

		public override Task<bool> ReadAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.ReadAsync(cancellationToken);
			}
			return DoReadAsync(cancellationToken);
		}

		internal Task<bool> DoReadAsync(CancellationToken cancellationToken)
		{
			EnsureBuffer();
			Task<bool> task;
			do
			{
				switch (_currentState)
				{
				case State.Start:
				case State.Property:
				case State.ArrayStart:
				case State.Array:
				case State.ConstructorStart:
				case State.Constructor:
					return ParseValueAsync(cancellationToken);
				case State.ObjectStart:
				case State.Object:
					return ParseObjectAsync(cancellationToken);
				case State.PostValue:
					task = ParsePostValueAsync(ignoreComments: false, cancellationToken);
					if (!task.IsCompletedSucessfully())
					{
						return DoReadAsync(task, cancellationToken);
					}
					break;
				case State.Finished:
					return ReadFromFinishedAsync(cancellationToken);
				default:
					throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
				}
			}
			while (!task.Result);
			return AsyncUtils.True;
		}

		private async Task<bool> DoReadAsync(Task<bool> task, CancellationToken cancellationToken)
		{
			if (await task.ConfigureAwait(continueOnCapturedContext: false))
			{
				return true;
			}
			return await DoReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<bool> ParsePostValueAsync(bool ignoreComments, CancellationToken cancellationToken)
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (await ReadDataAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == 0)
						{
							_currentState = State.Finished;
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					continue;
				case '}':
					_charPos++;
					SetToken(JsonToken.EndObject);
					return true;
				case ']':
					_charPos++;
					SetToken(JsonToken.EndArray);
					return true;
				case ')':
					_charPos++;
					SetToken(JsonToken.EndConstructor);
					return true;
				case '/':
					await ParseCommentAsync(!ignoreComments, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					if (!ignoreComments)
					{
						return true;
					}
					continue;
				case ',':
					_charPos++;
					SetStateBasedOnCurrent();
					return false;
				case '\t':
				case ' ':
					_charPos++;
					continue;
				case '\r':
					await ProcessCarriageReturnAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					continue;
				case '\n':
					ProcessLineFeed();
					continue;
				}
				if (char.IsWhiteSpace(c))
				{
					_charPos++;
					continue;
				}
				if (base.SupportMultipleContent && Depth == 0)
				{
					SetStateBasedOnCurrent();
					return false;
				}
				throw JsonReaderException.Create(this, "After parsing a value an unexpected character was encountered: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
			}
		}

		private async Task<bool> ReadFromFinishedAsync(CancellationToken cancellationToken)
		{
			if (await EnsureCharsAsync(0, append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
			{
				await EatWhitespaceAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (_isEndOfFile)
				{
					SetToken(JsonToken.None);
					return false;
				}
				if (_chars[_charPos] == '/')
				{
					await ParseCommentAsync(setToken: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					return true;
				}
				throw JsonReaderException.Create(this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
			}
			SetToken(JsonToken.None);
			return false;
		}

		private Task<int> ReadDataAsync(bool append, CancellationToken cancellationToken)
		{
			return ReadDataAsync(append, 0, cancellationToken);
		}

		private async Task<int> ReadDataAsync(bool append, int charsRequired, CancellationToken cancellationToken)
		{
			if (_isEndOfFile)
			{
				return 0;
			}
			PrepareBufferForReadData(append, charsRequired);
			int num = await _reader.ReadAsync(_chars, _charsUsed, _chars.Length - _charsUsed - 1, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			_charsUsed += num;
			if (num == 0)
			{
				_isEndOfFile = true;
			}
			_chars[_charsUsed] = '\0';
			return num;
		}

		private async Task<bool> ParseValueAsync(CancellationToken cancellationToken)
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (await ReadDataAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == 0)
						{
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '"':
				case '\'':
					await ParseStringAsync(c, ReadType.Read, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					return true;
				case 't':
					await ParseTrueAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					return true;
				case 'f':
					await ParseFalseAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					return true;
				case 'n':
					if (await EnsureCharsAsync(1, append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
					{
						switch (_chars[_charPos + 1])
						{
						case 'u':
							await ParseNullAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
							break;
						case 'e':
							await ParseConstructorAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
							break;
						default:
							throw CreateUnexpectedCharacterException(_chars[_charPos]);
						}
						return true;
					}
					_charPos++;
					throw CreateUnexpectedEndException();
				case 'N':
					await ParseNumberNaNAsync(ReadType.Read, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					return true;
				case 'I':
					await ParseNumberPositiveInfinityAsync(ReadType.Read, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					return true;
				case '-':
					if (!(await EnsureCharsAsync(1, append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)) || _chars[_charPos + 1] != 'I')
					{
						await ParseNumberAsync(ReadType.Read, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						await ParseNumberNegativeInfinityAsync(ReadType.Read, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					return true;
				case '/':
					await ParseCommentAsync(setToken: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					return true;
				case 'u':
					await ParseUndefinedAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					return true;
				case '{':
					_charPos++;
					SetToken(JsonToken.StartObject);
					return true;
				case '[':
					_charPos++;
					SetToken(JsonToken.StartArray);
					return true;
				case ']':
					_charPos++;
					SetToken(JsonToken.EndArray);
					return true;
				case ',':
					SetToken(JsonToken.Undefined);
					return true;
				case ')':
					_charPos++;
					SetToken(JsonToken.EndConstructor);
					return true;
				case '\r':
					await ProcessCarriageReturnAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					if (char.IsWhiteSpace(c))
					{
						_charPos++;
						break;
					}
					if (char.IsNumber(c) || c == '-' || c == '.')
					{
						await ParseNumberAsync(ReadType.Read, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return true;
					}
					throw CreateUnexpectedCharacterException(c);
				}
			}
		}

		private async Task ReadStringIntoBufferAsync(char quote, CancellationToken cancellationToken)
		{
			int charPos = _charPos;
			int initialPosition = _charPos;
			int lastWritePosition = _charPos;
			_stringBuffer.Position = 0;
			while (true)
			{
				switch (_chars[charPos++])
				{
				case '\0':
					if (_charsUsed == charPos - 1)
					{
						charPos--;
						if (await ReadDataAsync(append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == 0)
						{
							_charPos = charPos;
							throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
						}
					}
					break;
				case '\\':
				{
					_charPos = charPos;
					if (!(await EnsureCharsAsync(0, append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
					{
						throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
					}
					int escapeStartPos = charPos - 1;
					char c = _chars[charPos];
					charPos++;
					char writeChar;
					switch (c)
					{
					case 'b':
						writeChar = '\b';
						break;
					case 't':
						writeChar = '\t';
						break;
					case 'n':
						writeChar = '\n';
						break;
					case 'f':
						writeChar = '\f';
						break;
					case 'r':
						writeChar = '\r';
						break;
					case '\\':
						writeChar = '\\';
						break;
					case '"':
					case '\'':
					case '/':
						writeChar = c;
						break;
					case 'u':
						_charPos = charPos;
						writeChar = await ParseUnicodeAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						if (StringUtils.IsLowSurrogate(writeChar))
						{
							writeChar = '\ufffd';
						}
						else if (StringUtils.IsHighSurrogate(writeChar))
						{
							bool anotherHighSurrogate;
							do
							{
								anotherHighSurrogate = false;
								if (await EnsureCharsAsync(2, append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) && _chars[_charPos] == '\\' && _chars[_charPos + 1] == 'u')
								{
									char highSurrogate = writeChar;
									_charPos += 2;
									writeChar = await ParseUnicodeAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
									if (!StringUtils.IsLowSurrogate(writeChar))
									{
										if (StringUtils.IsHighSurrogate(writeChar))
										{
											highSurrogate = '\ufffd';
											anotherHighSurrogate = true;
										}
										else
										{
											highSurrogate = '\ufffd';
										}
									}
									EnsureBufferNotEmpty();
									WriteCharToBuffer(highSurrogate, lastWritePosition, escapeStartPos);
									lastWritePosition = _charPos;
								}
								else
								{
									writeChar = '\ufffd';
								}
							}
							while (anotherHighSurrogate);
						}
						charPos = _charPos;
						break;
					default:
						_charPos = charPos;
						throw JsonReaderException.Create(this, "Bad JSON escape sequence: {0}.".FormatWith(CultureInfo.InvariantCulture, "\\" + c));
					}
					EnsureBufferNotEmpty();
					WriteCharToBuffer(writeChar, lastWritePosition, escapeStartPos);
					lastWritePosition = charPos;
					break;
				}
				case '\r':
					_charPos = charPos - 1;
					await ProcessCarriageReturnAsync(append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					charPos = _charPos;
					break;
				case '\n':
					_charPos = charPos - 1;
					ProcessLineFeed();
					charPos = _charPos;
					break;
				case '"':
				case '\'':
					if (_chars[charPos - 1] == quote)
					{
						FinishReadStringIntoBuffer(charPos - 1, initialPosition, lastWritePosition);
						return;
					}
					break;
				}
			}
		}

		private Task ProcessCarriageReturnAsync(bool append, CancellationToken cancellationToken)
		{
			_charPos++;
			Task<bool> task = EnsureCharsAsync(1, append, cancellationToken);
			if (task.IsCompletedSucessfully())
			{
				SetNewLine(task.Result);
				return AsyncUtils.CompletedTask;
			}
			return ProcessCarriageReturnAsync(task);
		}

		private async Task ProcessCarriageReturnAsync(Task<bool> task)
		{
			SetNewLine(await task.ConfigureAwait(continueOnCapturedContext: false));
		}

		private async Task<char> ParseUnicodeAsync(CancellationToken cancellationToken)
		{
			return ConvertUnicode(await EnsureCharsAsync(4, append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		private Task<bool> EnsureCharsAsync(int relativePosition, bool append, CancellationToken cancellationToken)
		{
			if (_charPos + relativePosition < _charsUsed)
			{
				return AsyncUtils.True;
			}
			if (_isEndOfFile)
			{
				return AsyncUtils.False;
			}
			return ReadCharsAsync(relativePosition, append, cancellationToken);
		}

		private async Task<bool> ReadCharsAsync(int relativePosition, bool append, CancellationToken cancellationToken)
		{
			int charsRequired = _charPos + relativePosition - _charsUsed + 1;
			do
			{
				int num = await ReadDataAsync(append, charsRequired, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (num == 0)
				{
					return false;
				}
				charsRequired -= num;
			}
			while (charsRequired > 0);
			return true;
		}

		private async Task<bool> ParseObjectAsync(CancellationToken cancellationToken)
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (await ReadDataAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == 0)
						{
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '}':
					SetToken(JsonToken.EndObject);
					_charPos++;
					return true;
				case '/':
					await ParseCommentAsync(setToken: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					return true;
				case '\r':
					await ProcessCarriageReturnAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					if (char.IsWhiteSpace(c))
					{
						_charPos++;
						break;
					}
					return await ParsePropertyAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
			}
		}

		private async Task ParseCommentAsync(bool setToken, CancellationToken cancellationToken)
		{
			_charPos++;
			if (!(await EnsureCharsAsync(1, append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
			{
				throw JsonReaderException.Create(this, "Unexpected end while parsing comment.");
			}
			bool singlelineComment;
			if (_chars[_charPos] == '*')
			{
				singlelineComment = false;
			}
			else
			{
				if (_chars[_charPos] != '/')
				{
					throw JsonReaderException.Create(this, "Error parsing comment. Expected: *, got {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				singlelineComment = true;
			}
			_charPos++;
			int initialPosition = _charPos;
			while (true)
			{
				switch (_chars[_charPos])
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (await ReadDataAsync(append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == 0)
						{
							if (!singlelineComment)
							{
								throw JsonReaderException.Create(this, "Unexpected end while parsing comment.");
							}
							EndComment(setToken, initialPosition, _charPos);
							return;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '*':
					_charPos++;
					if (!singlelineComment && await EnsureCharsAsync(0, append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) && _chars[_charPos] == '/')
					{
						EndComment(setToken, initialPosition, _charPos - 1);
						_charPos++;
						return;
					}
					break;
				case '\r':
					if (singlelineComment)
					{
						EndComment(setToken, initialPosition, _charPos);
						return;
					}
					await ProcessCarriageReturnAsync(append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					break;
				case '\n':
					if (singlelineComment)
					{
						EndComment(setToken, initialPosition, _charPos);
						return;
					}
					ProcessLineFeed();
					break;
				default:
					_charPos++;
					break;
				}
			}
		}

		private async Task EatWhitespaceAsync(CancellationToken cancellationToken)
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (await ReadDataAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == 0)
						{
							return;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '\r':
					await ProcessCarriageReturnAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				default:
					if (!char.IsWhiteSpace(c))
					{
						return;
					}
					goto case ' ';
				case ' ':
					_charPos++;
					break;
				}
			}
		}

		private async Task ParseStringAsync(char quote, ReadType readType, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			_charPos++;
			ShiftBufferIfNeeded();
			await ReadStringIntoBufferAsync(quote, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ParseReadString(quote, readType);
		}

		private async Task<bool> MatchValueAsync(string value, CancellationToken cancellationToken)
		{
			return MatchValue(await EnsureCharsAsync(value.Length - 1, append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), value);
		}

		private async Task<bool> MatchValueWithTrailingSeparatorAsync(string value, CancellationToken cancellationToken)
		{
			if (!(await MatchValueAsync(value, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
			{
				return false;
			}
			if (!(await EnsureCharsAsync(0, append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
			{
				return true;
			}
			return IsSeparator(_chars[_charPos]) || _chars[_charPos] == '\0';
		}

		private async Task MatchAndSetAsync(string value, JsonToken newToken, object? tokenValue, CancellationToken cancellationToken)
		{
			if (await MatchValueWithTrailingSeparatorAsync(value, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
			{
				SetToken(newToken, tokenValue);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing " + newToken.ToString().ToLowerInvariant() + " value.");
		}

		private Task ParseTrueAsync(CancellationToken cancellationToken)
		{
			return MatchAndSetAsync(JsonConvert.True, JsonToken.Boolean, true, cancellationToken);
		}

		private Task ParseFalseAsync(CancellationToken cancellationToken)
		{
			return MatchAndSetAsync(JsonConvert.False, JsonToken.Boolean, false, cancellationToken);
		}

		private Task ParseNullAsync(CancellationToken cancellationToken)
		{
			return MatchAndSetAsync(JsonConvert.Null, JsonToken.Null, null, cancellationToken);
		}

		private async Task ParseConstructorAsync(CancellationToken cancellationToken)
		{
			if (await MatchValueWithTrailingSeparatorAsync("new", cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
			{
				await EatWhitespaceAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				int initialPosition = _charPos;
				int endPosition;
				while (true)
				{
					char c = _chars[_charPos];
					if (c == '\0')
					{
						if (_charsUsed == _charPos)
						{
							if (await ReadDataAsync(append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == 0)
							{
								throw JsonReaderException.Create(this, "Unexpected end while parsing constructor.");
							}
							continue;
						}
						endPosition = _charPos;
						_charPos++;
						break;
					}
					if (char.IsLetterOrDigit(c))
					{
						_charPos++;
						continue;
					}
					switch (c)
					{
					case '\r':
						endPosition = _charPos;
						await ProcessCarriageReturnAsync(append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						break;
					case '\n':
						endPosition = _charPos;
						ProcessLineFeed();
						break;
					default:
						if (char.IsWhiteSpace(c))
						{
							endPosition = _charPos;
							_charPos++;
							break;
						}
						if (c == '(')
						{
							endPosition = _charPos;
							break;
						}
						throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
					}
					break;
				}
				_stringReference = new StringReference(_chars, initialPosition, endPosition - initialPosition);
				string constructorName = _stringReference.ToString();
				await EatWhitespaceAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (_chars[_charPos] != '(')
				{
					throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				_charPos++;
				ClearRecentString();
				SetToken(JsonToken.StartConstructor, constructorName);
				return;
			}
			throw JsonReaderException.Create(this, "Unexpected content while parsing JSON.");
		}

		private async Task<object> ParseNumberNaNAsync(ReadType readType, CancellationToken cancellationToken)
		{
			return ParseNumberNaN(readType, await MatchValueWithTrailingSeparatorAsync(JsonConvert.NaN, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		private async Task<object> ParseNumberPositiveInfinityAsync(ReadType readType, CancellationToken cancellationToken)
		{
			return ParseNumberPositiveInfinity(readType, await MatchValueWithTrailingSeparatorAsync(JsonConvert.PositiveInfinity, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		private async Task<object> ParseNumberNegativeInfinityAsync(ReadType readType, CancellationToken cancellationToken)
		{
			return ParseNumberNegativeInfinity(readType, await MatchValueWithTrailingSeparatorAsync(JsonConvert.NegativeInfinity, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		private async Task ParseNumberAsync(ReadType readType, CancellationToken cancellationToken)
		{
			ShiftBufferIfNeeded();
			char firstChar = _chars[_charPos];
			int initialPosition = _charPos;
			await ReadNumberIntoBufferAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ParseReadNumber(readType, firstChar, initialPosition);
		}

		private Task ParseUndefinedAsync(CancellationToken cancellationToken)
		{
			return MatchAndSetAsync(JsonConvert.Undefined, JsonToken.Undefined, null, cancellationToken);
		}

		private async Task<bool> ParsePropertyAsync(CancellationToken cancellationToken)
		{
			char c = _chars[_charPos];
			char quoteChar;
			if (c == '"' || c == '\'')
			{
				_charPos++;
				quoteChar = c;
				ShiftBufferIfNeeded();
				await ReadStringIntoBufferAsync(quoteChar, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				if (!ValidIdentifierChar(c))
				{
					throw JsonReaderException.Create(this, "Invalid property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				quoteChar = '\0';
				ShiftBufferIfNeeded();
				await ParseUnquotedPropertyAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			string propertyName = ((PropertyNameTable == null) ? _stringReference.ToString() : (PropertyNameTable.Get(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length) ?? _stringReference.ToString()));
			await EatWhitespaceAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (_chars[_charPos] != ':')
			{
				throw JsonReaderException.Create(this, "Invalid character after parsing property name. Expected ':' but got: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
			}
			_charPos++;
			SetToken(JsonToken.PropertyName, propertyName);
			_quoteChar = quoteChar;
			ClearRecentString();
			return true;
		}

		private async Task ReadNumberIntoBufferAsync(CancellationToken cancellationToken)
		{
			int charPos = _charPos;
			while (true)
			{
				char c = _chars[charPos];
				if (c == '\0')
				{
					_charPos = charPos;
					if (_charsUsed != charPos || await ReadDataAsync(append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == 0)
					{
						break;
					}
				}
				else
				{
					if (ReadNumberCharIntoBuffer(c, charPos))
					{
						break;
					}
					charPos++;
				}
			}
		}

		private async Task ParseUnquotedPropertyAsync(CancellationToken cancellationToken)
		{
			int initialPosition = _charPos;
			while (true)
			{
				char c = _chars[_charPos];
				if (c == '\0')
				{
					if (_charsUsed != _charPos)
					{
						_stringReference = new StringReference(_chars, initialPosition, _charPos - initialPosition);
						break;
					}
					if (await ReadDataAsync(append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == 0)
					{
						throw JsonReaderException.Create(this, "Unexpected end while parsing unquoted property name.");
					}
				}
				else if (ReadUnquotedPropertyReportIfDone(c, initialPosition))
				{
					break;
				}
			}
		}

		private async Task<bool> ReadNullCharAsync(CancellationToken cancellationToken)
		{
			if (_charsUsed == _charPos)
			{
				if (await ReadDataAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == 0)
				{
					_isEndOfFile = true;
					return true;
				}
			}
			else
			{
				_charPos++;
			}
			return false;
		}

		private async Task HandleNullAsync(CancellationToken cancellationToken)
		{
			if (await EnsureCharsAsync(1, append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
			{
				if (_chars[_charPos + 1] == 'u')
				{
					await ParseNullAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					return;
				}
				_charPos += 2;
				throw CreateUnexpectedCharacterException(_chars[_charPos - 1]);
			}
			_charPos = _charsUsed;
			throw CreateUnexpectedEndException();
		}

		private async Task ReadFinishedAsync(CancellationToken cancellationToken)
		{
			if (await EnsureCharsAsync(0, append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
			{
				await EatWhitespaceAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (_isEndOfFile)
				{
					SetToken(JsonToken.None);
					return;
				}
				if (_chars[_charPos] != '/')
				{
					throw JsonReaderException.Create(this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				await ParseCommentAsync(setToken: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			SetToken(JsonToken.None);
		}

		private async Task<object?> ReadStringValueAsync(ReadType readType, CancellationToken cancellationToken)
		{
			EnsureBuffer();
			switch (_currentState)
			{
			case State.PostValue:
				if (await ParsePostValueAsync(ignoreComments: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
				{
					return null;
				}
				goto case State.Start;
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (await ReadNullCharAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
						await ParseStringAsync(c, readType, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return FinishReadQuotedStringValue(readType);
					case '-':
						if (await EnsureCharsAsync(1, append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) && _chars[_charPos + 1] == 'I')
						{
							return ParseNumberNegativeInfinity(readType);
						}
						await ParseNumberAsync(readType, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return Value;
					case '.':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						if (readType != ReadType.ReadAsString)
						{
							_charPos++;
							throw CreateUnexpectedCharacterException(c);
						}
						await ParseNumberAsync(ReadType.ReadAsString, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return Value;
					case 'f':
					case 't':
					{
						if (readType != ReadType.ReadAsString)
						{
							_charPos++;
							throw CreateUnexpectedCharacterException(c);
						}
						string expected = ((c == 't') ? JsonConvert.True : JsonConvert.False);
						if (!(await MatchValueWithTrailingSeparatorAsync(expected, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
						{
							throw CreateUnexpectedCharacterException(_chars[_charPos]);
						}
						SetToken(JsonToken.String, expected);
						return expected;
					}
					case 'I':
						return await ParseNumberPositiveInfinityAsync(readType, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					case 'N':
						return await ParseNumberNaNAsync(readType, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					case 'n':
						await HandleNullAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return null;
					case '/':
						await ParseCommentAsync(setToken: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						await ProcessCarriageReturnAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				await ReadFinishedAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		private async Task<object?> ReadNumberValueAsync(ReadType readType, CancellationToken cancellationToken)
		{
			EnsureBuffer();
			switch (_currentState)
			{
			case State.PostValue:
				if (await ParsePostValueAsync(ignoreComments: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
				{
					return null;
				}
				goto case State.Start;
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (await ReadNullCharAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
						await ParseStringAsync(c, readType, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return FinishReadQuotedNumber(readType);
					case 'n':
						await HandleNullAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return null;
					case 'N':
						return await ParseNumberNaNAsync(readType, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					case 'I':
						return await ParseNumberPositiveInfinityAsync(readType, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					case '-':
						if (await EnsureCharsAsync(1, append: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) && _chars[_charPos + 1] == 'I')
						{
							return await ParseNumberNegativeInfinityAsync(readType, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						}
						await ParseNumberAsync(readType, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return Value;
					case '.':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						await ParseNumberAsync(readType, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return Value;
					case '/':
						await ParseCommentAsync(setToken: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						await ProcessCarriageReturnAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				await ReadFinishedAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		public override Task<bool?> ReadAsBooleanAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.ReadAsBooleanAsync(cancellationToken);
			}
			return DoReadAsBooleanAsync(cancellationToken);
		}

		internal async Task<bool?> DoReadAsBooleanAsync(CancellationToken cancellationToken)
		{
			EnsureBuffer();
			switch (_currentState)
			{
			case State.PostValue:
				if (await ParsePostValueAsync(ignoreComments: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
				{
					return null;
				}
				goto case State.Start;
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (await ReadNullCharAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
						await ParseStringAsync(c, ReadType.Read, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return ReadBooleanString(_stringReference.ToString());
					case 'n':
						await HandleNullAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return null;
					case '-':
					case '.':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
					{
						await ParseNumberAsync(ReadType.Read, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						bool flag = ((!(Value is BigInteger bigInteger)) ? Convert.ToBoolean(Value, CultureInfo.InvariantCulture) : (bigInteger != 0L));
						SetToken(JsonToken.Boolean, flag, updateIndex: false);
						return flag;
					}
					case 'f':
					case 't':
					{
						bool isTrue = c == 't';
						if (!(await MatchValueWithTrailingSeparatorAsync(isTrue ? JsonConvert.True : JsonConvert.False, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
						{
							throw CreateUnexpectedCharacterException(_chars[_charPos]);
						}
						SetToken(JsonToken.Boolean, isTrue);
						return isTrue;
					}
					case '/':
						await ParseCommentAsync(setToken: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						await ProcessCarriageReturnAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				await ReadFinishedAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		public override Task<byte[]?> ReadAsBytesAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.ReadAsBytesAsync(cancellationToken);
			}
			return DoReadAsBytesAsync(cancellationToken);
		}

		internal async Task<byte[]?> DoReadAsBytesAsync(CancellationToken cancellationToken)
		{
			EnsureBuffer();
			bool isWrapped = false;
			switch (_currentState)
			{
			case State.PostValue:
				if (await ParsePostValueAsync(ignoreComments: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
				{
					return null;
				}
				goto case State.Start;
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (await ReadNullCharAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
					{
						await ParseStringAsync(c, ReadType.ReadAsBytes, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						byte[] data = (byte[])Value;
						if (isWrapped)
						{
							await ReaderReadAndAssertAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
							if (TokenType != JsonToken.EndObject)
							{
								throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
							}
							SetToken(JsonToken.Bytes, data, updateIndex: false);
						}
						return data;
					}
					case '{':
						_charPos++;
						SetToken(JsonToken.StartObject);
						await ReadIntoWrappedTypeObjectAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						isWrapped = true;
						break;
					case '[':
						_charPos++;
						SetToken(JsonToken.StartArray);
						return await ReadArrayIntoByteArrayAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					case 'n':
						await HandleNullAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return null;
					case '/':
						await ParseCommentAsync(setToken: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						await ProcessCarriageReturnAsync(append: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				await ReadFinishedAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		private async Task ReadIntoWrappedTypeObjectAsync(CancellationToken cancellationToken)
		{
			await ReaderReadAndAssertAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (Value != null && Value.ToString() == "$type")
			{
				await ReaderReadAndAssertAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (Value != null && Value.ToString().StartsWith("System.Byte[]", StringComparison.Ordinal))
				{
					await ReaderReadAndAssertAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					if (Value.ToString() == "$value")
					{
						return;
					}
				}
			}
			throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, JsonToken.StartObject));
		}

		public override Task<DateTime?> ReadAsDateTimeAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.ReadAsDateTimeAsync(cancellationToken);
			}
			return DoReadAsDateTimeAsync(cancellationToken);
		}

		internal async Task<DateTime?> DoReadAsDateTimeAsync(CancellationToken cancellationToken)
		{
			return (DateTime?)(await ReadStringValueAsync(ReadType.ReadAsDateTime, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		public override Task<DateTimeOffset?> ReadAsDateTimeOffsetAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.ReadAsDateTimeOffsetAsync(cancellationToken);
			}
			return DoReadAsDateTimeOffsetAsync(cancellationToken);
		}

		internal async Task<DateTimeOffset?> DoReadAsDateTimeOffsetAsync(CancellationToken cancellationToken)
		{
			return (DateTimeOffset?)(await ReadStringValueAsync(ReadType.ReadAsDateTimeOffset, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		public override Task<decimal?> ReadAsDecimalAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.ReadAsDecimalAsync(cancellationToken);
			}
			return DoReadAsDecimalAsync(cancellationToken);
		}

		internal async Task<decimal?> DoReadAsDecimalAsync(CancellationToken cancellationToken)
		{
			return (decimal?)(await ReadNumberValueAsync(ReadType.ReadAsDecimal, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		public override Task<double?> ReadAsDoubleAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.ReadAsDoubleAsync(cancellationToken);
			}
			return DoReadAsDoubleAsync(cancellationToken);
		}

		internal async Task<double?> DoReadAsDoubleAsync(CancellationToken cancellationToken)
		{
			return (double?)(await ReadNumberValueAsync(ReadType.ReadAsDouble, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		public override Task<int?> ReadAsInt32Async(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.ReadAsInt32Async(cancellationToken);
			}
			return DoReadAsInt32Async(cancellationToken);
		}

		internal async Task<int?> DoReadAsInt32Async(CancellationToken cancellationToken)
		{
			return (int?)(await ReadNumberValueAsync(ReadType.ReadAsInt32, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		public override Task<string?> ReadAsStringAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.ReadAsStringAsync(cancellationToken);
			}
			return DoReadAsStringAsync(cancellationToken);
		}

		internal async Task<string?> DoReadAsStringAsync(CancellationToken cancellationToken)
		{
			return (string)(await ReadStringValueAsync(ReadType.ReadAsString, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		public JsonTextReader(TextReader reader)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			_reader = reader;
			_lineNumber = 1;
			_safeAsync = GetType() == typeof(JsonTextReader);
		}

		private void EnsureBufferNotEmpty()
		{
			if (_stringBuffer.IsEmpty)
			{
				_stringBuffer = new StringBuffer(_arrayPool, 1024);
			}
		}

		private void SetNewLine(bool hasNextChar)
		{
			if (hasNextChar && _chars[_charPos] == '\n')
			{
				_charPos++;
			}
			OnNewLine(_charPos);
		}

		private void OnNewLine(int pos)
		{
			_lineNumber++;
			_lineStartPos = pos;
		}

		private void ParseString(char quote, ReadType readType)
		{
			_charPos++;
			ShiftBufferIfNeeded();
			ReadStringIntoBuffer(quote);
			ParseReadString(quote, readType);
		}

		private void ParseReadString(char quote, ReadType readType)
		{
			SetPostValueState(updateIndex: true);
			switch (readType)
			{
			case ReadType.ReadAsBytes:
			{
				Guid g;
				byte[] value2 = ((_stringReference.Length == 0) ? CollectionUtils.ArrayEmpty<byte>() : ((_stringReference.Length != 36 || !ConvertUtils.TryConvertGuid(_stringReference.ToString(), out g)) ? Convert.FromBase64CharArray(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length) : g.ToByteArray()));
				SetToken(JsonToken.Bytes, value2, updateIndex: false);
				return;
			}
			case ReadType.ReadAsString:
			{
				string value = _stringReference.ToString();
				SetToken(JsonToken.String, value, updateIndex: false);
				_quoteChar = quote;
				return;
			}
			case ReadType.ReadAsInt32:
			case ReadType.ReadAsDecimal:
			case ReadType.ReadAsBoolean:
				return;
			}
			if (_dateParseHandling != DateParseHandling.None)
			{
				DateTimeOffset dt2;
				if (readType switch
				{
					ReadType.ReadAsDateTime => 1, 
					ReadType.ReadAsDateTimeOffset => 2, 
					_ => (int)_dateParseHandling, 
				} == 1)
				{
					if (DateTimeUtils.TryParseDateTime(_stringReference, base.DateTimeZoneHandling, base.DateFormatString, base.Culture, out var dt))
					{
						SetToken(JsonToken.Date, dt, updateIndex: false);
						return;
					}
				}
				else if (DateTimeUtils.TryParseDateTimeOffset(_stringReference, base.DateFormatString, base.Culture, out dt2))
				{
					SetToken(JsonToken.Date, dt2, updateIndex: false);
					return;
				}
			}
			SetToken(JsonToken.String, _stringReference.ToString(), updateIndex: false);
			_quoteChar = quote;
		}

		private static void BlockCopyChars(char[] src, int srcOffset, char[] dst, int dstOffset, int count)
		{
			Buffer.BlockCopy(src, srcOffset * 2, dst, dstOffset * 2, count * 2);
		}

		private void ShiftBufferIfNeeded()
		{
			int num = _chars.Length;
			if ((double)(num - _charPos) <= (double)num * 0.1 || num >= 1073741823)
			{
				int num2 = _charsUsed - _charPos;
				if (num2 > 0)
				{
					BlockCopyChars(_chars, _charPos, _chars, 0, num2);
				}
				_lineStartPos -= _charPos;
				_charPos = 0;
				_charsUsed = num2;
				_chars[_charsUsed] = '\0';
			}
		}

		private int ReadData(bool append)
		{
			return ReadData(append, 0);
		}

		private void PrepareBufferForReadData(bool append, int charsRequired)
		{
			if (_charsUsed + charsRequired < _chars.Length - 1)
			{
				return;
			}
			if (append)
			{
				int num = _chars.Length * 2;
				int minSize = Math.Max((num < 0) ? int.MaxValue : num, _charsUsed + charsRequired + 1);
				char[] array = BufferUtils.RentBuffer(_arrayPool, minSize);
				BlockCopyChars(_chars, 0, array, 0, _chars.Length);
				BufferUtils.ReturnBuffer(_arrayPool, _chars);
				_chars = array;
				return;
			}
			int num2 = _charsUsed - _charPos;
			if (num2 + charsRequired + 1 >= _chars.Length)
			{
				char[] array2 = BufferUtils.RentBuffer(_arrayPool, num2 + charsRequired + 1);
				if (num2 > 0)
				{
					BlockCopyChars(_chars, _charPos, array2, 0, num2);
				}
				BufferUtils.ReturnBuffer(_arrayPool, _chars);
				_chars = array2;
			}
			else if (num2 > 0)
			{
				BlockCopyChars(_chars, _charPos, _chars, 0, num2);
			}
			_lineStartPos -= _charPos;
			_charPos = 0;
			_charsUsed = num2;
		}

		private int ReadData(bool append, int charsRequired)
		{
			if (_isEndOfFile)
			{
				return 0;
			}
			PrepareBufferForReadData(append, charsRequired);
			int count = _chars.Length - _charsUsed - 1;
			int num = _reader.Read(_chars, _charsUsed, count);
			_charsUsed += num;
			if (num == 0)
			{
				_isEndOfFile = true;
			}
			_chars[_charsUsed] = '\0';
			return num;
		}

		private bool EnsureChars(int relativePosition, bool append)
		{
			if (_charPos + relativePosition >= _charsUsed)
			{
				return ReadChars(relativePosition, append);
			}
			return true;
		}

		private bool ReadChars(int relativePosition, bool append)
		{
			if (_isEndOfFile)
			{
				return false;
			}
			int num = _charPos + relativePosition - _charsUsed + 1;
			int num2 = 0;
			do
			{
				int num3 = ReadData(append, num - num2);
				if (num3 == 0)
				{
					break;
				}
				num2 += num3;
			}
			while (num2 < num);
			if (num2 < num)
			{
				return false;
			}
			return true;
		}

		public override bool Read()
		{
			EnsureBuffer();
			do
			{
				switch (_currentState)
				{
				case State.Start:
				case State.Property:
				case State.ArrayStart:
				case State.Array:
				case State.ConstructorStart:
				case State.Constructor:
					return ParseValue();
				case State.ObjectStart:
				case State.Object:
					return ParseObject();
				case State.PostValue:
					break;
				case State.Finished:
					if (EnsureChars(0, append: false))
					{
						EatWhitespace();
						if (_isEndOfFile)
						{
							SetToken(JsonToken.None);
							return false;
						}
						if (_chars[_charPos] == '/')
						{
							ParseComment(setToken: true);
							return true;
						}
						throw JsonReaderException.Create(this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
					}
					SetToken(JsonToken.None);
					return false;
				default:
					throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
				}
			}
			while (!ParsePostValue(ignoreComments: false));
			return true;
		}

		public override int? ReadAsInt32()
		{
			return (int?)ReadNumberValue(ReadType.ReadAsInt32);
		}

		public override DateTime? ReadAsDateTime()
		{
			return (DateTime?)ReadStringValue(ReadType.ReadAsDateTime);
		}

		public override string? ReadAsString()
		{
			return (string)ReadStringValue(ReadType.ReadAsString);
		}

		public override byte[]? ReadAsBytes()
		{
			EnsureBuffer();
			bool flag = false;
			switch (_currentState)
			{
			case State.PostValue:
				if (ParsePostValue(ignoreComments: true))
				{
					return null;
				}
				goto case State.Start;
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (ReadNullChar())
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
					{
						ParseString(c, ReadType.ReadAsBytes);
						byte[] array = (byte[])Value;
						if (flag)
						{
							ReaderReadAndAssert();
							if (TokenType != JsonToken.EndObject)
							{
								throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
							}
							SetToken(JsonToken.Bytes, array, updateIndex: false);
						}
						return array;
					}
					case '{':
						_charPos++;
						SetToken(JsonToken.StartObject);
						ReadIntoWrappedTypeObject();
						flag = true;
						break;
					case '[':
						_charPos++;
						SetToken(JsonToken.StartArray);
						return ReadArrayIntoByteArray();
					case 'n':
						HandleNull();
						return null;
					case '/':
						ParseComment(setToken: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						ProcessCarriageReturn(append: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				ReadFinished();
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		private object? ReadStringValue(ReadType readType)
		{
			EnsureBuffer();
			switch (_currentState)
			{
			case State.PostValue:
				if (ParsePostValue(ignoreComments: true))
				{
					return null;
				}
				goto case State.Start;
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (ReadNullChar())
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
						ParseString(c, readType);
						return FinishReadQuotedStringValue(readType);
					case '-':
						if (EnsureChars(1, append: true) && _chars[_charPos + 1] == 'I')
						{
							return ParseNumberNegativeInfinity(readType);
						}
						ParseNumber(readType);
						return Value;
					case '.':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						if (readType != ReadType.ReadAsString)
						{
							_charPos++;
							throw CreateUnexpectedCharacterException(c);
						}
						ParseNumber(ReadType.ReadAsString);
						return Value;
					case 'f':
					case 't':
					{
						if (readType != ReadType.ReadAsString)
						{
							_charPos++;
							throw CreateUnexpectedCharacterException(c);
						}
						string text = ((c == 't') ? JsonConvert.True : JsonConvert.False);
						if (!MatchValueWithTrailingSeparator(text))
						{
							throw CreateUnexpectedCharacterException(_chars[_charPos]);
						}
						SetToken(JsonToken.String, text);
						return text;
					}
					case 'I':
						return ParseNumberPositiveInfinity(readType);
					case 'N':
						return ParseNumberNaN(readType);
					case 'n':
						HandleNull();
						return null;
					case '/':
						ParseComment(setToken: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						ProcessCarriageReturn(append: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				ReadFinished();
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		private object? FinishReadQuotedStringValue(ReadType readType)
		{
			switch (readType)
			{
			case ReadType.ReadAsBytes:
			case ReadType.ReadAsString:
				return Value;
			case ReadType.ReadAsDateTime:
				if (Value is DateTime dateTime)
				{
					return dateTime;
				}
				return ReadDateTimeString((string)Value);
			case ReadType.ReadAsDateTimeOffset:
				if (Value is DateTimeOffset dateTimeOffset)
				{
					return dateTimeOffset;
				}
				return ReadDateTimeOffsetString((string)Value);
			default:
				throw new ArgumentOutOfRangeException("readType");
			}
		}

		private JsonReaderException CreateUnexpectedCharacterException(char c)
		{
			return JsonReaderException.Create(this, "Unexpected character encountered while parsing value: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
		}

		public override bool? ReadAsBoolean()
		{
			EnsureBuffer();
			switch (_currentState)
			{
			case State.PostValue:
				if (ParsePostValue(ignoreComments: true))
				{
					return null;
				}
				goto case State.Start;
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (ReadNullChar())
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
						ParseString(c, ReadType.Read);
						return ReadBooleanString(_stringReference.ToString());
					case 'n':
						HandleNull();
						return null;
					case '-':
					case '.':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
					{
						ParseNumber(ReadType.Read);
						bool flag2 = ((!(Value is BigInteger bigInteger)) ? Convert.ToBoolean(Value, CultureInfo.InvariantCulture) : (bigInteger != 0L));
						SetToken(JsonToken.Boolean, flag2, updateIndex: false);
						return flag2;
					}
					case 'f':
					case 't':
					{
						bool flag = c == 't';
						string value = (flag ? JsonConvert.True : JsonConvert.False);
						if (!MatchValueWithTrailingSeparator(value))
						{
							throw CreateUnexpectedCharacterException(_chars[_charPos]);
						}
						SetToken(JsonToken.Boolean, flag);
						return flag;
					}
					case '/':
						ParseComment(setToken: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						ProcessCarriageReturn(append: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				ReadFinished();
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		private void ProcessValueComma()
		{
			_charPos++;
			if (_currentState != State.PostValue)
			{
				SetToken(JsonToken.Undefined);
				JsonReaderException ex = CreateUnexpectedCharacterException(',');
				_charPos--;
				throw ex;
			}
			SetStateBasedOnCurrent();
		}

		private object? ReadNumberValue(ReadType readType)
		{
			EnsureBuffer();
			switch (_currentState)
			{
			case State.PostValue:
				if (ParsePostValue(ignoreComments: true))
				{
					return null;
				}
				goto case State.Start;
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (ReadNullChar())
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
						ParseString(c, readType);
						return FinishReadQuotedNumber(readType);
					case 'n':
						HandleNull();
						return null;
					case 'N':
						return ParseNumberNaN(readType);
					case 'I':
						return ParseNumberPositiveInfinity(readType);
					case '-':
						if (EnsureChars(1, append: true) && _chars[_charPos + 1] == 'I')
						{
							return ParseNumberNegativeInfinity(readType);
						}
						ParseNumber(readType);
						return Value;
					case '.':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						ParseNumber(readType);
						return Value;
					case '/':
						ParseComment(setToken: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						ProcessCarriageReturn(append: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				ReadFinished();
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		private object? FinishReadQuotedNumber(ReadType readType)
		{
			return readType switch
			{
				ReadType.ReadAsInt32 => ReadInt32String(_stringReference.ToString()), 
				ReadType.ReadAsDecimal => ReadDecimalString(_stringReference.ToString()), 
				ReadType.ReadAsDouble => ReadDoubleString(_stringReference.ToString()), 
				_ => throw new ArgumentOutOfRangeException("readType"), 
			};
		}

		public override DateTimeOffset? ReadAsDateTimeOffset()
		{
			return (DateTimeOffset?)ReadStringValue(ReadType.ReadAsDateTimeOffset);
		}

		public override decimal? ReadAsDecimal()
		{
			return (decimal?)ReadNumberValue(ReadType.ReadAsDecimal);
		}

		public override double? ReadAsDouble()
		{
			return (double?)ReadNumberValue(ReadType.ReadAsDouble);
		}

		private void HandleNull()
		{
			if (EnsureChars(1, append: true))
			{
				if (_chars[_charPos + 1] == 'u')
				{
					ParseNull();
					return;
				}
				_charPos += 2;
				throw CreateUnexpectedCharacterException(_chars[_charPos - 1]);
			}
			_charPos = _charsUsed;
			throw CreateUnexpectedEndException();
		}

		private void ReadFinished()
		{
			if (EnsureChars(0, append: false))
			{
				EatWhitespace();
				if (_isEndOfFile)
				{
					return;
				}
				if (_chars[_charPos] != '/')
				{
					throw JsonReaderException.Create(this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				ParseComment(setToken: false);
			}
			SetToken(JsonToken.None);
		}

		private bool ReadNullChar()
		{
			if (_charsUsed == _charPos)
			{
				if (ReadData(append: false) == 0)
				{
					_isEndOfFile = true;
					return true;
				}
			}
			else
			{
				_charPos++;
			}
			return false;
		}

		private void EnsureBuffer()
		{
			if (_chars == null)
			{
				_chars = BufferUtils.RentBuffer(_arrayPool, 1024);
				_chars[0] = '\0';
			}
		}

		private void ReadStringIntoBuffer(char quote)
		{
			int num = _charPos;
			int charPos = _charPos;
			int lastWritePosition = _charPos;
			_stringBuffer.Position = 0;
			while (true)
			{
				switch (_chars[num++])
				{
				case '\0':
					if (_charsUsed == num - 1)
					{
						num--;
						if (ReadData(append: true) == 0)
						{
							_charPos = num;
							throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
						}
					}
					break;
				case '\\':
				{
					_charPos = num;
					if (!EnsureChars(0, append: true))
					{
						throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
					}
					int writeToPosition = num - 1;
					char c = _chars[num];
					num++;
					char c2;
					switch (c)
					{
					case 'b':
						c2 = '\b';
						break;
					case 't':
						c2 = '\t';
						break;
					case 'n':
						c2 = '\n';
						break;
					case 'f':
						c2 = '\f';
						break;
					case 'r':
						c2 = '\r';
						break;
					case '\\':
						c2 = '\\';
						break;
					case '"':
					case '\'':
					case '/':
						c2 = c;
						break;
					case 'u':
						_charPos = num;
						c2 = ParseUnicode();
						if (StringUtils.IsLowSurrogate(c2))
						{
							c2 = '\ufffd';
						}
						else if (StringUtils.IsHighSurrogate(c2))
						{
							bool flag;
							do
							{
								flag = false;
								if (EnsureChars(2, append: true) && _chars[_charPos] == '\\' && _chars[_charPos + 1] == 'u')
								{
									char writeChar = c2;
									_charPos += 2;
									c2 = ParseUnicode();
									if (!StringUtils.IsLowSurrogate(c2))
									{
										if (StringUtils.IsHighSurrogate(c2))
										{
											writeChar = '\ufffd';
											flag = true;
										}
										else
										{
											writeChar = '\ufffd';
										}
									}
									EnsureBufferNotEmpty();
									WriteCharToBuffer(writeChar, lastWritePosition, writeToPosition);
									lastWritePosition = _charPos;
								}
								else
								{
									c2 = '\ufffd';
								}
							}
							while (flag);
						}
						num = _charPos;
						break;
					default:
						_charPos = num;
						throw JsonReaderException.Create(this, "Bad JSON escape sequence: {0}.".FormatWith(CultureInfo.InvariantCulture, "\\" + c));
					}
					EnsureBufferNotEmpty();
					WriteCharToBuffer(c2, lastWritePosition, writeToPosition);
					lastWritePosition = num;
					break;
				}
				case '\r':
					_charPos = num - 1;
					ProcessCarriageReturn(append: true);
					num = _charPos;
					break;
				case '\n':
					_charPos = num - 1;
					ProcessLineFeed();
					num = _charPos;
					break;
				case '"':
				case '\'':
					if (_chars[num - 1] == quote)
					{
						FinishReadStringIntoBuffer(num - 1, charPos, lastWritePosition);
						return;
					}
					break;
				}
			}
		}

		private void FinishReadStringIntoBuffer(int charPos, int initialPosition, int lastWritePosition)
		{
			if (initialPosition == lastWritePosition)
			{
				_stringReference = new StringReference(_chars, initialPosition, charPos - initialPosition);
			}
			else
			{
				EnsureBufferNotEmpty();
				if (charPos > lastWritePosition)
				{
					_stringBuffer.Append(_arrayPool, _chars, lastWritePosition, charPos - lastWritePosition);
				}
				_stringReference = new StringReference(_stringBuffer.InternalBuffer, 0, _stringBuffer.Position);
			}
			_charPos = charPos + 1;
		}

		private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition)
		{
			if (writeToPosition > lastWritePosition)
			{
				_stringBuffer.Append(_arrayPool, _chars, lastWritePosition, writeToPosition - lastWritePosition);
			}
			_stringBuffer.Append(_arrayPool, writeChar);
		}

		private char ConvertUnicode(bool enoughChars)
		{
			if (enoughChars)
			{
				if (ConvertUtils.TryHexTextToInt(_chars, _charPos, _charPos + 4, out var value))
				{
					char result = Convert.ToChar(value);
					_charPos += 4;
					return result;
				}
				throw JsonReaderException.Create(this, "Invalid Unicode escape sequence: \\u{0}.".FormatWith(CultureInfo.InvariantCulture, new string(_chars, _charPos, 4)));
			}
			throw JsonReaderException.Create(this, "Unexpected end while parsing Unicode escape sequence.");
		}

		private char ParseUnicode()
		{
			return ConvertUnicode(EnsureChars(4, append: true));
		}

		private void ReadNumberIntoBuffer()
		{
			int num = _charPos;
			while (true)
			{
				char c = _chars[num];
				if (c == '\0')
				{
					_charPos = num;
					if (_charsUsed != num || ReadData(append: true) == 0)
					{
						break;
					}
				}
				else
				{
					if (ReadNumberCharIntoBuffer(c, num))
					{
						break;
					}
					num++;
				}
			}
		}

		private bool ReadNumberCharIntoBuffer(char currentChar, int charPos)
		{
			switch (currentChar)
			{
			case '+':
			case '-':
			case '.':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'X':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'x':
				return false;
			default:
				_charPos = charPos;
				if (char.IsWhiteSpace(currentChar) || currentChar == ',' || currentChar == '}' || currentChar == ']' || currentChar == ')' || currentChar == '/')
				{
					return true;
				}
				throw JsonReaderException.Create(this, "Unexpected character encountered while parsing number: {0}.".FormatWith(CultureInfo.InvariantCulture, currentChar));
			}
		}

		private void ClearRecentString()
		{
			_stringBuffer.Position = 0;
			_stringReference = default(StringReference);
		}

		private bool ParsePostValue(bool ignoreComments)
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							_currentState = State.Finished;
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					continue;
				case '}':
					_charPos++;
					SetToken(JsonToken.EndObject);
					return true;
				case ']':
					_charPos++;
					SetToken(JsonToken.EndArray);
					return true;
				case ')':
					_charPos++;
					SetToken(JsonToken.EndConstructor);
					return true;
				case '/':
					ParseComment(!ignoreComments);
					if (!ignoreComments)
					{
						return true;
					}
					continue;
				case ',':
					_charPos++;
					SetStateBasedOnCurrent();
					return false;
				case '\t':
				case ' ':
					_charPos++;
					continue;
				case '\r':
					ProcessCarriageReturn(append: false);
					continue;
				case '\n':
					ProcessLineFeed();
					continue;
				}
				if (char.IsWhiteSpace(c))
				{
					_charPos++;
					continue;
				}
				if (base.SupportMultipleContent && Depth == 0)
				{
					SetStateBasedOnCurrent();
					return false;
				}
				throw JsonReaderException.Create(this, "After parsing a value an unexpected character was encountered: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
			}
		}

		private bool ParseObject()
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '}':
					SetToken(JsonToken.EndObject);
					_charPos++;
					return true;
				case '/':
					ParseComment(setToken: true);
					return true;
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					if (char.IsWhiteSpace(c))
					{
						_charPos++;
						break;
					}
					return ParseProperty();
				}
			}
		}

		private bool ParseProperty()
		{
			char c = _chars[_charPos];
			char c2;
			if (c == '"' || c == '\'')
			{
				_charPos++;
				c2 = c;
				ShiftBufferIfNeeded();
				ReadStringIntoBuffer(c2);
			}
			else
			{
				if (!ValidIdentifierChar(c))
				{
					throw JsonReaderException.Create(this, "Invalid property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				c2 = '\0';
				ShiftBufferIfNeeded();
				ParseUnquotedProperty();
			}
			string text;
			if (PropertyNameTable != null)
			{
				text = PropertyNameTable.Get(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length);
				if (text == null)
				{
					text = _stringReference.ToString();
				}
			}
			else
			{
				text = _stringReference.ToString();
			}
			EatWhitespace();
			if (_chars[_charPos] != ':')
			{
				throw JsonReaderException.Create(this, "Invalid character after parsing property name. Expected ':' but got: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
			}
			_charPos++;
			SetToken(JsonToken.PropertyName, text);
			_quoteChar = c2;
			ClearRecentString();
			return true;
		}

		private bool ValidIdentifierChar(char value)
		{
			if (!char.IsLetterOrDigit(value) && value != '_')
			{
				return value == '$';
			}
			return true;
		}

		private void ParseUnquotedProperty()
		{
			int charPos = _charPos;
			while (true)
			{
				char c = _chars[_charPos];
				if (c == '\0')
				{
					if (_charsUsed != _charPos)
					{
						_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
						break;
					}
					if (ReadData(append: true) == 0)
					{
						throw JsonReaderException.Create(this, "Unexpected end while parsing unquoted property name.");
					}
				}
				else if (ReadUnquotedPropertyReportIfDone(c, charPos))
				{
					break;
				}
			}
		}

		private bool ReadUnquotedPropertyReportIfDone(char currentChar, int initialPosition)
		{
			if (ValidIdentifierChar(currentChar))
			{
				_charPos++;
				return false;
			}
			if (char.IsWhiteSpace(currentChar) || currentChar == ':')
			{
				_stringReference = new StringReference(_chars, initialPosition, _charPos - initialPosition);
				return true;
			}
			throw JsonReaderException.Create(this, "Invalid JavaScript property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture, currentChar));
		}

		private bool ParseValue()
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '"':
				case '\'':
					ParseString(c, ReadType.Read);
					return true;
				case 't':
					ParseTrue();
					return true;
				case 'f':
					ParseFalse();
					return true;
				case 'n':
					if (EnsureChars(1, append: true))
					{
						switch (_chars[_charPos + 1])
						{
						case 'u':
							ParseNull();
							break;
						case 'e':
							ParseConstructor();
							break;
						default:
							throw CreateUnexpectedCharacterException(_chars[_charPos]);
						}
						return true;
					}
					_charPos++;
					throw CreateUnexpectedEndException();
				case 'N':
					ParseNumberNaN(ReadType.Read);
					return true;
				case 'I':
					ParseNumberPositiveInfinity(ReadType.Read);
					return true;
				case '-':
					if (EnsureChars(1, append: true) && _chars[_charPos + 1] == 'I')
					{
						ParseNumberNegativeInfinity(ReadType.Read);
					}
					else
					{
						ParseNumber(ReadType.Read);
					}
					return true;
				case '/':
					ParseComment(setToken: true);
					return true;
				case 'u':
					ParseUndefined();
					return true;
				case '{':
					_charPos++;
					SetToken(JsonToken.StartObject);
					return true;
				case '[':
					_charPos++;
					SetToken(JsonToken.StartArray);
					return true;
				case ']':
					_charPos++;
					SetToken(JsonToken.EndArray);
					return true;
				case ',':
					SetToken(JsonToken.Undefined);
					return true;
				case ')':
					_charPos++;
					SetToken(JsonToken.EndConstructor);
					return true;
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					if (char.IsWhiteSpace(c))
					{
						_charPos++;
						break;
					}
					if (char.IsNumber(c) || c == '-' || c == '.')
					{
						ParseNumber(ReadType.Read);
						return true;
					}
					throw CreateUnexpectedCharacterException(c);
				}
			}
		}

		private void ProcessLineFeed()
		{
			_charPos++;
			OnNewLine(_charPos);
		}

		private void ProcessCarriageReturn(bool append)
		{
			_charPos++;
			SetNewLine(EnsureChars(1, append));
		}

		private void EatWhitespace()
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							return;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				default:
					if (!char.IsWhiteSpace(c))
					{
						return;
					}
					goto case ' ';
				case ' ':
					_charPos++;
					break;
				}
			}
		}

		private void ParseConstructor()
		{
			if (MatchValueWithTrailingSeparator("new"))
			{
				EatWhitespace();
				int charPos = _charPos;
				int charPos2;
				while (true)
				{
					char c = _chars[_charPos];
					if (c == '\0')
					{
						if (_charsUsed == _charPos)
						{
							if (ReadData(append: true) == 0)
							{
								throw JsonReaderException.Create(this, "Unexpected end while parsing constructor.");
							}
							continue;
						}
						charPos2 = _charPos;
						_charPos++;
						break;
					}
					if (char.IsLetterOrDigit(c))
					{
						_charPos++;
						continue;
					}
					switch (c)
					{
					case '\r':
						charPos2 = _charPos;
						ProcessCarriageReturn(append: true);
						break;
					case '\n':
						charPos2 = _charPos;
						ProcessLineFeed();
						break;
					default:
						if (char.IsWhiteSpace(c))
						{
							charPos2 = _charPos;
							_charPos++;
							break;
						}
						if (c == '(')
						{
							charPos2 = _charPos;
							break;
						}
						throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
					}
					break;
				}
				_stringReference = new StringReference(_chars, charPos, charPos2 - charPos);
				string value = _stringReference.ToString();
				EatWhitespace();
				if (_chars[_charPos] != '(')
				{
					throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				_charPos++;
				ClearRecentString();
				SetToken(JsonToken.StartConstructor, value);
				return;
			}
			throw JsonReaderException.Create(this, "Unexpected content while parsing JSON.");
		}

		private void ParseNumber(ReadType readType)
		{
			ShiftBufferIfNeeded();
			char firstChar = _chars[_charPos];
			int charPos = _charPos;
			ReadNumberIntoBuffer();
			ParseReadNumber(readType, firstChar, charPos);
		}

		private void ParseReadNumber(ReadType readType, char firstChar, int initialPosition)
		{
			SetPostValueState(updateIndex: true);
			_stringReference = new StringReference(_chars, initialPosition, _charPos - initialPosition);
			bool flag = char.IsDigit(firstChar) && _stringReference.Length == 1;
			bool flag2 = firstChar == '0' && _stringReference.Length > 1 && _stringReference.Chars[_stringReference.StartIndex + 1] != '.' && _stringReference.Chars[_stringReference.StartIndex + 1] != 'e' && _stringReference.Chars[_stringReference.StartIndex + 1] != 'E';
			JsonToken newToken;
			object value;
			switch (readType)
			{
			case ReadType.ReadAsString:
			{
				string text5 = _stringReference.ToString();
				double result3;
				if (flag2)
				{
					try
					{
						if (text5.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
						{
							Convert.ToInt64(text5, 16);
						}
						else
						{
							Convert.ToInt64(text5, 8);
						}
					}
					catch (Exception ex4)
					{
						throw ThrowReaderError("Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, text5), ex4);
					}
				}
				else if (!double.TryParse(text5, NumberStyles.Float, CultureInfo.InvariantCulture, out result3))
				{
					throw ThrowReaderError("Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
				}
				newToken = JsonToken.String;
				value = text5;
				break;
			}
			case ReadType.ReadAsInt32:
				if (flag)
				{
					value = firstChar - 48;
				}
				else if (flag2)
				{
					string text6 = _stringReference.ToString();
					try
					{
						value = (text6.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt32(text6, 16) : Convert.ToInt32(text6, 8));
					}
					catch (Exception ex5)
					{
						throw ThrowReaderError("Input string '{0}' is not a valid integer.".FormatWith(CultureInfo.InvariantCulture, text6), ex5);
					}
				}
				else
				{
					int value5;
					switch (ConvertUtils.Int32TryParse(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length, out value5))
					{
					case ParseResult.Success:
						break;
					case ParseResult.Overflow:
						throw ThrowReaderError("JSON integer {0} is too large or small for an Int32.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					default:
						throw ThrowReaderError("Input string '{0}' is not a valid integer.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					}
					value = value5;
				}
				newToken = JsonToken.Integer;
				break;
			case ReadType.ReadAsDecimal:
				if (flag)
				{
					value = (decimal)firstChar - 48m;
				}
				else if (flag2)
				{
					string text3 = _stringReference.ToString();
					try
					{
						value = Convert.ToDecimal(text3.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(text3, 16) : Convert.ToInt64(text3, 8));
					}
					catch (Exception ex2)
					{
						throw ThrowReaderError("Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, text3), ex2);
					}
				}
				else
				{
					if (ConvertUtils.DecimalTryParse(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length, out var value4) != ParseResult.Success)
					{
						throw ThrowReaderError("Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					}
					value = value4;
				}
				newToken = JsonToken.Float;
				break;
			case ReadType.ReadAsDouble:
				if (flag)
				{
					value = (double)(int)firstChar - 48.0;
				}
				else if (flag2)
				{
					string text4 = _stringReference.ToString();
					try
					{
						value = Convert.ToDouble(text4.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(text4, 16) : Convert.ToInt64(text4, 8));
					}
					catch (Exception ex3)
					{
						throw ThrowReaderError("Input string '{0}' is not a valid double.".FormatWith(CultureInfo.InvariantCulture, text4), ex3);
					}
				}
				else
				{
					if (!double.TryParse(_stringReference.ToString(), NumberStyles.Float, CultureInfo.InvariantCulture, out var result2))
					{
						throw ThrowReaderError("Input string '{0}' is not a valid double.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					}
					value = result2;
				}
				newToken = JsonToken.Float;
				break;
			case ReadType.Read:
			case ReadType.ReadAsInt64:
			{
				if (flag)
				{
					value = (long)firstChar - 48L;
					newToken = JsonToken.Integer;
					break;
				}
				if (flag2)
				{
					string text = _stringReference.ToString();
					try
					{
						value = (text.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(text, 16) : Convert.ToInt64(text, 8));
					}
					catch (Exception ex)
					{
						throw ThrowReaderError("Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, text), ex);
					}
					newToken = JsonToken.Integer;
					break;
				}
				long value2;
				switch (ConvertUtils.Int64TryParse(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length, out value2))
				{
				case ParseResult.Success:
					value = value2;
					newToken = JsonToken.Integer;
					break;
				case ParseResult.Overflow:
				{
					string text2 = _stringReference.ToString();
					if (text2.Length > 380)
					{
						throw ThrowReaderError("JSON integer {0} is too large to parse.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					}
					value = BigIntegerParse(text2, CultureInfo.InvariantCulture);
					newToken = JsonToken.Integer;
					break;
				}
				default:
					if (_floatParseHandling == FloatParseHandling.Decimal)
					{
						decimal value3;
						ParseResult parseResult = ConvertUtils.DecimalTryParse(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length, out value3);
						if (parseResult != ParseResult.Success)
						{
							throw ThrowReaderError("Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
						}
						value = value3;
					}
					else
					{
						if (!double.TryParse(_stringReference.ToString(), NumberStyles.Float, CultureInfo.InvariantCulture, out var result))
						{
							throw ThrowReaderError("Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
						}
						value = result;
					}
					newToken = JsonToken.Float;
					break;
				}
				break;
			}
			default:
				throw JsonReaderException.Create(this, "Cannot read number value as type.");
			}
			ClearRecentString();
			SetToken(newToken, value, updateIndex: false);
		}

		private JsonReaderException ThrowReaderError(string message, Exception? ex = null)
		{
			SetToken(JsonToken.Undefined, null, updateIndex: false);
			return JsonReaderException.Create(this, message, ex);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private static object BigIntegerParse(string number, CultureInfo culture)
		{
			return BigInteger.Parse(number, culture);
		}

		private void ParseComment(bool setToken)
		{
			_charPos++;
			if (!EnsureChars(1, append: false))
			{
				throw JsonReaderException.Create(this, "Unexpected end while parsing comment.");
			}
			bool flag;
			if (_chars[_charPos] == '*')
			{
				flag = false;
			}
			else
			{
				if (_chars[_charPos] != '/')
				{
					throw JsonReaderException.Create(this, "Error parsing comment. Expected: *, got {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				flag = true;
			}
			_charPos++;
			int charPos = _charPos;
			while (true)
			{
				switch (_chars[_charPos])
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: true) == 0)
						{
							if (!flag)
							{
								throw JsonReaderException.Create(this, "Unexpected end while parsing comment.");
							}
							EndComment(setToken, charPos, _charPos);
							return;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '*':
					_charPos++;
					if (!flag && EnsureChars(0, append: true) && _chars[_charPos] == '/')
					{
						EndComment(setToken, charPos, _charPos - 1);
						_charPos++;
						return;
					}
					break;
				case '\r':
					if (flag)
					{
						EndComment(setToken, charPos, _charPos);
						return;
					}
					ProcessCarriageReturn(append: true);
					break;
				case '\n':
					if (flag)
					{
						EndComment(setToken, charPos, _charPos);
						return;
					}
					ProcessLineFeed();
					break;
				default:
					_charPos++;
					break;
				}
			}
		}

		private void EndComment(bool setToken, int initialPosition, int endPosition)
		{
			if (setToken)
			{
				SetToken(JsonToken.Comment, new string(_chars, initialPosition, endPosition - initialPosition));
			}
		}

		private bool MatchValue(string value)
		{
			return MatchValue(EnsureChars(value.Length - 1, append: true), value);
		}

		private bool MatchValue(bool enoughChars, string value)
		{
			if (!enoughChars)
			{
				_charPos = _charsUsed;
				throw CreateUnexpectedEndException();
			}
			for (int i = 0; i < value.Length; i++)
			{
				if (_chars[_charPos + i] != value[i])
				{
					_charPos += i;
					return false;
				}
			}
			_charPos += value.Length;
			return true;
		}

		private bool MatchValueWithTrailingSeparator(string value)
		{
			if (!MatchValue(value))
			{
				return false;
			}
			if (!EnsureChars(0, append: false))
			{
				return true;
			}
			if (!IsSeparator(_chars[_charPos]))
			{
				return _chars[_charPos] == '\0';
			}
			return true;
		}

		private bool IsSeparator(char c)
		{
			switch (c)
			{
			case ',':
			case ']':
			case '}':
				return true;
			case '/':
			{
				if (!EnsureChars(1, append: false))
				{
					return false;
				}
				char c2 = _chars[_charPos + 1];
				if (c2 != '*')
				{
					return c2 == '/';
				}
				return true;
			}
			case ')':
				if (base.CurrentState == State.Constructor || base.CurrentState == State.ConstructorStart)
				{
					return true;
				}
				break;
			case '\t':
			case '\n':
			case '\r':
			case ' ':
				return true;
			default:
				if (char.IsWhiteSpace(c))
				{
					return true;
				}
				break;
			}
			return false;
		}

		private void ParseTrue()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.True))
			{
				SetToken(JsonToken.Boolean, true);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing boolean value.");
		}

		private void ParseNull()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.Null))
			{
				SetToken(JsonToken.Null);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing null value.");
		}

		private void ParseUndefined()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.Undefined))
			{
				SetToken(JsonToken.Undefined);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing undefined value.");
		}

		private void ParseFalse()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.False))
			{
				SetToken(JsonToken.Boolean, false);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing boolean value.");
		}

		private object ParseNumberNegativeInfinity(ReadType readType)
		{
			return ParseNumberNegativeInfinity(readType, MatchValueWithTrailingSeparator(JsonConvert.NegativeInfinity));
		}

		private object ParseNumberNegativeInfinity(ReadType readType, bool matched)
		{
			if (matched)
			{
				switch (readType)
				{
				case ReadType.Read:
				case ReadType.ReadAsDouble:
					if (_floatParseHandling == FloatParseHandling.Double)
					{
						SetToken(JsonToken.Float, double.NegativeInfinity);
						return double.NegativeInfinity;
					}
					break;
				case ReadType.ReadAsString:
					SetToken(JsonToken.String, JsonConvert.NegativeInfinity);
					return JsonConvert.NegativeInfinity;
				}
				throw JsonReaderException.Create(this, "Cannot read -Infinity value.");
			}
			throw JsonReaderException.Create(this, "Error parsing -Infinity value.");
		}

		private object ParseNumberPositiveInfinity(ReadType readType)
		{
			return ParseNumberPositiveInfinity(readType, MatchValueWithTrailingSeparator(JsonConvert.PositiveInfinity));
		}

		private object ParseNumberPositiveInfinity(ReadType readType, bool matched)
		{
			if (matched)
			{
				switch (readType)
				{
				case ReadType.Read:
				case ReadType.ReadAsDouble:
					if (_floatParseHandling == FloatParseHandling.Double)
					{
						SetToken(JsonToken.Float, double.PositiveInfinity);
						return double.PositiveInfinity;
					}
					break;
				case ReadType.ReadAsString:
					SetToken(JsonToken.String, JsonConvert.PositiveInfinity);
					return JsonConvert.PositiveInfinity;
				}
				throw JsonReaderException.Create(this, "Cannot read Infinity value.");
			}
			throw JsonReaderException.Create(this, "Error parsing Infinity value.");
		}

		private object ParseNumberNaN(ReadType readType)
		{
			return ParseNumberNaN(readType, MatchValueWithTrailingSeparator(JsonConvert.NaN));
		}

		private object ParseNumberNaN(ReadType readType, bool matched)
		{
			if (matched)
			{
				switch (readType)
				{
				case ReadType.Read:
				case ReadType.ReadAsDouble:
					if (_floatParseHandling == FloatParseHandling.Double)
					{
						SetToken(JsonToken.Float, double.NaN);
						return double.NaN;
					}
					break;
				case ReadType.ReadAsString:
					SetToken(JsonToken.String, JsonConvert.NaN);
					return JsonConvert.NaN;
				}
				throw JsonReaderException.Create(this, "Cannot read NaN value.");
			}
			throw JsonReaderException.Create(this, "Error parsing NaN value.");
		}

		public override void Close()
		{
			base.Close();
			if (_chars != null)
			{
				BufferUtils.ReturnBuffer(_arrayPool, _chars);
				_chars = null;
			}
			if (base.CloseInput)
			{
				_reader?.Close();
			}
			_stringBuffer.Clear(_arrayPool);
		}

		public bool HasLineInfo()
		{
			return true;
		}
	}
	internal enum ReadType
	{
		Read,
		ReadAsInt32,
		ReadAsInt64,
		ReadAsBytes,
		ReadAsString,
		ReadAsDecimal,
		ReadAsDateTime,
		ReadAsDateTimeOffset,
		ReadAsDouble,
		ReadAsBoolean
	}
	internal class JsonTextWriter : JsonWriter
	{
		private readonly bool _safeAsync;

		private const int IndentCharBufferSize = 12;

		private readonly TextWriter _writer;

		private Base64Encoder? _base64Encoder;

		private char _indentChar;

		private int _indentation;

		private char _quoteChar;

		private bool _quoteName;

		private bool[]? _charEscapeFlags;

		private char[]? _writeBuffer;

		private IArrayPool<char>? _arrayPool;

		private char[]? _indentChars;

		private Base64Encoder Base64Encoder
		{
			get
			{
				if (_base64Encoder == null)
				{
					_base64Encoder = new Base64Encoder(_writer);
				}
				return _base64Encoder;
			}
		}

		public IArrayPool<char>? ArrayPool
		{
			get
			{
				return _arrayPool;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				_arrayPool = value;
			}
		}

		public int Indentation
		{
			get
			{
				return _indentation;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("Indentation value must be greater than 0.");
				}
				_indentation = value;
			}
		}

		public char QuoteChar
		{
			get
			{
				return _quoteChar;
			}
			set
			{
				if (value != '"' && value != '\'')
				{
					throw new ArgumentException("Invalid JavaScript string quote character. Valid quote characters are ' and \".");
				}
				_quoteChar = value;
				UpdateCharEscapeFlags();
			}
		}

		public char IndentChar
		{
			get
			{
				return _indentChar;
			}
			set
			{
				if (value != _indentChar)
				{
					_indentChar = value;
					_indentChars = null;
				}
			}
		}

		public bool QuoteName
		{
			get
			{
				return _quoteName;
			}
			set
			{
				_quoteName = value;
			}
		}

		public override Task FlushAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.FlushAsync(cancellationToken);
			}
			return DoFlushAsync(cancellationToken);
		}

		internal Task DoFlushAsync(CancellationToken cancellationToken)
		{
			return cancellationToken.CancelIfRequestedAsync() ?? _writer.FlushAsync();
		}

		protected override Task WriteValueDelimiterAsync(CancellationToken cancellationToken)
		{
			if (!_safeAsync)
			{
				return base.WriteValueDelimiterAsync(cancellationToken);
			}
			return DoWriteValueDelimiterAsync(cancellationToken);
		}

		internal Task DoWriteValueDelimiterAsync(CancellationToken cancellationToken)
		{
			return _writer.WriteAsync(',', cancellationToken);
		}

		protected override Task WriteEndAsync(JsonToken token, CancellationToken cancellationToken)
		{
			if (!_safeAsync)
			{
				return base.WriteEndAsync(token, cancellationToken);
			}
			return DoWriteEndAsync(token, cancellationToken);
		}

		internal Task DoWriteEndAsync(JsonToken token, CancellationToken cancellationToken)
		{
			return token switch
			{
				JsonToken.EndObject => _writer.WriteAsync('}', cancellationToken), 
				JsonToken.EndArray => _writer.WriteAsync(']', cancellationToken), 
				JsonToken.EndConstructor => _writer.WriteAsync(')', cancellationToken), 
				_ => throw JsonWriterException.Create(this, "Invalid JsonToken: " + token, null), 
			};
		}

		public override Task CloseAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.CloseAsync(cancellationToken);
			}
			return DoCloseAsync(cancellationToken);
		}

		internal async Task DoCloseAsync(CancellationToken cancellationToken)
		{
			if (base.Top == 0)
			{
				cancellationToken.ThrowIfCancellationRequested();
			}
			while (base.Top > 0)
			{
				await WriteEndAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			CloseBufferAndWriter();
		}

		public override Task WriteEndAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteEndAsync(cancellationToken);
			}
			return WriteEndInternalAsync(cancellationToken);
		}

		protected override Task WriteIndentAsync(CancellationToken cancellationToken)
		{
			if (!_safeAsync)
			{
				return base.WriteIndentAsync(cancellationToken);
			}
			return DoWriteIndentAsync(cancellationToken);
		}

		internal Task DoWriteIndentAsync(CancellationToken cancellationToken)
		{
			int num = base.Top * _indentation;
			int num2 = SetIndentChars();
			if (num <= 12)
			{
				return _writer.WriteAsync(_indentChars, 0, num2 + num, cancellationToken);
			}
			return WriteIndentAsync(num, num2, cancellationToken);
		}

		private async Task WriteIndentAsync(int currentIndentCount, int newLineLen, CancellationToken cancellationToken)
		{
			await _writer.WriteAsync(_indentChars, 0, newLineLen + Math.Min(currentIndentCount, 12), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			while (true)
			{
				int num;
				currentIndentCount = (num = currentIndentCount - 12);
				if (num <= 0)
				{
					break;
				}
				await _writer.WriteAsync(_indentChars, newLineLen, Math.Min(currentIndentCount, 12), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		private Task WriteValueInternalAsync(JsonToken token, string value, CancellationToken cancellationToken)
		{
			Task task = InternalWriteValueAsync(token, cancellationToken);
			if (task.IsCompletedSucessfully())
			{
				return _writer.WriteAsync(value, cancellationToken);
			}
			return WriteValueInternalAsync(task, value, cancellationToken);
		}

		private async Task WriteValueInternalAsync(Task task, string value, CancellationToken cancellationToken)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(value, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		protected override Task WriteIndentSpaceAsync(CancellationToken cancellationToken)
		{
			if (!_safeAsync)
			{
				return base.WriteIndentSpaceAsync(cancellationToken);
			}
			return DoWriteIndentSpaceAsync(cancellationToken);
		}

		internal Task DoWriteIndentSpaceAsync(CancellationToken cancellationToken)
		{
			return _writer.WriteAsync(' ', cancellationToken);
		}

		public override Task WriteRawAsync(string? json, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteRawAsync(json, cancellationToken);
			}
			return DoWriteRawAsync(json, cancellationToken);
		}

		internal Task DoWriteRawAsync(string? json, CancellationToken cancellationToken)
		{
			return _writer.WriteAsync(json, cancellationToken);
		}

		public override Task WriteNullAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteNullAsync(cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		internal Task DoWriteNullAsync(CancellationToken cancellationToken)
		{
			return WriteValueInternalAsync(JsonToken.Null, JsonConvert.Null, cancellationToken);
		}

		private Task WriteDigitsAsync(ulong uvalue, bool negative, CancellationToken cancellationToken)
		{
			if (uvalue <= 9 && !negative)
			{
				return _writer.WriteAsync((char)(48 + uvalue), cancellationToken);
			}
			int count = WriteNumberToBuffer(uvalue, negative);
			return _writer.WriteAsync(_writeBuffer, 0, count, cancellationToken);
		}

		private Task WriteIntegerValueAsync(ulong uvalue, bool negative, CancellationToken cancellationToken)
		{
			Task task = InternalWriteValueAsync(JsonToken.Integer, cancellationToken);
			if (task.IsCompletedSucessfully())
			{
				return WriteDigitsAsync(uvalue, negative, cancellationToken);
			}
			return WriteIntegerValueAsync(task, uvalue, negative, cancellationToken);
		}

		private async Task WriteIntegerValueAsync(Task task, ulong uvalue, bool negative, CancellationToken cancellationToken)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			await WriteDigitsAsync(uvalue, negative, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal Task WriteIntegerValueAsync(long value, CancellationToken cancellationToken)
		{
			bool flag = value < 0;
			if (flag)
			{
				value = -value;
			}
			return WriteIntegerValueAsync((ulong)value, flag, cancellationToken);
		}

		internal Task WriteIntegerValueAsync(ulong uvalue, CancellationToken cancellationToken)
		{
			return WriteIntegerValueAsync(uvalue, negative: false, cancellationToken);
		}

		private Task WriteEscapedStringAsync(string value, bool quote, CancellationToken cancellationToken)
		{
			return JavaScriptUtils.WriteEscapedJavaScriptStringAsync(_writer, value, _quoteChar, quote, _charEscapeFlags, base.StringEscapeHandling, this, _writeBuffer, cancellationToken);
		}

		public override Task WritePropertyNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WritePropertyNameAsync(name, cancellationToken);
			}
			return DoWritePropertyNameAsync(name, cancellationToken);
		}

		internal Task DoWritePropertyNameAsync(string name, CancellationToken cancellationToken)
		{
			Task task = InternalWritePropertyNameAsync(name, cancellationToken);
			if (!task.IsCompletedSucessfully())
			{
				return DoWritePropertyNameAsync(task, name, cancellationToken);
			}
			task = WriteEscapedStringAsync(name, _quoteName, cancellationToken);
			if (task.IsCompletedSucessfully())
			{
				return _writer.WriteAsync(':', cancellationToken);
			}
			return JavaScriptUtils.WriteCharAsync(task, _writer, ':', cancellationToken);
		}

		private async Task DoWritePropertyNameAsync(Task task, string name, CancellationToken cancellationToken)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			await WriteEscapedStringAsync(name, _quoteName, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(':').ConfigureAwait(continueOnCapturedContext: false);
		}

		public override Task WritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WritePropertyNameAsync(name, escape, cancellationToken);
			}
			return DoWritePropertyNameAsync(name, escape, cancellationToken);
		}

		internal async Task DoWritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken)
		{
			await InternalWritePropertyNameAsync(name, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (escape)
			{
				await WriteEscapedStringAsync(name, _quoteName, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				if (_quoteName)
				{
					await _writer.WriteAsync(_quoteChar).ConfigureAwait(continueOnCapturedContext: false);
				}
				await _writer.WriteAsync(name, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (_quoteName)
				{
					await _writer.WriteAsync(_quoteChar).ConfigureAwait(continueOnCapturedContext: false);
				}
			}
			await _writer.WriteAsync(':').ConfigureAwait(continueOnCapturedContext: false);
		}

		public override Task WriteStartArrayAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteStartArrayAsync(cancellationToken);
			}
			return DoWriteStartArrayAsync(cancellationToken);
		}

		internal Task DoWriteStartArrayAsync(CancellationToken cancellationToken)
		{
			Task task = InternalWriteStartAsync(JsonToken.StartArray, JsonContainerType.Array, cancellationToken);
			if (task.IsCompletedSucessfully())
			{
				return _writer.WriteAsync('[', cancellationToken);
			}
			return DoWriteStartArrayAsync(task, cancellationToken);
		}

		internal async Task DoWriteStartArrayAsync(Task task, CancellationToken cancellationToken)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync('[', cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override Task WriteStartObjectAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteStartObjectAsync(cancellationToken);
			}
			return DoWriteStartObjectAsync(cancellationToken);
		}

		internal Task DoWriteStartObjectAsync(CancellationToken cancellationToken)
		{
			Task task = InternalWriteStartAsync(JsonToken.StartObject, JsonContainerType.Object, cancellationToken);
			if (task.IsCompletedSucessfully())
			{
				return _writer.WriteAsync('{', cancellationToken);
			}
			return DoWriteStartObjectAsync(task, cancellationToken);
		}

		internal async Task DoWriteStartObjectAsync(Task task, CancellationToken cancellationToken)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync('{', cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override Task WriteStartConstructorAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteStartConstructorAsync(name, cancellationToken);
			}
			return DoWriteStartConstructorAsync(name, cancellationToken);
		}

		internal async Task DoWriteStartConstructorAsync(string name, CancellationToken cancellationToken)
		{
			await InternalWriteStartAsync(JsonToken.StartConstructor, JsonContainerType.Constructor, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync("new ", cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(name, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync('(').ConfigureAwait(continueOnCapturedContext: false);
		}

		public override Task WriteUndefinedAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteUndefinedAsync(cancellationToken);
			}
			return DoWriteUndefinedAsync(cancellationToken);
		}

		internal Task DoWriteUndefinedAsync(CancellationToken cancellationToken)
		{
			Task task = InternalWriteValueAsync(JsonToken.Undefined, cancellationToken);
			if (task.IsCompletedSucessfully())
			{
				return _writer.WriteAsync(JsonConvert.Undefined, cancellationToken);
			}
			return DoWriteUndefinedAsync(task, cancellationToken);
		}

		private async Task DoWriteUndefinedAsync(Task task, CancellationToken cancellationToken)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(JsonConvert.Undefined, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override Task WriteWhitespaceAsync(string ws, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteWhitespaceAsync(ws, cancellationToken);
			}
			return DoWriteWhitespaceAsync(ws, cancellationToken);
		}

		internal Task DoWriteWhitespaceAsync(string ws, CancellationToken cancellationToken)
		{
			InternalWriteWhitespace(ws);
			return _writer.WriteAsync(ws, cancellationToken);
		}

		public override Task WriteValueAsync(bool value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(bool value, CancellationToken cancellationToken)
		{
			return WriteValueInternalAsync(JsonToken.Boolean, JsonConvert.ToString(value), cancellationToken);
		}

		public override Task WriteValueAsync(bool? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(bool? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return DoWriteValueAsync(value == true, cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteValueAsync(byte value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return WriteIntegerValueAsync(value, cancellationToken);
		}

		public override Task WriteValueAsync(byte? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(byte? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return WriteIntegerValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteValueAsync(byte[]? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			if (value != null)
			{
				return WriteValueNonNullAsync(value, cancellationToken);
			}
			return WriteNullAsync(cancellationToken);
		}

		internal async Task WriteValueNonNullAsync(byte[] value, CancellationToken cancellationToken)
		{
			await InternalWriteValueAsync(JsonToken.Bytes, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(_quoteChar).ConfigureAwait(continueOnCapturedContext: false);
			await Base64Encoder.EncodeAsync(value, 0, value.Length, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await Base64Encoder.FlushAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(_quoteChar).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override Task WriteValueAsync(char value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(char value, CancellationToken cancellationToken)
		{
			return WriteValueInternalAsync(JsonToken.String, JsonConvert.ToString(value), cancellationToken);
		}

		public override Task WriteValueAsync(char? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(char? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return DoWriteValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteValueAsync(DateTime value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal async Task DoWriteValueAsync(DateTime value, CancellationToken cancellationToken)
		{
			await InternalWriteValueAsync(JsonToken.Date, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			value = DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
			if (StringUtils.IsNullOrEmpty(base.DateFormatString))
			{
				int count = WriteValueToBuffer(value);
				await _writer.WriteAsync(_writeBuffer, 0, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				await _writer.WriteAsync(_quoteChar).ConfigureAwait(continueOnCapturedContext: false);
				await _writer.WriteAsync(value.ToString(base.DateFormatString, base.Culture), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				await _writer.WriteAsync(_quoteChar).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		public override Task WriteValueAsync(DateTime? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(DateTime? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return DoWriteValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal async Task DoWriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken)
		{
			await InternalWriteValueAsync(JsonToken.Date, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (StringUtils.IsNullOrEmpty(base.DateFormatString))
			{
				int count = WriteValueToBuffer(value);
				await _writer.WriteAsync(_writeBuffer, 0, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				await _writer.WriteAsync(_quoteChar).ConfigureAwait(continueOnCapturedContext: false);
				await _writer.WriteAsync(value.ToString(base.DateFormatString, base.Culture), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				await _writer.WriteAsync(_quoteChar).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		public override Task WriteValueAsync(DateTimeOffset? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(DateTimeOffset? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return DoWriteValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteValueAsync(decimal value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(decimal value, CancellationToken cancellationToken)
		{
			return WriteValueInternalAsync(JsonToken.Float, JsonConvert.ToString(value), cancellationToken);
		}

		public override Task WriteValueAsync(decimal? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(decimal? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return DoWriteValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteValueAsync(double value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return WriteValueAsync(value, nullable: false, cancellationToken);
		}

		internal Task WriteValueAsync(double value, bool nullable, CancellationToken cancellationToken)
		{
			return WriteValueInternalAsync(JsonToken.Float, JsonConvert.ToString(value, base.FloatFormatHandling, QuoteChar, nullable), cancellationToken);
		}

		public override Task WriteValueAsync(double? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			if (!value.HasValue)
			{
				return WriteNullAsync(cancellationToken);
			}
			return WriteValueAsync(value.GetValueOrDefault(), nullable: true, cancellationToken);
		}

		public override Task WriteValueAsync(float value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return WriteValueAsync(value, nullable: false, cancellationToken);
		}

		internal Task WriteValueAsync(float value, bool nullable, CancellationToken cancellationToken)
		{
			return WriteValueInternalAsync(JsonToken.Float, JsonConvert.ToString(value, base.FloatFormatHandling, QuoteChar, nullable), cancellationToken);
		}

		public override Task WriteValueAsync(float? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			if (!value.HasValue)
			{
				return WriteNullAsync(cancellationToken);
			}
			return WriteValueAsync(value.GetValueOrDefault(), nullable: true, cancellationToken);
		}

		public override Task WriteValueAsync(Guid value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal async Task DoWriteValueAsync(Guid value, CancellationToken cancellationToken)
		{
			await InternalWriteValueAsync(JsonToken.String, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(_quoteChar).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(value.ToString("D", CultureInfo.InvariantCulture), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(_quoteChar).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override Task WriteValueAsync(Guid? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(Guid? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return DoWriteValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteValueAsync(int value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return WriteIntegerValueAsync(value, cancellationToken);
		}

		public override Task WriteValueAsync(int? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(int? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return WriteIntegerValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteValueAsync(long value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return WriteIntegerValueAsync(value, cancellationToken);
		}

		public override Task WriteValueAsync(long? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(long? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return WriteIntegerValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		internal Task WriteValueAsync(BigInteger value, CancellationToken cancellationToken)
		{
			return WriteValueInternalAsync(JsonToken.Integer, value.ToString(CultureInfo.InvariantCulture), cancellationToken);
		}

		public override Task WriteValueAsync(object? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (_safeAsync)
			{
				if (value == null)
				{
					return WriteNullAsync(cancellationToken);
				}
				if (value is BigInteger value2)
				{
					return WriteValueAsync(value2, cancellationToken);
				}
				return JsonWriter.WriteValueAsync(this, ConvertUtils.GetTypeCode(value.GetType()), value, cancellationToken);
			}
			return base.WriteValueAsync(value, cancellationToken);
		}

		[CLSCompliant(false)]
		public override Task WriteValueAsync(sbyte value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return WriteIntegerValueAsync(value, cancellationToken);
		}

		[CLSCompliant(false)]
		public override Task WriteValueAsync(sbyte? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(sbyte? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return WriteIntegerValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteValueAsync(short value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return WriteIntegerValueAsync(value, cancellationToken);
		}

		public override Task WriteValueAsync(short? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(short? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return WriteIntegerValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteValueAsync(string? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(string? value, CancellationToken cancellationToken)
		{
			Task task = InternalWriteValueAsync(JsonToken.String, cancellationToken);
			if (task.IsCompletedSucessfully())
			{
				if (value != null)
				{
					return WriteEscapedStringAsync(value, quote: true, cancellationToken);
				}
				return _writer.WriteAsync(JsonConvert.Null, cancellationToken);
			}
			return DoWriteValueAsync(task, value, cancellationToken);
		}

		private async Task DoWriteValueAsync(Task task, string? value, CancellationToken cancellationToken)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			await ((value == null) ? _writer.WriteAsync(JsonConvert.Null, cancellationToken) : WriteEscapedStringAsync(value, quote: true, cancellationToken)).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override Task WriteValueAsync(TimeSpan value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal async Task DoWriteValueAsync(TimeSpan value, CancellationToken cancellationToken)
		{
			await InternalWriteValueAsync(JsonToken.String, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(_quoteChar, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(value.ToString(null, CultureInfo.InvariantCulture), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(_quoteChar, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override Task WriteValueAsync(TimeSpan? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(TimeSpan? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return DoWriteValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		[CLSCompliant(false)]
		public override Task WriteValueAsync(uint value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return WriteIntegerValueAsync(value, cancellationToken);
		}

		[CLSCompliant(false)]
		public override Task WriteValueAsync(uint? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(uint? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return WriteIntegerValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		[CLSCompliant(false)]
		public override Task WriteValueAsync(ulong value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return WriteIntegerValueAsync(value, cancellationToken);
		}

		[CLSCompliant(false)]
		public override Task WriteValueAsync(ulong? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(ulong? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return WriteIntegerValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteValueAsync(Uri? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			if (!(value == null))
			{
				return WriteValueNotNullAsync(value, cancellationToken);
			}
			return WriteNullAsync(cancellationToken);
		}

		internal Task WriteValueNotNullAsync(Uri value, CancellationToken cancellationToken)
		{
			Task task = InternalWriteValueAsync(JsonToken.String, cancellationToken);
			if (task.IsCompletedSucessfully())
			{
				return WriteEscapedStringAsync(value.OriginalString, quote: true, cancellationToken);
			}
			return WriteValueNotNullAsync(task, value, cancellationToken);
		}

		internal async Task WriteValueNotNullAsync(Task task, Uri value, CancellationToken cancellationToken)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			await WriteEscapedStringAsync(value.OriginalString, quote: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[CLSCompliant(false)]
		public override Task WriteValueAsync(ushort value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return WriteIntegerValueAsync(value, cancellationToken);
		}

		[CLSCompliant(false)]
		public override Task WriteValueAsync(ushort? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteValueAsync(value, cancellationToken);
			}
			return DoWriteValueAsync(value, cancellationToken);
		}

		internal Task DoWriteValueAsync(ushort? value, CancellationToken cancellationToken)
		{
			if (value.HasValue)
			{
				return WriteIntegerValueAsync(value.GetValueOrDefault(), cancellationToken);
			}
			return DoWriteNullAsync(cancellationToken);
		}

		public override Task WriteCommentAsync(string? text, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteCommentAsync(text, cancellationToken);
			}
			return DoWriteCommentAsync(text, cancellationToken);
		}

		internal async Task DoWriteCommentAsync(string? text, CancellationToken cancellationToken)
		{
			await InternalWriteCommentAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync("/*", cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync(text ?? string.Empty, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await _writer.WriteAsync("*/", cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override Task WriteEndArrayAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteEndArrayAsync(cancellationToken);
			}
			return InternalWriteEndAsync(JsonContainerType.Array, cancellationToken);
		}

		public override Task WriteEndConstructorAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteEndConstructorAsync(cancellationToken);
			}
			return InternalWriteEndAsync(JsonContainerType.Constructor, cancellationToken);
		}

		public override Task WriteEndObjectAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteEndObjectAsync(cancellationToken);
			}
			return InternalWriteEndAsync(JsonContainerType.Object, cancellationToken);
		}

		public override Task WriteRawValueAsync(string? json, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_safeAsync)
			{
				return base.WriteRawValueAsync(json, cancellationToken);
			}
			return DoWriteRawValueAsync(json, cancellationToken);
		}

		internal Task DoWriteRawValueAsync(string? json, CancellationToken cancellationToken)
		{
			UpdateScopeWithFinishedValue();
			Task task = AutoCompleteAsync(JsonToken.Undefined, cancellationToken);
			if (task.IsCompletedSucessfully())
			{
				return WriteRawAsync(json, cancellationToken);
			}
			return DoWriteRawValueAsync(task, json, cancellationToken);
		}

		private async Task DoWriteRawValueAsync(Task task, string? json, CancellationToken cancellationToken)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			await WriteRawAsync(json, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal char[] EnsureWriteBuffer(int length, int copyTo)
		{
			if (length < 35)
			{
				length = 35;
			}
			char[] writeBuffer = _writeBuffer;
			if (writeBuffer == null)
			{
				return _writeBuffer = BufferUtils.RentBuffer(_arrayPool, length);
			}
			if (writeBuffer.Length >= length)
			{
				return writeBuffer;
			}
			char[] array = BufferUtils.RentBuffer(_arrayPool, length);
			if (copyTo != 0)
			{
				Array.Copy(writeBuffer, array, copyTo);
			}
			BufferUtils.ReturnBuffer(_arrayPool, writeBuffer);
			_writeBuffer = array;
			return array;
		}

		public JsonTextWriter(TextWriter textWriter)
		{
			if (textWriter == null)
			{
				throw new ArgumentNullException("textWriter");
			}
			_writer = textWriter;
			_quoteChar = '"';
			_quoteName = true;
			_indentChar = ' ';
			_indentation = 2;
			UpdateCharEscapeFlags();
			_safeAsync = GetType() == typeof(JsonTextWriter);
		}

		public override void Flush()
		{
			_writer.Flush();
		}

		public override void Close()
		{
			base.Close();
			CloseBufferAndWriter();
		}

		private void CloseBufferAndWriter()
		{
			if (_writeBuffer != null)
			{
				BufferUtils.ReturnBuffer(_arrayPool, _writeBuffer);
				_writeBuffer = null;
			}
			if (base.CloseOutput)
			{
				_writer?.Close();
			}
		}

		public override void WriteStartObject()
		{
			InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);
			_writer.Write('{');
		}

		public override void WriteStartArray()
		{
			InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);
			_writer.Write('[');
		}

		public override void WriteStartConstructor(string name)
		{
			InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);
			_writer.Write("new ");
			_writer.Write(name);
			_writer.Write('(');
		}

		protected override void WriteEnd(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.EndObject:
				_writer.Write('}');
				break;
			case JsonToken.EndArray:
				_writer.Write(']');
				break;
			case JsonToken.EndConstructor:
				_writer.Write(')');
				break;
			default:
				throw JsonWriterException.Create(this, "Invalid JsonToken: " + token, null);
			}
		}

		public override void WritePropertyName(string name)
		{
			InternalWritePropertyName(name);
			WriteEscapedString(name, _quoteName);
			_writer.Write(':');
		}

		public override void WritePropertyName(string name, bool escape)
		{
			InternalWritePropertyName(name);
			if (escape)
			{
				WriteEscapedString(name, _quoteName);
			}
			else
			{
				if (_quoteName)
				{
					_writer.Write(_quoteChar);
				}
				_writer.Write(name);
				if (_quoteName)
				{
					_writer.Write(_quoteChar);
				}
			}
			_writer.Write(':');
		}

		internal override void OnStringEscapeHandlingChanged()
		{
			UpdateCharEscapeFlags();
		}

		private void UpdateCharEscapeFlags()
		{
			_charEscapeFlags = JavaScriptUtils.GetCharEscapeFlags(base.StringEscapeHandling, _quoteChar);
		}

		protected override void WriteIndent()
		{
			int num = base.Top * _indentation;
			int num2 = SetIndentChars();
			_writer.Write(_indentChars, 0, num2 + Math.Min(num, 12));
			while ((num -= 12) > 0)
			{
				_writer.Write(_indentChars, num2, Math.Min(num, 12));
			}
		}

		private int SetIndentChars()
		{
			string newLine = _writer.NewLine;
			int length = newLine.Length;
			bool flag = _indentChars != null && _indentChars.Length == 12 + length;
			if (flag)
			{
				for (int i = 0; i != length; i++)
				{
					if (newLine[i] != _indentChars[i])
					{
						flag = false;
						break;
					}
				}
			}
			if (!flag)
			{
				_indentChars = (newLine + new string(_indentChar, 12)).ToCharArray();
			}
			return length;
		}

		protected override void WriteValueDelimiter()
		{
			_writer.Write(',');
		}

		protected override void WriteIndentSpace()
		{
			_writer.Write(' ');
		}

		private void WriteValueInternal(string value, JsonToken token)
		{
			_writer.Write(value);
		}

		public override void WriteValue(object? value)
		{
			if (value is BigInteger bigInteger)
			{
				InternalWriteValue(JsonToken.Integer);
				WriteValueInternal(bigInteger.ToString(CultureInfo.InvariantCulture), JsonToken.String);
			}
			else
			{
				base.WriteValue(value);
			}
		}

		public override void WriteNull()
		{
			InternalWriteValue(JsonToken.Null);
			WriteValueInternal(JsonConvert.Null, JsonToken.Null);
		}

		public override void WriteUndefined()
		{
			InternalWriteValue(JsonToken.Undefined);
			WriteValueInternal(JsonConvert.Undefined, JsonToken.Undefined);
		}

		public override void WriteRaw(string? json)
		{
			InternalWriteRaw();
			_writer.Write(json);
		}

		public override void WriteValue(string? value)
		{
			InternalWriteValue(JsonToken.String);
			if (value == null)
			{
				WriteValueInternal(JsonConvert.Null, JsonToken.Null);
			}
			else
			{
				WriteEscapedString(value, quote: true);
			}
		}

		private void WriteEscapedString(string value, bool quote)
		{
			EnsureWriteBuffer();
			JavaScriptUtils.WriteEscapedJavaScriptString(_writer, value, _quoteChar, quote, _charEscapeFlags, base.StringEscapeHandling, _arrayPool, ref _writeBuffer);
		}

		public override void WriteValue(int value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		[CLSCompliant(false)]
		public override void WriteValue(uint value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(long value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ulong value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value, negative: false);
		}

		public override void WriteValue(float value)
		{
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value, base.FloatFormatHandling, QuoteChar, nullable: false), JsonToken.Float);
		}

		public override void WriteValue(float? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value.GetValueOrDefault(), base.FloatFormatHandling, QuoteChar, nullable: true), JsonToken.Float);
		}

		public override void WriteValue(double value)
		{
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value, base.FloatFormatHandling, QuoteChar, nullable: false), JsonToken.Float);
		}

		public override void WriteValue(double? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value.GetValueOrDefault(), base.FloatFormatHandling, QuoteChar, nullable: true), JsonToken.Float);
		}

		public override void WriteValue(bool value)
		{
			InternalWriteValue(JsonToken.Boolean);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Boolean);
		}

		public override void WriteValue(short value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ushort value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(char value)
		{
			InternalWriteValue(JsonToken.String);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.String);
		}

		public override void WriteValue(byte value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		[CLSCompliant(false)]
		public override void WriteValue(sbyte value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(decimal value)
		{
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Float);
		}

		public override void WriteValue(DateTime value)
		{
			InternalWriteValue(JsonToken.Date);
			value = DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
			if (StringUtils.IsNullOrEmpty(base.DateFormatString))
			{
				int count = WriteValueToBuffer(value);
				_writer.Write(_writeBuffer, 0, count);
			}
			else
			{
				_writer.Write(_quoteChar);
				_writer.Write(value.ToString(base.DateFormatString, base.Culture));
				_writer.Write(_quoteChar);
			}
		}

		private int WriteValueToBuffer(DateTime value)
		{
			EnsureWriteBuffer();
			int start = 0;
			_writeBuffer[start++] = _quoteChar;
			start = DateTimeUtils.WriteDateTimeString(_writeBuffer, start, value, null, value.Kind, base.DateFormatHandling);
			_writeBuffer[start++] = _quoteChar;
			return start;
		}

		public override void WriteValue(byte[]? value)
		{
			if (value == null)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.Bytes);
			_writer.Write(_quoteChar);
			Base64Encoder.Encode(value, 0, value.Length);
			Base64Encoder.Flush();
			_writer.Write(_quoteChar);
		}

		public override void WriteValue(DateTimeOffset value)
		{
			InternalWriteValue(JsonToken.Date);
			if (StringUtils.IsNullOrEmpty(base.DateFormatString))
			{
				int count = WriteValueToBuffer(value);
				_writer.Write(_writeBuffer, 0, count);
			}
			else
			{
				_writer.Write(_quoteChar);
				_writer.Write(value.ToString(base.DateFormatString, base.Culture));
				_writer.Write(_quoteChar);
			}
		}

		private int WriteValueToBuffer(DateTimeOffset value)
		{
			EnsureWriteBuffer();
			int start = 0;
			_writeBuffer[start++] = _quoteChar;
			start = DateTimeUtils.WriteDateTimeString(_writeBuffer, start, (base.DateFormatHandling == DateFormatHandling.IsoDateFormat) ? value.DateTime : value.UtcDateTime, value.Offset, DateTimeKind.Local, base.DateFormatHandling);
			_writeBuffer[start++] = _quoteChar;
			return start;
		}

		public override void WriteValue(Guid value)
		{
			InternalWriteValue(JsonToken.String);
			string value2 = value.ToString("D", CultureInfo.InvariantCulture);
			_writer.Write(_quoteChar);
			_writer.Write(value2);
			_writer.Write(_quoteChar);
		}

		public override void WriteValue(TimeSpan value)
		{
			InternalWriteValue(JsonToken.String);
			string value2 = value.ToString(null, CultureInfo.InvariantCulture);
			_writer.Write(_quoteChar);
			_writer.Write(value2);
			_writer.Write(_quoteChar);
		}

		public override void WriteValue(Uri? value)
		{
			if (value == null)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.String);
			WriteEscapedString(value.OriginalString, quote: true);
		}

		public override void WriteComment(string? text)
		{
			InternalWriteComment();
			_writer.Write("/*");
			_writer.Write(text);
			_writer.Write("*/");
		}

		public override void WriteWhitespace(string ws)
		{
			InternalWriteWhitespace(ws);
			_writer.Write(ws);
		}

		private void EnsureWriteBuffer()
		{
			if (_writeBuffer == null)
			{
				_writeBuffer = BufferUtils.RentBuffer(_arrayPool, 35);
			}
		}

		private void WriteIntegerValue(long value)
		{
			if (value >= 0 && value <= 9)
			{
				_writer.Write((char)(48 + value));
				return;
			}
			bool flag = value < 0;
			WriteIntegerValue((ulong)(flag ? (-value) : value), flag);
		}

		private void WriteIntegerValue(ulong value, bool negative)
		{
			if (!negative && value <= 9)
			{
				_writer.Write((char)(48 + value));
				return;
			}
			int count = WriteNumberToBuffer(value, negative);
			_writer.Write(_writeBuffer, 0, count);
		}

		private int WriteNumberToBuffer(ulong value, bool negative)
		{
			if (value <= uint.MaxValue)
			{
				return WriteNumberToBuffer((uint)value, negative);
			}
			EnsureWriteBuffer();
			int num = MathUtils.IntLength(value);
			if (negative)
			{
				num++;
				_writeBuffer[0] = '-';
			}
			int num2 = num;
			do
			{
				ulong num3 = value / 10;
				ulong num4 = value - num3 * 10;
				_writeBuffer[--num2] = (char)(48 + num4);
				value = num3;
			}
			while (value != 0L);
			return num;
		}

		private void WriteIntegerValue(int value)
		{
			if (value >= 0 && value <= 9)
			{
				_writer.Write((char)(48 + value));
				return;
			}
			bool flag = value < 0;
			WriteIntegerValue((uint)(flag ? (-value) : value), flag);
		}

		private void WriteIntegerValue(uint value, bool negative)
		{
			if (!negative && value <= 9)
			{
				_writer.Write((char)(48 + value));
				return;
			}
			int count = WriteNumberToBuffer(value, negative);
			_writer.Write(_writeBuffer, 0, count);
		}

		private int WriteNumberToBuffer(uint value, bool negative)
		{
			EnsureWriteBuffer();
			int num = MathUtils.IntLength(value);
			if (negative)
			{
				num++;
				_writeBuffer[0] = '-';
			}
			int num2 = num;
			do
			{
				uint num3 = value / 10;
				uint num4 = value - num3 * 10;
				_writeBuffer[--num2] = (char)(48 + num4);
				value = num3;
			}
			while (value != 0);
			return num;
		}
	}
	internal enum JsonToken
	{
		None,
		StartObject,
		StartArray,
		StartConstructor,
		PropertyName,
		Comment,
		Raw,
		Integer,
		Float,
		String,
		Boolean,
		Null,
		Undefined,
		EndObject,
		EndArray,
		EndConstructor,
		Date,
		Bytes
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class JsonValidatingReader : JsonReader, IJsonLineInfo
	{
		private class SchemaScope
		{
			private readonly JTokenType _tokenType;

			private readonly IList<JsonSchemaModel> _schemas;

			private readonly Dictionary<string, bool> _requiredProperties;

			public string CurrentPropertyName { get; set; }

			public int ArrayItemCount { get; set; }

			public bool IsUniqueArray { get; }

			public IList<JToken> UniqueArrayItems { get; }

			public JTokenWriter CurrentItemWriter { get; set; }

			public IList<JsonSchemaModel> Schemas => _schemas;

			public Dictionary<string, bool> RequiredProperties => _requiredProperties;

			public JTokenType TokenType => _tokenType;

			public SchemaScope(JTokenType tokenType, IList<JsonSchemaModel> schemas)
			{
				_tokenType = tokenType;
				_schemas = schemas;
				_requiredProperties = schemas.SelectMany(GetRequiredProperties).Distinct().ToDictionary((string p) => p, (string p) => false);
				if (tokenType == JTokenType.Array && schemas.Any((JsonSchemaModel s) => s.UniqueItems))
				{
					IsUniqueArray = true;
					UniqueArrayItems = new List<JToken>();
				}
			}

			private IEnumerable<string> GetRequiredProperties(JsonSchemaModel schema)
			{
				if (schema?.Properties == null)
				{
					return Enumerable.Empty<string>();
				}
				return from p in schema.Properties
					where p.Value.Required
					select p.Key;
			}
		}

		private readonly JsonReader _reader;

		private readonly Stack<SchemaScope> _stack;

		private JsonSchema _schema;

		private JsonSchemaModel _model;

		private SchemaScope _currentScope;

		private static readonly IList<JsonSchemaModel> EmptySchemaList = new List<JsonSchemaModel>();

		public override object Value => _reader.Value;

		public override int Depth => _reader.Depth;

		public override string Path => _reader.Path;

		public override char QuoteChar
		{
			get
			{
				return _reader.QuoteChar;
			}
			protected internal set
			{
			}
		}

		public override JsonToken TokenType => _reader.TokenType;

		public override Type ValueType => _reader.ValueType;

		private IList<JsonSchemaModel> CurrentSchemas => _currentScope.Schemas;

		private IList<JsonSchemaModel> CurrentMemberSchemas
		{
			get
			{
				if (_currentScope == null)
				{
					return new List<JsonSchemaModel>(new JsonSchemaModel[1] { _model });
				}
				if (_currentScope.Schemas == null || _currentScope.Schemas.Count == 0)
				{
					return EmptySchemaList;
				}
				switch (_currentScope.TokenType)
				{
				case JTokenType.None:
					return _currentScope.Schemas;
				case JTokenType.Object:
				{
					if (_currentScope.CurrentPropertyName == null)
					{
						throw new JsonReaderException("CurrentPropertyName has not been set on scope.");
					}
					IList<JsonSchemaModel> list2 = new List<JsonSchemaModel>();
					{
						foreach (JsonSchemaModel currentSchema in CurrentSchemas)
						{
							if (currentSchema.Properties != null && currentSchema.Properties.TryGetValue(_currentScope.CurrentPropertyName, out var value))
							{
								list2.Add(value);
							}
							if (currentSchema.PatternProperties != null)
							{
								foreach (KeyValuePair<string, JsonSchemaModel> patternProperty in currentSchema.PatternProperties)
								{
									if (Regex.IsMatch(_currentScope.CurrentPropertyName, patternProperty.Key))
									{
										list2.Add(patternProperty.Value);
									}
								}
							}
							if (list2.Count == 0 && currentSchema.AllowAdditionalProperties && currentSchema.AdditionalProperties != null)
							{
								list2.Add(currentSchema.AdditionalProperties);
							}
						}
						return list2;
					}
				}
				case JTokenType.Array:
				{
					IList<JsonSchemaModel> list = new List<JsonSchemaModel>();
					{
						foreach (JsonSchemaModel currentSchema2 in CurrentSchemas)
						{
							if (!currentSchema2.PositionalItemsValidation)
							{
								if (currentSchema2.Items != null && currentSchema2.Items.Count > 0)
								{
									list.Add(currentSchema2.Items[0]);
								}
								continue;
							}
							if (currentSchema2.Items != null && currentSchema2.Items.Count > 0 && currentSchema2.Items.Count > _currentScope.ArrayItemCount - 1)
							{
								list.Add(currentSchema2.Items[_currentScope.ArrayItemCount - 1]);
							}
							if (currentSchema2.AllowAdditionalItems && currentSchema2.AdditionalItems != null)
							{
								list.Add(currentSchema2.AdditionalItems);
							}
						}
						return list;
					}
				}
				case JTokenType.Constructor:
					return EmptySchemaList;
				default:
					throw new ArgumentOutOfRangeException("TokenType", "Unexpected token type: {0}".FormatWith(CultureInfo.InvariantCulture, _currentScope.TokenType));
				}
			}
		}

		public JsonSchema Schema
		{
			get
			{
				return _schema;
			}
			set
			{
				if (TokenType != JsonToken.None)
				{
					throw new InvalidOperationException("Cannot change schema while validating JSON.");
				}
				_schema = value;
				_model = null;
			}
		}

		public JsonReader Reader => _reader;

		int IJsonLineInfo.LineNumber
		{
			get
			{
				if (!(_reader is IJsonLineInfo jsonLineInfo))
				{
					return 0;
				}
				return jsonLineInfo.LineNumber;
			}
		}

		int IJsonLineInfo.LinePosition
		{
			get
			{
				if (!(_reader is IJsonLineInfo jsonLineInfo))
				{
					return 0;
				}
				return jsonLineInfo.LinePosition;
			}
		}

		public event ValidationEventHandler ValidationEventHandler;

		private void Push(SchemaScope scope)
		{
			_stack.Push(scope);
			_currentScope = scope;
		}

		private SchemaScope Pop()
		{
			SchemaScope result = _stack.Pop();
			_currentScope = ((_stack.Count != 0) ? _stack.Peek() : null);
			return result;
		}

		private void RaiseError(string message, JsonSchemaModel schema)
		{
			string message2 = (((IJsonLineInfo)this).HasLineInfo() ? (message + " Line {0}, position {1}.".FormatWith(CultureInfo.InvariantCulture, ((IJsonLineInfo)this).LineNumber, ((IJsonLineInfo)this).LinePosition)) : message);
			OnValidationEvent(new JsonSchemaException(message2, null, Path, ((IJsonLineInfo)this).LineNumber, ((IJsonLineInfo)this).LinePosition));
		}

		private void OnValidationEvent(JsonSchemaException exception)
		{
			ValidationEventHandler validationEventHandler = this.ValidationEventHandler;
			if (validationEventHandler != null)
			{
				validationEventHandler(this, new ValidationEventArgs(exception));
				return;
			}
			throw exception;
		}

		public JsonValidatingReader(JsonReader reader)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			_reader = reader;
			_stack = new Stack<SchemaScope>();
		}

		public override void Close()
		{
			base.Close();
			if (base.CloseInput)
			{
				_reader?.Close();
			}
		}

		private void ValidateNotDisallowed(JsonSchemaModel schema)
		{
			if (schema != null)
			{
				JsonSchemaType? currentNodeSchemaType = GetCurrentNodeSchemaType();
				if (currentNodeSchemaType.HasValue && JsonSchemaGenerator.HasFlag(schema.Disallow, currentNodeSchemaType.GetValueOrDefault()))
				{
					RaiseError("Type {0} is disallowed.".FormatWith(CultureInfo.InvariantCulture, currentNodeSchemaType), schema);
				}
			}
		}

		private JsonSchemaType? GetCurrentNodeSchemaType()
		{
			return _reader.TokenType switch
			{
				JsonToken.StartObject => JsonSchemaType.Object, 
				JsonToken.StartArray => JsonSchemaType.Array, 
				JsonToken.Integer => JsonSchemaType.Integer, 
				JsonToken.Float => JsonSchemaType.Float, 
				JsonToken.String => JsonSchemaType.String, 
				JsonToken.Boolean => JsonSchemaType.Boolean, 
				JsonToken.Null => JsonSchemaType.Null, 
				_ => null, 
			};
		}

		public override int? ReadAsInt32()
		{
			int? result = _reader.ReadAsInt32();
			ValidateCurrentToken();
			return result;
		}

		public override byte[] ReadAsBytes()
		{
			byte[]? result = _reader.ReadAsBytes();
			ValidateCurrentToken();
			return result;
		}

		public override decimal? ReadAsDecimal()
		{
			decimal? result = _reader.ReadAsDecimal();
			ValidateCurrentToken();
			return result;
		}

		public override double? ReadAsDouble()
		{
			double? result = _reader.ReadAsDouble();
			ValidateCurrentToken();
			return result;
		}

		public override bool? ReadAsBoolean()
		{
			bool? result = _reader.ReadAsBoolean();
			ValidateCurrentToken();
			return result;
		}

		public override string ReadAsString()
		{
			string? result = _reader.ReadAsString();
			ValidateCurrentToken();
			return result;
		}

		public override DateTime? ReadAsDateTime()
		{
			DateTime? result = _reader.ReadAsDateTime();
			ValidateCurrentToken();
			return result;
		}

		public override DateTimeOffset? ReadAsDateTimeOffset()
		{
			DateTimeOffset? result = _reader.ReadAsDateTimeOffset();
			ValidateCurrentToken();
			return result;
		}

		public override bool Read()
		{
			if (!_reader.Read())
			{
				return false;
			}
			if (_reader.TokenType == JsonToken.Comment)
			{
				return true;
			}
			ValidateCurrentToken();
			return true;
		}

		private void ValidateCurrentToken()
		{
			if (_model == null)
			{
				JsonSchemaModelBuilder jsonSchemaModelBuilder = new JsonSchemaModelBuilder();
				_model = jsonSchemaModelBuilder.Build(_schema);
				if (!JsonTokenUtils.IsStartToken(_reader.TokenType))
				{
					Push(new SchemaScope(JTokenType.None, CurrentMemberSchemas));
				}
			}
			switch (_reader.TokenType)
			{
			case JsonToken.StartObject:
			{
				ProcessValue();
				IList<JsonSchemaModel> schemas2 = CurrentMemberSchemas.Where(ValidateObject).ToList();
				Push(new SchemaScope(JTokenType.Object, schemas2));
				WriteToken(CurrentSchemas);
				break;
			}
			case JsonToken.StartArray:
			{
				ProcessValue();
				IList<JsonSchemaModel> schemas = CurrentMemberSchemas.Where(ValidateArray).ToList();
				Push(new SchemaScope(JTokenType.Array, schemas));
				WriteToken(CurrentSchemas);
				break;
			}
			case JsonToken.StartConstructor:
				ProcessValue();
				Push(new SchemaScope(JTokenType.Constructor, null));
				WriteToken(CurrentSchemas);
				break;
			case JsonToken.PropertyName:
				WriteToken(CurrentSchemas);
				{
					foreach (JsonSchemaModel currentSchema in CurrentSchemas)
					{
						ValidatePropertyName(currentSchema);
					}
					break;
				}
			case JsonToken.Raw:
				ProcessValue();
				break;
			case JsonToken.Integer:
				ProcessValue();
				WriteToken(CurrentMemberSchemas);
				{
					foreach (JsonSchemaModel currentMemberSchema in CurrentMemberSchemas)
					{
						ValidateInteger(currentMemberSchema);
					}
					break;
				}
			case JsonToken.Float:
				ProcessValue();
				WriteToken(CurrentMemberSchemas);
				{
					foreach (JsonSchemaModel currentMemberSchema2 in CurrentMemberSchemas)
					{
						ValidateFloat(currentMemberSchema2);
					}
					break;
				}
			case JsonToken.String:
				ProcessValue();
				WriteToken(CurrentMemberSchemas);
				{
					foreach (JsonSchemaModel currentMemberSchema3 in CurrentMemberSchemas)
					{
						ValidateString(currentMemberSchema3);
					}
					break;
				}
			case JsonToken.Boolean:
				ProcessValue();
				WriteToken(CurrentMemberSchemas);
				{
					foreach (JsonSchemaModel currentMemberSchema4 in CurrentMemberSchemas)
					{
						ValidateBoolean(currentMemberSchema4);
					}
					break;
				}
			case JsonToken.Null:
				ProcessValue();
				WriteToken(CurrentMemberSchemas);
				{
					foreach (JsonSchemaModel currentMemberSchema5 in CurrentMemberSchemas)
					{
						ValidateNull(currentMemberSchema5);
					}
					break;
				}
			case JsonToken.EndObject:
				WriteToken(CurrentSchemas);
				foreach (JsonSchemaModel currentSchema2 in CurrentSchemas)
				{
					ValidateEndObject(currentSchema2);
				}
				Pop();
				break;
			case JsonToken.EndArray:
				WriteToken(CurrentSchemas);
				foreach (JsonSchemaModel currentSchema3 in CurrentSchemas)
				{
					ValidateEndArray(currentSchema3);
				}
				Pop();
				break;
			case JsonToken.EndConstructor:
				WriteToken(CurrentSchemas);
				Pop();
				break;
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				WriteToken(CurrentMemberSchemas);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			case JsonToken.None:
				break;
			}
		}

		private void WriteToken(IList<JsonSchemaModel> schemas)
		{
			foreach (SchemaScope item in _stack)
			{
				bool flag = item.TokenType == JTokenType.Array && item.IsUniqueArray && item.ArrayItemCount > 0;
				if (!flag && !schemas.Any((JsonSchemaModel s) => s.Enum != null))
				{
					continue;
				}
				if (item.CurrentItemWriter == null)
				{
					if (JsonTokenUtils.IsEndToken(_reader.TokenType))
					{
						continue;
					}
					item.CurrentItemWriter = new JTokenWriter();
				}
				item.CurrentItemWriter.WriteToken(_reader, writeChildren: false);
				if (item.CurrentItemWriter.Top != 0 || _reader.TokenType == JsonToken.PropertyName)
				{
					continue;
				}
				JToken token = item.CurrentItemWriter.Token;
				item.CurrentItemWriter = null;
				if (flag)
				{
					if (item.UniqueArrayItems.Contains(token, JToken.EqualityComparer))
					{
						RaiseError("Non-unique array item at index {0}.".FormatWith(CultureInfo.InvariantCulture, item.ArrayItemCount - 1), item.Schemas.First((JsonSchemaModel s) => s.UniqueItems));
					}
					item.UniqueArrayItems.Add(token);
				}
				else
				{
					if (!schemas.Any((JsonSchemaModel s) => s.Enum != null))
					{
						continue;
					}
					foreach (JsonSchemaModel schema in schemas)
					{
						if (schema.Enum != null && !schema.Enum.ContainsValue(token, JToken.EqualityComparer))
						{
							StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
							token.WriteTo(new JsonTextWriter(stringWriter));
							RaiseError("Value {0} is not defined in enum.".FormatWith(CultureInfo.InvariantCulture, stringWriter.ToString()), schema);
						}
					}
				}
			}
		}

		private void ValidateEndObject(JsonSchemaModel schema)
		{
			if (schema == null)
			{
				return;
			}
			Dictionary<string, bool> requiredProperties = _currentScope.RequiredProperties;
			if (requiredProperties != null && requiredProperties.Values.Any((bool v) => !v))
			{
				IEnumerable<string> values = from kv in requiredProperties
					where !kv.Value
					select kv.Key;
				RaiseError("Required properties are missing from object: {0}.".FormatWith(CultureInfo.InvariantCulture, string.Join(", ", values)), schema);
			}
		}

		private void ValidateEndArray(JsonSchemaModel schema)
		{
			if (schema != null)
			{
				int arrayItemCount = _currentScope.ArrayItemCount;
				if (schema.MaximumItems.HasValue && arrayItemCount > schema.MaximumItems)
				{
					RaiseError("Array item count {0} exceeds maximum count of {1}.".FormatWith(CultureInfo.InvariantCulture, arrayItemCount, schema.MaximumItems), schema);
				}
				if (schema.MinimumItems.HasValue && arrayItemCount < schema.MinimumItems)
				{
					RaiseError("Array item count {0} is less than minimum count of {1}.".FormatWith(CultureInfo.InvariantCulture, arrayItemCount, schema.MinimumItems), schema);
				}
			}
		}

		private void ValidateNull(JsonSchemaModel schema)
		{
			if (schema != null && TestType(schema, JsonSchemaType.Null))
			{
				ValidateNotDisallowed(schema);
			}
		}

		private void ValidateBoolean(JsonSchemaModel schema)
		{
			if (schema != null && TestType(schema, JsonSchemaType.Boolean))
			{
				ValidateNotDisallowed(schema);
			}
		}

		private void ValidateString(JsonSchemaModel schema)
		{
			if (schema == null || !TestType(schema, JsonSchemaType.String))
			{
				return;
			}
			ValidateNotDisallowed(schema);
			string text = _reader.Value.ToString();
			if (schema.MaximumLength.HasValue && text.Length > schema.MaximumLength)
			{
				RaiseError("String '{0}' exceeds maximum length of {1}.".FormatWith(CultureInfo.InvariantCulture, text, schema.MaximumLength), schema);
			}
			if (schema.MinimumLength.HasValue && text.Length < schema.MinimumLength)
			{
				RaiseError("String '{0}' is less than minimum length of {1}.".FormatWith(CultureInfo.InvariantCulture, text, schema.MinimumLength), schema);
			}
			if (schema.Patterns == null)
			{
				return;
			}
			foreach (string pattern in schema.Patterns)
			{
				if (!Regex.IsMatch(text, pattern))
				{
					RaiseError("String '{0}' does not match regex pattern '{1}'.".FormatWith(CultureInfo.InvariantCulture, text, pattern), schema);
				}
			}
		}

		private void ValidateInteger(JsonSchemaModel schema)
		{
			if (schema == null || !TestType(schema, JsonSchemaType.Integer))
			{
				return;
			}
			ValidateNotDisallowed(schema);
			object value = _reader.Value;
			if (schema.Maximum.HasValue)
			{
				if (JValue.Compare(JTokenType.Integer, value, schema.Maximum) > 0)
				{
					RaiseError("Integer {0} exceeds maximum value of {1}.".FormatWith(CultureInfo.InvariantCulture, value, schema.Maximum), schema);
				}
				if (schema.ExclusiveMaximum && JValue.Compare(JTokenType.Integer, value, schema.Maximum) == 0)
				{
					RaiseError("Integer {0} equals maximum value of {1} and exclusive maximum is true.".FormatWith(CultureInfo.InvariantCulture, value, schema.Maximum), schema);
				}
			}
			if (schema.Minimum.HasValue)
			{
				if (JValue.Compare(JTokenType.Integer, value, schema.Minimum) < 0)
				{
					RaiseError("Integer {0} is less than minimum value of {1}.".FormatWith(CultureInfo.InvariantCulture, value, schema.Minimum), schema);
				}
				if (schema.ExclusiveMinimum && JValue.Compare(JTokenType.Integer, value, schema.Minimum) == 0)
				{
					RaiseError("Integer {0} equals minimum value of {1} and exclusive minimum is true.".FormatWith(CultureInfo.InvariantCulture, value, schema.Minimum), schema);
				}
			}
			if (schema.DivisibleBy.HasValue && ((!(value is BigInteger bigInteger)) ? (!IsZero((double)Convert.ToInt64(value, CultureInfo.InvariantCulture) % schema.DivisibleBy.GetValueOrDefault())) : (Math.Abs(schema.DivisibleBy.Value - Math.Truncate(schema.DivisibleBy.Value)).Equals(0.0) ? (bigInteger % new BigInteger(schema.DivisibleBy.Value) != 0L) : (bigInteger != 0L))))
			{
				RaiseError("Integer {0} is not evenly divisible by {1}.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(value), schema.DivisibleBy), schema);
			}
		}

		private void ProcessValue()
		{
			if (_currentScope == null || _currentScope.TokenType != JTokenType.Array)
			{
				return;
			}
			_currentScope.ArrayItemCount++;
			foreach (JsonSchemaModel currentSchema in CurrentSchemas)
			{
				if (currentSchema != null && currentSchema.PositionalItemsValidation && !currentSchema.AllowAdditionalItems && (currentSchema.Items == null || _currentScope.ArrayItemCount - 1 >= currentSchema.Items.Count))
				{
					RaiseError("Index {0} has not been defined and the schema does not allow additional items.".FormatWith(CultureInfo.InvariantCulture, _currentScope.ArrayItemCount), currentSchema);
				}
			}
		}

		private void ValidateFloat(JsonSchemaModel schema)
		{
			if (schema == null || !TestType(schema, JsonSchemaType.Float))
			{
				return;
			}
			ValidateNotDisallowed(schema);
			double num = Convert.ToDouble(_reader.Value, CultureInfo.InvariantCulture);
			if (schema.Maximum.HasValue)
			{
				if (num > schema.Maximum)
				{
					RaiseError("Float {0} exceeds maximum value of {1}.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(num), schema.Maximum), schema);
				}
				if (schema.ExclusiveMaximum && num == schema.Maximum)
				{
					RaiseError("Float {0} equals maximum value of {1} and exclusive maximum is true.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(num), schema.Maximum), schema);
				}
			}
			if (schema.Minimum.HasValue)
			{
				if (num < schema.Minimum)
				{
					RaiseError("Float {0} is less than minimum value of {1}.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(num), schema.Minimum), schema);
				}
				if (schema.ExclusiveMinimum && num == schema.Minimum)
				{
					RaiseError("Float {0} equals minimum value of {1} and exclusive minimum is true.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(num), schema.Minimum), schema);
				}
			}
			if (schema.DivisibleBy.HasValue && !IsZero(FloatingPointRemainder(num, schema.DivisibleBy.GetValueOrDefault())))
			{
				RaiseError("Float {0} is not evenly divisible by {1}.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(num), schema.DivisibleBy), schema);
			}
		}

		private static double FloatingPointRemainder(double dividend, double divisor)
		{
			return dividend - Math.Floor(dividend / divisor) * divisor;
		}

		private static bool IsZero(double value)
		{
			return Math.Abs(value) < 4.440892098500626E-15;
		}

		private void ValidatePropertyName(JsonSchemaModel schema)
		{
			if (schema != null)
			{
				string text = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
				if (_currentScope.RequiredProperties.ContainsKey(text))
				{
					_currentScope.RequiredProperties[text] = true;
				}
				if (!schema.AllowAdditionalProperties && !IsPropertyDefinied(schema, text))
				{
					RaiseError("Property '{0}' has not been defined and the schema does not allow additional properties.".FormatWith(CultureInfo.InvariantCulture, text), schema);
				}
				_currentScope.CurrentPropertyName = text;
			}
		}

		private bool IsPropertyDefinied(JsonSchemaModel schema, string propertyName)
		{
			if (schema.Properties != null && schema.Properties.ContainsKey(propertyName))
			{
				return true;
			}
			if (schema.PatternProperties != null)
			{
				foreach (string key in schema.PatternProperties.Keys)
				{
					if (Regex.IsMatch(propertyName, key))
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool ValidateArray(JsonSchemaModel schema)
		{
			if (schema == null)
			{
				return true;
			}
			return TestType(schema, JsonSchemaType.Array);
		}

		private bool ValidateObject(JsonSchemaModel schema)
		{
			if (schema == null)
			{
				return true;
			}
			return TestType(schema, JsonSchemaType.Object);
		}

		private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType)
		{
			if (!JsonSchemaGenerator.HasFlag(currentSchema.Type, currentType))
			{
				RaiseError("Invalid type. Expected {0} but got {1}.".FormatWith(CultureInfo.InvariantCulture, currentSchema.Type, currentType), currentSchema);
				return false;
			}
			return true;
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			if (_reader is IJsonLineInfo jsonLineInfo)
			{
				return jsonLineInfo.HasLineInfo();
			}
			return false;
		}
	}
	internal abstract class JsonWriter : IDisposable
	{
		internal enum State
		{
			Start,
			Property,
			ObjectStart,
			Object,
			ArrayStart,
			Array,
			ConstructorStart,
			Constructor,
			Closed,
			Error
		}

		private static readonly State[][] StateArray;

		internal static readonly State[][] StateArrayTemplate;

		private List<JsonPosition>? _stack;

		private JsonPosition _currentPosition;

		private State _currentState;

		private Formatting _formatting;

		private DateFormatHandling _dateFormatHandling;

		private DateTimeZoneHandling _dateTimeZoneHandling;

		private StringEscapeHandling _stringEscapeHandling;

		private FloatFormatHandling _floatFormatHandling;

		private string? _dateFormatString;

		private CultureInfo? _culture;

		public bool CloseOutput { get; set; }

		public bool AutoCompleteOnClose { get; set; }

		protected internal int Top
		{
			get
			{
				int num = _stack?.Count ?? 0;
				if (Peek() != JsonContainerType.None)
				{
					num++;
				}
				return num;
			}
		}

		public WriteState WriteState
		{
			get
			{
				switch (_currentState)
				{
				case State.Error:
					return WriteState.Error;
				case State.Closed:
					return WriteState.Closed;
				case State.ObjectStart:
				case State.Object:
					return WriteState.Object;
				case State.ArrayStart:
				case State.Array:
					return WriteState.Array;
				case State.ConstructorStart:
				case State.Constructor:
					return WriteState.Constructor;
				case State.Property:
					return WriteState.Property;
				case State.Start:
					return WriteState.Start;
				default:
					throw JsonWriterException.Create(this, "Invalid state: " + _currentState, null);
				}
			}
		}

		internal string ContainerPath
		{
			get
			{
				if (_currentPosition.Type == JsonContainerType.None || _stack == null)
				{
					return string.Empty;
				}
				return JsonPosition.BuildPath(_stack, null);
			}
		}

		public string Path
		{
			get
			{
				if (_currentPosition.Type == JsonContainerType.None)
				{
					return string.Empty;
				}
				JsonPosition? currentPosition = ((_currentState != State.ArrayStart && _currentState != State.ConstructorStart && _currentState != State.ObjectStart) ? new JsonPosition?(_currentPosition) : ((JsonPosition?)null));
				return JsonPosition.BuildPath(_stack, currentPosition);
			}
		}

		public Formatting Formatting
		{
			get
			{
				return _formatting;
			}
			set
			{
				if (value < Formatting.None || value > Formatting.Indented)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_formatting = value;
			}
		}

		public DateFormatHandling DateFormatHandling
		{
			get
			{
				return _dateFormatHandling;
			}
			set
			{
				if (value < DateFormatHandling.IsoDateFormat || value > DateFormatHandling.MicrosoftDateFormat)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dateFormatHandling = value;
			}
		}

		public DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _dateTimeZoneHandling;
			}
			set
			{
				if (value < DateTimeZoneHandling.Local || value > DateTimeZoneHandling.RoundtripKind)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dateTimeZoneHandling = value;
			}
		}

		public StringEscapeHandling StringEscapeHandling
		{
			get
			{
				return _stringEscapeHandling;
			}
			set
			{
				if (value < StringEscapeHandling.Default || value > StringEscapeHandling.EscapeHtml)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_stringEscapeHandling = value;
				OnStringEscapeHandlingChanged();
			}
		}

		public FloatFormatHandling FloatFormatHandling
		{
			get
			{
				return _floatFormatHandling;
			}
			set
			{
				if (value < FloatFormatHandling.String || value > FloatFormatHandling.DefaultValue)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_floatFormatHandling = value;
			}
		}

		public string? DateFormatString
		{
			get
			{
				return _dateFormatString;
			}
			set
			{
				_dateFormatString = value;
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? CultureInfo.InvariantCulture;
			}
			set
			{
				_culture = value;
			}
		}

		internal Task AutoCompleteAsync(JsonToken tokenBeingWritten, CancellationToken cancellationToken)
		{
			State currentState = _currentState;
			State state = StateArray[(int)tokenBeingWritten][(int)currentState];
			if (state == State.Error)
			{
				throw JsonWriterException.Create(this, "Token {0} in state {1} would result in an invalid JSON object.".FormatWith(CultureInfo.InvariantCulture, tokenBeingWritten.ToString(), currentState.ToString()), null);
			}
			_currentState = state;
			if (_formatting == Formatting.Indented)
			{
				switch (currentState)
				{
				case State.Property:
					return WriteIndentSpaceAsync(cancellationToken);
				case State.ArrayStart:
				case State.ConstructorStart:
					return WriteIndentAsync(cancellationToken);
				case State.Array:
				case State.Constructor:
					if (tokenBeingWritten != JsonToken.Comment)
					{
						return AutoCompleteAsync(cancellationToken);
					}
					return WriteIndentAsync(cancellationToken);
				case State.Object:
					switch (tokenBeingWritten)
					{
					case JsonToken.PropertyName:
						return AutoCompleteAsync(cancellationToken);
					default:
						return WriteValueDelimiterAsync(cancellationToken);
					case JsonToken.Comment:
						break;
					}
					break;
				default:
					if (tokenBeingWritten == JsonToken.PropertyName)
					{
						return WriteIndentAsync(cancellationToken);
					}
					break;
				case State.Start:
					break;
				}
			}
			else if (tokenBeingWritten != JsonToken.Comment)
			{
				switch (currentState)
				{
				case State.Object:
				case State.Array:
				case State.Constructor:
					return WriteValueDelimiterAsync(cancellationToken);
				}
			}
			return AsyncUtils.CompletedTask;
		}

		private async Task AutoCompleteAsync(CancellationToken cancellationToken)
		{
			await WriteValueDelimiterAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await WriteIndentAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Task CloseAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			Close();
			return AsyncUtils.CompletedTask;
		}

		public virtual Task FlushAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			Flush();
			return AsyncUtils.CompletedTask;
		}

		protected virtual Task WriteEndAsync(JsonToken token, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteEnd(token);
			return AsyncUtils.CompletedTask;
		}

		protected virtual Task WriteIndentAsync(CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteIndent();
			return AsyncUtils.CompletedTask;
		}

		protected virtual Task WriteValueDelimiterAsync(CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValueDelimiter();
			return AsyncUtils.CompletedTask;
		}

		protected virtual Task WriteIndentSpaceAsync(CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteIndentSpace();
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteRawAsync(string? json, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteRaw(json);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteEndAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteEnd();
			return AsyncUtils.CompletedTask;
		}

		internal Task WriteEndInternalAsync(CancellationToken cancellationToken)
		{
			JsonContainerType jsonContainerType = Peek();
			switch (jsonContainerType)
			{
			case JsonContainerType.Object:
				return WriteEndObjectAsync(cancellationToken);
			case JsonContainerType.Array:
				return WriteEndArrayAsync(cancellationToken);
			case JsonContainerType.Constructor:
				return WriteEndConstructorAsync(cancellationToken);
			default:
				if (cancellationToken.IsCancellationRequested)
				{
					return cancellationToken.FromCanceled();
				}
				throw JsonWriterException.Create(this, "Unexpected type when writing end: " + jsonContainerType, null);
			}
		}

		internal Task InternalWriteEndAsync(JsonContainerType type, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			int levelsToComplete = CalculateLevelsToComplete(type);
			while (levelsToComplete-- > 0)
			{
				JsonToken closeTokenForType = GetCloseTokenForType(Pop());
				Task task;
				if (_currentState == State.Property)
				{
					task = WriteNullAsync(cancellationToken);
					if (!task.IsCompletedSucessfully())
					{
						return AwaitProperty(task, levelsToComplete, closeTokenForType, cancellationToken);
					}
				}
				if (_formatting == Formatting.Indented && _currentState != State.ObjectStart && _currentState != State.ArrayStart)
				{
					task = WriteIndentAsync(cancellationToken);
					if (!task.IsCompletedSucessfully())
					{
						return AwaitIndent(task, levelsToComplete, closeTokenForType, cancellationToken);
					}
				}
				task = WriteEndAsync(closeTokenForType, cancellationToken);
				if (!task.IsCompletedSucessfully())
				{
					return AwaitEnd(task, levelsToComplete, cancellationToken);
				}
				UpdateCurrentState();
			}
			return AsyncUtils.CompletedTask;
			async Task AwaitEnd(Task task2, int LevelsToComplete, CancellationToken CancellationToken)
			{
				await task2.ConfigureAwait(continueOnCapturedContext: false);
				UpdateCurrentState();
				await AwaitRemaining(LevelsToComplete, CancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			async Task AwaitIndent(Task task2, int LevelsToComplete, JsonToken token, CancellationToken CancellationToken)
			{
				await task2.ConfigureAwait(continueOnCapturedContext: false);
				await WriteEndAsync(token, CancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				UpdateCurrentState();
				await AwaitRemaining(LevelsToComplete, CancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			async Task AwaitProperty(Task task2, int LevelsToComplete, JsonToken token, CancellationToken CancellationToken)
			{
				await task2.ConfigureAwait(continueOnCapturedContext: false);
				if (_formatting == Formatting.Indented && _currentState != State.ObjectStart && _currentState != State.ArrayStart)
				{
					await WriteIndentAsync(CancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				await WriteEndAsync(token, CancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				UpdateCurrentState();
				await AwaitRemaining(LevelsToComplete, CancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			async Task AwaitRemaining(int LevelsToComplete, CancellationToken CancellationToken)
			{
				while (LevelsToComplete-- > 0)
				{
					JsonToken token = GetCloseTokenForType(Pop());
					if (_currentState == State.Property)
					{
						await WriteNullAsync(CancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					if (_formatting == Formatting.Indented && _currentState != State.ObjectStart && _currentState != State.ArrayStart)
					{
						await WriteIndentAsync(CancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					await WriteEndAsync(token, CancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					UpdateCurrentState();
				}
			}
		}

		public virtual Task WriteEndArrayAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteEndArray();
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteEndConstructorAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteEndConstructor();
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteEndObjectAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteEndObject();
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteNullAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteNull();
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WritePropertyNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WritePropertyName(name);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WritePropertyName(name, escape);
			return AsyncUtils.CompletedTask;
		}

		internal Task InternalWritePropertyNameAsync(string name, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			_currentPosition.PropertyName = name;
			return AutoCompleteAsync(JsonToken.PropertyName, cancellationToken);
		}

		public virtual Task WriteStartArrayAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteStartArray();
			return AsyncUtils.CompletedTask;
		}

		internal async Task InternalWriteStartAsync(JsonToken token, JsonContainerType container, CancellationToken cancellationToken)
		{
			UpdateScopeWithFinishedValue();
			await AutoCompleteAsync(token, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			Push(container);
		}

		public virtual Task WriteCommentAsync(string? text, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteComment(text);
			return AsyncUtils.CompletedTask;
		}

		internal Task InternalWriteCommentAsync(CancellationToken cancellationToken)
		{
			return AutoCompleteAsync(JsonToken.Comment, cancellationToken);
		}

		public virtual Task WriteRawValueAsync(string? json, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteRawValue(json);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteStartConstructorAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteStartConstructor(name);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteStartObjectAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteStartObject();
			return AsyncUtils.CompletedTask;
		}

		public Task WriteTokenAsync(JsonReader reader, CancellationToken cancellationToken = default(CancellationToken))
		{
			return WriteTokenAsync(reader, writeChildren: true, cancellationToken);
		}

		public Task WriteTokenAsync(JsonReader reader, bool writeChildren, CancellationToken cancellationToken = default(CancellationToken))
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			return WriteTokenAsync(reader, writeChildren, writeDateConstructorAsDate: true, writeComments: true, cancellationToken);
		}

		public Task WriteTokenAsync(JsonToken token, CancellationToken cancellationToken = default(CancellationToken))
		{
			return WriteTokenAsync(token, null, cancellationToken);
		}

		public Task WriteTokenAsync(JsonToken token, object? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			switch (token)
			{
			case JsonToken.None:
				return AsyncUtils.CompletedTask;
			case JsonToken.StartObject:
				return WriteStartObjectAsync(cancellationToken);
			case JsonToken.StartArray:
				return WriteStartArrayAsync(cancellationToken);
			case JsonToken.StartConstructor:
				ValidationUtils.ArgumentNotNull(value, "value");
				return WriteStartConstructorAsync(value.ToString(), cancellationToken);
			case JsonToken.PropertyName:
				ValidationUtils.ArgumentNotNull(value, "value");
				return WritePropertyNameAsync(value.ToString(), cancellationToken);
			case JsonToken.Comment:
				return WriteCommentAsync(value?.ToString(), cancellationToken);
			case JsonToken.Integer:
				ValidationUtils.ArgumentNotNull(value, "value");
				if (!(value is BigInteger bigInteger))
				{
					return WriteValueAsync(Convert.ToInt64(value, CultureInfo.InvariantCulture), cancellationToken);
				}
				return WriteValueAsync(bigInteger, cancellationToken);
			case JsonToken.Float:
				ValidationUtils.ArgumentNotNull(value, "value");
				if (value is decimal value4)
				{
					return WriteValueAsync(value4, cancellationToken);
				}
				if (value is double value5)
				{
					return WriteValueAsync(value5, cancellationToken);
				}
				if (value is float value6)
				{
					return WriteValueAsync(value6, cancellationToken);
				}
				return WriteValueAsync(Convert.ToDouble(value, CultureInfo.InvariantCulture), cancellationToken);
			case JsonToken.String:
				ValidationUtils.ArgumentNotNull(value, "value");
				return WriteValueAsync(value.ToString(), cancellationToken);
			case JsonToken.Boolean:
				ValidationUtils.ArgumentNotNull(value, "value");
				return WriteValueAsync(Convert.ToBoolean(value, CultureInfo.InvariantCulture), cancellationToken);
			case JsonToken.Null:
				return WriteNullAsync(cancellationToken);
			case JsonToken.Undefined:
				return WriteUndefinedAsync(cancellationToken);
			case JsonToken.EndObject:
				return WriteEndObjectAsync(cancellationToken);
			case JsonToken.EndArray:
				return WriteEndArrayAsync(cancellationToken);
			case JsonToken.EndConstructor:
				return WriteEndConstructorAsync(cancellationToken);
			case JsonToken.Date:
				ValidationUtils.ArgumentNotNull(value, "value");
				if (value is DateTimeOffset value3)
				{
					return WriteValueAsync(value3, cancellationToken);
				}
				return WriteValueAsync(Convert.ToDateTime(value, CultureInfo.InvariantCulture), cancellationToken);
			case JsonToken.Raw:
				return WriteRawValueAsync(value?.ToString(), cancellationToken);
			case JsonToken.Bytes:
				ValidationUtils.ArgumentNotNull(value, "value");
				if (value is Guid value2)
				{
					return WriteValueAsync(value2, cancellationToken);
				}
				return WriteValueAsync((byte[])value, cancellationToken);
			default:
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException("token", token, "Unexpected token type.");
			}
		}

		internal virtual async Task WriteTokenAsync(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments, CancellationToken cancellationToken)
		{
			int initialDepth = CalculateWriteTokenInitialDepth(reader);
			bool flag;
			do
			{
				if (writeDateConstructorAsDate && reader.TokenType == JsonToken.StartConstructor && string.Equals(reader.Value?.ToString(), "Date", StringComparison.Ordinal))
				{
					await WriteConstructorDateAsync(reader, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				else if (writeComments || reader.TokenType != JsonToken.Comment)
				{
					await WriteTokenAsync(reader.TokenType, reader.Value, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				flag = initialDepth - 1 < reader.Depth - (JsonTokenUtils.IsEndToken(reader.TokenType) ? 1 : 0) && writeChildren;
				if (flag)
				{
					flag = await reader.ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
			}
			while (flag);
			if (IsWriteTokenIncomplete(reader, writeChildren, initialDepth))
			{
				throw JsonWriterException.Create(this, "Unexpected end when reading token.", null);
			}
		}

		internal async Task WriteTokenSyncReadingAsync(JsonReader reader, CancellationToken cancellationToken)
		{
			int initialDepth = CalculateWriteTokenInitialDepth(reader);
			bool flag;
			do
			{
				if (reader.TokenType == JsonToken.StartConstructor && string.Equals(reader.Value?.ToString(), "Date", StringComparison.Ordinal))
				{
					WriteConstructorDate(reader);
				}
				else
				{
					WriteToken(reader.TokenType, reader.Value);
				}
				flag = initialDepth - 1 < reader.Depth - (JsonTokenUtils.IsEndToken(reader.TokenType) ? 1 : 0);
				if (flag)
				{
					flag = await reader.ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
			}
			while (flag);
			if (initialDepth < CalculateWriteTokenFinalDepth(reader))
			{
				throw JsonWriterException.Create(this, "Unexpected end when reading token.", null);
			}
		}

		private async Task WriteConstructorDateAsync(JsonReader reader, CancellationToken cancellationToken)
		{
			if (!(await reader.ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
			{
				throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", null);
			}
			if (reader.TokenType != JsonToken.Integer)
			{
				throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected Integer, got " + reader.TokenType, null);
			}
			DateTime date = DateTimeUtils.ConvertJavaScriptTicksToDateTime((long)reader.Value);
			if (!(await reader.ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
			{
				throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", null);
			}
			if (reader.TokenType != JsonToken.EndConstructor)
			{
				throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected EndConstructor, got " + reader.TokenType, null);
			}
			await WriteValueAsync(date, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Task WriteValueAsync(bool value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(bool? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(byte value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(byte? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(byte[]? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(char value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(char? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(DateTime value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(DateTime? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(DateTimeOffset? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(decimal value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(decimal? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(double value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(double? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(float value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(float? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(Guid value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(Guid? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(int value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(int? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(long value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(long? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(object? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		[CLSCompliant(false)]
		public virtual Task WriteValueAsync(sbyte value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		[CLSCompliant(false)]
		public virtual Task WriteValueAsync(sbyte? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(short value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(short? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(string? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(TimeSpan value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(TimeSpan? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		[CLSCompliant(false)]
		public virtual Task WriteValueAsync(uint value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		[CLSCompliant(false)]
		public virtual Task WriteValueAsync(uint? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		[CLSCompliant(false)]
		public virtual Task WriteValueAsync(ulong value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		[CLSCompliant(false)]
		public virtual Task WriteValueAsync(ulong? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteValueAsync(Uri? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		[CLSCompliant(false)]
		public virtual Task WriteValueAsync(ushort value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		[CLSCompliant(false)]
		public virtual Task WriteValueAsync(ushort? value, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteValue(value);
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteUndefinedAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteUndefined();
			return AsyncUtils.CompletedTask;
		}

		public virtual Task WriteWhitespaceAsync(string ws, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			WriteWhitespace(ws);
			return AsyncUtils.CompletedTask;
		}

		internal Task InternalWriteValueAsync(JsonToken token, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			UpdateScopeWithFinishedValue();
			return AutoCompleteAsync(token, cancellationToken);
		}

		protected Task SetWriteStateAsync(JsonToken token, object value, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			switch (token)
			{
			case JsonToken.StartObject:
				return InternalWriteStartAsync(token, JsonContainerType.Object, cancellationToken);
			case JsonToken.StartArray:
				return InternalWriteStartAsync(token, JsonContainerType.Array, cancellationToken);
			case JsonToken.StartConstructor:
				return InternalWriteStartAsync(token, JsonContainerType.Constructor, cancellationToken);
			case JsonToken.PropertyName:
				if (!(value is string name))
				{
					throw new ArgumentException("A name is required when setting property name state.", "value");
				}
				return InternalWritePropertyNameAsync(name, cancellationToken);
			case JsonToken.Comment:
				return InternalWriteCommentAsync(cancellationToken);
			case JsonToken.Raw:
				return AsyncUtils.CompletedTask;
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				return InternalWriteValueAsync(token, cancellationToken);
			case JsonToken.EndObject:
				return InternalWriteEndAsync(JsonContainerType.Object, cancellationToken);
			case JsonToken.EndArray:
				return InternalWriteEndAsync(JsonContainerType.Array, cancellationToken);
			case JsonToken.EndConstructor:
				return InternalWriteEndAsync(JsonContainerType.Constructor, cancellationToken);
			default:
				throw new ArgumentOutOfRangeException("token");
			}
		}

		internal static Task WriteValueAsync(JsonWriter writer, PrimitiveTypeCode typeCode, object value, CancellationToken cancellationToken)
		{
			while (true)
			{
				switch (typeCode)
				{
				case PrimitiveTypeCode.Char:
					return writer.WriteValueAsync((char)value, cancellationToken);
				case PrimitiveTypeCode.CharNullable:
					return writer.WriteValueAsync((value == null) ? ((char?)null) : new char?((char)value), cancellationToken);
				case PrimitiveTypeCode.Boolean:
					return writer.WriteValueAsync((bool)value, cancellationToken);
				case PrimitiveTypeCode.BooleanNullable:
					return writer.WriteValueAsync((value == null) ? ((bool?)null) : new bool?((bool)value), cancellationToken);
				case PrimitiveTypeCode.SByte:
					return writer.WriteValueAsync((sbyte)value, cancellationToken);
				case PrimitiveTypeCode.SByteNullable:
					return writer.WriteValueAsync((value == null) ? ((sbyte?)null) : new sbyte?((sbyte)value), cancellationToken);
				case PrimitiveTypeCode.Int16:
					return writer.WriteValueAsync((short)value, cancellationToken);
				case PrimitiveTypeCode.Int16Nullable:
					return writer.WriteValueAsync((value == null) ? ((short?)null) : new short?((short)value), cancellationToken);
				case PrimitiveTypeCode.UInt16:
					return writer.WriteValueAsync((ushort)value, cancellationToken);
				case PrimitiveTypeCode.UInt16Nullable:
					return writer.WriteValueAsync((value == null) ? ((ushort?)null) : new ushort?((ushort)value), cancellationToken);
				case PrimitiveTypeCode.Int32:
					return writer.WriteValueAsync((int)value, cancellationToken);
				case PrimitiveTypeCode.Int32Nullable:
					return writer.WriteValueAsync((value == null) ? ((int?)null) : new int?((int)value), cancellationToken);
				case PrimitiveTypeCode.Byte:
					return writer.WriteValueAsync((byte)value, cancellationToken);
				case PrimitiveTypeCode.ByteNullable:
					return writer.WriteValueAsync((value == null) ? ((byte?)null) : new byte?((byte)value), cancellationToken);
				case PrimitiveTypeCode.UInt32:
					return writer.WriteValueAsync((uint)value, cancellationToken);
				case PrimitiveTypeCode.UInt32Nullable:
					return writer.WriteValueAsync((value == null) ? ((uint?)null) : new uint?((uint)value), cancellationToken);
				case PrimitiveTypeCode.Int64:
					return writer.WriteValueAsync((long)value, cancellationToken);
				case PrimitiveTypeCode.Int64Nullable:
					return writer.WriteValueAsync((value == null) ? ((long?)null) : new long?((long)value), cancellationToken);
				case PrimitiveTypeCode.UInt64:
					return writer.WriteValueAsync((ulong)value, cancellationToken);
				case PrimitiveTypeCode.UInt64Nullable:
					return writer.WriteValueAsync((value == null) ? ((ulong?)null) : new ulong?((ulong)value), cancellationToken);
				case PrimitiveTypeCode.Single:
					return writer.WriteValueAsync((float)value, cancellationToken);
				case PrimitiveTypeCode.SingleNullable:
					return writer.WriteValueAsync((value == null) ? ((float?)null) : new float?((float)value), cancellationToken);
				case PrimitiveTypeCode.Double:
					return writer.WriteValueAsync((double)value, cancellationToken);
				case PrimitiveTypeCode.DoubleNullable:
					return writer.WriteValueAsync((value == null) ? ((double?)null) : new double?((double)value), cancellationToken);
				case PrimitiveTypeCode.DateTime:
					return writer.WriteValueAsync((DateTime)value, cancellationToken);
				case PrimitiveTypeCode.DateTimeNullable:
					return writer.WriteValueAsync((value == null) ? ((DateTime?)null) : new DateTime?((DateTime)value), cancellationToken);
				case PrimitiveTypeCode.DateTimeOffset:
					return writer.WriteValueAsync((DateTimeOffset)value, cancellationToken);
				case PrimitiveTypeCode.DateTimeOffsetNullable:
					return writer.WriteValueAsync((value == null) ? ((DateTimeOffset?)null) : new DateTimeOffset?((DateTimeOffset)value), cancellationToken);
				case PrimitiveTypeCode.Decimal:
					return writer.WriteValueAsync((decimal)value, cancellationToken);
				case PrimitiveTypeCode.DecimalNullable:
					return writer.WriteValueAsync((value == null) ? ((decimal?)null) : new decimal?((decimal)value), cancellationToken);
				case PrimitiveTypeCode.Guid:
					return writer.WriteValueAsync((Guid)value, cancellationToken);
				case PrimitiveTypeCode.GuidNullable:
					return writer.WriteValueAsync((value == null) ? ((Guid?)null) : new Guid?((Guid)value), cancellationToken);
				case PrimitiveTypeCode.TimeSpan:
					return writer.WriteValueAsync((TimeSpan)value, cancellationToken);
				case PrimitiveTypeCode.TimeSpanNullable:
					return writer.WriteValueAsync((value == null) ? ((TimeSpan?)null) : new TimeSpan?((TimeSpan)value), cancellationToken);
				case PrimitiveTypeCode.BigInteger:
					return writer.WriteValueAsync((BigInteger)value, cancellationToken);
				case PrimitiveTypeCode.BigIntegerNullable:
					return writer.WriteValueAsync((value == null) ? ((BigInteger?)null) : new BigInteger?((BigInteger)value), cancellationToken);
				case PrimitiveTypeCode.Uri:
					return writer.WriteValueAsync((Uri)value, cancellationToken);
				case PrimitiveTypeCode.String:
					return writer.WriteValueAsync((string)value, cancellationToken);
				case PrimitiveTypeCode.Bytes:
					return writer.WriteValueAsync((byte[])value, cancellationToken);
				case PrimitiveTypeCode.DBNull:
					return writer.WriteNullAsync(cancellationToken);
				}
				if (value is IConvertible convertible)
				{
					ResolveConvertibleValue(convertible, out typeCode, out value);
					continue;
				}
				if (value == null)
				{
					return writer.WriteNullAsync(cancellationToken);
				}
				throw CreateUnsupportedTypeException(writer, value);
			}
		}

		internal static State[][] BuildStateArray()
		{
			List<State[]> list = StateArrayTemplate.ToList();
			State[] item = StateArrayTemplate[0];
			State[] item2 = StateArrayTemplate[7];
			ulong[] values = EnumUtils.GetEnumValuesAndNames(typeof(JsonToken)).Values;
			foreach (ulong num in values)
			{
				if (list.Count <= (int)num)
				{
					JsonToken jsonToken = (JsonToken)num;
					if ((uint)(jsonToken - 7) <= 5u || (uint)(jsonToken - 16) <= 1u)
					{
						list.Add(item2);
					}
					else
					{
						list.Add(item);
					}
				}
			}
			return list.ToArray();
		}

		static JsonWriter()
		{
			StateArrayTemplate = new State[8][]
			{
				new State[10]
				{
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.ObjectStart,
					State.ObjectStart,
					State.Error,
					State.Error,
					State.ObjectStart,
					State.ObjectStart,
					State.ObjectStart,
					State.ObjectStart,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.ArrayStart,
					State.ArrayStart,
					State.Error,
					State.Error,
					State.ArrayStart,
					State.ArrayStart,
					State.ArrayStart,
					State.ArrayStart,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.ConstructorStart,
					State.ConstructorStart,
					State.Error,
					State.Error,
					State.ConstructorStart,
					State.ConstructorStart,
					State.ConstructorStart,
					State.ConstructorStart,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Property,
					State.Error,
					State.Property,
					State.Property,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Start,
					State.Property,
					State.ObjectStart,
					State.Object,
					State.ArrayStart,
					State.Array,
					State.Constructor,
					State.Constructor,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Start,
					State.Property,
					State.ObjectStart,
					State.Object,
					State.ArrayStart,
					State.Array,
					State.Constructor,
					State.Constructor,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Start,
					State.Object,
					State.Error,
					State.Error,
					State.Array,
					State.Array,
					State.Constructor,
					State.Constructor,
					State.Error,
					State.Error
				}
			};
			StateArray = BuildStateArray();
		}

		internal virtual void OnStringEscapeHandlingChanged()
		{
		}

		protected JsonWriter()
		{
			_currentState = State.Start;
			_formatting = Formatting.None;
			_dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
			CloseOutput = true;
			AutoCompleteOnClose = true;
		}

		internal void UpdateScopeWithFinishedValue()
		{
			if (_currentPosition.HasIndex)
			{
				_currentPosition.Position++;
			}
		}

		private void Push(JsonContainerType value)
		{
			if (_currentPosition.Type != JsonContainerType.None)
			{
				if (_stack == null)
				{
					_stack = new List<JsonPosition>();
				}
				_stack.Add(_currentPosition);
			}
			_currentPosition = new JsonPosition(value);
		}

		private JsonContainerType Pop()
		{
			JsonPosition currentPosition = _currentPosition;
			if (_stack != null && _stack.Count > 0)
			{
				_currentPosition = _stack[_stack.Count - 1];
				_stack.RemoveAt(_stack.Count - 1);
			}
			else
			{
				_currentPosition = default(JsonPosition);
			}
			return currentPosition.Type;
		}

		private JsonContainerType Peek()
		{
			return _currentPosition.Type;
		}

		public abstract void Flush();

		public virtual void Close()
		{
			if (AutoCompleteOnClose)
			{
				AutoCompleteAll();
			}
		}

		public virtual void WriteStartObject()
		{
			InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);
		}

		public virtual void WriteEndObject()
		{
			InternalWriteEnd(JsonContainerType.Object);
		}

		public virtual void WriteStartArray()
		{
			InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);
		}

		public virtual void WriteEndArray()
		{
			InternalWriteEnd(JsonContainerType.Array);
		}

		public virtual void WriteStartConstructor(string name)
		{
			InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);
		}

		public virtual void WriteEndConstructor()
		{
			InternalWriteEnd(JsonContainerType.Constructor);
		}

		public virtual void WritePropertyName(string name)
		{
			InternalWritePropertyName(name);
		}

		public virtual void WritePropertyName(string name, bool escape)
		{
			WritePropertyName(name);
		}

		public virtual void WriteEnd()
		{
			WriteEnd(Peek());
		}

		public void WriteToken(JsonReader reader)
		{
			WriteToken(reader, writeChildren: true);
		}

		public void WriteToken(JsonReader reader, bool writeChildren)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			WriteToken(reader, writeChildren, writeDateConstructorAsDate: true, writeComments: true);
		}

		public void WriteToken(JsonToken token, object? value)
		{
			switch (token)
			{
			case JsonToken.StartObject:
				WriteStartObject();
				break;
			case JsonToken.StartArray:
				WriteStartArray();
				break;
			case JsonToken.StartConstructor:
				ValidationUtils.ArgumentNotNull(value, "value");
				WriteStartConstructor(value.ToString());
				break;
			case JsonToken.PropertyName:
				ValidationUtils.ArgumentNotNull(value, "value");
				WritePropertyName(value.ToString());
				break;
			case JsonToken.Comment:
				WriteComment(value?.ToString());
				break;
			case JsonToken.Integer:
				ValidationUtils.ArgumentNotNull(value, "value");
				if (value is BigInteger bigInteger)
				{
					WriteValue(bigInteger);
				}
				else
				{
					WriteValue(Convert.ToInt64(value, CultureInfo.InvariantCulture));
				}
				break;
			case JsonToken.Float:
				ValidationUtils.ArgumentNotNull(value, "value");
				if (value is decimal value3)
				{
					WriteValue(value3);
				}
				else if (value is double value4)
				{
					WriteValue(value4);
				}
				else if (value is float value5)
				{
					WriteValue(value5);
				}
				else
				{
					WriteValue(Convert.ToDouble(value, CultureInfo.InvariantCulture));
				}
				break;
			case JsonToken.String:
				WriteValue(value?.ToString());
				break;
			case JsonToken.Boolean:
				ValidationUtils.ArgumentNotNull(value, "value");
				WriteValue(Convert.ToBoolean(value, CultureInfo.InvariantCulture));
				break;
			case JsonToken.Null:
				WriteNull();
				break;
			case JsonToken.Undefined:
				WriteUndefined();
				break;
			case JsonToken.EndObject:
				WriteEndObject();
				break;
			case JsonToken.EndArray:
				WriteEndArray();
				break;
			case JsonToken.EndConstructor:
				WriteEndConstructor();
				break;
			case JsonToken.Date:
				ValidationUtils.ArgumentNotNull(value, "value");
				if (value is DateTimeOffset value6)
				{
					WriteValue(value6);
				}
				else
				{
					WriteValue(Convert.ToDateTime(value, CultureInfo.InvariantCulture));
				}
				break;
			case JsonToken.Raw:
				WriteRawValue(value?.ToString());
				break;
			case JsonToken.Bytes:
				ValidationUtils.ArgumentNotNull(value, "value");
				if (value is Guid value2)
				{
					WriteValue(value2);
				}
				else
				{
					WriteValue((byte[])value);
				}
				break;
			default:
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException("token", token, "Unexpected token type.");
			case JsonToken.None:
				break;
			}
		}

		public void WriteToken(JsonToken token)
		{
			WriteToken(token, null);
		}

		internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments)
		{
			int num = CalculateWriteTokenInitialDepth(reader);
			do
			{
				if (writeDateConstructorAsDate && reader.TokenType == JsonToken.StartConstructor && string.Equals(reader.Value?.ToString(), "Date", StringComparison.Ordinal))
				{
					WriteConstructorDate(reader);
				}
				else if (writeComments || reader.TokenType != JsonToken.Comment)
				{
					WriteToken(reader.TokenType, reader.Value);
				}
			}
			while (num - 1 < reader.Depth - (JsonTokenUtils.IsEndToken(reader.TokenType) ? 1 : 0) && writeChildren && reader.Read());
			if (IsWriteTokenIncomplete(reader, writeChildren, num))
			{
				throw JsonWriterException.Create(this, "Unexpected end when reading token.", null);
			}
		}

		private bool IsWriteTokenIncomplete(JsonReader reader, bool writeChildren, int initialDepth)
		{
			int num = CalculateWriteTokenFinalDepth(reader);
			if (initialDepth >= num)
			{
				if (writeChildren && initialDepth == num)
				{
					return JsonTokenUtils.IsStartToken(reader.TokenType);
				}
				return false;
			}
			return true;
		}

		private int CalculateWriteTokenInitialDepth(JsonReader reader)
		{
			JsonToken tokenType = reader.TokenType;
			if (tokenType == JsonToken.None)
			{
				return -1;
			}
			if (!JsonTokenUtils.IsStartToken(tokenType))
			{
				return reader.Depth + 1;
			}
			return reader.Depth;
		}

		private int CalculateWriteTokenFinalDepth(JsonReader reader)
		{
			JsonToken tokenType = reader.TokenType;
			if (tokenType == JsonToken.None)
			{
				return -1;
			}
			if (!JsonTokenUtils.IsEndToken(tokenType))
			{
				return reader.Depth;
			}
			return reader.Depth - 1;
		}

		private void WriteConstructorDate(JsonReader reader)
		{
			if (!JavaScriptUtils.TryGetDateFromConstructorJson(reader, out DateTime dateTime, out string errorMessage))
			{
				throw JsonWriterException.Create(this, errorMessage, null);
			}
			WriteValue(dateTime);
		}

		private void WriteEnd(JsonContainerType type)
		{
			switch (type)
			{
			case JsonContainerType.Object:
				WriteEndObject();
				break;
			case JsonContainerType.Array:
				WriteEndArray();
				break;
			case JsonContainerType.Constructor:
				WriteEndConstructor();
				break;
			default:
				throw JsonWriterException.Create(this, "Unexpected type when writing end: " + type, null);
			}
		}

		private void AutoCompleteAll()
		{
			while (Top > 0)
			{
				WriteEnd();
			}
		}

		private JsonToken GetCloseTokenForType(JsonContainerType type)
		{
			return type switch
			{
				JsonContainerType.Object => JsonToken.EndObject, 
				JsonContainerType.Array => JsonToken.EndArray, 
				JsonContainerType.Constructor => JsonToken.EndConstructor, 
				_ => throw JsonWriterException.Create(this, "No close token for type: " + type, null), 
			};
		}

		private void AutoCompleteClose(JsonContainerType type)
		{
			int num = CalculateLevelsToComplete(type);
			for (int i = 0; i < num; i++)
			{
				JsonToken closeTokenForType = GetCloseTokenForType(Pop());
				if (_currentState == State.Property)
				{
					WriteNull();
				}
				if (_formatting == Formatting.Indented && _currentState != State.ObjectStart && _currentState != State.ArrayStart)
				{
					WriteIndent();
				}
				WriteEnd(closeTokenForType);
				UpdateCurrentState();
			}
		}

		private int CalculateLevelsToComplete(JsonContainerType type)
		{
			int num = 0;
			if (_currentPosition.Type == type)
			{
				num = 1;
			}
			else
			{
				int num2 = Top - 2;
				for (int num3 = num2; num3 >= 0; num3--)
				{
					int index = num2 - num3;
					if (_stack[index].Type == type)
					{
						num = num3 + 2;
						break;
					}
				}
			}
			if (num == 0)
			{
				throw JsonWriterException.Create(this, "No token to close.", null);
			}
			return num;
		}

		private void UpdateCurrentState()
		{
			JsonContainerType jsonContainerType = Peek();
			switch (jsonContainerType)
			{
			case JsonContainerType.Object:
				_currentState = State.Object;
				break;
			case JsonContainerType.Array:
				_currentState = State.Array;
				break;
			case JsonContainerType.Constructor:
				_currentState = State.Array;
				break;
			case JsonContainerType.None:
				_currentState = State.Start;
				break;
			default:
				throw JsonWriterException.Create(this, "Unknown JsonType: " + jsonContainerType, null);
			}
		}

		protected virtual void WriteEnd(JsonToken token)
		{
		}

		protected virtual void WriteIndent()
		{
		}

		protected virtual void WriteValueDelimiter()
		{
		}

		protected virtual void WriteIndentSpace()
		{
		}

		internal void AutoComplete(JsonToken tokenBeingWritten)
		{
			State state = StateArray[(int)tokenBeingWritten][(int)_currentState];
			if (state == State.Error)
			{
				throw JsonWriterException.Create(this, "Token {0} in state {1} would result in an invalid JSON object.".FormatWith(CultureInfo.InvariantCulture, tokenBeingWritten.ToString(), _currentState.ToString()), null);
			}
			if ((_currentState == State.Object || _currentState == State.Array || _currentState == State.Constructor) && tokenBeingWritten != JsonToken.Comment)
			{
				WriteValueDelimiter();
			}
			if (_formatting == Formatting.Indented)
			{
				if (_currentState == State.Property)
				{
					WriteIndentSpace();
				}
				if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.Constructor || _currentState == State.ConstructorStart || (tokenBeingWritten == JsonToken.PropertyName && _currentState != State.Start))
				{
					WriteIndent();
				}
			}
			_currentState = state;
		}

		public virtual void WriteNull()
		{
			InternalWriteValue(JsonToken.Null);
		}

		public virtual void WriteUndefined()
		{
			InternalWriteValue(JsonToken.Undefined);
		}

		public virtual void WriteRaw(string? json)
		{
			InternalWriteRaw();
		}

		public virtual void WriteRawValue(string? json)
		{
			UpdateScopeWithFinishedValue();
			AutoComplete(JsonToken.Undefined);
			WriteRaw(json);
		}

		public virtual void WriteValue(string? value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(int value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(uint value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(long value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(ulong value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(float value)
		{
			InternalWriteValue(JsonToken.Float);
		}

		public virtual void WriteValue(double value)
		{
			InternalWriteValue(JsonToken.Float);
		}

		public virtual void WriteValue(bool value)
		{
			InternalWriteValue(JsonToken.Boolean);
		}

		public virtual void WriteValue(short value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(ushort value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(char value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(byte value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(sbyte value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(decimal value)
		{
			InternalWriteValue(JsonToken.Float);
		}

		public virtual void WriteValue(DateTime value)
		{
			InternalWriteValue(JsonToken.Date);
		}

		public virtual void WriteValue(DateTimeOffset value)
		{
			InternalWriteValue(JsonToken.Date);
		}

		public virtual void WriteValue(Guid value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(TimeSpan value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(int? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(uint? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(long? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(ulong? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(float? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(double? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(bool? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value == true);
			}
		}

		public virtual void WriteValue(short? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(ushort? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(char? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(byte? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(sbyte? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(decimal? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(DateTime? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(DateTimeOffset? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(Guid? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(TimeSpan? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(byte[]? value)
		{
			if (value == null)
			{
				WriteNull();
			}
			else
			{
				InternalWriteValue(JsonToken.Bytes);
			}
		}

		public virtual void WriteValue(Uri? value)
		{
			if (value == null)
			{
				WriteNull();
			}
			else
			{
				InternalWriteValue(JsonToken.String);
			}
		}

		public virtual void WriteValue(object? value)
		{
			if (value == null)
			{
				WriteNull();
				return;
			}
			if (value is BigInteger)
			{
				throw CreateUnsupportedTypeException(this, value);
			}
			WriteValue(this, ConvertUtils.GetTypeCode(value.GetType()), value);
		}

		public virtual void WriteComment(string? text)
		{
			InternalWriteComment();
		}

		public virtual void WriteWhitespace(string ws)
		{
			InternalWriteWhitespace(ws);
		}

		void IDisposable.Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (_currentState != State.Closed && disposing)
			{
				Close();
			}
		}

		internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value)
		{
			while (true)
			{
				switch (typeCode)
				{
				case PrimitiveTypeCode.Char:
					writer.WriteValue((char)value);
					return;
				case PrimitiveTypeCode.CharNullable:
					writer.WriteValue((value == null) ? ((char?)null) : new char?((char)value));
					return;
				case PrimitiveTypeCode.Boolean:
					writer.WriteValue((bool)value);
					return;
				case PrimitiveTypeCode.BooleanNullable:
					writer.WriteValue((value == null) ? ((bool?)null) : new bool?((bool)value));
					return;
				case PrimitiveTypeCode.SByte:
					writer.WriteValue((sbyte)value);
					return;
				case PrimitiveTypeCode.SByteNullable:
					writer.WriteValue((value == null) ? ((sbyte?)null) : new sbyte?((sbyte)value));
					return;
				case PrimitiveTypeCode.Int16:
					writer.WriteValue((short)value);
					return;
				case PrimitiveTypeCode.Int16Nullable:
					writer.WriteValue((value == null) ? ((short?)null) : new short?((short)value));
					return;
				case PrimitiveTypeCode.UInt16:
					writer.WriteValue((ushort)value);
					return;
				case PrimitiveTypeCode.UInt16Nullable:
					writer.WriteValue((value == null) ? ((ushort?)null) : new ushort?((ushort)value));
					return;
				case PrimitiveTypeCode.Int32:
					writer.WriteValue((int)value);
					return;
				case PrimitiveTypeCode.Int32Nullable:
					writer.WriteValue((value == null) ? ((int?)null) : new int?((int)value));
					return;
				case PrimitiveTypeCode.Byte:
					writer.WriteValue((byte)value);
					return;
				case PrimitiveTypeCode.ByteNullable:
					writer.WriteValue((value == null) ? ((byte?)null) : new byte?((byte)value));
					return;
				case PrimitiveTypeCode.UInt32:
					writer.WriteValue((uint)value);
					return;
				case PrimitiveTypeCode.UInt32Nullable:
					writer.WriteValue((value == null) ? ((uint?)null) : new uint?((uint)value));
					return;
				case PrimitiveTypeCode.Int64:
					writer.WriteValue((long)value);
					return;
				case PrimitiveTypeCode.Int64Nullable:
					writer.WriteValue((value == null) ? ((long?)null) : new long?((long)value));
					return;
				case PrimitiveTypeCode.UInt64:
					writer.WriteValue((ulong)value);
					return;
				case PrimitiveTypeCode.UInt64Nullable:
					writer.WriteValue((value == null) ? ((ulong?)null) : new ulong?((ulong)value));
					return;
				case PrimitiveTypeCode.Single:
					writer.WriteValue((float)value);
					return;
				case PrimitiveTypeCode.SingleNullable:
					writer.WriteValue((value == null) ? ((float?)null) : new float?((float)value));
					return;
				case PrimitiveTypeCode.Double:
					writer.WriteValue((double)value);
					return;
				case PrimitiveTypeCode.DoubleNullable:
					writer.WriteValue((value == null) ? ((double?)null) : new double?((double)value));
					return;
				case PrimitiveTypeCode.DateTime:
					writer.WriteValue((DateTime)value);
					return;
				case PrimitiveTypeCode.DateTimeNullable:
					writer.WriteValue((value == null) ? ((DateTime?)null) : new DateTime?((DateTime)value));
					return;
				case PrimitiveTypeCode.DateTimeOffset:
					writer.WriteValue((DateTimeOffset)value);
					return;
				case PrimitiveTypeCode.DateTimeOffsetNullable:
					writer.WriteValue((value == null) ? ((DateTimeOffset?)null) : new DateTimeOffset?((DateTimeOffset)value));
					return;
				case PrimitiveTypeCode.Decimal:
					writer.WriteValue((decimal)value);
					return;
				case PrimitiveTypeCode.DecimalNullable:
					writer.WriteValue((value == null) ? ((decimal?)null) : new decimal?((decimal)value));
					return;
				case PrimitiveTypeCode.Guid:
					writer.WriteValue((Guid)value);
					return;
				case PrimitiveTypeCode.GuidNullable:
					writer.WriteValue((value == null) ? ((Guid?)null) : new Guid?((Guid)value));
					return;
				case PrimitiveTypeCode.TimeSpan:
					writer.WriteValue((TimeSpan)value);
					return;
				case PrimitiveTypeCode.TimeSpanNullable:
					writer.WriteValue((value == null) ? ((TimeSpan?)null) : new TimeSpan?((TimeSpan)value));
					return;
				case PrimitiveTypeCode.BigInteger:
					writer.WriteValue((BigInteger)value);
					return;
				case PrimitiveTypeCode.BigIntegerNullable:
					writer.WriteValue((value == null) ? ((BigInteger?)null) : new BigInteger?((BigInteger)value));
					return;
				case PrimitiveTypeCode.Uri:
					writer.WriteValue((Uri)value);
					return;
				case PrimitiveTypeCode.String:
					writer.WriteValue((string)value);
					return;
				case PrimitiveTypeCode.Bytes:
					writer.WriteValue((byte[])value);
					return;
				case PrimitiveTypeCode.DBNull:
					writer.WriteNull();
					return;
				}
				if (value is IConvertible convertible)
				{
					ResolveConvertibleValue(convertible, out typeCode, out value);
					continue;
				}
				if (value == null)
				{
					writer.WriteNull();
					return;
				}
				throw CreateUnsupportedTypeException(writer, value);
			}
		}

		private static void ResolveConvertibleValue(IConvertible convertible, out PrimitiveTypeCode typeCode, out object value)
		{
			TypeInformation typeInformation = ConvertUtils.GetTypeInformation(convertible);
			typeCode = ((typeInformation.TypeCode == PrimitiveTypeCode.Object) ? PrimitiveTypeCode.String : typeInformation.TypeCode);
			Type conversionType = ((typeInformation.TypeCode == PrimitiveTypeCode.Object) ? typeof(string) : typeInformation.Type);
			value = convertible.ToType(conversionType, CultureInfo.InvariantCulture);
		}

		private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value)
		{
			return JsonWriterException.Create(writer, "Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), null);
		}

		protected void SetWriteState(JsonToken token, object value)
		{
			switch (token)
			{
			case JsonToken.StartObject:
				InternalWriteStart(token, JsonContainerType.Object);
				break;
			case JsonToken.StartArray:
				InternalWriteStart(token, JsonContainerType.Array);
				break;
			case JsonToken.StartConstructor:
				InternalWriteStart(token, JsonContainerType.Constructor);
				break;
			case JsonToken.PropertyName:
				if (!(value is string name))
				{
					throw new ArgumentException("A name is required when setting property name state.", "value");
				}
				InternalWritePropertyName(name);
				break;
			case JsonToken.Comment:
				InternalWriteComment();
				break;
			case JsonToken.Raw:
				InternalWriteRaw();
				break;
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				InternalWriteValue(token);
				break;
			case JsonToken.EndObject:
				InternalWriteEnd(JsonContainerType.Object);
				break;
			case JsonToken.EndArray:
				InternalWriteEnd(JsonContainerType.Array);
				break;
			case JsonToken.EndConstructor:
				InternalWriteEnd(JsonContainerType.Constructor);
				break;
			default:
				throw new ArgumentOutOfRangeException("token");
			}
		}

		internal void InternalWriteEnd(JsonContainerType container)
		{
			AutoCompleteClose(container);
		}

		internal void InternalWritePropertyName(string name)
		{
			_currentPosition.PropertyName = name;
			AutoComplete(JsonToken.PropertyName);
		}

		internal void InternalWriteRaw()
		{
		}

		internal void InternalWriteStart(JsonToken token, JsonContainerType container)
		{
			UpdateScopeWithFinishedValue();
			AutoComplete(token);
			Push(container);
		}

		internal void InternalWriteValue(JsonToken token)
		{
			UpdateScopeWithFinishedValue();
			AutoComplete(token);
		}

		internal void InternalWriteWhitespace(string ws)
		{
			if (ws != null && !StringUtils.IsWhiteSpace(ws))
			{
				throw JsonWriterException.Create(this, "Only white space characters should be used.", null);
			}
		}

		internal void InternalWriteComment()
		{
			AutoComplete(JsonToken.Comment);
		}
	}
	[Serializable]
	internal class JsonWriterException : JsonException
	{
		public string? Path { get; }

		public JsonWriterException()
		{
		}

		public JsonWriterException(string message)
			: base(message)
		{
		}

		public JsonWriterException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonWriterException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		public JsonWriterException(string message, string path, Exception? innerException)
			: base(message, innerException)
		{
			Path = path;
		}

		internal static JsonWriterException Create(JsonWriter writer, string message, Exception? ex)
		{
			return Create(writer.ContainerPath, message, ex);
		}

		internal static JsonWriterException Create(string path, string message, Exception? ex)
		{
			message = JsonPosition.FormatMessage(null, path, message);
			return new JsonWriterException(message, path, ex);
		}
	}
	internal enum MemberSerialization
	{
		OptOut,
		OptIn,
		Fields
	}
	internal enum MetadataPropertyHandling
	{
		Default,
		ReadAhead,
		Ignore
	}
	internal enum MissingMemberHandling
	{
		Ignore,
		Error
	}
	internal enum NullValueHandling
	{
		Include,
		Ignore
	}
	internal enum ObjectCreationHandling
	{
		Auto,
		Reuse,
		Replace
	}
	[Flags]
	internal enum PreserveReferencesHandling
	{
		None = 0,
		Objects = 1,
		Arrays = 2,
		All = 3
	}
	internal enum ReferenceLoopHandling
	{
		Error,
		Ignore,
		Serialize
	}
	internal enum Required
	{
		Default,
		AllowNull,
		Always,
		DisallowNull
	}
	internal enum StringEscapeHandling
	{
		Default,
		EscapeNonAscii,
		EscapeHtml
	}
	internal enum TypeNameAssemblyFormatHandling
	{
		Simple,
		Full
	}
	[Flags]
	internal enum TypeNameHandling
	{
		None = 0,
		Objects = 1,
		Arrays = 2,
		All = 3,
		Auto = 4
	}
	internal enum WriteState
	{
		Error,
		Closed,
		Object,
		Array,
		Constructor,
		Property,
		Start
	}
}
namespace Microsoft.Identity.Json.Utilities
{
	internal static class AsyncUtils
	{
		public static readonly Task<bool> False = Task.FromResult(result: false);

		public static readonly Task<bool> True = Task.FromResult(result: true);

		internal static readonly Task CompletedTask = Task.Delay(0);

		internal static Task<bool> ToAsync(this bool value)
		{
			if (!value)
			{
				return False;
			}
			return True;
		}

		public static Task? CancelIfRequestedAsync(this CancellationToken cancellationToken)
		{
			if (!cancellationToken.IsCancellationRequested)
			{
				return null;
			}
			return cancellationToken.FromCanceled();
		}

		public static Task<T>? CancelIfRequestedAsync<T>(this CancellationToken cancellationToken)
		{
			if (!cancellationToken.IsCancellationRequested)
			{
				return null;
			}
			return cancellationToken.FromCanceled<T>();
		}

		public static Task FromCanceled(this CancellationToken cancellationToken)
		{
			return new Task(delegate
			{
			}, cancellationToken);
		}

		public static Task<T> FromCanceled<T>(this CancellationToken cancellationToken)
		{
			return new Task<T>(() => default(T), cancellationToken);
		}

		public static Task WriteAsync(this TextWriter writer, char value, CancellationToken cancellationToken)
		{
			if (!cancellationToken.IsCancellationRequested)
			{
				return writer.WriteAsync(value);
			}
			return cancellationToken.FromCanceled();
		}

		public static Task WriteAsync(this TextWriter writer, string? value, CancellationToken cancellationToken)
		{
			if (!cancellationToken.IsCancellationRequested)
			{
				return writer.WriteAsync(value);
			}
			return cancellationToken.FromCanceled();
		}

		public static Task WriteAsync(this TextWriter writer, char[] value, int start, int count, CancellationToken cancellationToken)
		{
			if (!cancellationToken.IsCancellationRequested)
			{
				return writer.WriteAsync(value, start, count);
			}
			return cancellationToken.FromCanceled();
		}

		public static Task<int> ReadAsync(this TextReader reader, char[] buffer, int index, int count, CancellationToken cancellationToken)
		{
			if (!cancellationToken.IsCancellationRequested)
			{
				return reader.ReadAsync(buffer, index, count);
			}
			return cancellationToken.FromCanceled<int>();
		}

		public static bool IsCompletedSucessfully(this Task task)
		{
			return task.Status == TaskStatus.RanToCompletion;
		}
	}
	internal class Base64Encoder
	{
		private const int Base64LineSize = 76;

		private const int LineSizeInBytes = 57;

		private readonly char[] _charsLine = new char[76];

		private readonly TextWriter _writer;

		private byte[]? _leftOverBytes;

		private int _leftOverBytesCount;

		public Base64Encoder(TextWriter writer)
		{
			ValidationUtils.ArgumentNotNull(writer, "writer");
			_writer = writer;
		}

		private void ValidateEncode(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (count > buffer.Length - index)
			{
				throw new ArgumentOutOfRangeException("count");
			}
		}

		public void Encode(byte[] buffer, int index, int count)
		{
			ValidateEncode(buffer, index, count);
			if (_leftOverBytesCount > 0)
			{
				if (FulfillFromLeftover(buffer, index, ref count))
				{
					return;
				}
				int count2 = Convert.ToBase64CharArray(_leftOverBytes, 0, 3, _charsLine, 0);
				WriteChars(_charsLine, 0, count2);
			}
			StoreLeftOverBytes(buffer, index, ref count);
			int num = index + count;
			int num2 = 57;
			while (index < num)
			{
				if (index + num2 > num)
				{
					num2 = num - index;
				}
				int count3 = Convert.ToBase64CharArray(buffer, index, num2, _charsLine, 0);
				WriteChars(_charsLine, 0, count3);
				index += num2;
			}
		}

		private void StoreLeftOverBytes(byte[] buffer, int index, ref int count)
		{
			int num = count % 3;
			if (num > 0)
			{
				count -= num;
				if (_leftOverBytes == null)
				{
					_leftOverBytes = new byte[3];
				}
				for (int i = 0; i < num; i++)
				{
					_leftOverBytes[i] = buffer[index + count + i];
				}
			}
			_leftOverBytesCount = num;
		}

		private bool FulfillFromLeftover(byte[] buffer, int index, ref int count)
		{
			int leftOverBytesCount = _leftOverBytesCount;
			while (leftOverBytesCount < 3 && count > 0)
			{
				_leftOverBytes[leftOverBytesCount++] = buffer[index++];
				count--;
			}
			if (count == 0 && leftOverBytesCount < 3)
			{
				_leftOverBytesCount = leftOverBytesCount;
				return true;
			}
			return false;
		}

		public void Flush()
		{
			if (_leftOverBytesCount > 0)
			{
				int count = Convert.ToBase64CharArray(_leftOverBytes, 0, _leftOverBytesCount, _charsLine, 0);
				WriteChars(_charsLine, 0, count);
				_leftOverBytesCount = 0;
			}
		}

		private void WriteChars(char[] chars, int index, int count)
		{
			_writer.Write(chars, index, count);
		}

		public async Task EncodeAsync(byte[] buffer, int index, int count, CancellationToken cancellationToken)
		{
			ValidateEncode(buffer, index, count);
			if (_leftOverBytesCount > 0)
			{
				if (FulfillFromLeftover(buffer, index, ref count))
				{
					return;
				}
				int count2 = Convert.ToBase64CharArray(_leftOverBytes, 0, 3, _charsLine, 0);
				await WriteCharsAsync(_charsLine, 0, count2, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			StoreLeftOverBytes(buffer, index, ref count);
			int num4 = index + count;
			int length = 57;
			while (index < num4)
			{
				if (index + length > num4)
				{
					length = num4 - index;
				}
				int count3 = Convert.ToBase64CharArray(buffer, index, length, _charsLine, 0);
				await WriteCharsAsync(_charsLine, 0, count3, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				index += length;
			}
		}

		private Task WriteCharsAsync(char[] chars, int index, int count, CancellationToken cancellationToken)
		{
			return _writer.WriteAsync(chars, index, count, cancellationToken);
		}

		public Task FlushAsync(CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			if (_leftOverBytesCount > 0)
			{
				int count = Convert.ToBase64CharArray(_leftOverBytes, 0, _leftOverBytesCount, _charsLine, 0);
				_leftOverBytesCount = 0;
				return WriteCharsAsync(_charsLine, 0, count, cancellationToken);
			}
			return AsyncUtils.CompletedTask;
		}
	}
	internal class BidirectionalDictionary<TFirst, TSecond>
	{
		private readonly IDictionary<TFirst, TSecond> _firstToSecond;

		private readonly IDictionary<TSecond, TFirst> _secondToFirst;

		private readonly string _duplicateFirstErrorMessage;

		private readonly string _duplicateSecondErrorMessage;

		public BidirectionalDictionary()
			: this((IEqualityComparer<TFirst>)EqualityComparer<TFirst>.Default, (IEqualityComparer<TSecond>)EqualityComparer<TSecond>.Default)
		{
		}

		public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer)
			: this(firstEqualityComparer, secondEqualityComparer, "Duplicate item already exists for '{0}'.", "Duplicate item already exists for '{0}'.")
		{
		}

		public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage)
		{
			_firstToSecond = new Dictionary<TFirst, TSecond>(firstEqualityComparer);
			_secondToFirst = new Dictionary<TSecond, TFirst>(secondEqualityComparer);
			_duplicateFirstErrorMessage = duplicateFirstErrorMessage;
			_duplicateSecondErrorMessage = duplicateSecondErrorMessage;
		}

		public void Set(TFirst first, TSecond second)
		{
			if (_firstToSecond.TryGetValue(first, out var value))
			{
				object obj = second;
				if (!value.Equals(obj))
				{
					throw new ArgumentException(_duplicateFirstErrorMessage.FormatWith(CultureInfo.InvariantCulture, first));
				}
			}
			if (_secondToFirst.TryGetValue(second, out var value2))
			{
				object obj2 = first;
				if (!value2.Equals(obj2))
				{
					throw new ArgumentException(_duplicateSecondErrorMessage.FormatWith(CultureInfo.InvariantCulture, second));
				}
			}
			_firstToSecond.Add(first, second);
			_secondToFirst.Add(second, first);
		}

		public bool TryGetByFirst(TFirst first, out TSecond second)
		{
			return _firstToSecond.TryGetValue(first, out second);
		}

		public bool TryGetBySecond(TSecond second, out TFirst first)
		{
			return _secondToFirst.TryGetValue(second, out first);
		}
	}
	internal static class CollectionUtils
	{
		private static class EmptyArrayContainer<T>
		{
			public static readonly T[] Empty = new T[0];
		}

		public static bool IsNullOrEmpty<T>(ICollection<T> collection)
		{
			if (collection != null)
			{
				return collection.Count == 0;
			}
			return true;
		}

		public static void AddRange<T>(this IList<T> initial, IEnumerable<T> collection)
		{
			if (initial == null)
			{
				throw new ArgumentNullException("initial");
			}
			if (collection == null)
			{
				return;
			}
			foreach (T item in collection)
			{
				initial.Add(item);
			}
		}

		public static bool IsDictionaryType(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (typeof(IDictionary).IsAssignableFrom(type))
			{
				return true;
			}
			if (ReflectionUtils.ImplementsGenericDefinition(type, typeof(IDictionary<, >)))
			{
				return true;
			}
			if (ReflectionUtils.ImplementsGenericDefinition(type, typeof(IReadOnlyDictionary<, >)))
			{
				return true;
			}
			return false;
		}

		public static ConstructorInfo? ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType)
		{
			Type constructorArgumentType = typeof(IList<>).MakeGenericType(collectionItemType);
			return ResolveEnumerableCollectionConstructor(collectionType, collectionItemType, constructorArgumentType);
		}

		public static ConstructorInfo? ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType)
		{
			Type type = typeof(IEnumerable<>).MakeGenericType(collectionItemType);
			ConstructorInfo constructorInfo = null;
			ConstructorInfo[] constructors = collectionType.GetConstructors(BindingFlags.Instance | BindingFlags.Public);
			foreach (ConstructorInfo constructorInfo2 in constructors)
			{
				IList<ParameterInfo> parameters = constructorInfo2.GetParameters();
				if (parameters.Count == 1)
				{
					Type parameterType = parameters[0].ParameterType;
					if (type == parameterType)
					{
						constructorInfo = constructorInfo2;
						break;
					}
					if (constructorInfo == null && parameterType.IsAssignableFrom(constructorArgumentType))
					{
						constructorInfo = constructorInfo2;
					}
				}
			}
			return constructorInfo;
		}

		public static bool AddDistinct<T>(this IList<T> list, T value)
		{
			return list.AddDistinct(value, EqualityComparer<T>.Default);
		}

		public static bool AddDistinct<T>(this IList<T> list, T value, IEqualityComparer<T> comparer)
		{
			if (list.ContainsValue(value, comparer))
			{
				return false;
			}
			list.Add(value);
			return true;
		}

		public static bool ContainsValue<TSource>(this IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<TSource>.Default;
			}
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			foreach (TSource item in source)
			{
				if (comparer.Equals(item, value))
				{
					return true;
				}
			}
			return false;
		}

		public static bool AddRangeDistinct<T>(this IList<T> list, IEnumerable<T> values, IEqualityComparer<T> comparer)
		{
			bool result = true;
			foreach (T value in values)
			{
				if (!list.AddDistinct(value, comparer))
				{
					result = false;
				}
			}
			return result;
		}

		public static int IndexOf<T>(this IEnumerable<T> collection, Func<T, bool> predicate)
		{
			int num = 0;
			foreach (T item in collection)
			{
				if (predicate(item))
				{
					return num;
				}
				num++;
			}
			return -1;
		}

		public static bool Contains<T>(this List<T> list, T value, IEqualityComparer comparer)
		{
			for (int i = 0; i < list.Count; i++)
			{
				if (comparer.Equals(value, list[i]))
				{
					return true;
				}
			}
			return false;
		}

		public static int IndexOfReference<T>(this List<T> list, T item)
		{
			for (int i = 0; i < list.Count; i++)
			{
				if ((object)item == (object)list[i])
				{
					return i;
				}
			}
			return -1;
		}

		public static void FastReverse<T>(this List<T> list)
		{
			int num = 0;
			int num2 = list.Count - 1;
			while (num < num2)
			{
				T value = list[num];
				list[num] = list[num2];
				list[num2] = value;
				num++;
				num2--;
			}
		}

		private static IList<int> GetDimensions(IList values, int dimensionsCount)
		{
			IList<int> list = new List<int>();
			IList list2 = values;
			while (true)
			{
				list.Add(list2.Count);
				if (list.Count == dimensionsCount || list2.Count == 0 || !(list2[0] is IList list3))
				{
					break;
				}
				list2 = list3;
			}
			return list;
		}

		private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, int[] indices)
		{
			int num = indices.Length;
			if (num == multidimensionalArray.Rank)
			{
				multidimensionalArray.SetValue(JaggedArrayGetValue(values, indices), indices);
				return;
			}
			int length = multidimensionalArray.GetLength(num);
			if (((IList)JaggedArrayGetValue(values, indices)).Count != length)
			{
				throw new Exception("Cannot deserialize non-cubical array as multidimensional array.");
			}
			int[] array = new int[num + 1];
			for (int i = 0; i < num; i++)
			{
				array[i] = indices[i];
			}
			for (int j = 0; j < multidimensionalArray.GetLength(num); j++)
			{
				array[num] = j;
				CopyFromJaggedToMultidimensionalArray(values, multidimensionalArray, array);
			}
		}

		private static object JaggedArrayGetValue(IList values, int[] indices)
		{
			IList list = values;
			for (int i = 0; i < indices.Length; i++)
			{
				int index = indices[i];
				if (i == indices.Length - 1)
				{
					return list[index];
				}
				list = (IList)list[index];
			}
			return list;
		}

		public static Array ToMultidimensionalArray(IList values, Type type, int rank)
		{
			IList<int> dimensions = GetDimensions(values, rank);
			while (dimensions.Count < rank)
			{
				dimensions.Add(0);
			}
			Array array = Array.CreateInstance(type, dimensions.ToArray());
			CopyFromJaggedToMultidimensionalArray(values, array, ArrayEmpty<int>());
			return array;
		}

		public static T[] ArrayEmpty<T>()
		{
			return EmptyArrayContainer<T>.Empty;
		}
	}
	internal interface IWrappedCollection : IList, ICollection, IEnumerable
	{
		object UnderlyingCollection { get; }
	}
	internal class CollectionWrapper<T> : ICollection<T>, IEnumerable<T>, IEnumerable, IWrappedCollection, IList, ICollection
	{
		private readonly IList? _list;

		private readonly ICollection<T>? _genericCollection;

		private object? _syncRoot;

		public virtual int Count
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.Count;
				}
				return _list.Count;
			}
		}

		public virtual bool IsReadOnly
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.IsReadOnly;
				}
				return _list.IsReadOnly;
			}
		}

		bool IList.IsFixedSize
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.IsReadOnly;
				}
				return _list.IsFixedSize;
			}
		}

		object IList.this[int index]
		{
			get
			{
				if (_genericCollection != null)
				{
					throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");
				}
				return _list[index];
			}
			set
			{
				if (_genericCollection != null)
				{
					throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");
				}
				VerifyValueType(value);
				_list[index] = (T)value;
			}
		}

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		public object UnderlyingCollection => ((object)_genericCollection) ?? ((object)_list);

		public CollectionWrapper(IList list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			if (list is ICollection<T> genericCollection)
			{
				_genericCollection = genericCollection;
			}
			else
			{
				_list = list;
			}
		}

		public CollectionWrapper(ICollection<T> list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			_genericCollection = list;
		}

		public virtual void Add(T item)
		{
			if (_genericCollection != null)
			{
				_genericCollection.Add(item);
			}
			else
			{
				_list.Add(item);
			}
		}

		public virtual void Clear()
		{
			if (_genericCollection != null)
			{
				_genericCollection.Clear();
			}
			else
			{
				_list.Clear();
			}
		}

		public virtual bool Contains(T item)
		{
			if (_genericCollection != null)
			{
				return _genericCollection.Contains(item);
			}
			return _list.Contains(item);
		}

		public virtual void CopyTo(T[] array, int arrayIndex)
		{
			if (_genericCollection != null)
			{
				_genericCollection.CopyTo(array, arrayIndex);
			}
			else
			{
				_list.CopyTo(array, arrayIndex);
			}
		}

		public virtual bool Remove(T item)
		{
			if (_genericCollection != null)
			{
				return _genericCollection.Remove(item);
			}
			bool num = _list.Contains(item);
			if (num)
			{
				_list.Remove(item);
			}
			return num;
		}

		public virtual IEnumerator<T> GetEnumerator()
		{
			IEnumerable<T> genericCollection = _genericCollection;
			return (genericCollection ?? _list.Cast<T>()).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			IEnumerable genericCollection = _genericCollection;
			return (genericCollection ?? _list).GetEnumerator();
		}

		int IList.Add(object value)
		{
			VerifyValueType(value);
			Add((T)value);
			return Count - 1;
		}

		bool IList.Contains(object value)
		{
			if (IsCompatibleObject(value))
			{
				return Contains((T)value);
			}
			return false;
		}

		int IList.IndexOf(object value)
		{
			if (_genericCollection != null)
			{
				throw new InvalidOperationException("Wrapped ICollection<T> does not support IndexOf.");
			}
			if (IsCompatibleObject(value))
			{
				return _list.IndexOf((T)value);
			}
			return -1;
		}

		void IList.RemoveAt(int index)
		{
			if (_genericCollection != null)
			{
				throw new InvalidOperationException("Wrapped ICollection<T> does not support RemoveAt.");
			}
			_list.RemoveAt(index);
		}

		void IList.Insert(int index, object value)
		{
			if (_genericCollection != null)
			{
				throw new InvalidOperationException("Wrapped ICollection<T> does not support Insert.");
			}
			VerifyValueType(value);
			_list.Insert(index, (T)value);
		}

		void IList.Remove(object value)
		{
			if (IsCompatibleObject(value))
			{
				Remove((T)value);
			}
		}

		void ICollection.CopyTo(Array array, int arrayIndex)
		{
			CopyTo((T[])array, arrayIndex);
		}

		private static void VerifyValueType(object value)
		{
			if (!IsCompatibleObject(value))
			{
				throw new ArgumentException("The value '{0}' is not of type '{1}' and cannot be used in this generic collection.".FormatWith(CultureInfo.InvariantCulture, value, typeof(T)), "value");
			}
		}

		private static bool IsCompatibleObject(object value)
		{
			if (!(value is T) && (value != null || (typeof(T).IsValueType() && !ReflectionUtils.IsNullableType(typeof(T)))))
			{
				return false;
			}
			return true;
		}
	}
	internal enum PrimitiveTypeCode
	{
		Empty,
		Object,
		Char,
		CharNullable,
		Boolean,
		BooleanNullable,
		SByte,
		SByteNullable,
		Int16,
		Int16Nullable,
		UInt16,
		UInt16Nullable,
		Int32,
		Int32Nullable,
		Byte,
		ByteNullable,
		UInt32,
		UInt32Nullable,
		Int64,
		Int64Nullable,
		UInt64,
		UInt64Nullable,
		Single,
		SingleNullable,
		Double,
		DoubleNullable,
		DateTime,
		DateTimeNullable,
		DateTimeOffset,
		DateTimeOffsetNullable,
		Decimal,
		DecimalNullable,
		Guid,
		GuidNullable,
		TimeSpan,
		TimeSpanNullable,
		BigInteger,
		BigIntegerNullable,
		Uri,
		String,
		Bytes,
		DBNull
	}
	internal class TypeInformation
	{
		public Type Type { get; }

		public PrimitiveTypeCode TypeCode { get; }

		public TypeInformation(Type type, PrimitiveTypeCode typeCode)
		{
			Type = type;
			TypeCode = typeCode;
		}
	}
	internal enum ParseResult
	{
		None,
		Success,
		Overflow,
		Invalid
	}
	internal static class ConvertUtils
	{
		internal enum ConvertResult
		{
			Success,
			CannotConvertNull,
			NotInstantiableType,
			NoValidConversion
		}

		private static readonly Dictionary<Type, PrimitiveTypeCode> TypeCodeMap = new Dictionary<Type, PrimitiveTypeCode>
		{
			{
				typeof(char),
				PrimitiveTypeCode.Char
			},
			{
				typeof(char?),
				PrimitiveTypeCode.CharNullable
			},
			{
				typeof(bool),
				PrimitiveTypeCode.Boolean
			},
			{
				typeof(bool?),
				PrimitiveTypeCode.BooleanNullable
			},
			{
				typeof(sbyte),
				PrimitiveTypeCode.SByte
			},
			{
				typeof(sbyte?),
				PrimitiveTypeCode.SByteNullable
			},
			{
				typeof(short),
				PrimitiveTypeCode.Int16
			},
			{
				typeof(short?),
				PrimitiveTypeCode.Int16Nullable
			},
			{
				typeof(ushort),
				PrimitiveTypeCode.UInt16
			},
			{
				typeof(ushort?),
				PrimitiveTypeCode.UInt16Nullable
			},
			{
				typeof(int),
				PrimitiveTypeCode.Int32
			},
			{
				typeof(int?),
				PrimitiveTypeCode.Int32Nullable
			},
			{
				typeof(byte),
				PrimitiveTypeCode.Byte
			},
			{
				typeof(byte?),
				PrimitiveTypeCode.ByteNullable
			},
			{
				typeof(uint),
				PrimitiveTypeCode.UInt32
			},
			{
				typeof(uint?),
				PrimitiveTypeCode.UInt32Nullable
			},
			{
				typeof(long),
				PrimitiveTypeCode.Int64
			},
			{
				typeof(long?),
				PrimitiveTypeCode.Int64Nullable
			},
			{
				typeof(ulong),
				PrimitiveTypeCode.UInt64
			},
			{
				typeof(ulong?),
				PrimitiveTypeCode.UInt64Nullable
			},
			{
				typeof(float),
				PrimitiveTypeCode.Single
			},
			{
				typeof(float?),
				PrimitiveTypeCode.SingleNullable
			},
			{
				typeof(double),
				PrimitiveTypeCode.Double
			},
			{
				typeof(double?),
				PrimitiveTypeCode.DoubleNullable
			},
			{
				typeof(DateTime),
				PrimitiveTypeCode.DateTime
			},
			{
				typeof(DateTime?),
				PrimitiveTypeCode.DateTimeNullable
			},
			{
				typeof(DateTimeOffset),
				PrimitiveTypeCode.DateTimeOffset
			},
			{
				typeof(DateTimeOffset?),
				PrimitiveTypeCode.DateTimeOffsetNullable
			},
			{
				typeof(decimal),
				PrimitiveTypeCode.Decimal
			},
			{
				typeof(decimal?),
				PrimitiveTypeCode.DecimalNullable
			},
			{
				typeof(Guid),
				PrimitiveTypeCode.Guid
			},
			{
				typeof(Guid?),
				PrimitiveTypeCode.GuidNullable
			},
			{
				typeof(TimeSpan),
				PrimitiveTypeCode.TimeSpan
			},
			{
				typeof(TimeSpan?),
				PrimitiveTypeCode.TimeSpanNullable
			},
			{
				typeof(BigInteger),
				PrimitiveTypeCode.BigInteger
			},
			{
				typeof(BigInteger?),
				PrimitiveTypeCode.BigIntegerNullable
			},
			{
				typeof(Uri),
				PrimitiveTypeCode.Uri
			},
			{
				typeof(string),
				PrimitiveTypeCode.String
			},
			{
				typeof(byte[]),
				PrimitiveTypeCode.Bytes
			},
			{
				typeof(DBNull),
				PrimitiveTypeCode.DBNull
			}
		};

		private static readonly TypeInformation[] PrimitiveTypeCodes = new TypeInformation[19]
		{
			new TypeInformation(typeof(object), PrimitiveTypeCode.Empty),
			new TypeInformation(typeof(object), PrimitiveTypeCode.Object),
			new TypeInformation(typeof(object), PrimitiveTypeCode.DBNull),
			new TypeInformation(typeof(bool), PrimitiveTypeCode.Boolean),
			new TypeInformation(typeof(char), PrimitiveTypeCode.Char),
			new TypeInformation(typeof(sbyte), PrimitiveTypeCode.SByte),
			new TypeInformation(typeof(byte), PrimitiveTypeCode.Byte),
			new TypeInformation(typeof(short), PrimitiveTypeCode.Int16),
			new TypeInformation(typeof(ushort), PrimitiveTypeCode.UInt16),
			new TypeInformation(typeof(int), PrimitiveTypeCode.Int32),
			new TypeInformation(typeof(uint), PrimitiveTypeCode.UInt32),
			new TypeInformation(typeof(long), PrimitiveTypeCode.Int64),
			new TypeInformation(typeof(ulong), PrimitiveTypeCode.UInt64),
			new TypeInformation(typeof(float), PrimitiveTypeCode.Single),
			new TypeInformation(typeof(double), PrimitiveTypeCode.Double),
			new TypeInformation(typeof(decimal), PrimitiveTypeCode.Decimal),
			new TypeInformation(typeof(DateTime), PrimitiveTypeCode.DateTime),
			new TypeInformation(typeof(object), PrimitiveTypeCode.Empty),
			new TypeInformation(typeof(string), PrimitiveTypeCode.String)
		};

		private static readonly ThreadSafeStore<StructMultiKey<Type, Type>, Func<object?, object?>?> CastConverters = new ThreadSafeStore<StructMultiKey<Type, Type>, Func<object, object>>(CreateCastConverter);

		public static PrimitiveTypeCode GetTypeCode(Type t)
		{
			bool isEnum;
			return GetTypeCode(t, out isEnum);
		}

		public static PrimitiveTypeCode GetTypeCode(Type t, out bool isEnum)
		{
			if (TypeCodeMap.TryGetValue(t, out var value))
			{
				isEnum = false;
				return value;
			}
			if (t.IsEnum())
			{
				isEnum = true;
				return GetTypeCode(Enum.GetUnderlyingType(t));
			}
			if (ReflectionUtils.IsNullableType(t))
			{
				Type underlyingType = Nullable.GetUnderlyingType(t);
				if (underlyingType.IsEnum())
				{
					Type t2 = typeof(Nullable<>).MakeGenericType(Enum.GetUnderlyingType(underlyingType));
					isEnum = true;
					return GetTypeCode(t2);
				}
			}
			isEnum = false;
			return PrimitiveTypeCode.Object;
		}

		public static TypeInformation GetTypeInformation(IConvertible convertable)
		{
			return PrimitiveTypeCodes[(int)convertable.GetTypeCode()];
		}

		public static bool IsConvertible(Type t)
		{
			return typeof(IConvertible).IsAssignableFrom(t);
		}

		public static TimeSpan ParseTimeSpan(string input)
		{
			return TimeSpan.Parse(input, CultureInfo.InvariantCulture);
		}

		private static Func<object?, object?>? CreateCastConverter(StructMultiKey<Type, Type> t)
		{
			Type value = t.Value1;
			Type value2 = t.Value2;
			MethodInfo methodInfo = value2.GetMethod("op_Implicit", new Type[1] { value }) ?? value2.GetMethod("op_Explicit", new Type[1] { value });
			if (methodInfo == null)
			{
				return null;
			}
			MethodCall<object?, object?> call = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(methodInfo);
			return (object? o) => call(null, o);
		}

		internal static BigInteger ToBigInteger(object value)
		{
			if (value is BigInteger)
			{
				return (BigInteger)value;
			}
			if (value is string value2)
			{
				return BigInteger.Parse(value2, CultureInfo.InvariantCulture);
			}
			if (value is float value3)
			{
				return new BigInteger(value3);
			}
			if (value is double value4)
			{
				return new BigInteger(value4);
			}
			if (value is decimal value5)
			{
				return new BigInteger(value5);
			}
			if (value is int value6)
			{
				return new BigInteger(value6);
			}
			if (value is long value7)
			{
				return new BigInteger(value7);
			}
			if (value is uint value8)
			{
				return new BigInteger(value8);
			}
			if (value is ulong value9)
			{
				return new BigInteger(value9);
			}
			if (value is byte[] value10)
			{
				return new BigInteger(value10);
			}
			throw new InvalidCastException("Cannot convert {0} to BigInteger.".FormatWith(CultureInfo.InvariantCulture, value.GetType()));
		}

		public static object FromBigInteger(BigInteger i, Type targetType)
		{
			if (targetType == typeof(decimal))
			{
				return (decimal)i;
			}
			if (targetType == typeof(double))
			{
				return (double)i;
			}
			if (targetType == typeof(float))
			{
				return (float)i;
			}
			if (targetType == typeof(ulong))
			{
				return (ulong)i;
			}
			if (targetType == typeof(bool))
			{
				return i != 0L;
			}
			try
			{
				return System.Convert.ChangeType((long)i, targetType, CultureInfo.InvariantCulture);
			}
			catch (Exception innerException)
			{
				throw new InvalidOperationException("Can not convert from BigInteger to {0}.".FormatWith(CultureInfo.InvariantCulture, targetType), innerException);
			}
		}

		public static object Convert(object initialValue, CultureInfo culture, Type targetType)
		{
			object value;
			return TryConvertInternal(initialValue, culture, targetType, out value) switch
			{
				ConvertResult.Success => value, 
				ConvertResult.CannotConvertNull => throw new Exception("Can not convert null {0} into non-nullable {1}.".FormatWith(CultureInfo.InvariantCulture, initialValue.GetType(), targetType)), 
				ConvertResult.NotInstantiableType => throw new ArgumentException("Target type {0} is not a value type or a non-abstract class.".FormatWith(CultureInfo.InvariantCulture, targetType), "targetType"), 
				ConvertResult.NoValidConversion => throw new InvalidOperationException("Can not convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, initialValue.GetType(), targetType)), 
				_ => throw new InvalidOperationException("Unexpected conversion result."), 
			};
		}

		private static bool TryConvert(object? initialValue, CultureInfo culture, Type targetType, out object? value)
		{
			try
			{
				if (TryConvertInternal(initialValue, culture, targetType, out value) == ConvertResult.Success)
				{
					return true;
				}
				value = null;
				return false;
			}
			catch
			{
				value = null;
				return false;
			}
		}

		private static ConvertResult TryConvertInternal(object? initialValue, CultureInfo culture, Type targetType, out object? value)
		{
			if (initialValue == null)
			{
				throw new ArgumentNullException("initialValue");
			}
			if (ReflectionUtils.IsNullableType(targetType))
			{
				targetType = Nullable.GetUnderlyingType(targetType);
			}
			Type type = initialValue.GetType();
			if (targetType == type)
			{
				value = initialValue;
				return ConvertResult.Success;
			}
			if (IsConvertible(initialValue.GetType()) && IsConvertible(targetType))
			{
				if (targetType.IsEnum())
				{
					if (initialValue is string)
					{
						value = Enum.Parse(targetType, initialValue.ToString(), ignoreCase: true);
						return ConvertResult.Success;
					}
					if (IsInteger(initialValue))
					{
						value = Enum.ToObject(targetType, initialValue);
						return ConvertResult.Success;
					}
				}
				value = System.Convert.ChangeType(initialValue, targetType, culture);
				return ConvertResult.Success;
			}
			if (initialValue is DateTime dateTime && targetType == typeof(DateTimeOffset))
			{
				value = new DateTimeOffset(dateTime);
				return ConvertResult.Success;
			}
			if (initialValue is byte[] b && targetType == typeof(Guid))
			{
				value = new Guid(b);
				return ConvertResult.Success;
			}
			if (initialValue is Guid guid && targetType == typeof(byte[]))
			{
				value = guid.ToByteArray();
				return ConvertResult.Success;
			}
			if (initialValue is string text)
			{
				if (targetType == typeof(Guid))
				{
					value = new Guid(text);
					return ConvertResult.Success;
				}
				if (targetType == typeof(Uri))
				{
					value = new Uri(text, UriKind.RelativeOrAbsolute);
					return ConvertResult.Success;
				}
				if (targetType == typeof(TimeSpan))
				{
					value = ParseTimeSpan(text);
					return ConvertResult.Success;
				}
				if (targetType == typeof(byte[]))
				{
					value = System.Convert.FromBase64String(text);
					return ConvertResult.Success;
				}
				if (targetType == typeof(Version))
				{
					if (VersionTryParse(text, out Version result))
					{
						value = result;
						return ConvertResult.Success;
					}
					value = null;
					return ConvertResult.NoValidConversion;
				}
				if (typeof(Type).IsAssignableFrom(targetType))
				{
					value = Type.GetType(text, throwOnError: true);
					return ConvertResult.Success;
				}
			}
			if (targetType == typeof(BigInteger))
			{
				value = ToBigInteger(initialValue);
				return ConvertResult.Success;
			}
			if (initialValue is BigInteger i)
			{
				value = FromBigInteger(i, targetType);
				return ConvertResult.Success;
			}
			TypeConverter converter = TypeDescriptor.GetConverter(type);
			if (converter != null && converter.CanConvertTo(targetType))
			{
				value = converter.ConvertTo(null, culture, initialValue, targetType);
				return ConvertResult.Success;
			}
			TypeConverter converter2 = TypeDescriptor.GetConverter(targetType);
			if (converter2 != null && converter2.CanConvertFrom(type))
			{
				value = converter2.ConvertFrom(null, culture, initialValue);
				return ConvertResult.Success;
			}
			if (initialValue == DBNull.Value)
			{
				if (ReflectionUtils.IsNullable(targetType))
				{
					value = EnsureTypeAssignable(null, type, targetType);
					return ConvertResult.Success;
				}
				value = null;
				return ConvertResult.CannotConvertNull;
			}
			if (targetType.IsInterface() || targetType.IsGenericTypeDefinition() || targetType.IsAbstract())
			{
				value = null;
				return ConvertResult.NotInstantiableType;
			}
			value = null;
			return ConvertResult.NoValidConversion;
		}

		public static object? ConvertOrCast(object? initialValue, CultureInfo culture, Type targetType)
		{
			if (targetType == typeof(object))
			{
				return initialValue;
			}
			if (initialValue == null && ReflectionUtils.IsNullable(targetType))
			{
				return null;
			}
			if (TryConvert(initialValue, culture, targetType, out object value))
			{
				return value;
			}
			return EnsureTypeAssignable(initialValue, ReflectionUtils.GetObjectType(initialValue), targetType);
		}

		private static object? EnsureTypeAssignable(object? value, Type initialType, Type targetType)
		{
			if (value != null)
			{
				Type type = value.GetType();
				if (targetType.IsAssignableFrom(type))
				{
					return value;
				}
				Func<object, object> func = CastConverters.Get(new StructMultiKey<Type, Type>(type, targetType));
				if (func != null)
				{
					return func(value);
				}
			}
			else if (ReflectionUtils.IsNullable(targetType))
			{
				return null;
			}
			throw new ArgumentException("Could not cast or convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, initialType?.ToString() ?? "{null}", targetType));
		}

		public static bool VersionTryParse(string input, [NotNullWhen(true)] out Version? result)
		{
			return Version.TryParse(input, out result);
		}

		public static bool IsInteger(object value)
		{
			switch (GetTypeCode(value.GetType()))
			{
			case PrimitiveTypeCode.SByte:
			case PrimitiveTypeCode.Int16:
			case PrimitiveTypeCode.UInt16:
			case PrimitiveTypeCode.Int32:
			case PrimitiveTypeCode.Byte:
			case PrimitiveTypeCode.UInt32:
			case PrimitiveTypeCode.Int64:
			case PrimitiveTypeCode.UInt64:
				return true;
			default:
				return false;
			}
		}

		public static ParseResult Int32TryParse(char[] chars, int start, int length, out int value)
		{
			value = 0;
			if (length == 0)
			{
				return ParseResult.Invalid;
			}
			bool flag = chars[start] == '-';
			if (flag)
			{
				if (length == 1)
				{
					return ParseResult.Invalid;
				}
				start++;
				length--;
			}
			int num = start + length;
			if (length > 10 || (length == 10 && chars[start] - 48 > 2))
			{
				for (int i = start; i < num; i++)
				{
					int num2 = chars[i] - 48;
					if (num2 < 0 || num2 > 9)
					{
						return ParseResult.Invalid;
					}
				}
				return ParseResult.Overflow;
			}
			for (int j = start; j < num; j++)
			{
				int num3 = chars[j] - 48;
				if (num3 < 0 || num3 > 9)
				{
					return ParseResult.Invalid;
				}
				int num4 = 10 * value - num3;
				if (num4 > value)
				{
					for (j++; j < num; j++)
					{
						num3 = chars[j] - 48;
						if (num3 < 0 || num3 > 9)
						{
							return ParseResult.Invalid;
						}
					}
					return ParseResult.Overflow;
				}
				value = num4;
			}
			if (!flag)
			{
				if (value == int.MinValue)
				{
					return ParseResult.Overflow;
				}
				value = -value;
			}
			return ParseResult.Success;
		}

		public static ParseResult Int64TryParse(char[] chars, int start, int length, out long value)
		{
			value = 0L;
			if (length == 0)
			{
				return ParseResult.Invalid;
			}
			bool flag = chars[start] == '-';
			if (flag)
			{
				if (length == 1)
				{
					return ParseResult.Invalid;
				}
				start++;
				length--;
			}
			int num = start + length;
			if (length > 19)
			{
				for (int i = start; i < num; i++)
				{
					int num2 = chars[i] - 48;
					if (num2 < 0 || num2 > 9)
					{
						return ParseResult.Invalid;
					}
				}
				return ParseResult.Overflow;
			}
			for (int j = start; j < num; j++)
			{
				int num3 = chars[j] - 48;
				if (num3 < 0 || num3 > 9)
				{
					return ParseResult.Invalid;
				}
				long num4 = 10 * value - num3;
				if (num4 > value)
				{
					for (j++; j < num; j++)
					{
						num3 = chars[j] - 48;
						if (num3 < 0 || num3 > 9)
						{
							return ParseResult.Invalid;
						}
					}
					return ParseResult.Overflow;
				}
				value = num4;
			}
			if (!flag)
			{
				if (value == long.MinValue)
				{
					return ParseResult.Overflow;
				}
				value = -value;
			}
			return ParseResult.Success;
		}

		public static ParseResult DecimalTryParse(char[] chars, int start, int length, out decimal value)
		{
			value = default(decimal);
			if (length == 0)
			{
				return ParseResult.Invalid;
			}
			bool flag = chars[start] == '-';
			if (flag)
			{
				if (length == 1)
				{
					return ParseResult.Invalid;
				}
				start++;
				length--;
			}
			int i = start;
			int num = start + length;
			int num2 = num;
			int num3 = num;
			int num4 = 0;
			ulong num5 = 0uL;
			ulong num6 = 0uL;
			int num7 = 0;
			int num8 = 0;
			char? c = null;
			bool? flag2 = null;
			for (; i < num; i++)
			{
				char c2 = chars[i];
				if (c2 == '.')
				{
					goto IL_0074;
				}
				if (c2 == 'E' || c2 == 'e')
				{
					goto IL_0091;
				}
				if (c2 < '0' || c2 > '9')
				{
					return ParseResult.Invalid;
				}
				if (i == start && c2 == '0')
				{
					i++;
					if (i != num)
					{
						c2 = chars[i];
						if (c2 == '.')
						{
							goto IL_0074;
						}
						if (c2 != 'e' && c2 != 'E')
						{
							return ParseResult.Invalid;
						}
						goto IL_0091;
					}
				}
				if (num7 < 29)
				{
					if (num7 == 28)
					{
						bool? flag3 = flag2;
						bool valueOrDefault;
						if (!flag3.HasValue)
						{
							flag2 = num5 > 7922816251426433759L || (num5 == 7922816251426433759L && (num6 > 354395033 || (num6 == 354395033 && c2 > '5')));
							bool? flag4 = flag2;
							valueOrDefault = flag4 == true;
						}
						else
						{
							valueOrDefault = flag3 == true;
						}
						if (valueOrDefault)
						{
							goto IL_01ff;
						}
					}
					if (num7 < 19)
					{
						num5 = num5 * 10 + (ulong)(c2 - 48);
					}
					else
					{
						num6 = num6 * 10 + (ulong)(c2 - 48);
					}
					num7++;
					continue;
				}
				goto IL_01ff;
				IL_0074:
				if (i == start)
				{
					return ParseResult.Invalid;
				}
				if (i + 1 == num)
				{
					return ParseResult.Invalid;
				}
				if (num2 != num)
				{
					return ParseResult.Invalid;
				}
				num2 = i + 1;
				continue;
				IL_01ff:
				if (!c.HasValue)
				{
					c = c2;
				}
				num8++;
				continue;
				IL_0091:
				if (i == start)
				{
					return ParseResult.Invalid;
				}
				if (i == num2)
				{
					return ParseResult.Invalid;
				}
				i++;
				if (i == num)
				{
					return ParseResult.Invalid;
				}
				if (num2 < num)
				{
					num3 = i - 1;
				}
				c2 = chars[i];
				bool flag5 = false;
				switch (c2)
				{
				case '-':
					flag5 = true;
					i++;
					break;
				case '+':
					i++;
					break;
				}
				for (; i < num; i++)
				{
					c2 = chars[i];
					if (c2 < '0' || c2 > '9')
					{
						return ParseResult.Invalid;
					}
					int num9 = 10 * num4 + (c2 - 48);
					if (num4 < num9)
					{
						num4 = num9;
					}
				}
				if (flag5)
				{
					num4 = -num4;
				}
			}
			num4 += num8;
			num4 -= num3 - num2;
			if (num7 <= 19)
			{
				value = num5;
			}
			else
			{
				value = (decimal)num5 / new decimal(1, 0, 0, isNegative: false, (byte)(num7 - 19)) + (decimal)num6;
			}
			if (num4 > 0)
			{
				num7 += num4;
				if (num7 > 29)
				{
					return ParseResult.Overflow;
				}
				if (num7 == 29)
				{
					if (num4 > 1)
					{
						value /= new decimal(1, 0, 0, isNegative: false, (byte)(num4 - 1));
						if (value > 7922816251426433759354395033m)
						{
							return ParseResult.Overflow;
						}
					}
					else if (value == 7922816251426433759354395033m && c > '5')
					{
						return ParseResult.Overflow;
					}
					value *= 10m;
				}
				else
				{
					value /= new decimal(1, 0, 0, isNegative: false, (byte)num4);
				}
			}
			else
			{
				if (c >= '5' && num4 >= -28)
				{
					++value;
				}
				if (num4 < 0)
				{
					if (num7 + num4 + 28 <= 0)
					{
						value = (flag ? 0m : 0m);
						return ParseResult.Success;
					}
					if (num4 >= -28)
					{
						value *= new decimal(1, 0, 0, isNegative: false, (byte)(-num4));
					}
					else
					{
						value /= 10000000000000000000000000000m;
						value *= new decimal(1, 0, 0, isNegative: false, (byte)(-num4 - 28));
					}
				}
			}
			if (flag)
			{
				value = -value;
			}
			return ParseResult.Success;
		}

		public static bool TryConvertGuid(string s, out Guid g)
		{
			return Guid.TryParseExact(s, "D", out g);
		}

		public static bool TryHexTextToInt(char[] text, int start, int end, out int value)
		{
			value = 0;
			for (int i = start; i < end; i++)
			{
				char c = text[i];
				int num;
				if (c <= '9' && c >= '0')
				{
					num = c - 48;
				}
				else if (c <= 'F' && c >= 'A')
				{
					num = c - 55;
				}
				else
				{
					if (c > 'f' || c < 'a')
					{
						value = 0;
						return false;
					}
					num = c - 87;
				}
				value += num << (end - 1 - i) * 4;
			}
			return true;
		}
	}
	internal enum ParserTimeZone
	{
		Unspecified,
		Utc,
		LocalWestOfUtc,
		LocalEastOfUtc
	}
	internal struct DateTimeParser
	{
		public int Year;

		public int Month;

		public int Day;

		public int Hour;

		public int Minute;

		public int Second;

		public int Fraction;

		public int ZoneHour;

		public int ZoneMinute;

		public ParserTimeZone Zone;

		private char[] _text;

		private int _end;

		private static readonly int[] Power10;

		private static readonly int Lzyyyy;

		private static readonly int Lzyyyy_;

		private static readonly int Lzyyyy_MM;

		private static readonly int Lzyyyy_MM_;

		private static readonly int Lzyyyy_MM_dd;

		private static readonly int Lzyyyy_MM_ddT;

		private static readonly int LzHH;

		private static readonly int LzHH_;

		private static readonly int LzHH_mm;

		private static readonly int LzHH_mm_;

		private static readonly int LzHH_mm_ss;

		private static readonly int Lz_;

		private static readonly int Lz_zz;

		private const short MaxFractionDigits = 7;

		static DateTimeParser()
		{
			Power10 = new int[7] { -1, 10, 100, 1000, 10000, 100000, 1000000 };
			Lzyyyy = "yyyy".Length;
			Lzyyyy_ = "yyyy-".Length;
			Lzyyyy_MM = "yyyy-MM".Length;
			Lzyyyy_MM_ = "yyyy-MM-".Length;
			Lzyyyy_MM_dd = "yyyy-MM-dd".Length;
			Lzyyyy_MM_ddT = "yyyy-MM-ddT".Length;
			LzHH = "HH".Length;
			LzHH_ = "HH:".Length;
			LzHH_mm = "HH:mm".Length;
			LzHH_mm_ = "HH:mm:".Length;
			LzHH_mm_ss = "HH:mm:ss".Length;
			Lz_ = "-".Length;
			Lz_zz = "-zz".Length;
		}

		public bool Parse(char[] text, int startIndex, int length)
		{
			_text = text;
			_end = startIndex + length;
			if (ParseDate(startIndex) && ParseChar(Lzyyyy_MM_dd + startIndex, 'T') && ParseTimeAndZoneAndWhitespace(Lzyyyy_MM_ddT + startIndex))
			{
				return true;
			}
			return false;
		}

		private bool ParseDate(int start)
		{
			if (Parse4Digit(start, out Year) && 1 <= Year && ParseChar(start + Lzyyyy, '-') && Parse2Digit(start + Lzyyyy_, out Month) && 1 <= Month && Month <= 12 && ParseChar(start + Lzyyyy_MM, '-') && Parse2Digit(start + Lzyyyy_MM_, out Day) && 1 <= Day)
			{
				return Day <= DateTime.DaysInMonth(Year, Month);
			}
			return false;
		}

		private bool ParseTimeAndZoneAndWhitespace(int start)
		{
			if (ParseTime(ref start))
			{
				return ParseZone(start);
			}
			return false;
		}

		private bool ParseTime(ref int start)
		{
			if (!Parse2Digit(start, out Hour) || Hour > 24 || !ParseChar(start + LzHH, ':') || !Parse2Digit(start + LzHH_, out Minute) || Minute >= 60 || !ParseChar(start + LzHH_mm, ':') || !Parse2Digit(start + LzHH_mm_, out Second) || Second >= 60 || (Hour == 24 && (Minute != 0 || Second != 0)))
			{
				return false;
			}
			start += LzHH_mm_ss;
			if (ParseChar(start, '.'))
			{
				Fraction = 0;
				int num = 0;
				while (++start < _end && num < 7)
				{
					int num2 = _text[start] - 48;
					if (num2 < 0 || num2 > 9)
					{
						break;
					}
					Fraction = Fraction * 10 + num2;
					num++;
				}
				if (num < 7)
				{
					if (num == 0)
					{
						return false;
					}
					Fraction *= Power10[7 - num];
				}
				if (Hour == 24 && Fraction != 0)
				{
					return false;
				}
			}
			return true;
		}

		private bool ParseZone(int start)
		{
			if (start < _end)
			{
				char c = _text[start];
				if (c == 'Z' || c == 'z')
				{
					Zone = ParserTimeZone.Utc;
					start++;
				}
				else
				{
					if (start + 2 < _end && Parse2Digit(start + Lz_, out ZoneHour) && ZoneHour <= 99)
					{
						switch (c)
						{
						case '-':
							Zone = ParserTimeZone.LocalWestOfUtc;
							start += Lz_zz;
							break;
						case '+':
							Zone = ParserTimeZone.LocalEastOfUtc;
							start += Lz_zz;
							break;
						}
					}
					if (start < _end)
					{
						if (ParseChar(start, ':'))
						{
							start++;
							if (start + 1 < _end && Parse2Digit(start, out ZoneMinute) && ZoneMinute <= 99)
							{
								start += 2;
							}
						}
						else if (start + 1 < _end && Parse2Digit(start, out ZoneMinute) && ZoneMinute <= 99)
						{
							start += 2;
						}
					}
				}
			}
			return start == _end;
		}

		private bool Parse4Digit(int start, out int num)
		{
			if (start + 3 < _end)
			{
				int num2 = _text[start] - 48;
				int num3 = _text[start + 1] - 48;
				int num4 = _text[start + 2] - 48;
				int num5 = _text[start + 3] - 48;
				if (0 <= num2 && num2 < 10 && 0 <= num3 && num3 < 10 && 0 <= num4 && num4 < 10 && 0 <= num5 && num5 < 10)
				{
					num = ((num2 * 10 + num3) * 10 + num4) * 10 + num5;
					return true;
				}
			}
			num = 0;
			return false;
		}

		private bool Parse2Digit(int start, out int num)
		{
			if (start + 1 < _end)
			{
				int num2 = _text[start] - 48;
				int num3 = _text[start + 1] - 48;
				if (0 <= num2 && num2 < 10 && 0 <= num3 && num3 < 10)
				{
					num = num2 * 10 + num3;
					return true;
				}
			}
			num = 0;
			return false;
		}

		private bool ParseChar(int start, char ch)
		{
			if (start < _end)
			{
				return _text[start] == ch;
			}
			return false;
		}
	}
	internal static class DateTimeUtils
	{
		internal static readonly long InitialJavaScriptDateTicks;

		private const string IsoDateFormat = "yyyy-MM-ddTHH:mm:ss.FFFFFFFK";

		private const int DaysPer100Years = 36524;

		private const int DaysPer400Years = 146097;

		private const int DaysPer4Years = 1461;

		private const int DaysPerYear = 365;

		private const long TicksPerDay = 864000000000L;

		private static readonly int[] DaysToMonth365;

		private static readonly int[] DaysToMonth366;

		static DateTimeUtils()
		{
			InitialJavaScriptDateTicks = 621355968000000000L;
			DaysToMonth365 = new int[13]
			{
				0, 31, 59, 90, 120, 151, 181, 212, 243, 273,
				304, 334, 365
			};
			DaysToMonth366 = new int[13]
			{
				0, 31, 60, 91, 121, 152, 182, 213, 244, 274,
				305, 335, 366
			};
		}

		public static TimeSpan GetUtcOffset(this DateTime d)
		{
			return TimeZoneInfo.Local.GetUtcOffset(d);
		}

		public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind)
		{
			return kind switch
			{
				DateTimeKind.Local => XmlDateTimeSerializationMode.Local, 
				DateTimeKind.Unspecified => XmlDateTimeSerializationMode.Unspecified, 
				DateTimeKind.Utc => XmlDateTimeSerializationMode.Utc, 
				_ => throw MiscellaneousUtils.CreateArgumentOutOfRangeException("kind", kind, "Unexpected DateTimeKind value."), 
			};
		}

		internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone)
		{
			switch (timeZone)
			{
			case DateTimeZoneHandling.Local:
				value = SwitchToLocalTime(value);
				break;
			case DateTimeZoneHandling.Utc:
				value = SwitchToUtcTime(value);
				break;
			case DateTimeZoneHandling.Unspecified:
				value = new DateTime(value.Ticks, DateTimeKind.Unspecified);
				break;
			default:
				throw new ArgumentException("Invalid date time handling value.");
			case DateTimeZoneHandling.RoundtripKind:
				break;
			}
			return value;
		}

		private static DateTime SwitchToLocalTime(DateTime value)
		{
			return value.Kind switch
			{
				DateTimeKind.Unspecified => new DateTime(value.Ticks, DateTimeKind.Local), 
				DateTimeKind.Utc => value.ToLocalTime(), 
				DateTimeKind.Local => value, 
				_ => value, 
			};
		}

		private static DateTime SwitchToUtcTime(DateTime value)
		{
			return value.Kind switch
			{
				DateTimeKind.Unspecified => new DateTime(value.Ticks, DateTimeKind.Utc), 
				DateTimeKind.Utc => value, 
				DateTimeKind.Local => value.ToUniversalTime(), 
				_ => value, 
			};
		}

		private static long ToUniversalTicks(DateTime dateTime)
		{
			if (dateTime.Kind == DateTimeKind.Utc)
			{
				return dateTime.Ticks;
			}
			return ToUniversalTicks(dateTime, dateTime.GetUtcOffset());
		}

		private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset)
		{
			if (dateTime.Kind == DateTimeKind.Utc || dateTime == DateTime.MaxValue || dateTime == DateTime.MinValue)
			{
				return dateTime.Ticks;
			}
			long num = dateTime.Ticks - offset.Ticks;
			if (num > 3155378975999999999L)
			{
				return 3155378975999999999L;
			}
			if (num < 0)
			{
				return 0L;
			}
			return num;
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset)
		{
			return UniversalTicksToJavaScriptTicks(ToUniversalTicks(dateTime, offset));
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime)
		{
			return ConvertDateTimeToJavaScriptTicks(dateTime, convertToUtc: true);
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc)
		{
			return UniversalTicksToJavaScriptTicks(convertToUtc ? ToUniversalTicks(dateTime) : dateTime.Ticks);
		}

		private static long UniversalTicksToJavaScriptTicks(long universalTicks)
		{
			return (universalTicks - InitialJavaScriptDateTicks) / 10000;
		}

		internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks)
		{
			return new DateTime(javaScriptTicks * 10000 + InitialJavaScriptDateTicks, DateTimeKind.Utc);
		}

		internal static bool TryParseDateTimeIso(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, out DateTime dt)
		{
			DateTimeParser dateTimeParser = default(DateTimeParser);
			if (!dateTimeParser.Parse(text.Chars, text.StartIndex, text.Length))
			{
				dt = default(DateTime);
				return false;
			}
			DateTime dateTime = CreateDateTime(dateTimeParser);
			switch (dateTimeParser.Zone)
			{
			case ParserTimeZone.Utc:
				dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Utc);
				break;
			case ParserTimeZone.LocalWestOfUtc:
			{
				TimeSpan timeSpan2 = new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0);
				long num = dateTime.Ticks + timeSpan2.Ticks;
				long num4 = num;
				DateTime minValue = DateTime.MaxValue;
				if (num4 <= minValue.Ticks)
				{
					dateTime = new DateTime(num, DateTimeKind.Utc).ToLocalTime();
					break;
				}
				num += dateTime.GetUtcOffset().Ticks;
				long num5 = num;
				minValue = DateTime.MaxValue;
				if (num5 > minValue.Ticks)
				{
					minValue = DateTime.MaxValue;
					num = minValue.Ticks;
				}
				dateTime = new DateTime(num, DateTimeKind.Local);
				break;
			}
			case ParserTimeZone.LocalEastOfUtc:
			{
				TimeSpan timeSpan = new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0);
				long num = dateTime.Ticks - timeSpan.Ticks;
				long num2 = num;
				DateTime minValue = DateTime.MinValue;
				if (num2 >= minValue.Ticks)
				{
					dateTime = new DateTime(num, DateTimeKind.Utc).ToLocalTime();
					break;
				}
				num += dateTime.GetUtcOffset().Ticks;
				long num3 = num;
				minValue = DateTime.MinValue;
				if (num3 < minValue.Ticks)
				{
					minValue = DateTime.MinValue;
					num = minValue.Ticks;
				}
				dateTime = new DateTime(num, DateTimeKind.Local);
				break;
			}
			}
			dt = EnsureDateTime(dateTime, dateTimeZoneHandling);
			return true;
		}

		internal static bool TryParseDateTimeOffsetIso(StringReference text, out DateTimeOffset dt)
		{
			DateTimeParser dateTimeParser = default(DateTimeParser);
			if (!dateTimeParser.Parse(text.Chars, text.StartIndex, text.Length))
			{
				dt = default(DateTimeOffset);
				return false;
			}
			DateTime dateTime = CreateDateTime(dateTimeParser);
			TimeSpan offset = dateTimeParser.Zone switch
			{
				ParserTimeZone.Utc => new TimeSpan(0L), 
				ParserTimeZone.LocalWestOfUtc => new TimeSpan(-dateTimeParser.ZoneHour, -dateTimeParser.ZoneMinute, 0), 
				ParserTimeZone.LocalEastOfUtc => new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0), 
				_ => TimeZoneInfo.Local.GetUtcOffset(dateTime), 
			};
			long num = dateTime.Ticks - offset.Ticks;
			if (num < 0 || num > 3155378975999999999L)
			{
				dt = default(DateTimeOffset);
				return false;
			}
			dt = new DateTimeOffset(dateTime, offset);
			return true;
		}

		private static DateTime CreateDateTime(DateTimeParser dateTimeParser)
		{
			bool flag;
			if (dateTimeParser.Hour == 24)
			{
				flag = true;
				dateTimeParser.Hour = 0;
			}
			else
			{
				flag = false;
			}
			DateTime result = new DateTime(dateTimeParser.Year, dateTimeParser.Month, dateTimeParser.Day, dateTimeParser.Hour, dateTimeParser.Minute, dateTimeParser.Second).AddTicks(dateTimeParser.Fraction);
			if (flag)
			{
				result = result.AddDays(1.0);
			}
			return result;
		}

		internal static bool TryParseDateTime(StringReference s, DateTimeZoneHandling dateTimeZoneHandling, string? dateFormatString, CultureInfo culture, out DateTime dt)
		{
			if (s.Length > 0)
			{
				int startIndex = s.StartIndex;
				if (s[startIndex] == '/')
				{
					if (s.Length >= 9 && s.StartsWith("/Date(") && s.EndsWith(")/") && TryParseDateTimeMicrosoft(s, dateTimeZoneHandling, out dt))
					{
						return true;
					}
				}
				else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[startIndex]) && s[startIndex + 10] == 'T' && TryParseDateTimeIso(s, dateTimeZoneHandling, out dt))
				{
					return true;
				}
				if (!StringUtils.IsNullOrEmpty(dateFormatString) && TryParseDateTimeExact(s.ToString(), dateTimeZoneHandling, dateFormatString, culture, out dt))
				{
					return true;
				}
			}
			dt = default(DateTime);
			return false;
		}

		internal static bool TryParseDateTime(string s, DateTimeZoneHandling dateTimeZoneHandling, string? dateFormatString, CultureInfo culture, out DateTime dt)
		{
			if (s.Length > 0)
			{
				if (s[0] == '/')
				{
					if (s.Length >= 9 && s.StartsWith("/Date(", StringComparison.Ordinal) && s.EndsWith(")/", StringComparison.Ordinal) && TryParseDateTimeMicrosoft(new StringReference(s.ToCharArray(), 0, s.Length), dateTimeZoneHandling, out dt))
					{
						return true;
					}
				}
				else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[0]) && s[10] == 'T' && DateTime.TryParseExact(s, "yyyy-MM-ddTHH:mm:ss.FFFFFFFK", CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out dt))
				{
					dt = EnsureDateTime(dt, dateTimeZoneHandling);
					return true;
				}
				if (!StringUtils.IsNullOrEmpty(dateFormatString) && TryParseDateTimeExact(s, dateTimeZoneHandling, dateFormatString, culture, out dt))
				{
					return true;
				}
			}
			dt = default(DateTime);
			return false;
		}

		internal static bool TryParseDateTimeOffset(StringReference s, string? dateFormatString, CultureInfo culture, out DateTimeOffset dt)
		{
			if (s.Length > 0)
			{
				int startIndex = s.StartIndex;
				if (s[startIndex] == '/')
				{
					if (s.Length >= 9 && s.StartsWith("/Date(") && s.EndsWith(")/") && TryParseDateTimeOffsetMicrosoft(s, out dt))
					{
						return true;
					}
				}
				else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[startIndex]) && s[startIndex + 10] == 'T' && TryParseDateTimeOffsetIso(s, out dt))
				{
					return true;
				}
				if (!StringUtils.IsNullOrEmpty(dateFormatString) && TryParseDateTimeOffsetExact(s.ToString(), dateFormatString, culture, out dt))
				{
					return true;
				}
			}
			dt = default(DateTimeOffset);
			return false;
		}

		internal static bool TryParseDateTimeOffset(string s, string? dateFormatString, CultureInfo culture, out DateTimeOffset dt)
		{
			if (s.Length > 0)
			{
				if (s[0] == '/')
				{
					if (s.Length >= 9 && s.StartsWith("/Date(", StringComparison.Ordinal) && s.EndsWith(")/", StringComparison.Ordinal) && TryParseDateTimeOffsetMicrosoft(new StringReference(s.ToCharArray(), 0, s.Length), out dt))
					{
						return true;
					}
				}
				else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[0]) && s[10] == 'T' && DateTimeOffset.TryParseExact(s, "yyyy-MM-ddTHH:mm:ss.FFFFFFFK", CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out dt) && TryParseDateTimeOffsetIso(new StringReference(s.ToCharArray(), 0, s.Length), out dt))
				{
					return true;
				}
				if (!StringUtils.IsNullOrEmpty(dateFormatString) && TryParseDateTimeOffsetExact(s, dateFormatString, culture, out dt))
				{
					return true;
				}
			}
			dt = default(DateTimeOffset);
			return false;
		}

		private static bool TryParseMicrosoftDate(StringReference text, out long ticks, out TimeSpan offset, out DateTimeKind kind)
		{
			kind = DateTimeKind.Utc;
			int num = text.IndexOf('+', 7, text.Length - 8);
			if (num == -1)
			{
				num = text.IndexOf('-', 7, text.Length - 8);
			}
			if (num != -1)
			{
				kind = DateTimeKind.Local;
				if (!TryReadOffset(text, num + text.StartIndex, out offset))
				{
					ticks = 0L;
					return false;
				}
			}
			else
			{
				offset = TimeSpan.Zero;
				num = text.Length - 2;
			}
			return ConvertUtils.Int64TryParse(text.Chars, 6 + text.StartIndex, num - 6, out ticks) == ParseResult.Success;
		}

		private static bool TryParseDateTimeMicrosoft(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, out DateTime dt)
		{
			if (!TryParseMicrosoftDate(text, out var ticks, out var _, out var kind))
			{
				dt = default(DateTime);
				return false;
			}
			DateTime dateTime = ConvertJavaScriptTicksToDateTime(ticks);
			switch (kind)
			{
			case DateTimeKind.Unspecified:
				dt = DateTime.SpecifyKind(dateTime.ToLocalTime(), DateTimeKind.Unspecified);
				break;
			case DateTimeKind.Local:
				dt = dateTime.ToLocalTime();
				break;
			default:
				dt = dateTime;
				break;
			}
			dt = EnsureDateTime(dt, dateTimeZoneHandling);
			return true;
		}

		private static bool TryParseDateTimeExact(string text, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, out DateTime dt)
		{
			if (DateTime.TryParseExact(text, dateFormatString, culture, DateTimeStyles.RoundtripKind, out var result))
			{
				result = EnsureDateTime(result, dateTimeZoneHandling);
				dt = result;
				return true;
			}
			dt = default(DateTime);
			return false;
		}

		private static bool TryParseDateTimeOffsetMicrosoft(StringReference text, out DateTimeOffset dt)
		{
			if (!TryParseMicrosoftDate(text, out var ticks, out var offset, out var _))
			{
				dt = default(DateTime);
				return false;
			}
			dt = new DateTimeOffset(ConvertJavaScriptTicksToDateTime(ticks).Add(offset).Ticks, offset);
			return true;
		}

		private static bool TryParseDateTimeOffsetExact(string text, string dateFormatString, CultureInfo culture, out DateTimeOffset dt)
		{
			if (DateTimeOffset.TryParseExact(text, dateFormatString, culture, DateTimeStyles.RoundtripKind, out var result))
			{
				dt = result;
				return true;
			}
			dt = default(DateTimeOffset);
			return false;
		}

		private static bool TryReadOffset(StringReference offsetText, int startIndex, out TimeSpan offset)
		{
			bool flag = offsetText[startIndex] == '-';
			if (ConvertUtils.Int32TryParse(offsetText.Chars, startIndex + 1, 2, out var value) != ParseResult.Success)
			{
				offset = default(TimeSpan);
				return false;
			}
			int value2 = 0;
			if (offsetText.Length - startIndex > 5 && ConvertUtils.Int32TryParse(offsetText.Chars, startIndex + 3, 2, out value2) != ParseResult.Success)
			{
				offset = default(TimeSpan);
				return false;
			}
			offset = TimeSpan.FromHours(value) + TimeSpan.FromMinutes(value2);
			if (flag)
			{
				offset = offset.Negate();
			}
			return true;
		}

		internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string? formatString, CultureInfo culture)
		{
			if (StringUtils.IsNullOrEmpty(formatString))
			{
				char[] array = new char[64];
				int count = WriteDateTimeString(array, 0, value, null, value.Kind, format);
				writer.Write(array, 0, count);
			}
			else
			{
				writer.Write(value.ToString(formatString, culture));
			}
		}

		internal static int WriteDateTimeString(char[] chars, int start, DateTime value, TimeSpan? offset, DateTimeKind kind, DateFormatHandling format)
		{
			int num = start;
			if (format == DateFormatHandling.MicrosoftDateFormat)
			{
				TimeSpan offset2 = offset ?? value.GetUtcOffset();
				long num2 = ConvertDateTimeToJavaScriptTicks(value, offset2);
				"\\/Date(".CopyTo(0, chars, num, 7);
				num += 7;
				string text = num2.ToString(CultureInfo.InvariantCulture);
				text.CopyTo(0, chars, num, text.Length);
				num += text.Length;
				switch (kind)
				{
				case DateTimeKind.Unspecified:
					if (value != DateTime.MaxValue && value != DateTime.MinValue)
					{
						num = WriteDateTimeOffset(chars, num, offset2, format);
					}
					break;
				case DateTimeKind.Local:
					num = WriteDateTimeOffset(chars, num, offset2, format);
					break;
				}
				")\\/".CopyTo(0, chars, num, 3);
				num += 3;
			}
			else
			{
				num = WriteDefaultIsoDate(chars, num, value);
				switch (kind)
				{
				case DateTimeKind.Local:
					num = WriteDateTimeOffset(chars, num, offset ?? value.GetUtcOffset(), format);
					break;
				case DateTimeKind.Utc:
					chars[num++] = 'Z';
					break;
				}
			}
			return num;
		}

		internal static int WriteDefaultIsoDate(char[] chars, int start, DateTime dt)
		{
			int num = 19;
			GetDateValues(dt, out var year, out var month, out var day);
			CopyIntToCharArray(chars, start, year, 4);
			chars[start + 4] = '-';
			CopyIntToCharArray(chars, start + 5, month, 2);
			chars[start + 7] = '-';
			CopyIntToCharArray(chars, start + 8, day, 2);
			chars[start + 10] = 'T';
			CopyIntToCharArray(chars, start + 11, dt.Hour, 2);
			chars[start + 13] = ':';
			CopyIntToCharArray(chars, start + 14, dt.Minute, 2);
			chars[start + 16] = ':';
			CopyIntToCharArray(chars, start + 17, dt.Second, 2);
			int num2 = (int)(dt.Ticks % 10000000);
			if (num2 != 0)
			{
				int num3 = 7;
				while (num2 % 10 == 0)
				{
					num3--;
					num2 /= 10;
				}
				chars[start + 19] = '.';
				CopyIntToCharArray(chars, start + 20, num2, num3);
				num += num3 + 1;
			}
			return start + num;
		}

		private static void CopyIntToCharArray(char[] chars, int start, int value, int digits)
		{
			while (digits-- != 0)
			{
				chars[start + digits] = (char)(value % 10 + 48);
				value /= 10;
			}
		}

		internal static int WriteDateTimeOffset(char[] chars, int start, TimeSpan offset, DateFormatHandling format)
		{
			chars[start++] = ((offset.Ticks >= 0) ? '+' : '-');
			int value = Math.Abs(offset.Hours);
			CopyIntToCharArray(chars, start, value, 2);
			start += 2;
			if (format == DateFormatHandling.IsoDateFormat)
			{
				chars[start++] = ':';
			}
			int value2 = Math.Abs(offset.Minutes);
			CopyIntToCharArray(chars, start, value2, 2);
			start += 2;
			return start;
		}

		internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string? formatString, CultureInfo culture)
		{
			if (StringUtils.IsNullOrEmpty(formatString))
			{
				char[] array = new char[64];
				int count = WriteDateTimeString(array, 0, (format == DateFormatHandling.IsoDateFormat) ? value.DateTime : value.UtcDateTime, value.Offset, DateTimeKind.Local, format);
				writer.Write(array, 0, count);
			}
			else
			{
				writer.Write(value.ToString(formatString, culture));
			}
		}

		private static void GetDateValues(DateTime td, out int year, out int month, out int day)
		{
			int num = (int)(td.Ticks / 864000000000L);
			int num2 = num / 146097;
			num -= num2 * 146097;
			int num3 = num / 36524;
			if (num3 == 4)
			{
				num3 = 3;
			}
			num -= num3 * 36524;
			int num4 = num / 1461;
			num -= num4 * 1461;
			int num5 = num / 365;
			if (num5 == 4)
			{
				num5 = 3;
			}
			year = num2 * 400 + num3 * 100 + num4 * 4 + num5 + 1;
			num -= num5 * 365;
			int[] array = ((num5 == 3 && (num4 != 24 || num3 == 3)) ? DaysToMonth366 : DaysToMonth365);
			int i;
			for (i = num >> 6; num >= array[i]; i++)
			{
			}
			month = i;
			day = num - array[i - 1] + 1;
		}
	}
	internal interface IWrappedDictionary : IDictionary, ICollection, IEnumerable
	{
		object UnderlyingDictionary { get; }
	}
	internal class DictionaryWrapper<TKey, TValue> : IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IWrappedDictionary, IDictionary, ICollection
	{
		private readonly struct DictionaryEnumerator<TEnumeratorKey, TEnumeratorValue> : IDictionaryEnumerator, IEnumerator
		{
			private readonly IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

			public DictionaryEntry Entry => (DictionaryEntry)Current;

			public object Key => Entry.Key;

			public object Value => Entry.Value;

			public object Current => new DictionaryEntry(_e.Current.Key, _e.Current.Value);

			public DictionaryEnumerator(IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
			{
				ValidationUtils.ArgumentNotNull(e, "e");
				_e = e;
			}

			public bool MoveNext()
			{
				return _e.MoveNext();
			}

			public void Reset()
			{
				_e.Reset();
			}
		}

		private readonly IDictionary? _dictionary;

		private readonly IDictionary<TKey, TValue>? _genericDictionary;

		private readonly IReadOnlyDictionary<TKey, TValue>? _readOnlyDictionary;

		private object? _syncRoot;

		internal IDictionary<TKey, TValue> GenericDictionary => _genericDictionary;

		public ICollection<TKey> Keys
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.Keys.Cast<TKey>().ToList();
				}
				if (_readOnlyDictionary != null)
				{
					return _readOnlyDictionary.Keys.ToList();
				}
				return GenericDictionary.Keys;
			}
		}

		public ICollection<TValue> Values
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.Values.Cast<TValue>().ToList();
				}
				if (_readOnlyDictionary != null)
				{
					return _readOnlyDictionary.Values.ToList();
				}
				return GenericDictionary.Values;
			}
		}

		public TValue this[TKey key]
		{
			get
			{
				if (_dictionary != null)
				{
					return (TValue)_dictionary[key];
				}
				if (_readOnlyDictionary != null)
				{
					return _readOnlyDictionary[key];
				}
				return GenericDictionary[key];
			}
			set
			{
				if (_dictionary != null)
				{
					_dictionary[key] = value;
					return;
				}
				if (_readOnlyDictionary != null)
				{
					throw new NotSupportedException();
				}
				GenericDictionary[key] = value;
			}
		}

		public int Count
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.Count;
				}
				if (_readOnlyDictionary != null)
				{
					return _readOnlyDictionary.Count;
				}
				return GenericDictionary.Count;
			}
		}

		public bool IsReadOnly
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.IsReadOnly;
				}
				if (_readOnlyDictionary != null)
				{
					return true;
				}
				return GenericDictionary.IsReadOnly;
			}
		}

		object? IDictionary.this[object key]
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary[key];
				}
				if (_readOnlyDictionary != null)
				{
					return _readOnlyDictionary[(TKey)key];
				}
				return GenericDictionary[(TKey)key];
			}
			set
			{
				if (_dictionary != null)
				{
					_dictionary[key] = value;
					return;
				}
				if (_readOnlyDictionary != null)
				{
					throw new NotSupportedException();
				}
				GenericDictionary[(TKey)key] = (TValue)value;
			}
		}

		bool IDictionary.IsFixedSize
		{
			get
			{
				if (_genericDictionary != null)
				{
					return false;
				}
				if (_readOnlyDictionary != null)
				{
					return true;
				}
				return _dictionary.IsFixedSize;
			}
		}

		ICollection IDictionary.Keys
		{
			get
			{
				if (_genericDictionary != null)
				{
					return _genericDictionary.Keys.ToList();
				}
				if (_readOnlyDictionary != null)
				{
					return _readOnlyDictionary.Keys.ToList();
				}
				return _dictionary.Keys;
			}
		}

		ICollection IDictionary.Values
		{
			get
			{
				if (_genericDictionary != null)
				{
					return _genericDictionary.Values.ToList();
				}
				if (_readOnlyDictionary != null)
				{
					return _readOnlyDictionary.Values.ToList();
				}
				return _dictionary.Values;
			}
		}

		bool ICollection.IsSynchronized
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.IsSynchronized;
				}
				return false;
			}
		}

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		public object UnderlyingDictionary
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary;
				}
				if (_readOnlyDictionary != null)
				{
					return _readOnlyDictionary;
				}
				return GenericDictionary;
			}
		}

		public DictionaryWrapper(IDictionary dictionary)
		{
			ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
			_dictionary = dictionary;
		}

		public DictionaryWrapper(IDictionary<TKey, TValue> dictionary)
		{
			ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
			_genericDictionary = dictionary;
		}

		public DictionaryWrapper(IReadOnlyDictionary<TKey, TValue> dictionary)
		{
			ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
			_readOnlyDictionary = dictionary;
		}

		public void Add(TKey key, TValue value)
		{
			if (_dictionary != null)
			{
				_dictionary.Add(key, value);
				return;
			}
			if (_genericDictionary != null)
			{
				_genericDictionary.Add(key, value);
				return;
			}
			throw new NotSupportedException();
		}

		public bool ContainsKey(TKey key)
		{
			if (_dictionary != null)
			{
				return _dictionary.Contains(key);
			}
			if (_readOnlyDictionary != null)
			{
				return _readOnlyDictionary.ContainsKey(key);
			}
			return GenericDictionary.ContainsKey(key);
		}

		public bool Remove(TKey key)
		{
			if (_dictionary != null)
			{
				if (_dictionary.Contains(key))
				{
					_dictionary.Remove(key);
					return true;
				}
				return false;
			}
			if (_readOnlyDictionary != null)
			{
				throw new NotSupportedException();
			}
			return GenericDictionary.Remove(key);
		}

		public bool TryGetValue(TKey key, out TValue? value)
		{
			if (_dictionary != null)
			{
				if (!_dictionary.Contains(key))
				{
					value = default(TValue);
					return false;
				}
				value = (TValue)_dictionary[key];
				return true;
			}
			if (_readOnlyDictionary != null)
			{
				throw new NotSupportedException();
			}
			return GenericDictionary.TryGetValue(key, out value);
		}

		public void Add(KeyValuePair<TKey, TValue> item)
		{
			if (_dictionary != null)
			{
				((IList)_dictionary).Add(item);
				return;
			}
			if (_readOnlyDictionary != null)
			{
				throw new NotSupportedException();
			}
			_genericDictionary?.Add(item);
		}

		public void Clear()
		{
			if (_dictionary != null)
			{
				_dictionary.Clear();
				return;
			}
			if (_readOnlyDictionary != null)
			{
				throw new NotSupportedException();
			}
			GenericDictionary.Clear();
		}

		public bool Contains(KeyValuePair<TKey, TValue> item)
		{
			if (_dictionary != null)
			{
				return ((IList)_dictionary).Contains(item);
			}
			if (_readOnlyDictionary != null)
			{
				return _readOnlyDictionary.Contains(item);
			}
			return GenericDictionary.Contains(item);
		}

		public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
		{
			if (_dictionary != null)
			{
				foreach (DictionaryEntry item in _dictionary)
				{
					array[arrayIndex++] = new KeyValuePair<TKey, TValue>((TKey)item.Key, (TValue)item.Value);
				}
				return;
			}
			if (_readOnlyDictionary != null)
			{
				throw new NotSupportedException();
			}
			GenericDictionary.CopyTo(array, arrayIndex);
		}

		public bool Remove(KeyValuePair<TKey, TValue> item)
		{
			if (_dictionary != null)
			{
				if (_dictionary.Contains(item.Key))
				{
					if (object.Equals(_dictionary[item.Key], item.Value))
					{
						_dictionary.Remove(item.Key);
						return true;
					}
					return false;
				}
				return true;
			}
			if (_readOnlyDictionary != null)
			{
				throw new NotSupportedException();
			}
			return GenericDictionary.Remove(item);
		}

		public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
		{
			if (_dictionary != null)
			{
				return (from DictionaryEntry de in _dictionary
					select new KeyValuePair<TKey, TValue>((TKey)de.Key, (TValue)de.Value)).GetEnumerator();
			}
			if (_readOnlyDictionary != null)
			{
				return _readOnlyDictionary.GetEnumerator();
			}
			return GenericDictionary.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		void IDictionary.Add(object key, object value)
		{
			if (_dictionary != null)
			{
				_dictionary.Add(key, value);
				return;
			}
			if (_readOnlyDictionary != null)
			{
				throw new NotSupportedException();
			}
			GenericDictionary.Add((TKey)key, (TValue)value);
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			if (_dictionary != null)
			{
				return _dictionary.GetEnumerator();
			}
			if (_readOnlyDictionary != null)
			{
				return new DictionaryEnumerator<TKey, TValue>(_readOnlyDictionary.GetEnumerator());
			}
			return new DictionaryEnumerator<TKey, TValue>(GenericDictionary.GetEnumerator());
		}

		bool IDictionary.Contains(object key)
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.ContainsKey((TKey)key);
			}
			if (_readOnlyDictionary != null)
			{
				return _readOnlyDictionary.ContainsKey((TKey)key);
			}
			return _dictionary.Contains(key);
		}

		public void Remove(object key)
		{
			if (_dictionary != null)
			{
				_dictionary.Remove(key);
				return;
			}
			if (_readOnlyDictionary != null)
			{
				throw new NotSupportedException();
			}
			GenericDictionary.Remove((TKey)key);
		}

		void ICollection.CopyTo(Array array, int index)
		{
			if (_dictionary != null)
			{
				_dictionary.CopyTo(array, index);
				return;
			}
			if (_readOnlyDictionary != null)
			{
				throw new NotSupportedException();
			}
			GenericDictionary.CopyTo((KeyValuePair<TKey, TValue>[])array, index);
		}
	}
	internal class DynamicProxy<T>
	{
		public virtual IEnumerable<string> GetDynamicMemberNames(T instance)
		{
			return CollectionUtils.ArrayEmpty<string>();
		}

		public virtual bool TryBinaryOperation(T instance, BinaryOperationBinder binder, object arg, out object? result)
		{
			result = null;
			return false;
		}

		public virtual bool TryConvert(T instance, ConvertBinder binder, out object? result)
		{
			result = null;
			return false;
		}

		public virtual bool TryCreateInstance(T instance, CreateInstanceBinder binder, object[] args, out object? result)
		{
			result = null;
			return false;
		}

		public virtual bool TryDeleteIndex(T instance, DeleteIndexBinder binder, object[] indexes)
		{
			return false;
		}

		public virtual bool TryDeleteMember(T instance, DeleteMemberBinder binder)
		{
			return false;
		}

		public virtual bool TryGetIndex(T instance, GetIndexBinder binder, object[] indexes, out object? result)
		{
			result = null;
			return false;
		}

		public virtual bool TryGetMember(T instance, GetMemberBinder binder, out object? result)
		{
			result = null;
			return false;
		}

		public virtual bool TryInvoke(T instance, InvokeBinder binder, object[] args, out object? result)
		{
			result = null;
			return false;
		}

		public virtual bool TryInvokeMember(T instance, InvokeMemberBinder binder, object[] args, out object? result)
		{
			result = null;
			return false;
		}

		public virtual bool TrySetIndex(T instance, SetIndexBinder binder, object[] indexes, object value)
		{
			return false;
		}

		public virtual bool TrySetMember(T instance, SetMemberBinder binder, object value)
		{
			return false;
		}

		public virtual bool TryUnaryOperation(T instance, UnaryOperationBinder binder, out object? result)
		{
			result = null;
			return false;
		}
	}
	internal sealed class DynamicProxyMetaObject<T> : DynamicMetaObject
	{
		private delegate DynamicMetaObject Fallback(DynamicMetaObject? errorSuggestion);

		private sealed class GetBinderAdapter : GetMemberBinder
		{
			internal GetBinderAdapter(InvokeMemberBinder binder)
				: base(binder.Name, binder.IgnoreCase)
			{
			}

			public override DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion)
			{
				throw new NotSupportedException();
			}
		}

		private readonly DynamicProxy<T> _proxy;

		private static Expression[] NoArgs => CollectionUtils.ArrayEmpty<Expression>();

		internal DynamicProxyMetaObject(Expression expression, T value, DynamicProxy<T> proxy)
			: base(expression, BindingRestrictions.Empty, value)
		{
			_proxy = proxy;
		}

		private bool IsOverridden(string method)
		{
			return ReflectionUtils.IsMethodOverridden(_proxy.GetType(), typeof(DynamicProxy<T>), method);
		}

		public override DynamicMetaObject BindGetMember(GetMemberBinder binder)
		{
			if (!IsOverridden("TryGetMember"))
			{
				return base.BindGetMember(binder);
			}
			return CallMethodWithResult("TryGetMember", binder, NoArgs, (DynamicMetaObject? e) => binder.FallbackGetMember(this, e));
		}

		public override DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value)
		{
			if (!IsOverridden("TrySetMember"))
			{
				return base.BindSetMember(binder, value);
			}
			return CallMethodReturnLast("TrySetMember", binder, GetArgs(value), (DynamicMetaObject? e) => binder.FallbackSetMember(this, value, e));
		}

		public override DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder)
		{
			if (!IsOverridden("TryDeleteMember"))
			{
				return base.BindDeleteMember(binder);
			}
			return CallMethodNoResult("TryDeleteMember", binder, NoArgs, (DynamicMetaObject? e) => binder.FallbackDeleteMember(this, e));
		}

		public override DynamicMetaObject BindConvert(ConvertBinder binder)
		{
			if (!IsOverridden("TryConvert"))
			{
				return base.BindConvert(binder);
			}
			return CallMethodWithResult("TryConvert", binder, NoArgs, (DynamicMetaObject? e) => binder.FallbackConvert(this, e));
		}

		public override DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args)
		{
			if (!IsOverridden("TryInvokeMember"))
			{
				return base.BindInvokeMember(binder, args);
			}
			Fallback fallback = (DynamicMetaObject? e) => binder.FallbackInvokeMember(this, args, e);
			return BuildCallMethodWithResult("TryInvokeMember", binder, GetArgArray(args), BuildCallMethodWithResult("TryGetMember", new GetBinderAdapter(binder), NoArgs, fallback(null), (DynamicMetaObject? e) => binder.FallbackInvoke(e, args, null)), null);
		}

		public override DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args)
		{
			if (!IsOverridden("TryCreateInstance"))
			{
				return base.BindCreateInstance(binder, args);
			}
			return CallMethodWithResult("TryCreateInstance", binder, GetArgArray(args), (DynamicMetaObject? e) => binder.FallbackCreateInstance(this, args, e));
		}

		public override DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args)
		{
			if (!IsOverridden("TryInvoke"))
			{
				return base.BindInvoke(binder, args);
			}
			return CallMethodWithResult("TryInvoke", binder, GetArgArray(args), (DynamicMetaObject? e) => binder.FallbackInvoke(this, args, e));
		}

		public override DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg)
		{
			if (!IsOverridden("TryBinaryOperation"))
			{
				return base.BindBinaryOperation(binder, arg);
			}
			return CallMethodWithResult("TryBinaryOperation", binder, GetArgs(arg), (DynamicMetaObject? e) => binder.FallbackBinaryOperation(this, arg, e));
		}

		public override DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder)
		{
			if (!IsOverridden("TryUnaryOperation"))
			{
				return base.BindUnaryOperation(binder);
			}
			return CallMethodWithResult("TryUnaryOperation", binder, NoArgs, (DynamicMetaObject? e) => binder.FallbackUnaryOperation(this, e));
		}

		public override DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes)
		{
			if (!IsOverridden("TryGetIndex"))
			{
				return base.BindGetIndex(binder, indexes);
			}
			return CallMethodWithResult("TryGetIndex", binder, GetArgArray(indexes), (DynamicMetaObject? e) => binder.FallbackGetIndex(this, indexes, e));
		}

		public override DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value)
		{
			if (!IsOverridden("TrySetIndex"))
			{
				return base.BindSetIndex(binder, indexes, value);
			}
			return CallMethodReturnLast("TrySetIndex", binder, GetArgArray(indexes, value), (DynamicMetaObject? e) => binder.FallbackSetIndex(this, indexes, value, e));
		}

		public override DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes)
		{
			if (!IsOverridden("TryDeleteIndex"))
			{
				return base.BindDeleteIndex(binder, indexes);
			}
			return CallMethodNoResult("TryDeleteIndex", binder, GetArgArray(indexes), (DynamicMetaObject? e) => binder.FallbackDeleteIndex(this, indexes, e));
		}

		private static IEnumerable<Expression> GetArgs(params DynamicMetaObject[] args)
		{
			return args.Select(delegate(DynamicMetaObject arg)
			{
				Expression expression = arg.Expression;
				return (!expression.Type.IsValueType()) ? expression : Expression.Convert(expression, typeof(object));
			});
		}

		private static Expression[] GetArgArray(DynamicMetaObject[] args)
		{
			return new NewArrayExpression[1] { Expression.NewArrayInit(typeof(object), GetArgs(args)) };
		}

		private static Expression[] GetArgArray(DynamicMetaObject[] args, DynamicMetaObject value)
		{
			Expression expression = value.Expression;
			return new Expression[2]
			{
				Expression.NewArrayInit(typeof(object), GetArgs(args)),
				expression.Type.IsValueType() ? Expression.Convert(expression, typeof(object)) : expression
			};
		}

		private static ConstantExpression Constant(DynamicMetaObjectBinder binder)
		{
			Type type = binder.GetType();
			while (!type.IsVisible())
			{
				type = type.BaseType();
			}
			return Expression.Constant(binder, type);
		}

		private DynamicMetaObject CallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, IEnumerable<Expression> args, Fallback fallback, Fallback? fallbackInvoke = null)
		{
			DynamicMetaObject fallbackResult = fallback(null);
			return BuildCallMethodWithResult(methodName, binder, args, fallbackResult, fallbackInvoke);
		}

		private DynamicMetaObject BuildCallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, IEnumerable<Expression> args, DynamicMetaObject fallbackResult, Fallback? fallbackInvoke)
		{
			ParameterExpression parameterExpression = Expression.Parameter(typeof(object), null);
			IList<Expression> list = new List<Expression>();
			list.Add(Expression.Convert(base.Expression, typeof(T)));
			list.Add(Constant(binder));
			list.AddRange(args);
			list.Add(parameterExpression);
			DynamicMetaObject dynamicMetaObject = new DynamicMetaObject(parameterExpression, BindingRestrictions.Empty);
			if (binder.ReturnType != typeof(object))
			{
				dynamicMetaObject = new DynamicMetaObject(Expression.Convert(dynamicMetaObject.Expression, binder.ReturnType), dynamicMetaObject.Restrictions);
			}
			if (fallbackInvoke != null)
			{
				dynamicMetaObject = fallbackInvoke(dynamicMetaObject);
			}
			return new DynamicMetaObject(Expression.Block(new ParameterExpression[1] { parameterExpression }, Expression.Condition(Expression.Call(Expression.Constant(_proxy), typeof(DynamicProxy<T>).GetMethod(methodName), list), dynamicMetaObject.Expression, fallbackResult.Expression, binder.ReturnType)), GetRestrictions().Merge(dynamicMetaObject.Restrictions).Merge(fallbackResult.Restrictions));
		}

		private DynamicMetaObject CallMethodReturnLast(string methodName, DynamicMetaObjectBinder binder, IEnumerable<Expression> args, Fallback fallback)
		{
			DynamicMetaObject dynamicMetaObject = fallback(null);
			ParameterExpression parameterExpression = Expression.Parameter(typeof(object), null);
			IList<Expression> list = new List<Expression>();
			list.Add(Expression.Convert(base.Expression, typeof(T)));
			list.Add(Constant(binder));
			list.AddRange(args);
			list[list.Count - 1] = Expression.Assign(parameterExpression, list[list.Count - 1]);
			return new DynamicMetaObject(Expression.Block(new ParameterExpression[1] { parameterExpression }, Expression.Condition(Expression.Call(Expression.Constant(_proxy), typeof(DynamicProxy<T>).GetMethod(methodName), list), parameterExpression, dynamicMetaObject.Expression, typeof(object))), GetRestrictions().Merge(dynamicMetaObject.Restrictions));
		}

		private DynamicMetaObject CallMethodNoResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback fallback)
		{
			DynamicMetaObject dynamicMetaObject = fallback(null);
			IList<Expression> list = new List<Expression>();
			list.Add(Expression.Convert(base.Expression, typeof(T)));
			list.Add(Constant(binder));
			list.AddRange(args);
			return new DynamicMetaObject(Expression.Condition(Expression.Call(Expression.Constant(_proxy), typeof(DynamicProxy<T>).GetMethod(methodName), list), Expression.Empty(), dynamicMetaObject.Expression, typeof(void)), GetRestrictions().Merge(dynamicMetaObject.Restrictions));
		}

		private BindingRestrictions GetRestrictions()
		{
			if (base.Value != null || !base.HasValue)
			{
				return BindingRestrictions.GetTypeRestriction(base.Expression, base.LimitType);
			}
			return BindingRestrictions.GetInstanceRestriction(base.Expression, null);
		}

		public override IEnumerable<string> GetDynamicMemberNames()
		{
			return _proxy.GetDynamicMemberNames((T)base.Value);
		}
	}
	internal static class DynamicUtils
	{
		internal static class BinderWrapper
		{
			public const string CSharpAssemblyName = "Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

			private const string BinderTypeName = "Microsoft.CSharp.RuntimeBinder.Binder, Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

			private const string CSharpArgumentInfoTypeName = "Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo, Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

			private const string CSharpArgumentInfoFlagsTypeName = "Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags, Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

			private const string CSharpBinderFlagsTypeName = "Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags, Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

			private static object? _getCSharpArgumentInfoArray;

			private static object? _setCSharpArgumentInfoArray;

			private static MethodCall<object?, object?>? _getMemberCall;

			private static MethodCall<object?, object?>? _setMemberCall;

			private static bool _init;

			private static void Init()
			{
				if (!_init)
				{
					if (Type.GetType("Microsoft.CSharp.RuntimeBinder.Binder, Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false) == null)
					{
						throw new InvalidOperationException("Could not resolve type '{0}'. You may need to add a reference to Microsoft.CSharp.dll to work with dynamic types.".FormatWith(CultureInfo.InvariantCulture, "Microsoft.CSharp.RuntimeBinder.Binder, Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
					}
					_getCSharpArgumentInfoArray = CreateSharpArgumentInfoArray(default(int));
					_setCSharpArgumentInfoArray = CreateSharpArgumentInfoArray(0, 3);
					CreateMemberCalls();
					_init = true;
				}
			}

			private static object CreateSharpArgumentInfoArray(params int[] values)
			{
				Type type = Type.GetType("Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo, Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
				Type type2 = Type.GetType("Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags, Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
				Array array = Array.CreateInstance(type, values.Length);
				for (int i = 0; i < values.Length; i++)
				{
					object value = type.GetMethod("Create", new Type[2]
					{
						type2,
						typeof(string)
					}).Invoke(null, new object[2] { 0, null });
					array.SetValue(value, i);
				}
				return array;
			}

			private static void CreateMemberCalls()
			{
				Type type = Type.GetType("Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo, Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: true);
				Type type2 = Type.GetType("Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags, Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: true);
				Type type3 = Type.GetType("Microsoft.CSharp.RuntimeBinder.Binder, Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: true);
				Type type4 = typeof(IEnumerable<>).MakeGenericType(type);
				MethodInfo method = type3.GetMethod("GetMember", new Type[4]
				{
					type2,
					typeof(string),
					typeof(Type),
					type4
				});
				_getMemberCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
				MethodInfo method2 = type3.GetMethod("SetMember", new Type[4]
				{
					type2,
					typeof(string),
					typeof(Type),
					type4
				});
				_setMemberCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method2);
			}

			public static CallSiteBinder GetMember(string name, Type context)
			{
				Init();
				return (CallSiteBinder)_getMemberCall(null, 0, name, context, _getCSharpArgumentInfoArray);
			}

			public static CallSiteBinder SetMember(string name, Type context)
			{
				Init();
				return (CallSiteBinder)_setMemberCall(null, 0, name, context, _setCSharpArgumentInfoArray);
			}
		}

		public static IEnumerable<string> GetDynamicMemberNames(this IDynamicMetaObjectProvider dynamicProvider)
		{
			return dynamicProvider.GetMetaObject(Expression.Constant(dynamicProvider)).GetDynamicMemberNames();
		}
	}
	internal class NoThrowGetBinderMember : GetMemberBinder
	{
		private readonly GetMemberBinder _innerBinder;

		public NoThrowGetBinderMember(GetMemberBinder innerBinder)
			: base(innerBinder.Name, innerBinder.IgnoreCase)
		{
			_innerBinder = innerBinder;
		}

		public override DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion)
		{
			DynamicMetaObject dynamicMetaObject = _innerBinder.Bind(target, CollectionUtils.ArrayEmpty<DynamicMetaObject>());
			return new DynamicMetaObject(new NoThrowExpressionVisitor().Visit(dynamicMetaObject.Expression), dynamicMetaObject.Restrictions);
		}
	}
	internal class NoThrowSetBinderMember : SetMemberBinder
	{
		private readonly SetMemberBinder _innerBinder;

		public NoThrowSetBinderMember(SetMemberBinder innerBinder)
			: base(innerBinder.Name, innerBinder.IgnoreCase)
		{
			_innerBinder = innerBinder;
		}

		public override DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion)
		{
			DynamicMetaObject dynamicMetaObject = _innerBinder.Bind(target, new DynamicMetaObject[1] { value });
			return new DynamicMetaObject(new NoThrowExpressionVisitor().Visit(dynamicMetaObject.Expression), dynamicMetaObject.Restrictions);
		}
	}
	internal class NoThrowExpressionVisitor : ExpressionVisitor
	{
		internal static readonly object ErrorResult = new object();

		protected override Expression VisitConditional(ConditionalExpression node)
		{
			if (node.IfFalse.NodeType == ExpressionType.Throw)
			{
				return Expression.Condition(node.Test, node.IfTrue, Expression.Constant(ErrorResult));
			}
			return base.VisitConditional(node);
		}
	}
	internal class EnumInfo
	{
		public readonly bool IsFlags;

		public readonly ulong[] Values;

		public readonly string[] Names;

		public readonly string[] ResolvedNames;

		internal EnumInfo(bool isFlags, ulong[] values, string[] names, string[] resolvedNames)
		{
			IsFlags = isFlags;
			Values = values;
			Names = names;
			ResolvedNames = resolvedNames;
		}
	}
	internal static class EnumUtils
	{
		private const char EnumSeparatorChar = ',';

		private const string EnumSeparatorString = ", ";

		private static readonly ThreadSafeStore<StructMultiKey<Type, NamingStrategy?>, EnumInfo> ValuesAndNamesPerEnum = new ThreadSafeStore<StructMultiKey<Type, NamingStrategy>, EnumInfo>(InitializeValuesAndNames);

		private static CamelCaseNamingStrategy _camelCaseNamingStrategy = new CamelCaseNamingStrategy();

		private static EnumInfo InitializeValuesAndNames(StructMultiKey<Type, NamingStrategy?> key)
		{
			Type value = key.Value1;
			string[] names = Enum.GetNames(value);
			string[] array = new string[names.Length];
			ulong[] array2 = new ulong[names.Length];
			for (int i = 0; i < names.Length; i++)
			{
				string text = names[i];
				FieldInfo field = value.GetField(text, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
				array2[i] = ToUInt64(field.GetValue(null));
				string text2 = (from EnumMemberAttribute a in field.GetCustomAttributes(typeof(EnumMemberAttribute), inherit: true)
					select a.Value).SingleOrDefault();
				bool hasSpecifiedName = text2 != null;
				if (text2 == null)
				{
					text2 = text;
				}
				string text3 = text2;
				if (Array.IndexOf(array, text3, 0, i) != -1)
				{
					throw new InvalidOperationException("Enum name '{0}' already exists on enum '{1}'.".FormatWith(CultureInfo.InvariantCulture, text3, value.Name));
				}
				array[i] = ((key.Value2 != null) ? key.Value2.GetPropertyName(text3, hasSpecifiedName) : text3);
			}
			return new EnumInfo(value.IsDefined(typeof(FlagsAttribute), inherit: false), array2, names, array);
		}

		public static IList<T> GetFlagsValues<T>(T value) where T : struct
		{
			Type typeFromHandle = typeof(T);
			if (!typeFromHandle.IsDefined(typeof(FlagsAttribute), inherit: false))
			{
				throw new ArgumentException("Enum type {0} is not a set of flags.".FormatWith(CultureInfo.InvariantCulture, typeFromHandle));
			}
			Type underlyingType = Enum.GetUnderlyingType(value.GetType());
			ulong num = ToUInt64(value);
			EnumInfo enumValuesAndNames = GetEnumValuesAndNames(typeFromHandle);
			IList<T> list = new List<T>();
			for (int i = 0; i < enumValuesAndNames.Values.Length; i++)
			{
				ulong num2 = enumValuesAndNames.Values[i];
				if ((num & num2) == num2 && num2 != 0L)
				{
					list.Add((T)Convert.ChangeType(num2, underlyingType, CultureInfo.CurrentCulture));
				}
			}
			if (list.Count == 0 && enumValuesAndNames.Values.Any((ulong v) => v == 0))
			{
				list.Add(default(T));
			}
			return list;
		}

		public static bool TryToString(Type enumType, object value, bool camelCase, [NotNullWhen(true)] out string? name)
		{
			return TryToString(enumType, value, camelCase ? _camelCaseNamingStrategy : null, out name);
		}

		public static bool TryToString(Type enumType, object value, NamingStrategy? namingStrategy, [NotNullWhen(true)] out string? name)
		{
			EnumInfo enumInfo = ValuesAndNamesPerEnum.Get(new StructMultiKey<Type, NamingStrategy>(enumType, namingStrategy));
			ulong num = ToUInt64(value);
			if (!enumInfo.IsFlags)
			{
				int num2 = Array.BinarySearch(enumInfo.Values, num);
				if (num2 >= 0)
				{
					name = enumInfo.ResolvedNames[num2];
					return true;
				}
				name = null;
				return false;
			}
			name = InternalFlagsFormat(enumInfo, num);
			return name != null;
		}

		private static string? InternalFlagsFormat(EnumInfo entry, ulong result)
		{
			string[] resolvedNames = entry.ResolvedNames;
			ulong[] values = entry.Values;
			int num = values.Length - 1;
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			ulong num2 = result;
			while (num >= 0 && (num != 0 || values[num] != 0L))
			{
				if ((result & values[num]) == values[num])
				{
					result -= values[num];
					if (!flag)
					{
						stringBuilder.Insert(0, ", ");
					}
					string value = resolvedNames[num];
					stringBuilder.Insert(0, value);
					flag = false;
				}
				num--;
			}
			if (result != 0L)
			{
				return null;
			}
			if (num2 == 0L)
			{
				if (values.Length != 0 && values[0] == 0L)
				{
					return resolvedNames[0];
				}
				return null;
			}
			return stringBuilder.ToString();
		}

		public static EnumInfo GetEnumValuesAndNames(Type enumType)
		{
			return ValuesAndNamesPerEnum.Get(new StructMultiKey<Type, NamingStrategy>(enumType, null));
		}

		private static ulong ToUInt64(object value)
		{
			bool isEnum;
			return ConvertUtils.GetTypeCode(value.GetType(), out isEnum) switch
			{
				PrimitiveTypeCode.SByte => (ulong)(sbyte)value, 
				PrimitiveTypeCode.Byte => (byte)value, 
				PrimitiveTypeCode.Boolean => Convert.ToByte((bool)value), 
				PrimitiveTypeCode.Int16 => (ulong)(short)value, 
				PrimitiveTypeCode.UInt16 => (ushort)value, 
				PrimitiveTypeCode.Char => (char)value, 
				PrimitiveTypeCode.UInt32 => (uint)value, 
				PrimitiveTypeCode.Int32 => (ulong)(int)value, 
				PrimitiveTypeCode.UInt64 => (ulong)value, 
				PrimitiveTypeCode.Int64 => (ulong)(long)value, 
				_ => throw new InvalidOperationException("Unknown enum type."), 
			};
		}

		public static object ParseEnum(Type enumType, NamingStrategy? namingStrategy, string value, bool disallowNumber)
		{
			ValidationUtils.ArgumentNotNull(enumType, "enumType");
			ValidationUtils.ArgumentNotNull(value, "value");
			if (!enumType.IsEnum())
			{
				throw new ArgumentException("Type provided must be an Enum.", "enumType");
			}
			EnumInfo enumInfo = ValuesAndNamesPerEnum.Get(new StructMultiKey<Type, NamingStrategy>(enumType, namingStrategy));
			string[] names = enumInfo.Names;
			string[] resolvedNames = enumInfo.ResolvedNames;
			ulong[] values = enumInfo.Values;
			int? num = FindIndexByName(resolvedNames, value, 0, value.Length, StringComparison.Ordinal);
			if (num.HasValue)
			{
				return Enum.ToObject(enumType, values[num.Value]);
			}
			int num2 = -1;
			for (int i = 0; i < value.Length; i++)
			{
				if (!char.IsWhiteSpace(value[i]))
				{
					num2 = i;
					break;
				}
			}
			if (num2 == -1)
			{
				throw new ArgumentException("Must specify valid information for parsing in the string.");
			}
			char c = value[num2];
			if (char.IsDigit(c) || c == '-' || c == '+')
			{
				Type underlyingType = Enum.GetUnderlyingType(enumType);
				value = value.Trim();
				object obj = null;
				try
				{
					obj = Convert.ChangeType(value, underlyingType, CultureInfo.InvariantCulture);
				}
				catch (FormatException)
				{
				}
				if (obj != null)
				{
					if (disallowNumber)
					{
						throw new FormatException("Integer string '{0}' is not allowed.".FormatWith(CultureInfo.InvariantCulture, value));
					}
					return Enum.ToObject(enumType, obj);
				}
			}
			ulong num3 = 0uL;
			int j = num2;
			while (j <= value.Length)
			{
				int num4 = value.IndexOf(',', j);
				if (num4 == -1)
				{
					num4 = value.Length;
				}
				int num5 = num4;
				for (; j < num4 && char.IsWhiteSpace(value[j]); j++)
				{
				}
				while (num5 > j && char.IsWhiteSpace(value[num5 - 1]))
				{
					num5--;
				}
				int valueSubstringLength = num5 - j;
				num = MatchName(value, names, resolvedNames, j, valueSubstringLength, StringComparison.Ordinal);
				if (!num.HasValue)
				{
					num = MatchName(value, names, resolvedNames, j, valueSubstringLength, StringComparison.OrdinalIgnoreCase);
				}
				if (!num.HasValue)
				{
					num = FindIndexByName(resolvedNames, value, 0, value.Length, StringComparison.OrdinalIgnoreCase);
					if (num.HasValue)
					{
						return Enum.ToObject(enumType, values[num.Value]);
					}
					throw new ArgumentException("Requested value '{0}' was not found.".FormatWith(CultureInfo.InvariantCulture, value));
				}
				num3 |= values[num.Value];
				j = num4 + 1;
			}
			return Enum.ToObject(enumType, num3);
		}

		private static int? MatchName(string value, string[] enumNames, string[] resolvedNames, int valueIndex, int valueSubstringLength, StringComparison comparison)
		{
			int? result = FindIndexByName(resolvedNames, value, valueIndex, valueSubstringLength, comparison);
			if (!result.HasValue)
			{
				result = FindIndexByName(enumNames, value, valueIndex, valueSubstringLength, comparison);
			}
			return result;
		}

		private static int? FindIndexByName(string[] enumNames, string value, int valueIndex, int valueSubstringLength, StringComparison comparison)
		{
			for (int i = 0; i < enumNames.Length; i++)
			{
				if (enumNames[i].Length == valueSubstringLength && string.Compare(enumNames[i], 0, value, valueIndex, valueSubstringLength, comparison) == 0)
				{
					return i;
				}
			}
			return null;
		}
	}
	internal class FSharpFunction
	{
		private readonly object? _instance;

		private readonly MethodCall<object?, object> _invoker;

		public FSharpFunction(object? instance, MethodCall<object?, object> invoker)
		{
			_instance = instance;
			_invoker = invoker;
		}

		public object Invoke(params object[] args)
		{
			return _invoker(_instance, args);
		}
	}
	internal class FSharpUtils
	{
		private static readonly object Lock = new object();

		private static FSharpUtils? _instance;

		private MethodInfo _ofSeq;

		private Type _mapType;

		public const string FSharpSetTypeName = "FSharpSet`1";

		public const string FSharpListTypeName = "FSharpList`1";

		public const string FSharpMapTypeName = "FSharpMap`2";

		public static FSharpUtils Instance => _instance;

		public Assembly FSharpCoreAssembly { get; private set; }

		public MethodCall<object?, object> IsUnion { get; private set; }

		public MethodCall<object?, object> GetUnionCases { get; private set; }

		public MethodCall<object?, object> PreComputeUnionTagReader { get; private set; }

		public MethodCall<object?, object> PreComputeUnionReader { get; private set; }

		public MethodCall<object?, object> PreComputeUnionConstructor { get; private set; }

		public Func<object, object> GetUnionCaseInfoDeclaringType { get; private set; }

		public Func<object, object> GetUnionCaseInfoName { get; private set; }

		public Func<object, object> GetUnionCaseInfoTag { get; private set; }

		public MethodCall<object, object?> GetUnionCaseInfoFields { get; private set; }

		private FSharpUtils(Assembly fsharpCoreAssembly)
		{
			FSharpCoreAssembly = fsharpCoreAssembly;
			Type type = fsharpCoreAssembly.GetType("Microsoft.FSharp.Reflection.FSharpType");
			MethodInfo methodWithNonPublicFallback = GetMethodWithNonPublicFallback(type, "IsUnion", BindingFlags.Static | BindingFlags.Public);
			IsUnion = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(methodWithNonPublicFallback);
			MethodInfo methodWithNonPublicFallback2 = GetMethodWithNonPublicFallback(type, "GetUnionCases", BindingFlags.Static | BindingFlags.Public);
			GetUnionCases = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(methodWithNonPublicFallback2);
			Type type2 = fsharpCoreAssembly.GetType("Microsoft.FSharp.Reflection.FSharpValue");
			PreComputeUnionTagReader = CreateFSharpFuncCall(type2, "PreComputeUnionTagReader");
			PreComputeUnionReader = CreateFSharpFuncCall(type2, "PreComputeUnionReader");
			PreComputeUnionConstructor = CreateFSharpFuncCall(type2, "PreComputeUnionConstructor");
			Type type3 = fsharpCoreAssembly.GetType("Microsoft.FSharp.Reflection.UnionCaseInfo");
			GetUnionCaseInfoName = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(type3.GetProperty("Name"));
			GetUnionCaseInfoTag = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(type3.GetProperty("Tag"));
			GetUnionCaseInfoDeclaringType = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(type3.GetProperty("DeclaringType"));
			GetUnionCaseInfoFields = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(type3.GetMethod("GetFields"));
			Type type4 = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.ListModule");
			_ofSeq = type4.GetMethod("OfSeq");
			_mapType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.FSharpMap`2");
		}

		public static void EnsureInitialized(Assembly fsharpCoreAssembly)
		{
			if (_instance != null)
			{
				return;
			}
			lock (Lock)
			{
				if (_instance == null)
				{
					_instance = new FSharpUtils(fsharpCoreAssembly);
				}
			}
		}

		private static MethodInfo GetMethodWithNonPublicFallback(Type type, string methodName, BindingFlags bindingFlags)
		{
			MethodInfo method = type.GetMethod(methodName, bindingFlags);
			if (method == null && (bindingFlags & BindingFlags.NonPublic) != BindingFlags.NonPublic)
			{
				method = type.GetMethod(methodName, bindingFlags | BindingFlags.NonPublic);
			}
			return method;
		}

		private static MethodCall<object?, object> CreateFSharpFuncCall(Type type, string methodName)
		{
			MethodInfo methodWithNonPublicFallback = GetMethodWithNonPublicFallback(type, methodName, BindingFlags.Static | BindingFlags.Public);
			MethodInfo method = methodWithNonPublicFallback.ReturnType.GetMethod("Invoke", BindingFlags.Instance | BindingFlags.Public);
			MethodCall<object?, object?> call = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(methodWithNonPublicFallback);
			MethodCall<object?, object> invoke = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
			return (object? target, object?[] args) => new FSharpFunction(call(target, args), invoke);
		}

		public ObjectConstructor<object> CreateSeq(Type t)
		{
			MethodInfo method = _ofSeq.MakeGenericMethod(t);
			return JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(method);
		}

		public ObjectConstructor<object> CreateMap(Type keyType, Type valueType)
		{
			return (ObjectConstructor<object>)typeof(FSharpUtils).GetMethod("BuildMapCreator").MakeGenericMethod(keyType, valueType).Invoke(this, null);
		}

		public ObjectConstructor<object> BuildMapCreator<TKey, TValue>()
		{
			ConstructorInfo constructor = _mapType.MakeGenericType(typeof(TKey), typeof(TValue)).GetConstructor(new Type[1] { typeof(IEnumerable<Tuple<TKey, TValue>>) });
			ObjectConstructor<object> ctorDelegate = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(constructor);
			return delegate(object?[] args)
			{
				IEnumerable<Tuple<TKey, TValue>> enumerable = ((IEnumerable<KeyValuePair<TKey, TValue>>)args[0]).Select((KeyValuePair<TKey, TValue> kv) => new Tuple<TKey, TValue>(kv.Key, kv.Value));
				return ctorDelegate(enumerable);
			};
		}
	}
	internal static class ImmutableCollectionsUtils
	{
		internal class ImmutableCollectionTypeInfo
		{
			public string ContractTypeName { get; set; }

			public string CreatedTypeName { get; set; }

			public string BuilderTypeName { get; set; }

			public ImmutableCollectionTypeInfo(string contractTypeName, string createdTypeName, string builderTypeName)
			{
				ContractTypeName = contractTypeName;
				CreatedTypeName = createdTypeName;
				BuilderTypeName = builderTypeName;
			}
		}

		private const string ImmutableListGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableList`1";

		private const string ImmutableQueueGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableQueue`1";

		private const string ImmutableStackGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableStack`1";

		private const string ImmutableSetGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableSet`1";

		private const string ImmutableArrayTypeName = "System.Collections.Immutable.ImmutableArray";

		private const string ImmutableArrayGenericTypeName = "System.Collections.Immutable.ImmutableArray`1";

		private const string ImmutableListTypeName = "System.Collections.Immutable.ImmutableList";

		private const string ImmutableListGenericTypeName = "System.Collections.Immutable.ImmutableList`1";

		private const string ImmutableQueueTypeName = "System.Collections.Immutable.ImmutableQueue";

		private const string ImmutableQueueGenericTypeName = "System.Collections.Immutable.ImmutableQueue`1";

		private const string ImmutableStackTypeName = "System.Collections.Immutable.ImmutableStack";

		private const string ImmutableStackGenericTypeName = "System.Collections.Immutable.ImmutableStack`1";

		private const string ImmutableSortedSetTypeName = "System.Collections.Immutable.ImmutableSortedSet";

		private const string ImmutableSortedSetGenericTypeName = "System.Collections.Immutable.ImmutableSortedSet`1";

		private const string ImmutableHashSetTypeName = "System.Collections.Immutable.ImmutableHashSet";

		private const string ImmutableHashSetGenericTypeName = "System.Collections.Immutable.ImmutableHashSet`1";

		private static readonly IList<ImmutableCollectionTypeInfo> ArrayContractImmutableCollectionDefinitions = new List<ImmutableCollectionTypeInfo>
		{
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.IImmutableList`1", "System.Collections.Immutable.ImmutableList`1", "System.Collections.Immutable.ImmutableList"),
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableList`1", "System.Collections.Immutable.ImmutableList`1", "System.Collections.Immutable.ImmutableList"),
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.IImmutableQueue`1", "System.Collections.Immutable.ImmutableQueue`1", "System.Collections.Immutable.ImmutableQueue"),
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableQueue`1", "System.Collections.Immutable.ImmutableQueue`1", "System.Collections.Immutable.ImmutableQueue"),
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.IImmutableStack`1", "System.Collections.Immutable.ImmutableStack`1", "System.Collections.Immutable.ImmutableStack"),
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableStack`1", "System.Collections.Immutable.ImmutableStack`1", "System.Collections.Immutable.ImmutableStack"),
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.IImmutableSet`1", "System.Collections.Immutable.ImmutableHashSet`1", "System.Collections.Immutable.ImmutableHashSet"),
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableSortedSet`1", "System.Collections.Immutable.ImmutableSortedSet`1", "System.Collections.Immutable.ImmutableSortedSet"),
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableHashSet`1", "System.Collections.Immutable.ImmutableHashSet`1", "System.Collections.Immutable.ImmutableHashSet"),
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableArray`1", "System.Collections.Immutable.ImmutableArray`1", "System.Collections.Immutable.ImmutableArray")
		};

		private const string ImmutableDictionaryGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableDictionary`2";

		private const string ImmutableDictionaryTypeName = "System.Collections.Immutable.ImmutableDictionary";

		private const string ImmutableDictionaryGenericTypeName = "System.Collections.Immutable.ImmutableDictionary`2";

		private const string ImmutableSortedDictionaryTypeName = "System.Collections.Immutable.ImmutableSortedDictionary";

		private const string ImmutableSortedDictionaryGenericTypeName = "System.Collections.Immutable.ImmutableSortedDictionary`2";

		private static readonly IList<ImmutableCollectionTypeInfo> DictionaryContractImmutableCollectionDefinitions = new List<ImmutableCollectionTypeInfo>
		{
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.IImmutableDictionary`2", "System.Collections.Immutable.ImmutableDictionary`2", "System.Collections.Immutable.ImmutableDictionary"),
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableSortedDictionary`2", "System.Collections.Immutable.ImmutableSortedDictionary`2", "System.Collections.Immutable.ImmutableSortedDictionary"),
			new ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableDictionary`2", "System.Collections.Immutable.ImmutableDictionary`2", "System.Collections.Immutable.ImmutableDictionary")
		};

		internal static bool TryBuildImmutableForArrayContract(Type underlyingType, Type collectionItemType, [NotNullWhen(true)] out Type? createdType, [NotNullWhen(true)] out ObjectConstructor<object>? parameterizedCreator)
		{
			if (underlyingType.IsGenericType())
			{
				Type genericTypeDefinition = underlyingType.GetGenericTypeDefinition();
				string name = genericTypeDefinition.FullName;
				ImmutableCollectionTypeInfo immutableCollectionTypeInfo = ArrayContractImmutableCollectionDefinitions.FirstOrDefault((ImmutableCollectionTypeInfo d) => d.ContractTypeName == name);
				if (immutableCollectionTypeInfo != null)
				{
					Type type = genericTypeDefinition.Assembly().GetType(immutableCollectionTypeInfo.CreatedTypeName);
					Type type2 = genericTypeDefinition.Assembly().GetType(immutableCollectionTypeInfo.BuilderTypeName);
					if (type != null && type2 != null)
					{
						MethodInfo methodInfo = type2.GetMethods().FirstOrDefault((MethodInfo m) => m.Name == "CreateRange" && m.GetParameters().Length == 1);
						if (methodInfo != null)
						{
							createdType = type.MakeGenericType(collectionItemType);
							MethodInfo method = methodInfo.MakeGenericMethod(collectionItemType);
							parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(method);
							return true;
						}
					}
				}
			}
			createdType = null;
			parameterizedCreator = null;
			return false;
		}

		internal static bool TryBuildImmutableForDictionaryContract(Type underlyingType, Type keyItemType, Type valueItemType, [NotNullWhen(true)] out Type? createdType, [NotNullWhen(true)] out ObjectConstructor<object>? parameterizedCreator)
		{
			if (underlyingType.IsGenericType())
			{
				Type genericTypeDefinition = underlyingType.GetGenericTypeDefinition();
				string name = genericTypeDefinition.FullName;
				ImmutableCollectionTypeInfo immutableCollectionTypeInfo = DictionaryContractImmutableCollectionDefinitions.FirstOrDefault((ImmutableCollectionTypeInfo d) => d.ContractTypeName == name);
				if (immutableCollectionTypeInfo != null)
				{
					Type type = genericTypeDefinition.Assembly().GetType(immutableCollectionTypeInfo.CreatedTypeName);
					Type type2 = genericTypeDefinition.Assembly().GetType(immutableCollectionTypeInfo.BuilderTypeName);
					if (type != null && type2 != null)
					{
						MethodInfo methodInfo = type2.GetMethods().FirstOrDefault(delegate(MethodInfo m)
						{
							ParameterInfo[] parameters = m.GetParameters();
							return m.Name == "CreateRange" && parameters.Length == 1 && parameters[0].ParameterType.IsGenericType() && parameters[0].ParameterType.GetGenericTypeDefinition() == typeof(IEnumerable<>);
						});
						if (methodInfo != null)
						{
							createdType = type.MakeGenericType(keyItemType, valueItemType);
							MethodInfo method = methodInfo.MakeGenericMethod(keyItemType, valueItemType);
							parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(method);
							return true;
						}
					}
				}
			}
			createdType = null;
			parameterizedCreator = null;
			return false;
		}
	}
	internal static class BufferUtils
	{
		public static char[] RentBuffer(IArrayPool<char>? bufferPool, int minSize)
		{
			if (bufferPool == null)
			{
				return new char[minSize];
			}
			return bufferPool.Rent(minSize);
		}

		public static void ReturnBuffer(IArrayPool<char>? bufferPool, char[]? buffer)
		{
			bufferPool?.Return(buffer);
		}

		public static char[] EnsureBufferSize(IArrayPool<char>? bufferPool, int size, char[]? buffer)
		{
			if (bufferPool == null)
			{
				return new char[size];
			}
			if (buffer != null)
			{
				bufferPool.Return(buffer);
			}
			return bufferPool.Rent(size);
		}
	}
	internal static class JavaScriptUtils
	{
		internal static readonly bool[] SingleQuoteCharEscapeFlags;

		internal static readonly bool[] DoubleQuoteCharEscapeFlags;

		internal static readonly bool[] HtmlCharEscapeFlags;

		private const int UnicodeTextLength = 6;

		private const string EscapedUnicodeText = "!";

		static JavaScriptUtils()
		{
			SingleQuoteCharEscapeFlags = new bool[128];
			DoubleQuoteCharEscapeFlags = new bool[128];
			HtmlCharEscapeFlags = new bool[128];
			IList<char> list = new List<char> { '\n', '\r', '\t', '\\', '\f', '\b' };
			for (int i = 0; i < 32; i++)
			{
				list.Add((char)i);
			}
			foreach (char item in list.Union(new char[1] { '\'' }))
			{
				SingleQuoteCharEscapeFlags[(uint)item] = true;
			}
			foreach (char item2 in list.Union(new char[1] { '"' }))
			{
				DoubleQuoteCharEscapeFlags[(uint)item2] = true;
			}
			foreach (char item3 in list.Union(new char[5] { '"', '\'', '<', '>', '&' }))
			{
				HtmlCharEscapeFlags[(uint)item3] = true;
			}
		}

		public static bool[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar)
		{
			if (stringEscapeHandling == StringEscapeHandling.EscapeHtml)
			{
				return HtmlCharEscapeFlags;
			}
			if (quoteChar == '"')
			{
				return DoubleQuoteCharEscapeFlags;
			}
			return SingleQuoteCharEscapeFlags;
		}

		public static bool ShouldEscapeJavaScriptString(string? s, bool[] charEscapeFlags)
		{
			if (s == null)
			{
				return false;
			}
			foreach (char c in s)
			{
				if (c >= charEscapeFlags.Length || charEscapeFlags[(uint)c])
				{
					return true;
				}
			}
			return false;
		}

		public static void WriteEscapedJavaScriptString(TextWriter writer, string? s, char delimiter, bool appendDelimiters, bool[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, IArrayPool<char>? bufferPool, ref char[]? writeBuffer)
		{
			if (appendDelimiters)
			{
				writer.Write(delimiter);
			}
			if (!StringUtils.IsNullOrEmpty(s))
			{
				int num = FirstCharToEscape(s, charEscapeFlags, stringEscapeHandling);
				if (num == -1)
				{
					writer.Write(s);
				}
				else
				{
					if (num != 0)
					{
						if (writeBuffer == null || writeBuffer.Length < num)
						{
							writeBuffer = BufferUtils.EnsureBufferSize(bufferPool, num, writeBuffer);
						}
						s.CopyTo(0, writeBuffer, 0, num);
						writer.Write(writeBuffer, 0, num);
					}
					int num2;
					for (int i = num; i < s.Length; i++)
					{
						char c = s[i];
						if (c < charEscapeFlags.Length && !charEscapeFlags[(uint)c])
						{
							continue;
						}
						string text;
						switch (c)
						{
						case '\t':
							text = "\\t";
							break;
						case '\n':
							text = "\\n";
							break;
						case '\r':
							text = "\\r";
							break;
						case '\f':
							text = "\\f";
							break;
						case '\b':
							text = "\\b";
							break;
						case '\\':
							text = "\\\\";
							break;
						case '\u0085':
							text = "\\u0085";
							break;
						case '\u2028':
							text = "\\u2028";
							break;
						case '\u2029':
							text = "\\u2029";
							break;
						default:
							if (c < charEscapeFlags.Length || stringEscapeHandling == StringEscapeHandling.EscapeNonAscii)
							{
								if (c == '\'' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
								{
									text = "\\'";
									break;
								}
								if (c == '"' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
								{
									text = "\\\"";
									break;
								}
								if (writeBuffer == null || writeBuffer.Length < 6)
								{
									writeBuffer = BufferUtils.EnsureBufferSize(bufferPool, 6, writeBuffer);
								}
								StringUtils.ToCharAsUnicode(c, writeBuffer);
								text = "!";
							}
							else
							{
								text = null;
							}
							break;
						}
						if (text == null)
						{
							continue;
						}
						bool flag = string.Equals(text, "!", StringComparison.Ordinal);
						if (i > num)
						{
							num2 = i - num + (flag ? 6 : 0);
							int num3 = (flag ? 6 : 0);
							if (writeBuffer == null || writeBuffer.Length < num2)
							{
								char[] array = BufferUtils.RentBuffer(bufferPool, num2);
								if (flag)
								{
									Array.Copy(writeBuffer, array, 6);
								}
								BufferUtils.ReturnBuffer(bufferPool, writeBuffer);
								writeBuffer = array;
							}
							s.CopyTo(num, writeBuffer, num3, num2 - num3);
							writer.Write(writeBuffer, num3, num2 - num3);
						}
						num = i + 1;
						if (!flag)
						{
							writer.Write(text);
						}
						else
						{
							writer.Write(writeBuffer, 0, 6);
						}
					}
					num2 = s.Length - num;
					if (num2 > 0)
					{
						if (writeBuffer == null || writeBuffer.Length < num2)
						{
							writeBuffer = BufferUtils.EnsureBufferSize(bufferPool, num2, writeBuffer);
						}
						s.CopyTo(num, writeBuffer, 0, num2);
						writer.Write(writeBuffer, 0, num2);
					}
				}
			}
			if (appendDelimiters)
			{
				writer.Write(delimiter);
			}
		}

		public static string ToEscapedJavaScriptString(string? value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling)
		{
			bool[] charEscapeFlags = GetCharEscapeFlags(stringEscapeHandling, delimiter);
			using StringWriter stringWriter = StringUtils.CreateStringWriter(value?.Length ?? 16);
			char[] writeBuffer = null;
			WriteEscapedJavaScriptString(stringWriter, value, delimiter, appendDelimiters, charEscapeFlags, stringEscapeHandling, null, ref writeBuffer);
			return stringWriter.ToString();
		}

		private static int FirstCharToEscape(string s, bool[] charEscapeFlags, StringEscapeHandling stringEscapeHandling)
		{
			for (int i = 0; i != s.Length; i++)
			{
				char c = s[i];
				if (c < charEscapeFlags.Length)
				{
					if (charEscapeFlags[(uint)c])
					{
						return i;
					}
					continue;
				}
				if (stringEscapeHandling == StringEscapeHandling.EscapeNonAscii)
				{
					return i;
				}
				if (c == '\u0085' || c == '\u2028' || c == '\u2029')
				{
					return i;
				}
			}
			return -1;
		}

		public static Task WriteEscapedJavaScriptStringAsync(TextWriter writer, string s, char delimiter, bool appendDelimiters, bool[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, char[] writeBuffer, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return cancellationToken.FromCanceled();
			}
			if (appendDelimiters)
			{
				return WriteEscapedJavaScriptStringWithDelimitersAsync(writer, s, delimiter, charEscapeFlags, stringEscapeHandling, client, writeBuffer, cancellationToken);
			}
			if (StringUtils.IsNullOrEmpty(s))
			{
				return cancellationToken.CancelIfRequestedAsync() ?? AsyncUtils.CompletedTask;
			}
			return WriteEscapedJavaScriptStringWithoutDelimitersAsync(writer, s, charEscapeFlags, stringEscapeHandling, client, writeBuffer, cancellationToken);
		}

		private static Task WriteEscapedJavaScriptStringWithDelimitersAsync(TextWriter writer, string s, char delimiter, bool[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, char[] writeBuffer, CancellationToken cancellationToken)
		{
			Task task = writer.WriteAsync(delimiter, cancellationToken);
			if (!task.IsCompletedSucessfully())
			{
				return WriteEscapedJavaScriptStringWithDelimitersAsync(task, writer, s, delimiter, charEscapeFlags, stringEscapeHandling, client, writeBuffer, cancellationToken);
			}
			if (!StringUtils.IsNullOrEmpty(s))
			{
				task = WriteEscapedJavaScriptStringWithoutDelimitersAsync(writer, s, charEscapeFlags, stringEscapeHandling, client, writeBuffer, cancellationToken);
				if (task.IsCompletedSucessfully())
				{
					return writer.WriteAsync(delimiter, cancellationToken);
				}
			}
			return WriteCharAsync(task, writer, delimiter, cancellationToken);
		}

		private static async Task WriteEscapedJavaScriptStringWithDelimitersAsync(Task task, TextWriter writer, string s, char delimiter, bool[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, char[] writeBuffer, CancellationToken cancellationToken)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			if (!StringUtils.IsNullOrEmpty(s))
			{
				await WriteEscapedJavaScriptStringWithoutDelimitersAsync(writer, s, charEscapeFlags, stringEscapeHandling, client, writeBuffer, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			await writer.WriteAsync(delimiter).ConfigureAwait(continueOnCapturedContext: false);
		}

		public static async Task WriteCharAsync(Task task, TextWriter writer, char c, CancellationToken cancellationToken)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			await writer.WriteAsync(c, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private static Task WriteEscapedJavaScriptStringWithoutDelimitersAsync(TextWriter writer, string s, bool[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, char[] writeBuffer, CancellationToken cancellationToken)
		{
			int num = FirstCharToEscape(s, charEscapeFlags, stringEscapeHandling);
			if (num != -1)
			{
				return WriteDefinitelyEscapedJavaScriptStringWithoutDelimitersAsync(writer, s, num, charEscapeFlags, stringEscapeHandling, client, writeBuffer, cancellationToken);
			}
			return writer.WriteAsync(s, cancellationToken);
		}

		private static async Task WriteDefinitelyEscapedJavaScriptStringWithoutDelimitersAsync(TextWriter writer, string s, int lastWritePosition, bool[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, char[] writeBuffer, CancellationToken cancellationToken)
		{
			if (writeBuffer == null || writeBuffer.Length < lastWritePosition)
			{
				writeBuffer = client.EnsureWriteBuffer(lastWritePosition, 6);
			}
			if (lastWritePosition != 0)
			{
				s.CopyTo(0, writeBuffer, 0, lastWritePosition);
				await writer.WriteAsync(writeBuffer, 0, lastWritePosition, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			bool isEscapedUnicodeText = false;
			string escapedValue = null;
			int num;
			for (int i = lastWritePosition; i < s.Length; i++)
			{
				char c = s[i];
				if (c < charEscapeFlags.Length && !charEscapeFlags[(uint)c])
				{
					continue;
				}
				switch (c)
				{
				case '\t':
					escapedValue = "\\t";
					break;
				case '\n':
					escapedValue = "\\n";
					break;
				case '\r':
					escapedValue = "\\r";
					break;
				case '\f':
					escapedValue = "\\f";
					break;
				case '\b':
					escapedValue = "\\b";
					break;
				case '\\':
					escapedValue = "\\\\";
					break;
				case '\u0085':
					escapedValue = "\\u0085";
					break;
				case '\u2028':
					escapedValue = "\\u2028";
					break;
				case '\u2029':
					escapedValue = "\\u2029";
					break;
				default:
					if (c >= charEscapeFlags.Length && stringEscapeHandling != StringEscapeHandling.EscapeNonAscii)
					{
						continue;
					}
					if (c == '\'' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
					{
						escapedValue = "\\'";
						break;
					}
					if (c == '"' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
					{
						escapedValue = "\\\"";
						break;
					}
					if (writeBuffer.Length < 6)
					{
						writeBuffer = client.EnsureWriteBuffer(6, 0);
					}
					StringUtils.ToCharAsUnicode(c, writeBuffer);
					isEscapedUnicodeText = true;
					break;
				}
				if (i > lastWritePosition)
				{
					num = i - lastWritePosition + (isEscapedUnicodeText ? 6 : 0);
					int num2 = (isEscapedUnicodeText ? 6 : 0);
					if (writeBuffer.Length < num)
					{
						writeBuffer = client.EnsureWriteBuffer(num, 6);
					}
					s.CopyTo(lastWritePosition, writeBuffer, num2, num - num2);
					await writer.WriteAsync(writeBuffer, num2, num - num2, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				lastWritePosition = i + 1;
				if (!isEscapedUnicodeText)
				{
					await writer.WriteAsync(escapedValue, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					continue;
				}
				await writer.WriteAsync(writeBuffer, 0, 6, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				isEscapedUnicodeText = false;
			}
			num = s.Length - lastWritePosition;
			if (num != 0)
			{
				if (writeBuffer.Length < num)
				{
					writeBuffer = client.EnsureWriteBuffer(num, 0);
				}
				s.CopyTo(lastWritePosition, writeBuffer, 0, num);
				await writer.WriteAsync(writeBuffer, 0, num, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		public static bool TryGetDateFromConstructorJson(JsonReader reader, out DateTime dateTime, [NotNullWhen(false)] out string? errorMessage)
		{
			dateTime = default(DateTime);
			errorMessage = null;
			if (!TryGetDateConstructorValue(reader, out var integer, out errorMessage) || !integer.HasValue)
			{
				errorMessage = errorMessage ?? "Date constructor has no arguments.";
				return false;
			}
			if (!TryGetDateConstructorValue(reader, out var integer2, out errorMessage))
			{
				return false;
			}
			if (integer2.HasValue)
			{
				List<long> list = new List<long> { integer.Value, integer2.Value };
				while (true)
				{
					if (!TryGetDateConstructorValue(reader, out var integer3, out errorMessage))
					{
						return false;
					}
					if (!integer3.HasValue)
					{
						break;
					}
					list.Add(integer3.Value);
				}
				if (list.Count > 7)
				{
					errorMessage = "Unexpected number of arguments when reading date constructor.";
					return false;
				}
				while (list.Count < 7)
				{
					list.Add(0L);
				}
				dateTime = new DateTime((int)list[0], (int)list[1] + 1, (int)((list[2] == 0L) ? 1 : list[2]), (int)list[3], (int)list[4], (int)list[5], (int)list[6]);
			}
			else
			{
				dateTime = DateTimeUtils.ConvertJavaScriptTicksToDateTime(integer.Value);
			}
			return true;
		}

		private static bool TryGetDateConstructorValue(JsonReader reader, out long? integer, [NotNullWhen(false)] out string? errorMessage)
		{
			integer = null;
			errorMessage = null;
			if (!reader.Read())
			{
				errorMessage = "Unexpected end when reading date constructor.";
				return false;
			}
			if (reader.TokenType == JsonToken.EndConstructor)
			{
				return true;
			}
			if (reader.TokenType != JsonToken.Integer)
			{
				errorMessage = "Unexpected token when reading date constructor. Expected Integer, got " + reader.TokenType;
				return false;
			}
			integer = (long)reader.Value;
			return true;
		}
	}
	internal static class JsonTokenUtils
	{
		internal static bool IsEndToken(JsonToken token)
		{
			if ((uint)(token - 13) <= 2u)
			{
				return true;
			}
			return false;
		}

		internal static bool IsStartToken(JsonToken token)
		{
			if ((uint)(token - 1) <= 2u)
			{
				return true;
			}
			return false;
		}

		internal static bool IsPrimitiveToken(JsonToken token)
		{
			if ((uint)(token - 7) <= 5u || (uint)(token - 16) <= 1u)
			{
				return true;
			}
			return false;
		}
	}
	internal class LateBoundReflectionDelegateFactory : ReflectionDelegateFactory
	{
		private static readonly LateBoundReflectionDelegateFactory _instance = new LateBoundReflectionDelegateFactory();

		internal static ReflectionDelegateFactory Instance => _instance;

		public override ObjectConstructor<object> CreateParameterizedConstructor(MethodBase method)
		{
			ValidationUtils.ArgumentNotNull(method, "method");
			ConstructorInfo c = method as ConstructorInfo;
			if ((object)c != null)
			{
				return (object?[] a) => c.Invoke(a);
			}
			return (object?[] a) => method.Invoke(null, a);
		}

		public override MethodCall<T, object?> CreateMethodCall<T>(MethodBase method)
		{
			ValidationUtils.ArgumentNotNull(method, "method");
			ConstructorInfo c = method as ConstructorInfo;
			if ((object)c != null)
			{
				return (T o, object?[] a) => c.Invoke(a);
			}
			return (T o, object?[] a) => method.Invoke(o, a);
		}

		public override Func<T> CreateDefaultConstructor<T>(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (type.IsValueType())
			{
				return () => (T)Activator.CreateInstance(type);
			}
			ConstructorInfo constructorInfo = ReflectionUtils.GetDefaultConstructor(type, nonPublic: true);
			return () => (T)constructorInfo.Invoke(null);
		}

		public override Func<T, object?> CreateGet<T>(PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			return (T o) => propertyInfo.GetValue(o, null);
		}

		public override Func<T, object?> CreateGet<T>(FieldInfo fieldInfo)
		{
			ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");
			return (T o) => fieldInfo.GetValue(o);
		}

		public override Action<T, object?> CreateSet<T>(FieldInfo fieldInfo)
		{
			ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");
			return delegate(T o, object? v)
			{
				fieldInfo.SetValue(o, v);
			};
		}

		public override Action<T, object?> CreateSet<T>(PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			return delegate(T o, object? v)
			{
				propertyInfo.SetValue(o, v, null);
			};
		}
	}
	internal static class MathUtils
	{
		public static int IntLength(ulong i)
		{
			if (i < 10000000000L)
			{
				if (i < 10)
				{
					return 1;
				}
				if (i < 100)
				{
					return 2;
				}
				if (i < 1000)
				{
					return 3;
				}
				if (i < 10000)
				{
					return 4;
				}
				if (i < 100000)
				{
					return 5;
				}
				if (i < 1000000)
				{
					return 6;
				}
				if (i < 10000000)
				{
					return 7;
				}
				if (i < 100000000)
				{
					return 8;
				}
				if (i < 1000000000)
				{
					return 9;
				}
				return 10;
			}
			if (i < 100000000000L)
			{
				return 11;
			}
			if (i < 1000000000000L)
			{
				return 12;
			}
			if (i < 10000000000000L)
			{
				return 13;
			}
			if (i < 100000000000000L)
			{
				return 14;
			}
			if (i < 1000000000000000L)
			{
				return 15;
			}
			if (i < 10000000000000000L)
			{
				return 16;
			}
			if (i < 100000000000000000L)
			{
				return 17;
			}
			if (i < 1000000000000000000L)
			{
				return 18;
			}
			if (i < 10000000000000000000uL)
			{
				return 19;
			}
			return 20;
		}

		public static char IntToHex(int n)
		{
			if (n <= 9)
			{
				return (char)(n + 48);
			}
			return (char)(n - 10 + 97);
		}

		public static int? Min(int? val1, int? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Min(val1.GetValueOrDefault(), val2.GetValueOrDefault());
		}

		public static int? Max(int? val1, int? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Max(val1.GetValueOrDefault(), val2.GetValueOrDefault());
		}

		public static double? Max(double? val1, double? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Max(val1.GetValueOrDefault(), val2.GetValueOrDefault());
		}

		public static bool ApproxEquals(double d1, double d2)
		{
			if (d1 == d2)
			{
				return true;
			}
			double num = (Math.Abs(d1) + Math.Abs(d2) + 10.0) * 2.220446049250313E-16;
			double num2 = d1 - d2;
			if (0.0 - num < num2)
			{
				return num > num2;
			}
			return false;
		}
	}
	internal delegate TResult MethodCall<T, TResult>(T target, params object?[] args);
	internal delegate T Creator<T>();
	internal static class MiscellaneousUtils
	{
		[Conditional("DEBUG")]
		public static void Assert([DoesNotReturnIf(false)] bool condition, string? message = null)
		{
		}

		public static bool ValueEquals(object? objA, object? objB)
		{
			if (objA == objB)
			{
				return true;
			}
			if (objA == null || objB == null)
			{
				return false;
			}
			if (objA.GetType() != objB.GetType())
			{
				if (ConvertUtils.IsInteger(objA) && ConvertUtils.IsInteger(objB))
				{
					return Convert.ToDecimal(objA, CultureInfo.CurrentCulture).Equals(Convert.ToDecimal(objB, CultureInfo.CurrentCulture));
				}
				if ((objA is double || objA is float || objA is decimal) && (objB is double || objB is float || objB is decimal))
				{
					return MathUtils.ApproxEquals(Convert.ToDouble(objA, CultureInfo.CurrentCulture), Convert.ToDouble(objB, CultureInfo.CurrentCulture));
				}
				return false;
			}
			return objA.Equals(objB);
		}

		public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message)
		{
			string message2 = message + Environment.NewLine + "Actual value was {0}.".FormatWith(CultureInfo.InvariantCulture, actualValue);
			return new ArgumentOutOfRangeException(paramName, message2);
		}

		public static string ToString(object? value)
		{
			if (value == null)
			{
				return "{null}";
			}
			if (!(value is string text))
			{
				return value.ToString();
			}
			return "\"" + text + "\"";
		}

		public static int ByteArrayCompare(byte[] a1, byte[] a2)
		{
			int num = a1.Length.CompareTo(a2.Length);
			if (num != 0)
			{
				return num;
			}
			for (int i = 0; i < a1.Length; i++)
			{
				int num2 = a1[i].CompareTo(a2[i]);
				if (num2 != 0)
				{
					return num2;
				}
			}
			return 0;
		}

		public static string? GetPrefix(string qualifiedName)
		{
			GetQualifiedNameParts(qualifiedName, out string prefix, out string _);
			return prefix;
		}

		public static string GetLocalName(string qualifiedName)
		{
			GetQualifiedNameParts(qualifiedName, out string _, out string localName);
			return localName;
		}

		public static void GetQualifiedNameParts(string qualifiedName, out string? prefix, out string localName)
		{
			int num = qualifiedName.IndexOf(':');
			if (num == -1 || num == 0 || qualifiedName.Length - 1 == num)
			{
				prefix = null;
				localName = qualifiedName;
			}
			else
			{
				prefix = qualifiedName.Substring(0, num);
				localName = qualifiedName.Substring(num + 1);
			}
		}

		internal static RegexOptions GetRegexOptions(string optionsText)
		{
			RegexOptions regexOptions = RegexOptions.None;
			for (int i = 0; i < optionsText.Length; i++)
			{
				switch (optionsText[i])
				{
				case 'i':
					regexOptions |= RegexOptions.IgnoreCase;
					break;
				case 'm':
					regexOptions |= RegexOptions.Multiline;
					break;
				case 's':
					regexOptions |= RegexOptions.Singleline;
					break;
				case 'x':
					regexOptions |= RegexOptions.ExplicitCapture;
					break;
				}
			}
			return regexOptions;
		}
	}
	internal abstract class ReflectionDelegateFactory
	{
		public Func<T, object?> CreateGet<T>(MemberInfo memberInfo)
		{
			if (memberInfo is PropertyInfo propertyInfo)
			{
				if (propertyInfo.PropertyType.IsByRef)
				{
					throw new InvalidOperationException("Could not create getter for {0}. ByRef return values are not supported.".FormatWith(CultureInfo.InvariantCulture, propertyInfo));
				}
				return CreateGet<T>(propertyInfo);
			}
			if (memberInfo is FieldInfo fieldInfo)
			{
				return CreateGet<T>(fieldInfo);
			}
			throw new Exception("Could not create getter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
		}

		public Action<T, object?> CreateSet<T>(MemberInfo memberInfo)
		{
			if (memberInfo is PropertyInfo propertyInfo)
			{
				return CreateSet<T>(propertyInfo);
			}
			if (memberInfo is FieldInfo fieldInfo)
			{
				return CreateSet<T>(fieldInfo);
			}
			throw new Exception("Could not create setter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
		}

		public abstract MethodCall<T, object?> CreateMethodCall<T>(MethodBase method);

		public abstract ObjectConstructor<object> CreateParameterizedConstructor(MethodBase method);

		public abstract Func<T> CreateDefaultConstructor<T>(Type type);

		public abstract Func<T, object?> CreateGet<T>(PropertyInfo propertyInfo);

		public abstract Func<T, object?> CreateGet<T>(FieldInfo fieldInfo);

		public abstract Action<T, object?> CreateSet<T>(FieldInfo fieldInfo);

		public abstract Action<T, object?> CreateSet<T>(PropertyInfo propertyInfo);
	}
	internal class ReflectionMember
	{
		public Type? MemberType { get; set; }

		public Func<object, object?>? Getter { get; set; }

		public Action<object, object?>? Setter { get; set; }
	}
	internal class ReflectionObject
	{
		public ObjectConstructor<object>? Creator { get; }

		public IDictionary<string, ReflectionMember> Members { get; }

		private ReflectionObject(ObjectConstructor<object>? creator)
		{
			Members = new Dictionary<string, ReflectionMember>();
			Creator = creator;
		}

		public object? GetValue(object target, string member)
		{
			return Members[member].Getter(target);
		}

		public void SetValue(object target, string member, object? value)
		{
			Members[member].Setter(target, value);
		}

		public Type GetType(string member)
		{
			return Members[member].MemberType;
		}

		public static ReflectionObject Create(Type t, params string[] memberNames)
		{
			return Create(t, null, memberNames);
		}

		public static ReflectionObject Create(Type t, MethodBase? creator, params string[] memberNames)
		{
			ReflectionDelegateFactory reflectionDelegateFactory = JsonTypeReflector.ReflectionDelegateFactory;
			ObjectConstructor<object> creator2 = null;
			if (creator != null)
			{
				creator2 = reflectionDelegateFactory.CreateParameterizedConstructor(creator);
			}
			else if (ReflectionUtils.HasDefaultConstructor(t, nonPublic: false))
			{
				Func<object> ctor = reflectionDelegateFactory.CreateDefaultConstructor<object>(t);
				creator2 = (object?[] args) => ctor();
			}
			ReflectionObject reflectionObject = new ReflectionObject(creator2);
			foreach (string text in memberNames)
			{
				MemberInfo[] member = t.GetMember(text, BindingFlags.Instance | BindingFlags.Public);
				if (member.Length != 1)
				{
					throw new ArgumentException("Expected a single member with the name '{0}'.".FormatWith(CultureInfo.InvariantCulture, text));
				}
				MemberInfo memberInfo = member.Single();
				ReflectionMember reflectionMember = new ReflectionMember();
				switch (memberInfo.MemberType())
				{
				case MemberTypes.Field:
				case MemberTypes.Property:
					if (ReflectionUtils.CanReadMemberValue(memberInfo, nonPublic: false))
					{
						reflectionMember.Getter = reflectionDelegateFactory.CreateGet<object>(memberInfo);
					}
					if (ReflectionUtils.CanSetMemberValue(memberInfo, nonPublic: false, canSetReadOnly: false))
					{
						reflectionMember.Setter = reflectionDelegateFactory.CreateSet<object>(memberInfo);
					}
					break;
				case MemberTypes.Method:
				{
					MethodInfo methodInfo = (MethodInfo)memberInfo;
					if (!methodInfo.IsPublic)
					{
						break;
					}
					ParameterInfo[] parameters = methodInfo.GetParameters();
					if (parameters.Length == 0 && methodInfo.ReturnType != typeof(void))
					{
						MethodCall<object, object?> call = reflectionDelegateFactory.CreateMethodCall<object>(methodInfo);
						reflectionMember.Getter = (object target) => call(target);
					}
					else if (parameters.Length == 1 && methodInfo.ReturnType == typeof(void))
					{
						MethodCall<object, object?> call2 = reflectionDelegateFactory.CreateMethodCall<object>(methodInfo);
						reflectionMember.Setter = delegate(object target, object? arg)
						{
							call2(target, arg);
						};
					}
					break;
				}
				default:
					throw new ArgumentException("Unexpected member type '{0}' for member '{1}'.".FormatWith(CultureInfo.InvariantCulture, memberInfo.MemberType(), memberInfo.Name));
				}
				reflectionMember.MemberType = ReflectionUtils.GetMemberUnderlyingType(memberInfo);
				reflectionObject.Members[text] = reflectionMember;
			}
			return reflectionObject;
		}
	}
	internal static class ReflectionUtils
	{
		public static readonly Type[] EmptyTypes;

		static ReflectionUtils()
		{
			EmptyTypes = Type.EmptyTypes;
		}

		public static bool IsVirtual(this PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			MethodInfo getMethod = propertyInfo.GetGetMethod(nonPublic: true);
			if (getMethod != null && getMethod.IsVirtual)
			{
				return true;
			}
			getMethod = propertyInfo.GetSetMethod(nonPublic: true);
			if (getMethod != null && getMethod.IsVirtual)
			{
				return true;
			}
			return false;
		}

		public static MethodInfo? GetBaseDefinition(this PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			MethodInfo getMethod = propertyInfo.GetGetMethod(nonPublic: true);
			if (getMethod != null)
			{
				return getMethod.GetBaseDefinition();
			}
			return propertyInfo.GetSetMethod(nonPublic: true)?.GetBaseDefinition();
		}

		public static bool IsPublic(PropertyInfo property)
		{
			MethodInfo getMethod = property.GetGetMethod();
			if (getMethod != null && getMethod.IsPublic)
			{
				return true;
			}
			MethodInfo setMethod = property.GetSetMethod();
			if (setMethod != null && setMethod.IsPublic)
			{
				return true;
			}
			return false;
		}

		public static Type? GetObjectType(object? v)
		{
			return v?.GetType();
		}

		public static string GetTypeName(Type t, TypeNameAssemblyFormatHandling assemblyFormat, ISerializationBinder? binder)
		{
			string fullyQualifiedTypeName = GetFullyQualifiedTypeName(t, binder);
			return assemblyFormat switch
			{
				TypeNameAssemblyFormatHandling.Simple => RemoveAssemblyDetails(fullyQualifiedTypeName), 
				TypeNameAssemblyFormatHandling.Full => fullyQualifiedTypeName, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		private static string GetFullyQualifiedTypeName(Type t, ISerializationBinder? binder)
		{
			if (binder != null)
			{
				binder.BindToName(t, out string assemblyName, out string typeName);
				return typeName + ((assemblyName == null) ? "" : (", " + assemblyName));
			}
			return t.AssemblyQualifiedName;
		}

		private static string RemoveAssemblyDetails(string fullyQualifiedTypeName)
		{
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = false;
			bool flag2 = false;
			foreach (char c in fullyQualifiedTypeName)
			{
				switch (c)
				{
				case '[':
				case ']':
					flag = false;
					flag2 = false;
					stringBuilder.Append(c);
					break;
				case ',':
					if (!flag)
					{
						flag = true;
						stringBuilder.Append(c);
					}
					else
					{
						flag2 = true;
					}
					break;
				default:
					if (!flag2)
					{
						stringBuilder.Append(c);
					}
					break;
				}
			}
			return stringBuilder.ToString();
		}

		public static bool HasDefaultConstructor(Type t, bool nonPublic)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			if (t.IsValueType())
			{
				return true;
			}
			return GetDefaultConstructor(t, nonPublic) != null;
		}

		public static ConstructorInfo GetDefaultConstructor(Type t)
		{
			return GetDefaultConstructor(t, nonPublic: false);
		}

		public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic)
		{
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public;
			if (nonPublic)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			return t.GetConstructors(bindingFlags).SingleOrDefault((ConstructorInfo c) => !c.GetParameters().Any());
		}

		public static bool IsNullable(Type t)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			if (t.IsValueType())
			{
				return IsNullableType(t);
			}
			return true;
		}

		public static bool IsNullableType(Type t)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			if (t.IsGenericType())
			{
				return t.GetGenericTypeDefinition() == typeof(Nullable<>);
			}
			return false;
		}

		public static Type EnsureNotNullableType(Type t)
		{
			if (!IsNullableType(t))
			{
				return t;
			}
			return Nullable.GetUnderlyingType(t);
		}

		public static Type EnsureNotByRefType(Type t)
		{
			if (!t.IsByRef || !t.HasElementType)
			{
				return t;
			}
			return t.GetElementType();
		}

		public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition)
		{
			if (!type.IsGenericType())
			{
				return false;
			}
			return type.GetGenericTypeDefinition() == genericInterfaceDefinition;
		}

		public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition)
		{
			Type implementingType;
			return ImplementsGenericDefinition(type, genericInterfaceDefinition, out implementingType);
		}

		public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, [NotNullWhen(true)] out Type? implementingType)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			ValidationUtils.ArgumentNotNull(genericInterfaceDefinition, "genericInterfaceDefinition");
			if (!genericInterfaceDefinition.IsInterface() || !genericInterfaceDefinition.IsGenericTypeDefinition())
			{
				throw new ArgumentNullException("'{0}' is not a generic interface definition.".FormatWith(CultureInfo.InvariantCulture, genericInterfaceDefinition));
			}
			if (type.IsInterface() && type.IsGenericType())
			{
				Type genericTypeDefinition = type.GetGenericTypeDefinition();
				if (genericInterfaceDefinition == genericTypeDefinition)
				{
					implementingType = type;
					return true;
				}
			}
			Type[] interfaces = type.GetInterfaces();
			foreach (Type type2 in interfaces)
			{
				if (type2.IsGenericType())
				{
					Type genericTypeDefinition2 = type2.GetGenericTypeDefinition();
					if (genericInterfaceDefinition == genericTypeDefinition2)
					{
						implementingType = type2;
						return true;
					}
				}
			}
			implementingType = null;
			return false;
		}

		public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition)
		{
			Type implementingType;
			return InheritsGenericDefinition(type, genericClassDefinition, out implementingType);
		}

		public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, out Type? implementingType)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			ValidationUtils.ArgumentNotNull(genericClassDefinition, "genericClassDefinition");
			if (!genericClassDefinition.IsClass() || !genericClassDefinition.IsGenericTypeDefinition())
			{
				throw new ArgumentNullException("'{0}' is not a generic class definition.".FormatWith(CultureInfo.InvariantCulture, genericClassDefinition));
			}
			return InheritsGenericDefinitionInternal(type, genericClassDefinition, out implementingType);
		}

		private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, out Type? implementingType)
		{
			do
			{
				if (currentType.IsGenericType() && genericClassDefinition == currentType.GetGenericTypeDefinition())
				{
					implementingType = currentType;
					return true;
				}
				currentType = currentType.BaseType();
			}
			while (currentType != null);
			implementingType = null;
			return false;
		}

		public static Type? GetCollectionItemType(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (type.IsArray)
			{
				return type.GetElementType();
			}
			if (ImplementsGenericDefinition(type, typeof(IEnumerable<>), out Type implementingType))
			{
				if (implementingType.IsGenericTypeDefinition())
				{
					throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));
				}
				return implementingType.GetGenericArguments()[0];
			}
			if (typeof(IEnumerable).IsAssignableFrom(type))
			{
				return null;
			}
			throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));
		}

		public static void GetDictionaryKeyValueTypes(Type dictionaryType, out Type? keyType, out Type? valueType)
		{
			ValidationUtils.ArgumentNotNull(dictionaryType, "dictionaryType");
			if (ImplementsGenericDefinition(dictionaryType, typeof(IDictionary<, >), out Type implementingType))
			{
				if (implementingType.IsGenericTypeDefinition())
				{
					throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));
				}
				Type[] genericArguments = implementingType.GetGenericArguments();
				keyType = genericArguments[0];
				valueType = genericArguments[1];
			}
			else
			{
				if (!typeof(IDictionary).IsAssignableFrom(dictionaryType))
				{
					throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));
				}
				keyType = null;
				valueType = null;
			}
		}

		public static Type GetMemberUnderlyingType(MemberInfo member)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			return member.MemberType() switch
			{
				MemberTypes.Field => ((FieldInfo)member).FieldType, 
				MemberTypes.Property => ((PropertyInfo)member).PropertyType, 
				MemberTypes.Event => ((EventInfo)member).EventHandlerType, 
				MemberTypes.Method => ((MethodInfo)member).ReturnType, 
				_ => throw new ArgumentException("MemberInfo must be of type FieldInfo, PropertyInfo, EventInfo or MethodInfo", "member"), 
			};
		}

		public static bool IsByRefLikeType(Type type)
		{
			if (!type.IsValueType())
			{
				return false;
			}
			Attribute[] attributes = GetAttributes(type, null, inherit: false);
			for (int i = 0; i < attributes.Length; i++)
			{
				if (string.Equals(attributes[i].GetType().FullName, "System.Runtime.CompilerServices.IsByRefLikeAttribute", StringComparison.Ordinal))
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsIndexedProperty(PropertyInfo property)
		{
			ValidationUtils.ArgumentNotNull(property, "property");
			return property.GetIndexParameters().Length != 0;
		}

		public static object GetMemberValue(MemberInfo member, object target)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			ValidationUtils.ArgumentNotNull(target, "target");
			switch (member.MemberType())
			{
			case MemberTypes.Field:
				return ((FieldInfo)member).GetValue(target);
			case MemberTypes.Property:
				try
				{
					return ((PropertyInfo)member).GetValue(target, null);
				}
				catch (TargetParameterCountException innerException)
				{
					throw new ArgumentException("MemberInfo '{0}' has index parameters".FormatWith(CultureInfo.InvariantCulture, member.Name), innerException);
				}
			default:
				throw new ArgumentException("MemberInfo '{0}' is not of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, member.Name), "member");
			}
		}

		public static void SetMemberValue(MemberInfo member, object target, object? value)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			ValidationUtils.ArgumentNotNull(target, "target");
			switch (member.MemberType())
			{
			case MemberTypes.Field:
				((FieldInfo)member).SetValue(target, value);
				break;
			case MemberTypes.Property:
				((PropertyInfo)member).SetValue(target, value, null);
				break;
			default:
				throw new ArgumentException("MemberInfo '{0}' must be of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, member.Name), "member");
			}
		}

		public static bool CanReadMemberValue(MemberInfo member, bool nonPublic)
		{
			switch (member.MemberType())
			{
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				if (nonPublic)
				{
					return true;
				}
				if (fieldInfo.IsPublic)
				{
					return true;
				}
				return false;
			}
			case MemberTypes.Property:
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				if (!propertyInfo.CanRead)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				return propertyInfo.GetGetMethod(nonPublic) != null;
			}
			default:
				return false;
			}
		}

		public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly)
		{
			switch (member.MemberType())
			{
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				if (fieldInfo.IsLiteral)
				{
					return false;
				}
				if (fieldInfo.IsInitOnly && !canSetReadOnly)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				if (fieldInfo.IsPublic)
				{
					return true;
				}
				return false;
			}
			case MemberTypes.Property:
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				if (!propertyInfo.CanWrite)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				return propertyInfo.GetSetMethod(nonPublic) != null;
			}
			default:
				return false;
			}
		}

		public static List<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr)
		{
			List<MemberInfo> list = new List<MemberInfo>();
			list.AddRange(GetFields(type, bindingAttr));
			list.AddRange(GetProperties(type, bindingAttr));
			List<MemberInfo> list2 = new List<MemberInfo>(list.Count);
			foreach (IGrouping<string, MemberInfo> item in from m in list
				group m by m.Name)
			{
				if (item.Count() == 1)
				{
					list2.Add(item.First());
					continue;
				}
				List<MemberInfo> list3 = new List<MemberInfo>();
				foreach (MemberInfo memberInfo in item)
				{
					if (list3.Count == 0)
					{
						list3.Add(memberInfo);
					}
					else if ((!IsOverridenGenericMember(memberInfo, bindingAttr) || memberInfo.Name == "Item") && !list3.Any((MemberInfo m) => m.DeclaringType == memberInfo.DeclaringType))
					{
						list3.Add(memberInfo);
					}
				}
				list2.AddRange(list3);
			}
			return list2;
		}

		private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr)
		{
			if (memberInfo.MemberType() != MemberTypes.Property)
			{
				return false;
			}
			PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
			if (!propertyInfo.IsVirtual())
			{
				return false;
			}
			Type declaringType = propertyInfo.DeclaringType;
			if (!declaringType.IsGenericType())
			{
				return false;
			}
			Type genericTypeDefinition = declaringType.GetGenericTypeDefinition();
			if (genericTypeDefinition == null)
			{
				return false;
			}
			MemberInfo[] member = genericTypeDefinition.GetMember(propertyInfo.Name, bindingAttr);
			if (member.Length == 0)
			{
				return false;
			}
			if (!GetMemberUnderlyingType(member[0]).IsGenericParameter)
			{
				return false;
			}
			return true;
		}

		public static T? GetAttribute<T>(object attributeProvider) where T : Attribute
		{
			return GetAttribute<T>(attributeProvider, inherit: true);
		}

		public static T? GetAttribute<T>(object attributeProvider, bool inherit) where T : Attribute
		{
			T[] attributes = GetAttributes<T>(attributeProvider, inherit);
			if (attributes == null)
			{
				return null;
			}
			return attributes.FirstOrDefault();
		}

		public static T[] GetAttributes<T>(object attributeProvider, bool inherit) where T : Attribute
		{
			Attribute[] attributes = GetAttributes(attributeProvider, typeof(T), inherit);
			if (attributes is T[] result)
			{
				return result;
			}
			return attributes.Cast<T>().ToArray();
		}

		public static Attribute[] GetAttributes(object attributeProvider, Type? attributeType, bool inherit)
		{
			ValidationUtils.ArgumentNotNull(attributeProvider, "attributeProvider");
			if (!(attributeProvider is Type type))
			{
				if (!(attributeProvider is Assembly element))
				{
					if (!(attributeProvider is MemberInfo element2))
					{
						if (!(attributeProvider is Module element3))
						{
							if (attributeProvider is ParameterInfo element4)
							{
								if (!(attributeType != null))
								{
									return Attribute.GetCustomAttributes(element4, inherit);
								}
								return Attribute.GetCustomAttributes(element4, attributeType, inherit);
							}
							ICustomAttributeProvider customAttributeProvider = (ICustomAttributeProvider)attributeProvider;
							return (Attribute[])((attributeType != null) ? customAttributeProvider.GetCustomAttributes(attributeType, inherit) : customAttributeProvider.GetCustomAttributes(inherit));
						}
						if (!(attributeType != null))
						{
							return Attribute.GetCustomAttributes(element3, inherit);
						}
						return Attribute.GetCustomAttributes(element3, attributeType, inherit);
					}
					if (!(attributeType != null))
					{
						return Attribute.GetCustomAttributes(element2, inherit);
					}
					return Attribute.GetCustomAttributes(element2, attributeType, inherit);
				}
				if (!(attributeType != null))
				{
					return Attribute.GetCustomAttributes(element);
				}
				return Attribute.GetCustomAttributes(element, attributeType);
			}
			return ((attributeType != null) ? type.GetCustomAttributes(attributeType, inherit) : type.GetCustomAttributes(inherit)).Cast<Attribute>().ToArray();
		}

		public static StructMultiKey<string?, string> SplitFullyQualifiedTypeName(string fullyQualifiedTypeName)
		{
			int? assemblyDelimiterIndex = GetAssemblyDelimiterIndex(fullyQualifiedTypeName);
			string v;
			string v2;
			if (assemblyDelimiterIndex.HasValue)
			{
				v = fullyQualifiedTypeName.Trim(0, assemblyDelimiterIndex.GetValueOrDefault());
				v2 = fullyQualifiedTypeName.Trim(assemblyDelimiterIndex.GetValueOrDefault() + 1, fullyQualifiedTypeName.Length - assemblyDelimiterIndex.GetValueOrDefault() - 1);
			}
			else
			{
				v = fullyQualifiedTypeName;
				v2 = null;
			}
			return new StructMultiKey<string, string>(v2, v);
		}

		private static int? GetAssemblyDelimiterIndex(string fullyQualifiedTypeName)
		{
			int num = 0;
			for (int i = 0; i < fullyQualifiedTypeName.Length; i++)
			{
				switch (fullyQualifiedTypeName[i])
				{
				case '[':
					num++;
					break;
				case ']':
					num--;
					break;
				case ',':
					if (num == 0)
					{
						return i;
					}
					break;
				}
			}
			return null;
		}

		public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo)
		{
			if (memberInfo.MemberType() == MemberTypes.Property)
			{
				PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
				Type[] types = (from p in propertyInfo.GetIndexParameters()
					select p.ParameterType).ToArray();
				return targetType.GetProperty(propertyInfo.Name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, propertyInfo.PropertyType, types, null);
			}
			return targetType.GetMember(memberInfo.Name, memberInfo.MemberType(), BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic).SingleOrDefault();
		}

		public static IEnumerable<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr)
		{
			ValidationUtils.ArgumentNotNull(targetType, "targetType");
			List<MemberInfo> list = new List<MemberInfo>(targetType.GetFields(bindingAttr));
			GetChildPrivateFields(list, targetType, bindingAttr);
			return list.Cast<FieldInfo>();
		}

		private static void GetChildPrivateFields(IList<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr)
		{
			if ((bindingAttr & BindingFlags.NonPublic) == 0)
			{
				return;
			}
			BindingFlags bindingAttr2 = bindingAttr.RemoveFlag(BindingFlags.Public);
			while ((targetType = targetType.BaseType()) != null)
			{
				IEnumerable<FieldInfo> collection = from f in targetType.GetFields(bindingAttr2)
					where f.IsPrivate
					select f;
				initialFields.AddRange(collection);
			}
		}

		public static IEnumerable<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr)
		{
			ValidationUtils.ArgumentNotNull(targetType, "targetType");
			List<PropertyInfo> list = new List<PropertyInfo>(targetType.GetProperties(bindingAttr));
			if (targetType.IsInterface())
			{
				Type[] interfaces = targetType.GetInterfaces();
				foreach (Type type in interfaces)
				{
					list.AddRange(type.GetProperties(bindingAttr));
				}
			}
			GetChildPrivateProperties(list, targetType, bindingAttr);
			for (int j = 0; j < list.Count; j++)
			{
				PropertyInfo propertyInfo = list[j];
				if (propertyInfo.DeclaringType != targetType)
				{
					PropertyInfo value = (PropertyInfo)GetMemberInfoFromType(propertyInfo.DeclaringType, propertyInfo);
					list[j] = value;
				}
			}
			return list;
		}

		public static BindingFlags RemoveFlag(this BindingFlags bindingAttr, BindingFlags flag)
		{
			if ((bindingAttr & flag) != flag)
			{
				return bindingAttr;
			}
			return bindingAttr ^ flag;
		}

		private static void GetChildPrivateProperties(IList<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr)
		{
			while ((targetType = targetType.BaseType()) != null)
			{
				PropertyInfo[] properties = targetType.GetProperties(bindingAttr);
				foreach (PropertyInfo propertyInfo in properties)
				{
					PropertyInfo subTypeProperty = propertyInfo;
					if (!subTypeProperty.IsVirtual())
					{
						if (!IsPublic(subTypeProperty))
						{
							int num = initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name);
							if (num == -1)
							{
								initialProperties.Add(subTypeProperty);
							}
							else if (!IsPublic(initialProperties[num]))
							{
								initialProperties[num] = subTypeProperty;
							}
						}
						else if (initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name && p.DeclaringType == subTypeProperty.DeclaringType) == -1)
						{
							initialProperties.Add(subTypeProperty);
						}
					}
					else
					{
						Type subTypePropertyDeclaringType = subTypeProperty.GetBaseDefinition()?.DeclaringType ?? subTypeProperty.DeclaringType;
						if (initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name && p.IsVirtual() && (p.GetBaseDefinition()?.DeclaringType ?? p.DeclaringType).IsAssignableFrom(subTypePropertyDeclaringType)) == -1)
						{
							initialProperties.Add(subTypeProperty);
						}
					}
				}
			}
		}

		public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method)
		{
			return currentType.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Any((MethodInfo info) => info.Name == method && info.DeclaringType != methodDeclaringType && info.GetBaseDefinition().DeclaringType == methodDeclaringType);
		}

		public static object? GetDefaultValue(Type type)
		{
			if (!type.IsValueType())
			{
				return null;
			}
			switch (ConvertUtils.GetTypeCode(type))
			{
			case PrimitiveTypeCode.Boolean:
				return false;
			case PrimitiveTypeCode.Char:
			case PrimitiveTypeCode.SByte:
			case PrimitiveTypeCode.Int16:
			case PrimitiveTypeCode.UInt16:
			case PrimitiveTypeCode.Int32:
			case PrimitiveTypeCode.Byte:
			case PrimitiveTypeCode.UInt32:
				return 0;
			case PrimitiveTypeCode.Int64:
			case PrimitiveTypeCode.UInt64:
				return 0L;
			case PrimitiveTypeCode.Single:
				return 0f;
			case PrimitiveTypeCode.Double:
				return 0.0;
			case PrimitiveTypeCode.Decimal:
				return 0m;
			case PrimitiveTypeCode.DateTime:
				return default(DateTime);
			case PrimitiveTypeCode.BigInteger:
				return default(BigInteger);
			case PrimitiveTypeCode.Guid:
				return default(Guid);
			case PrimitiveTypeCode.DateTimeOffset:
				return default(DateTimeOffset);
			default:
				if (IsNullable(type))
				{
					return null;
				}
				return Activator.CreateInstance(type);
			}
		}
	}
	internal struct StringBuffer
	{
		private char[]? _buffer;

		private int _position;

		public int Position
		{
			get
			{
				return _position;
			}
			set
			{
				_position = value;
			}
		}

		public bool IsEmpty => _buffer == null;

		public char[]? InternalBuffer => _buffer;

		public StringBuffer(IArrayPool<char>? bufferPool, int initalSize)
			: this(BufferUtils.RentBuffer(bufferPool, initalSize))
		{
		}

		private StringBuffer(char[] buffer)
		{
			_buffer = buffer;
			_position = 0;
		}

		public void Append(IArrayPool<char>? bufferPool, char value)
		{
			if (_position == _buffer.Length)
			{
				EnsureSize(bufferPool, 1);
			}
			_buffer[_position++] = value;
		}

		public void Append(IArrayPool<char>? bufferPool, char[] buffer, int startIndex, int count)
		{
			if (_position + count >= _buffer.Length)
			{
				EnsureSize(bufferPool, count);
			}
			Array.Copy(buffer, startIndex, _buffer, _position, count);
			_position += count;
		}

		public void Clear(IArrayPool<char>? bufferPool)
		{
			if (_buffer != null)
			{
				BufferUtils.ReturnBuffer(bufferPool, _buffer);
				_buffer = null;
			}
			_position = 0;
		}

		private void EnsureSize(IArrayPool<char>? bufferPool, int appendLength)
		{
			char[] array = BufferUtils.RentBuffer(bufferPool, (_position + appendLength) * 2);
			if (_buffer != null)
			{
				Array.Copy(_buffer, array, _position);
				BufferUtils.ReturnBuffer(bufferPool, _buffer);
			}
			_buffer = array;
		}

		public override string ToString()
		{
			return ToString(0, _position);
		}

		public string ToString(int start, int length)
		{
			return new string(_buffer, start, length);
		}
	}
	internal readonly struct StringReference
	{
		private readonly char[] _chars;

		private readonly int _startIndex;

		private readonly int _length;

		public char this[int i] => _chars[i];

		public char[] Chars => _chars;

		public int StartIndex => _startIndex;

		public int Length => _length;

		public StringReference(char[] chars, int startIndex, int length)
		{
			_chars = chars;
			_startIndex = startIndex;
			_length = length;
		}

		public override string ToString()
		{
			return new string(_chars, _startIndex, _length);
		}
	}
	internal static class StringReferenceExtensions
	{
		public static int IndexOf(this StringReference s, char c, int startIndex, int length)
		{
			int num = Array.IndexOf(s.Chars, c, s.StartIndex + startIndex, length);
			if (num == -1)
			{
				return -1;
			}
			return num - s.StartIndex;
		}

		public static bool StartsWith(this StringReference s, string text)
		{
			if (text.Length > s.Length)
			{
				return false;
			}
			char[] chars = s.Chars;
			for (int i = 0; i < text.Length; i++)
			{
				if (text[i] != chars[i + s.StartIndex])
				{
					return false;
				}
			}
			return true;
		}

		public static bool EndsWith(this StringReference s, string text)
		{
			if (text.Length > s.Length)
			{
				return false;
			}
			char[] chars = s.Chars;
			int num = s.StartIndex + s.Length - text.Length;
			for (int i = 0; i < text.Length; i++)
			{
				if (text[i] != chars[i + num])
				{
					return false;
				}
			}
			return true;
		}
	}
	internal static class StringUtils
	{
		private enum SeparatedCaseState
		{
			Start,
			Lower,
			Upper,
			NewWord
		}

		public const string CarriageReturnLineFeed = "\r\n";

		public const string Empty = "";

		public const char CarriageReturn = '\r';

		public const char LineFeed = '\n';

		public const char Tab = '\t';

		public static bool IsNullOrEmpty([NotNullWhen(false)] string? value)
		{
			return string.IsNullOrEmpty(value);
		}

		public static string FormatWith(this string format, IFormatProvider provider, object? arg0)
		{
			return format.FormatWith(provider, new object[1] { arg0 });
		}

		public static string FormatWith(this string format, IFormatProvider provider, object? arg0, object? arg1)
		{
			return format.FormatWith(provider, new object[2] { arg0, arg1 });
		}

		public static string FormatWith(this string format, IFormatProvider provider, object? arg0, object? arg1, object? arg2)
		{
			return format.FormatWith(provider, new object[3] { arg0, arg1, arg2 });
		}

		public static string FormatWith(this string format, IFormatProvider provider, object? arg0, object? arg1, object? arg2, object? arg3)
		{
			return format.FormatWith(provider, new object[4] { arg0, arg1, arg2, arg3 });
		}

		private static string FormatWith(this string format, IFormatProvider provider, params object?[] args)
		{
			ValidationUtils.ArgumentNotNull(format, "format");
			return string.Format(provider, format, args);
		}

		public static bool IsWhiteSpace(string s)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (s.Length == 0)
			{
				return false;
			}
			for (int i = 0; i < s.Length; i++)
			{
				if (!char.IsWhiteSpace(s[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static StringWriter CreateStringWriter(int capacity)
		{
			return new StringWriter(new StringBuilder(capacity), CultureInfo.InvariantCulture);
		}

		public static void ToCharAsUnicode(char c, char[] buffer)
		{
			buffer[0] = '\\';
			buffer[1] = 'u';
			buffer[2] = MathUtils.IntToHex(((int)c >> 12) & 0xF);
			buffer[3] = MathUtils.IntToHex(((int)c >> 8) & 0xF);
			buffer[4] = MathUtils.IntToHex(((int)c >> 4) & 0xF);
			buffer[5] = MathUtils.IntToHex(c & 0xF);
		}

		public static TSource ForgivingCaseSensitiveFind<TSource>(this IEnumerable<TSource> source, Func<TSource, string> valueSelector, string testValue)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (valueSelector == null)
			{
				throw new ArgumentNullException("valueSelector");
			}
			IEnumerable<TSource> source2 = source.Where((TSource s) => string.Equals(valueSelector(s), testValue, StringComparison.OrdinalIgnoreCase));
			if (source2.Count() <= 1)
			{
				return source2.SingleOrDefault();
			}
			return source.Where((TSource s) => string.Equals(valueSelector(s), testValue, StringComparison.Ordinal)).SingleOrDefault();
		}

		public static string ToCamelCase(string s)
		{
			if (IsNullOrEmpty(s) || !char.IsUpper(s[0]))
			{
				return s;
			}
			char[] array = s.ToCharArray();
			for (int i = 0; i < array.Length && (i != 1 || char.IsUpper(array[i])); i++)
			{
				bool flag = i + 1 < array.Length;
				if (i > 0 && flag && !char.IsUpper(array[i + 1]))
				{
					if (char.IsSeparator(array[i + 1]))
					{
						array[i] = ToLower(array[i]);
					}
					break;
				}
				array[i] = ToLower(array[i]);
			}
			return new string(array);
		}

		private static char ToLower(char c)
		{
			c = char.ToLower(c, CultureInfo.InvariantCulture);
			return c;
		}

		public static string ToSnakeCase(string s)
		{
			return ToSeparatedCase(s, '_');
		}

		public static string ToKebabCase(string s)
		{
			return ToSeparatedCase(s, '-');
		}

		private static string ToSeparatedCase(string s, char separator)
		{
			if (IsNullOrEmpty(s))
			{
				return s;
			}
			StringBuilder stringBuilder = new StringBuilder();
			SeparatedCaseState separatedCaseState = SeparatedCaseState.Start;
			for (int i = 0; i < s.Length; i++)
			{
				if (s[i] == ' ')
				{
					if (separatedCaseState != SeparatedCaseState.Start)
					{
						separatedCaseState = SeparatedCaseState.NewWord;
					}
				}
				else if (char.IsUpper(s[i]))
				{
					switch (separatedCaseState)
					{
					case SeparatedCaseState.Upper:
					{
						bool flag = i + 1 < s.Length;
						if (i > 0 && flag)
						{
							char c = s[i + 1];
							if (!char.IsUpper(c) && c != separator)
							{
								stringBuilder.Append(separator);
							}
						}
						break;
					}
					case SeparatedCaseState.Lower:
					case SeparatedCaseState.NewWord:
						stringBuilder.Append(separator);
						break;
					}
					char value = char.ToLower(s[i], CultureInfo.InvariantCulture);
					stringBuilder.Append(value);
					separatedCaseState = SeparatedCaseState.Upper;
				}
				else if (s[i] == separator)
				{
					stringBuilder.Append(separator);
					separatedCaseState = SeparatedCaseState.Start;
				}
				else
				{
					if (separatedCaseState == SeparatedCaseState.NewWord)
					{
						stringBuilder.Append(separator);
					}
					stringBuilder.Append(s[i]);
					separatedCaseState = SeparatedCaseState.Lower;
				}
			}
			return stringBuilder.ToString();
		}

		public static bool IsHighSurrogate(char c)
		{
			return char.IsHighSurrogate(c);
		}

		public static bool IsLowSurrogate(char c)
		{
			return char.IsLowSurrogate(c);
		}

		public static bool StartsWith(this string source, char value)
		{
			if (source.Length > 0)
			{
				return source[0] == value;
			}
			return false;
		}

		public static bool EndsWith(this string source, char value)
		{
			if (source.Length > 0)
			{
				return source[source.Length - 1] == value;
			}
			return false;
		}

		public static string Trim(this string s, int start, int length)
		{
			if (s == null)
			{
				throw new ArgumentNullException();
			}
			if (start < 0)
			{
				throw new ArgumentOutOfRangeException("start");
			}
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			int num = start + length - 1;
			if (num >= s.Length)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			while (start < num && char.IsWhiteSpace(s[start]))
			{
				start++;
			}
			while (num >= start && char.IsWhiteSpace(s[num]))
			{
				num--;
			}
			return s.Substring(start, num - start + 1);
		}
	}
	internal readonly struct StructMultiKey<T1, T2> : IEquatable<StructMultiKey<T1, T2>>
	{
		public readonly T1 Value1;

		public readonly T2 Value2;

		public StructMultiKey(T1 v1, T2 v2)
		{
			Value1 = v1;
			Value2 = v2;
		}

		public override int GetHashCode()
		{
			T1 value = Value1;
			int num = ((value != null) ? value.GetHashCode() : 0);
			T2 value2 = Value2;
			return num ^ ((value2 != null) ? value2.GetHashCode() : 0);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is StructMultiKey<T1, T2> other))
			{
				return false;
			}
			return Equals(other);
		}

		public bool Equals(StructMultiKey<T1, T2> other)
		{
			if (object.Equals(Value1, other.Value1))
			{
				return object.Equals(Value2, other.Value2);
			}
			return false;
		}
	}
	internal class ThreadSafeStore<TKey, TValue>
	{
		private readonly ConcurrentDictionary<TKey, TValue> _concurrentStore;

		private readonly Func<TKey, TValue> _creator;

		public ThreadSafeStore(Func<TKey, TValue> creator)
		{
			ValidationUtils.ArgumentNotNull(creator, "creator");
			_creator = creator;
			_concurrentStore = new ConcurrentDictionary<TKey, TValue>();
		}

		public TValue Get(TKey key)
		{
			return _concurrentStore.GetOrAdd(key, _creator);
		}
	}
	internal static class TypeExtensions
	{
		public static MethodInfo Method(this Delegate d)
		{
			return d.Method;
		}

		public static MemberTypes MemberType(this MemberInfo memberInfo)
		{
			return memberInfo.MemberType;
		}

		public static bool ContainsGenericParameters(this Type type)
		{
			return type.ContainsGenericParameters;
		}

		public static bool IsInterface(this Type type)
		{
			return type.IsInterface;
		}

		public static bool IsGenericType(this Type type)
		{
			return type.IsGenericType;
		}

		public static bool IsGenericTypeDefinition(this Type type)
		{
			return type.IsGenericTypeDefinition;
		}

		public static Type BaseType(this Type type)
		{
			return type.BaseType;
		}

		public static Assembly Assembly(this Type type)
		{
			return type.Assembly;
		}

		public static bool IsEnum(this Type type)
		{
			return type.IsEnum;
		}

		public static bool IsClass(this Type type)
		{
			return type.IsClass;
		}

		public static bool IsSealed(this Type type)
		{
			return type.IsSealed;
		}

		public static bool IsAbstract(this Type type)
		{
			return type.IsAbstract;
		}

		public static bool IsVisible(this Type type)
		{
			return type.IsVisible;
		}

		public static bool IsValueType(this Type type)
		{
			return type.IsValueType;
		}

		public static bool IsPrimitive(this Type type)
		{
			return type.IsPrimitive;
		}

		public static bool AssignableToTypeName(this Type type, string fullTypeName, bool searchInterfaces, [NotNullWhen(true)] out Type? match)
		{
			Type type2 = type;
			while (type2 != null)
			{
				if (string.Equals(type2.FullName, fullTypeName, StringComparison.Ordinal))
				{
					match = type2;
					return true;
				}
				type2 = type2.BaseType();
			}
			if (searchInterfaces)
			{
				Type[] interfaces = type.GetInterfaces();
				for (int i = 0; i < interfaces.Length; i++)
				{
					if (string.Equals(interfaces[i].Name, fullTypeName, StringComparison.Ordinal))
					{
						match = type;
						return true;
					}
				}
			}
			match = null;
			return false;
		}

		public static bool AssignableToTypeName(this Type type, string fullTypeName, bool searchInterfaces)
		{
			Type match;
			return type.AssignableToTypeName(fullTypeName, searchInterfaces, out match);
		}

		public static bool ImplementInterface(this Type type, Type interfaceType)
		{
			Type type2 = type;
			while (type2 != null)
			{
				foreach (Type item in (IEnumerable<Type>)type2.GetInterfaces())
				{
					if (item == interfaceType || (item != null && item.ImplementInterface(interfaceType)))
					{
						return true;
					}
				}
				type2 = type2.BaseType();
			}
			return false;
		}
	}
	internal static class ValidationUtils
	{
		public static void ArgumentNotNull([NotNull] object? value, string parameterName)
		{
			if (value == null)
			{
				throw new ArgumentNullException(parameterName);
			}
		}
	}
}
namespace Microsoft.Identity.Json.Serialization
{
	internal static class CachedAttributeGetter<T> where T : Attribute
	{
		private static readonly ThreadSafeStore<object, T?> TypeAttributeCache = new ThreadSafeStore<object, T>(JsonTypeReflector.GetAttribute<T>);

		public static T? GetAttribute(object type)
		{
			return TypeAttributeCache.Get(type);
		}
	}
	internal class CamelCaseNamingStrategy : NamingStrategy
	{
		public CamelCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames)
		{
			base.ProcessDictionaryKeys = processDictionaryKeys;
			base.OverrideSpecifiedNames = overrideSpecifiedNames;
		}

		public CamelCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames)
			: this(processDictionaryKeys, overrideSpecifiedNames)
		{
			base.ProcessExtensionDataNames = processExtensionDataNames;
		}

		public CamelCaseNamingStrategy()
		{
		}

		protected override string ResolvePropertyName(string name)
		{
			return StringUtils.ToCamelCase(name);
		}
	}
	internal class CamelCasePropertyNamesContractResolver : DefaultContractResolver
	{
		private static readonly object TypeContractCacheLock = new object();

		private static readonly DefaultJsonNameTable NameTable = new DefaultJsonNameTable();

		private static Dictionary<StructMultiKey<Type, Type>, JsonContract>? _contractCache;

		public CamelCasePropertyNamesContractResolver()
		{
			base.NamingStrategy = new CamelCaseNamingStrategy
			{
				ProcessDictionaryKeys = true,
				OverrideSpecifiedNames = true
			};
		}

		public override JsonContract ResolveContract(Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			StructMultiKey<Type, Type> key = new StructMultiKey<Type, Type>(GetType(), type);
			Dictionary<StructMultiKey<Type, Type>, JsonContract> contractCache = _contractCache;
			if (contractCache == null || !contractCache.TryGetValue(key, out var value))
			{
				value = CreateContract(type);
				lock (TypeContractCacheLock)
				{
					contractCache = _contractCache;
					Dictionary<StructMultiKey<Type, Type>, JsonContract> obj = ((contractCache != null) ? new Dictionary<StructMultiKey<Type, Type>, JsonContract>(contractCache) : new Dictionary<StructMultiKey<Type, Type>, JsonContract>());
					obj[key] = value;
					_contractCache = obj;
				}
			}
			return value;
		}

		internal override DefaultJsonNameTable GetNameTable()
		{
			return NameTable;
		}
	}
	internal class DefaultContractResolver : IContractResolver
	{
		internal class EnumerableDictionaryWrapper<TEnumeratorKey, TEnumeratorValue> : IEnumerable<KeyValuePair<object, object>>, IEnumerable
		{
			private readonly IEnumerable<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

			public EnumerableDictionaryWrapper(IEnumerable<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
			{
				ValidationUtils.ArgumentNotNull(e, "e");
				_e = e;
			}

			public IEnumerator<KeyValuePair<object, object>> GetEnumerator()
			{
				foreach (KeyValuePair<TEnumeratorKey, TEnumeratorValue> item in _e)
				{
					yield return new KeyValuePair<object, object>(item.Key, item.Value);
				}
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		private static readonly IContractResolver _instance = new DefaultContractResolver();

		private static readonly string[] RestrictedTypeNames = new string[3] { "System.IO.DriveInfo", "System.IO.FileInfo", "System.IO.DirectoryInfo" };

		private static readonly JsonConverter[] BuiltInConverters = new JsonConverter[10]
		{
			new EntityKeyMemberConverter(),
			new ExpandoObjectConverter(),
			new XmlNodeConverter(),
			new BinaryConverter(),
			new DataSetConverter(),
			new DataTableConverter(),
			new DiscriminatedUnionConverter(),
			new KeyValuePairConverter(),
			new BsonObjectIdConverter(),
			new RegexConverter()
		};

		private readonly DefaultJsonNameTable _nameTable = new DefaultJsonNameTable();

		private readonly ThreadSafeStore<Type, JsonContract> _contractCache;

		internal static IContractResolver Instance => _instance;

		public bool DynamicCodeGeneration => JsonTypeReflector.DynamicCodeGeneration;

		[Obsolete("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]
		public BindingFlags DefaultMembersSearchFlags { get; set; }

		public bool SerializeCompilerGeneratedMembers { get; set; }

		public bool IgnoreSerializableInterface { get; set; }

		public bool IgnoreSerializableAttribute { get; set; }

		public bool IgnoreIsSpecifiedMembers { get; set; }

		public bool IgnoreShouldSerializeMembers { get; set; }

		public NamingStrategy? NamingStrategy { get; set; }

		public DefaultContractResolver()
		{
			IgnoreSerializableAttribute = true;
			DefaultMembersSearchFlags = BindingFlags.Instance | BindingFlags.Public;
			_contractCache = new ThreadSafeStore<Type, JsonContract>(CreateContract);
		}

		public virtual JsonContract ResolveContract(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			return _contractCache.Get(type);
		}

		private static bool FilterMembers(MemberInfo member)
		{
			if (member is PropertyInfo propertyInfo)
			{
				if (ReflectionUtils.IsIndexedProperty(propertyInfo))
				{
					return false;
				}
				return !ReflectionUtils.IsByRefLikeType(propertyInfo.PropertyType);
			}
			if (member is FieldInfo fieldInfo)
			{
				return !ReflectionUtils.IsByRefLikeType(fieldInfo.FieldType);
			}
			return true;
		}

		protected virtual List<MemberInfo> GetSerializableMembers(Type objectType)
		{
			bool ignoreSerializableAttribute = IgnoreSerializableAttribute;
			MemberSerialization objectMemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(objectType, ignoreSerializableAttribute);
			IEnumerable<MemberInfo> enumerable = from m in ReflectionUtils.GetFieldsAndProperties(objectType, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)
				where !(m is PropertyInfo property) || !ReflectionUtils.IsIndexedProperty(property)
				select m;
			List<MemberInfo> list = new List<MemberInfo>();
			if (objectMemberSerialization != MemberSerialization.Fields)
			{
				DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(objectType);
				List<MemberInfo> list2 = ReflectionUtils.GetFieldsAndProperties(objectType, DefaultMembersSearchFlags).Where(FilterMembers).ToList();
				foreach (MemberInfo item in enumerable)
				{
					if (SerializeCompilerGeneratedMembers || !item.IsDefined(typeof(CompilerGeneratedAttribute), inherit: true))
					{
						if (list2.Contains(item))
						{
							list.Add(item);
						}
						else if (JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(item) != null)
						{
							list.Add(item);
						}
						else if (JsonTypeReflector.GetAttribute<JsonRequiredAttribute>(item) != null)
						{
							list.Add(item);
						}
						else if (dataContractAttribute != null && JsonTypeReflector.GetAttribute<DataMemberAttribute>(item) != null)
						{
							list.Add(item);
						}
						else if (objectMemberSerialization == MemberSerialization.Fields && item.MemberType() == MemberTypes.Field)
						{
							list.Add(item);
						}
					}
				}
				if (objectType.AssignableToTypeName("System.Data.Objects.DataClasses.EntityObject", searchInterfaces: false, out Type _))
				{
					list = list.Where(ShouldSerializeEntityMember).ToList();
				}
				if (typeof(Exception).IsAssignableFrom(objectType))
				{
					list = list.Where((MemberInfo m) => !string.Equals(m.Name, "TargetSite", StringComparison.Ordinal)).ToList();
				}
			}
			else
			{
				foreach (MemberInfo item2 in enumerable)
				{
					if (item2 is FieldInfo { IsStatic: false })
					{
						list.Add(item2);
					}
				}
			}
			return list;
		}

		private bool ShouldSerializeEntityMember(MemberInfo memberInfo)
		{
			if (memberInfo is PropertyInfo propertyInfo && propertyInfo.PropertyType.IsGenericType() && propertyInfo.PropertyType.GetGenericTypeDefinition().FullName == "System.Data.Objects.DataClasses.EntityReference`1")
			{
				return false;
			}
			return true;
		}

		protected virtual JsonObjectContract CreateObjectContract(Type objectType)
		{
			JsonObjectContract jsonObjectContract = new JsonObjectContract(objectType);
			InitializeContract(jsonObjectContract);
			bool ignoreSerializableAttribute = IgnoreSerializableAttribute;
			jsonObjectContract.MemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(jsonObjectContract.NonNullableUnderlyingType, ignoreSerializableAttribute);
			jsonObjectContract.Properties.AddRange(CreateProperties(jsonObjectContract.NonNullableUnderlyingType, jsonObjectContract.MemberSerialization));
			Func<string, string> func = null;
			JsonObjectAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonObjectAttribute>(jsonObjectContract.NonNullableUnderlyingType);
			if (cachedAttribute != null)
			{
				jsonObjectContract.ItemRequired = cachedAttribute._itemRequired;
				jsonObjectContract.ItemNullValueHandling = cachedAttribute._itemNullValueHandling;
				jsonObjectContract.MissingMemberHandling = cachedAttribute._missingMemberHandling;
				if (cachedAttribute.NamingStrategyType != null)
				{
					NamingStrategy namingStrategy = JsonTypeReflector.GetContainerNamingStrategy(cachedAttribute);
					func = (string s) => namingStrategy.GetDictionaryKey(s);
				}
			}
			if (func == null)
			{
				func = ResolveExtensionDataName;
			}
			jsonObjectContract.ExtensionDataNameResolver = func;
			if (jsonObjectContract.IsInstantiable)
			{
				ConstructorInfo attributeConstructor = GetAttributeConstructor(jsonObjectContract.NonNullableUnderlyingType);
				if (attributeConstructor != null)
				{
					jsonObjectContract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(attributeConstructor);
					jsonObjectContract.CreatorParameters.AddRange(CreateConstructorParameters(attributeConstructor, jsonObjectContract.Properties));
				}
				else if (jsonObjectContract.MemberSerialization == MemberSerialization.Fields)
				{
					if (JsonTypeReflector.FullyTrusted)
					{
						jsonObjectContract.DefaultCreator = jsonObjectContract.GetUninitializedObject;
					}
				}
				else if (jsonObjectContract.DefaultCreator == null || jsonObjectContract.DefaultCreatorNonPublic)
				{
					ConstructorInfo parameterizedConstructor = GetParameterizedConstructor(jsonObjectContract.NonNullableUnderlyingType);
					if (parameterizedConstructor != null)
					{
						jsonObjectContract.ParameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(parameterizedConstructor);
						jsonObjectContract.CreatorParameters.AddRange(CreateConstructorParameters(parameterizedConstructor, jsonObjectContract.Properties));
					}
				}
				else if (jsonObjectContract.NonNullableUnderlyingType.IsValueType())
				{
					ConstructorInfo immutableConstructor = GetImmutableConstructor(jsonObjectContract.NonNullableUnderlyingType, jsonObjectContract.Properties);
					if (immutableConstructor != null)
					{
						jsonObjectContract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(immutableConstructor);
						jsonObjectContract.CreatorParameters.AddRange(CreateConstructorParameters(immutableConstructor, jsonObjectContract.Properties));
					}
				}
			}
			MemberInfo extensionDataMemberForType = GetExtensionDataMemberForType(jsonObjectContract.NonNullableUnderlyingType);
			if (extensionDataMemberForType != null)
			{
				SetExtensionDataDelegates(jsonObjectContract, extensionDataMemberForType);
			}
			if (Array.IndexOf(RestrictedTypeNames, objectType.FullName) != -1)
			{
				jsonObjectContract.OnSerializingCallbacks.Add(ThrowUnableToSerializeError);
			}
			return jsonObjectContract;
		}

		private static void ThrowUnableToSerializeError(object o, StreamingContext context)
		{
			throw new JsonSerializationException("Unable to serialize instance of '{0}'.".FormatWith(CultureInfo.InvariantCulture, o.GetType()));
		}

		private MemberInfo GetExtensionDataMemberForType(Type type)
		{
			return GetClassHierarchyForType(type).SelectMany(delegate(Type baseType)
			{
				List<MemberInfo> list = new List<MemberInfo>();
				CollectionUtils.AddRange(list, baseType.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
				CollectionUtils.AddRange(list, baseType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
				return list;
			}).LastOrDefault(delegate(MemberInfo m)
			{
				MemberTypes memberTypes = m.MemberType();
				if (memberTypes != MemberTypes.Property && memberTypes != MemberTypes.Field)
				{
					return false;
				}
				if (!m.IsDefined(typeof(JsonExtensionDataAttribute), inherit: false))
				{
					return false;
				}
				if (!ReflectionUtils.CanReadMemberValue(m, nonPublic: true))
				{
					throw new JsonException("Invalid extension data attribute on '{0}'. Member '{1}' must have a getter.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(m.DeclaringType), m.Name));
				}
				if (ReflectionUtils.ImplementsGenericDefinition(ReflectionUtils.GetMemberUnderlyingType(m), typeof(IDictionary<, >), out Type implementingType))
				{
					Type obj = implementingType.GetGenericArguments()[0];
					Type type2 = implementingType.GetGenericArguments()[1];
					if (obj.IsAssignableFrom(typeof(string)) && type2.IsAssignableFrom(typeof(JToken)))
					{
						return true;
					}
				}
				throw new JsonException("Invalid extension data attribute on '{0}'. Member '{1}' type must implement IDictionary<string, JToken>.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(m.DeclaringType), m.Name));
			});
		}

		private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member)
		{
			JsonExtensionDataAttribute attribute = ReflectionUtils.GetAttribute<JsonExtensionDataAttribute>(member);
			if (attribute == null)
			{
				return;
			}
			Type memberUnderlyingType = ReflectionUtils.GetMemberUnderlyingType(member);
			ReflectionUtils.ImplementsGenericDefinition(memberUnderlyingType, typeof(IDictionary<, >), out Type implementingType);
			Type type = implementingType.GetGenericArguments()[0];
			Type type2 = implementingType.GetGenericArguments()[1];
			Type type3 = ((!ReflectionUtils.IsGenericDefinition(memberUnderlyingType, typeof(IDictionary<, >))) ? memberUnderlyingType : typeof(Dictionary<, >).MakeGenericType(type, type2));
			Func<object, object?> getExtensionDataDictionary = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(member);
			if (attribute.ReadData)
			{
				Action<object, object?> setExtensionDataDictionary = (ReflectionUtils.CanSetMemberValue(member, nonPublic: true, canSetReadOnly: false) ? JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(member) : null);
				Func<object> createExtensionDataDictionary = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type3);
				MethodInfo methodInfo = memberUnderlyingType.GetProperty("Item", BindingFlags.Instance | BindingFlags.Public, null, type2, new Type[1] { type }, null)?.GetSetMethod();
				if (methodInfo == null)
				{
					methodInfo = implementingType.GetProperty("Item", BindingFlags.Instance | BindingFlags.Public, null, type2, new Type[1] { type }, null)?.GetSetMethod();
				}
				MethodCall<object, object?> setExtensionDataDictionaryValue = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(methodInfo);
				ExtensionDataSetter extensionDataSetter = delegate(object o, string key, object? value)
				{
					object obj = getExtensionDataDictionary(o);
					if (obj == null)
					{
						if (setExtensionDataDictionary == null)
						{
							throw new JsonSerializationException("Cannot set value onto extension data member '{0}'. The extension data collection is null and it cannot be set.".FormatWith(CultureInfo.InvariantCulture, member.Name));
						}
						obj = createExtensionDataDictionary();
						setExtensionDataDictionary(o, obj);
					}
					setExtensionDataDictionaryValue(obj, key, value);
				};
				contract.ExtensionDataSetter = extensionDataSetter;
			}
			if (attribute.WriteData)
			{
				ConstructorInfo method = typeof(EnumerableDictionaryWrapper<, >).MakeGenericType(type, type2).GetConstructors().First();
				ObjectConstructor<object> createEnumerableWrapper = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(method);
				ExtensionDataGetter extensionDataGetter = delegate(object o)
				{
					object obj = getExtensionDataDictionary(o);
					return (obj == null) ? null : ((IEnumerable<KeyValuePair<object, object>>)createEnumerableWrapper(obj));
				};
				contract.ExtensionDataGetter = extensionDataGetter;
			}
			contract.ExtensionDataValueType = type2;
		}

		private ConstructorInfo? GetAttributeConstructor(Type objectType)
		{
			IEnumerator<ConstructorInfo> enumerator = (from c in objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
				where c.IsDefined(typeof(JsonConstructorAttribute), inherit: true)
				select c).GetEnumerator();
			if (enumerator.MoveNext())
			{
				ConstructorInfo current = enumerator.Current;
				if (enumerator.MoveNext())
				{
					throw new JsonException("Multiple constructors with the JsonConstructorAttribute.");
				}
				return current;
			}
			if (objectType == typeof(Version))
			{
				return objectType.GetConstructor(new Type[4]
				{
					typeof(int),
					typeof(int),
					typeof(int),
					typeof(int)
				});
			}
			return null;
		}

		private ConstructorInfo? GetImmutableConstructor(Type objectType, JsonPropertyCollection memberProperties)
		{
			IEnumerator<ConstructorInfo> enumerator = ((IEnumerable<ConstructorInfo>)objectType.GetConstructors()).GetEnumerator();
			if (enumerator.MoveNext())
			{
				ConstructorInfo current = enumerator.Current;
				if (!enumerator.MoveNext())
				{
					ParameterInfo[] parameters = current.GetParameters();
					if (parameters.Length != 0)
					{
						ParameterInfo[] array = parameters;
						foreach (ParameterInfo parameterInfo in array)
						{
							JsonProperty jsonProperty = MatchProperty(memberProperties, parameterInfo.Name, parameterInfo.ParameterType);
							if (jsonProperty == null || jsonProperty.Writable)
							{
								return null;
							}
						}
						return current;
					}
				}
			}
			return null;
		}

		private ConstructorInfo? GetParameterizedConstructor(Type objectType)
		{
			ConstructorInfo[] constructors = objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public);
			if (constructors.Length == 1)
			{
				return constructors[0];
			}
			return null;
		}

		protected virtual IList<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties)
		{
			ParameterInfo[] parameters = constructor.GetParameters();
			JsonPropertyCollection jsonPropertyCollection = new JsonPropertyCollection(constructor.DeclaringType);
			ParameterInfo[] array = parameters;
			foreach (ParameterInfo parameterInfo in array)
			{
				if (parameterInfo.Name == null)
				{
					continue;
				}
				JsonProperty jsonProperty = MatchProperty(memberProperties, parameterInfo.Name, parameterInfo.ParameterType);
				if (jsonProperty != null || parameterInfo.Name != null)
				{
					JsonProperty jsonProperty2 = CreatePropertyFromConstructorParameter(jsonProperty, parameterInfo);
					if (jsonProperty2 != null)
					{
						jsonPropertyCollection.AddProperty(jsonProperty2);
					}
				}
			}
			return jsonPropertyCollection;
		}

		private JsonProperty? MatchProperty(JsonPropertyCollection properties, string name, Type type)
		{
			if (name == null)
			{
				return null;
			}
			JsonProperty closestMatchProperty = properties.GetClosestMatchProperty(name);
			if (closestMatchProperty == null || closestMatchProperty.PropertyType != type)
			{
				return null;
			}
			return closestMatchProperty;
		}

		protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty? matchingMemberProperty, ParameterInfo parameterInfo)
		{
			JsonProperty jsonProperty = new JsonProperty();
			jsonProperty.PropertyType = parameterInfo.ParameterType;
			jsonProperty.AttributeProvider = new ReflectionAttributeProvider(parameterInfo);
			SetPropertySettingsFromAttributes(jsonProperty, parameterInfo, parameterInfo.Name, parameterInfo.Member.DeclaringType, MemberSerialization.OptOut, out var _);
			jsonProperty.Readable = false;
			jsonProperty.Writable = true;
			if (matchingMemberProperty != null)
			{
				jsonProperty.PropertyName = ((jsonProperty.PropertyName != parameterInfo.Name) ? jsonProperty.PropertyName : matchingMemberProperty.PropertyName);
				jsonProperty.Converter = jsonProperty.Converter ?? matchingMemberProperty.Converter;
				if (!jsonProperty._hasExplicitDefaultValue && matchingMemberProperty._hasExplicitDefaultValue)
				{
					jsonProperty.DefaultValue = matchingMemberProperty.DefaultValue;
				}
				jsonProperty._required = jsonProperty._required ?? matchingMemberProperty._required;
				jsonProperty.IsReference = jsonProperty.IsReference ?? matchingMemberProperty.IsReference;
				jsonProperty.NullValueHandling = jsonProperty.NullValueHandling ?? matchingMemberProperty.NullValueHandling;
				jsonProperty.DefaultValueHandling = jsonProperty.DefaultValueHandling ?? matchingMemberProperty.DefaultValueHandling;
				jsonProperty.ReferenceLoopHandling = jsonProperty.ReferenceLoopHandling ?? matchingMemberProperty.ReferenceLoopHandling;
				jsonProperty.ObjectCreationHandling = jsonProperty.ObjectCreationHandling ?? matchingMemberProperty.ObjectCreationHandling;
				jsonProperty.TypeNameHandling = jsonProperty.TypeNameHandling ?? matchingMemberProperty.TypeNameHandling;
			}
			return jsonProperty;
		}

		protected virtual JsonConverter? ResolveContractConverter(Type objectType)
		{
			return JsonTypeReflector.GetJsonConverter(objectType);
		}

		private Func<object> GetDefaultCreator(Type createdType)
		{
			return JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(createdType);
		}

		private void InitializeContract(JsonContract contract)
		{
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(contract.NonNullableUnderlyingType);
			if (cachedAttribute != null)
			{
				contract.IsReference = cachedAttribute._isReference;
			}
			else
			{
				DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(contract.NonNullableUnderlyingType);
				if (dataContractAttribute != null && dataContractAttribute.IsReference)
				{
					contract.IsReference = true;
				}
			}
			contract.Converter = ResolveContractConverter(contract.NonNullableUnderlyingType);
			contract.InternalConverter = JsonSerializer.GetMatchingConverter(BuiltInConverters, contract.NonNullableUnderlyingType);
			if (contract.IsInstantiable && (ReflectionUtils.HasDefaultConstructor(contract.CreatedType, nonPublic: true) || contract.CreatedType.IsValueType()))
			{
				contract.DefaultCreator = GetDefaultCreator(contract.CreatedType);
				contract.DefaultCreatorNonPublic = !contract.CreatedType.IsValueType() && ReflectionUtils.GetDefaultConstructor(contract.CreatedType) == null;
			}
			ResolveCallbackMethods(contract, contract.NonNullableUnderlyingType);
		}

		private void ResolveCallbackMethods(JsonContract contract, Type t)
		{
			GetCallbackMethodsForType(t, out List<SerializationCallback> onSerializing, out List<SerializationCallback> onSerialized, out List<SerializationCallback> onDeserializing, out List<SerializationCallback> onDeserialized, out List<SerializationErrorCallback> onError);
			if (onSerializing != null)
			{
				contract.OnSerializingCallbacks.AddRange(onSerializing);
			}
			if (onSerialized != null)
			{
				contract.OnSerializedCallbacks.AddRange(onSerialized);
			}
			if (onDeserializing != null)
			{
				contract.OnDeserializingCallbacks.AddRange(onDeserializing);
			}
			if (onDeserialized != null)
			{
				contract.OnDeserializedCallbacks.AddRange(onDeserialized);
			}
			if (onError != null)
			{
				contract.OnErrorCallbacks.AddRange(onError);
			}
		}

		private void GetCallbackMethodsForType(Type type, out List<SerializationCallback>? onSerializing, out List<SerializationCallback>? onSerialized, out List<SerializationCallback>? onDeserializing, out List<SerializationCallback>? onDeserialized, out List<SerializationErrorCallback>? onError)
		{
			onSerializing = null;
			onSerialized = null;
			onDeserializing = null;
			onDeserialized = null;
			onError = null;
			foreach (Type item in GetClassHierarchyForType(type))
			{
				MethodInfo currentCallback = null;
				MethodInfo currentCallback2 = null;
				MethodInfo currentCallback3 = null;
				MethodInfo currentCallback4 = null;
				MethodInfo currentCallback5 = null;
				bool flag = ShouldSkipSerializing(item);
				bool flag2 = ShouldSkipDeserialized(item);
				MethodInfo[] methods = item.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (MethodInfo methodInfo in methods)
				{
					if (!methodInfo.ContainsGenericParameters)
					{
						Type prevAttributeType = null;
						ParameterInfo[] parameters = methodInfo.GetParameters();
						if (!flag && IsValidCallback(methodInfo, parameters, typeof(OnSerializingAttribute), currentCallback, ref prevAttributeType))
						{
							onSerializing = onSerializing ?? new List<SerializationCallback>();
							onSerializing.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback = methodInfo;
						}
						if (IsValidCallback(methodInfo, parameters, typeof(OnSerializedAttribute), currentCallback2, ref prevAttributeType))
						{
							onSerialized = onSerialized ?? new List<SerializationCallback>();
							onSerialized.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback2 = methodInfo;
						}
						if (IsValidCallback(methodInfo, parameters, typeof(OnDeserializingAttribute), currentCallback3, ref prevAttributeType))
						{
							onDeserializing = onDeserializing ?? new List<SerializationCallback>();
							onDeserializing.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback3 = methodInfo;
						}
						if (!flag2 && IsValidCallback(methodInfo, parameters, typeof(OnDeserializedAttribute), currentCallback4, ref prevAttributeType))
						{
							onDeserialized = onDeserialized ?? new List<SerializationCallback>();
							onDeserialized.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback4 = methodInfo;
						}
						if (IsValidCallback(methodInfo, parameters, typeof(OnErrorAttribute), currentCallback5, ref prevAttributeType))
						{
							onError = onError ?? new List<SerializationErrorCallback>();
							onError.Add(JsonContract.CreateSerializationErrorCallback(methodInfo));
							currentCallback5 = methodInfo;
						}
					}
				}
			}
		}

		private static bool IsConcurrentOrObservableCollection(Type t)
		{
			if (t.IsGenericType())
			{
				switch (t.GetGenericTypeDefinition().FullName)
				{
				case "System.Collections.Concurrent.ConcurrentQueue`1":
				case "System.Collections.Concurrent.ConcurrentStack`1":
				case "System.Collections.Concurrent.ConcurrentBag`1":
				case "System.Collections.Concurrent.ConcurrentDictionary`2":
				case "System.Collections.ObjectModel.ObservableCollection`1":
					return true;
				}
			}
			return false;
		}

		private static bool ShouldSkipDeserialized(Type t)
		{
			if (IsConcurrentOrObservableCollection(t))
			{
				return true;
			}
			if (t.Name == "FSharpSet`1" || t.Name == "FSharpMap`2")
			{
				return true;
			}
			return false;
		}

		private static bool ShouldSkipSerializing(Type t)
		{
			if (IsConcurrentOrObservableCollection(t))
			{
				return true;
			}
			if (t.Name == "FSharpSet`1" || t.Name == "FSharpMap`2")
			{
				return true;
			}
			return false;
		}

		private List<Type> GetClassHierarchyForType(Type type)
		{
			List<Type> list = new List<Type>();
			Type type2 = type;
			while (type2 != null && type2 != typeof(object))
			{
				list.Add(type2);
				type2 = type2.BaseType();
			}
			list.Reverse();
			return list;
		}

		protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType)
		{
			JsonDictionaryContract jsonDictionaryContract = new JsonDictionaryContract(objectType);
			InitializeContract(jsonDictionaryContract);
			JsonContainerAttribute attribute = JsonTypeReflector.GetAttribute<JsonContainerAttribute>(objectType);
			if (attribute?.NamingStrategyType != null)
			{
				NamingStrategy namingStrategy = JsonTypeReflector.GetContainerNamingStrategy(attribute);
				jsonDictionaryContract.DictionaryKeyResolver = (string s) => namingStrategy.GetDictionaryKey(s);
			}
			else
			{
				jsonDictionaryContract.DictionaryKeyResolver = ResolveDictionaryKey;
			}
			ConstructorInfo attributeConstructor = GetAttributeConstructor(jsonDictionaryContract.NonNullableUnderlyingType);
			if (attributeConstructor != null)
			{
				ParameterInfo[] parameters = attributeConstructor.GetParameters();
				Type type = ((jsonDictionaryContract.DictionaryKeyType != null && jsonDictionaryContract.DictionaryValueType != null) ? typeof(IEnumerable<>).MakeGenericType(typeof(KeyValuePair<, >).MakeGenericType(jsonDictionaryContract.DictionaryKeyType, jsonDictionaryContract.DictionaryValueType)) : typeof(IDictionary));
				if (parameters.Length == 0)
				{
					jsonDictionaryContract.HasParameterizedCreator = false;
				}
				else
				{
					if (parameters.Length != 1 || !type.IsAssignableFrom(parameters[0].ParameterType))
					{
						throw new JsonException("Constructor for '{0}' must have no parameters or a single parameter that implements '{1}'.".FormatWith(CultureInfo.InvariantCulture, jsonDictionaryContract.UnderlyingType, type));
					}
					jsonDictionaryContract.HasParameterizedCreator = true;
				}
				jsonDictionaryContract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(attributeConstructor);
			}
			return jsonDictionaryContract;
		}

		protected virtual JsonArrayContract CreateArrayContract(Type objectType)
		{
			JsonArrayContract jsonArrayContract = new JsonArrayContract(objectType);
			InitializeContract(jsonArrayContract);
			ConstructorInfo attributeConstructor = GetAttributeConstructor(jsonArrayContract.NonNullableUnderlyingType);
			if (attributeConstructor != null)
			{
				ParameterInfo[] parameters = attributeConstructor.GetParameters();
				Type type = ((jsonArrayContract.CollectionItemType != null) ? typeof(IEnumerable<>).MakeGenericType(jsonArrayContract.CollectionItemType) : typeof(IEnumerable));
				if (parameters.Length == 0)
				{
					jsonArrayContract.HasParameterizedCreator = false;
				}
				else
				{
					if (parameters.Length != 1 || !type.IsAssignableFrom(parameters[0].ParameterType))
					{
						throw new JsonException("Constructor for '{0}' must have no parameters or a single parameter that implements '{1}'.".FormatWith(CultureInfo.InvariantCulture, jsonArrayContract.UnderlyingType, type));
					}
					jsonArrayContract.HasParameterizedCreator = true;
				}
				jsonArrayContract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(attributeConstructor);
			}
			return jsonArrayContract;
		}

		protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType)
		{
			JsonPrimitiveContract jsonPrimitiveContract = new JsonPrimitiveContract(objectType);
			InitializeContract(jsonPrimitiveContract);
			return jsonPrimitiveContract;
		}

		protected virtual JsonLinqContract CreateLinqContract(Type objectType)
		{
			JsonLinqContract jsonLinqContract = new JsonLinqContract(objectType);
			InitializeContract(jsonLinqContract);
			return jsonLinqContract;
		}

		protected virtual JsonISerializableContract CreateISerializableContract(Type objectType)
		{
			JsonISerializableContract jsonISerializableContract = new JsonISerializableContract(objectType);
			InitializeContract(jsonISerializableContract);
			if (jsonISerializableContract.IsInstantiable)
			{
				ConstructorInfo constructor = jsonISerializableContract.NonNullableUnderlyingType.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
				{
					typeof(SerializationInfo),
					typeof(StreamingContext)
				}, null);
				if (constructor != null)
				{
					ObjectConstructor<object> iSerializableCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(constructor);
					jsonISerializableContract.ISerializableCreator = iSerializableCreator;
				}
			}
			return jsonISerializableContract;
		}

		protected virtual JsonDynamicContract CreateDynamicContract(Type objectType)
		{
			JsonDynamicContract jsonDynamicContract = new JsonDynamicContract(objectType);
			InitializeContract(jsonDynamicContract);
			JsonContainerAttribute attribute = JsonTypeReflector.GetAttribute<JsonContainerAttribute>(objectType);
			if (attribute?.NamingStrategyType != null)
			{
				NamingStrategy namingStrategy = JsonTypeReflector.GetContainerNamingStrategy(attribute);
				jsonDynamicContract.PropertyNameResolver = (string s) => namingStrategy.GetDictionaryKey(s);
			}
			else
			{
				jsonDynamicContract.PropertyNameResolver = ResolveDictionaryKey;
			}
			jsonDynamicContract.Properties.AddRange(CreateProperties(objectType, MemberSerialization.OptOut));
			return jsonDynamicContract;
		}

		protected virtual JsonStringContract CreateStringContract(Type objectType)
		{
			JsonStringContract jsonStringContract = new JsonStringContract(objectType);
			InitializeContract(jsonStringContract);
			return jsonStringContract;
		}

		protected virtual JsonContract CreateContract(Type objectType)
		{
			Type t = ReflectionUtils.EnsureNotByRefType(objectType);
			if (IsJsonPrimitiveType(t))
			{
				return CreatePrimitiveContract(objectType);
			}
			t = ReflectionUtils.EnsureNotNullableType(t);
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(t);
			if (cachedAttribute is JsonObjectAttribute)
			{
				return CreateObjectContract(objectType);
			}
			if (cachedAttribute is JsonArrayAttribute)
			{
				return CreateArrayContract(objectType);
			}
			if (cachedAttribute is JsonDictionaryAttribute)
			{
				return CreateDictionaryContract(objectType);
			}
			if (t == typeof(JToken) || t.IsSubclassOf(typeof(JToken)))
			{
				return CreateLinqContract(objectType);
			}
			if (CollectionUtils.IsDictionaryType(t))
			{
				return CreateDictionaryContract(objectType);
			}
			if (typeof(IEnumerable).IsAssignableFrom(t))
			{
				return CreateArrayContract(objectType);
			}
			if (CanConvertToString(t))
			{
				return CreateStringContract(objectType);
			}
			if (!IgnoreSerializableInterface && typeof(ISerializable).IsAssignableFrom(t) && JsonTypeReflector.IsSerializable(t))
			{
				return CreateISerializableContract(objectType);
			}
			if (typeof(IDynamicMetaObjectProvider).IsAssignableFrom(t))
			{
				return CreateDynamicContract(objectType);
			}
			if (IsIConvertible(t))
			{
				return CreatePrimitiveContract(t);
			}
			return CreateObjectContract(objectType);
		}

		internal static bool IsJsonPrimitiveType(Type t)
		{
			PrimitiveTypeCode typeCode = ConvertUtils.GetTypeCode(t);
			if (typeCode != PrimitiveTypeCode.Empty)
			{
				return typeCode != PrimitiveTypeCode.Object;
			}
			return false;
		}

		internal static bool IsIConvertible(Type t)
		{
			if (typeof(IConvertible).IsAssignableFrom(t) || (ReflectionUtils.IsNullableType(t) && typeof(IConvertible).IsAssignableFrom(Nullable.GetUnderlyingType(t))))
			{
				return !typeof(JToken).IsAssignableFrom(t);
			}
			return false;
		}

		internal static bool CanConvertToString(Type type)
		{
			if (JsonTypeReflector.CanTypeDescriptorConvertString(type, out var _))
			{
				return true;
			}
			if (type == typeof(Type) || type.IsSubclassOf(typeof(Type)))
			{
				return true;
			}
			return false;
		}

		private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo? currentCallback, ref Type? prevAttributeType)
		{
			if (!method.IsDefined(attributeType, inherit: false))
			{
				return false;
			}
			if (currentCallback != null)
			{
				throw new JsonException("Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.".FormatWith(CultureInfo.InvariantCulture, method, currentCallback, GetClrTypeFullName(method.DeclaringType), attributeType));
			}
			if (prevAttributeType != null)
			{
				throw new JsonException("Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.".FormatWith(CultureInfo.InvariantCulture, prevAttributeType, attributeType, GetClrTypeFullName(method.DeclaringType), method));
			}
			if (method.IsVirtual)
			{
				throw new JsonException("Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.".FormatWith(CultureInfo.InvariantCulture, method, GetClrTypeFullName(method.DeclaringType), attributeType));
			}
			if (method.ReturnType != typeof(void))
			{
				throw new JsonException("Serialization Callback '{1}' in type '{0}' must return void.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method));
			}
			if (attributeType == typeof(OnErrorAttribute))
			{
				if (parameters == null || parameters.Length != 2 || parameters[0].ParameterType != typeof(StreamingContext) || parameters[1].ParameterType != typeof(ErrorContext))
				{
					throw new JsonException("Serialization Error Callback '{1}' in type '{0}' must have two parameters of type '{2}' and '{3}'.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext), typeof(ErrorContext)));
				}
			}
			else if (parameters == null || parameters.Length != 1 || parameters[0].ParameterType != typeof(StreamingContext))
			{
				throw new JsonException("Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext)));
			}
			prevAttributeType = attributeType;
			return true;
		}

		internal static string GetClrTypeFullName(Type type)
		{
			if (type.IsGenericTypeDefinition() || !type.ContainsGenericParameters())
			{
				return type.FullName;
			}
			return "{0}.{1}".FormatWith(CultureInfo.InvariantCulture, type.Namespace, type.Name);
		}

		protected virtual IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
		{
			List<MemberInfo> obj = GetSerializableMembers(type) ?? throw new JsonSerializationException("Null collection of serializable members returned.");
			DefaultJsonNameTable nameTable = GetNameTable();
			JsonPropertyCollection jsonPropertyCollection = new JsonPropertyCollection(type);
			foreach (MemberInfo item in obj)
			{
				JsonProperty jsonProperty = CreateProperty(item, memberSerialization);
				if (jsonProperty != null)
				{
					lock (nameTable)
					{
						jsonProperty.PropertyName = nameTable.Add(jsonProperty.PropertyName);
					}
					jsonPropertyCollection.AddProperty(jsonProperty);
				}
			}
			return jsonPropertyCollection.OrderBy((JsonProperty p) => p.Order ?? (-1)).ToList();
		}

		internal virtual DefaultJsonNameTable GetNameTable()
		{
			return _nameTable;
		}

		protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member)
		{
			return new ReflectionValueProvider(member);
		}

		protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)
		{
			JsonProperty jsonProperty = new JsonProperty();
			jsonProperty.PropertyType = ReflectionUtils.GetMemberUnderlyingType(member);
			jsonProperty.DeclaringType = member.DeclaringType;
			jsonProperty.ValueProvider = CreateMemberValueProvider(member);
			jsonProperty.AttributeProvider = new ReflectionAttributeProvider(member);
			SetPropertySettingsFromAttributes(jsonProperty, member, member.Name, member.DeclaringType, memberSerialization, out var allowNonPublicAccess);
			if (memberSerialization != MemberSerialization.Fields)
			{
				jsonProperty.Readable = ReflectionUtils.CanReadMemberValue(member, allowNonPublicAccess);
				jsonProperty.Writable = ReflectionUtils.CanSetMemberValue(member, allowNonPublicAccess, jsonProperty.HasMemberAttribute);
			}
			else
			{
				jsonProperty.Readable = true;
				jsonProperty.Writable = true;
			}
			if (!IgnoreShouldSerializeMembers)
			{
				jsonProperty.ShouldSerialize = CreateShouldSerializeTest(member);
			}
			if (!IgnoreIsSpecifiedMembers)
			{
				SetIsSpecifiedActions(jsonProperty, member, allowNonPublicAccess);
			}
			return jsonProperty;
		}

		private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, out bool allowNonPublicAccess)
		{
			DataContractAttribute? dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(declaringType);
			MemberInfo memberInfo = attributeProvider as MemberInfo;
			DataMemberAttribute dataMemberAttribute = ((dataContractAttribute == null || !(memberInfo != null)) ? null : JsonTypeReflector.GetDataMemberAttribute(memberInfo));
			JsonPropertyAttribute attribute = JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(attributeProvider);
			JsonRequiredAttribute? attribute2 = JsonTypeReflector.GetAttribute<JsonRequiredAttribute>(attributeProvider);
			string text;
			bool hasSpecifiedName;
			if (attribute != null && attribute.PropertyName != null)
			{
				text = attribute.PropertyName;
				hasSpecifiedName = true;
			}
			else if (dataMemberAttribute != null && dataMemberAttribute.Name != null)
			{
				text = dataMemberAttribute.Name;
				hasSpecifiedName = true;
			}
			else
			{
				text = name;
				hasSpecifiedName = false;
			}
			JsonContainerAttribute attribute3 = JsonTypeReflector.GetAttribute<JsonContainerAttribute>(declaringType);
			NamingStrategy namingStrategy = ((attribute?.NamingStrategyType != null) ? JsonTypeReflector.CreateNamingStrategyInstance(attribute.NamingStrategyType, attribute.NamingStrategyParameters) : ((!(attribute3?.NamingStrategyType != null)) ? NamingStrategy : JsonTypeReflector.GetContainerNamingStrategy(attribute3)));
			if (namingStrategy != null)
			{
				property.PropertyName = namingStrategy.GetPropertyName(text, hasSpecifiedName);
			}
			else
			{
				property.PropertyName = ResolvePropertyName(text);
			}
			property.UnderlyingName = name;
			bool flag = false;
			if (attribute != null)
			{
				property._required = attribute._required;
				property.Order = attribute._order;
				property.DefaultValueHandling = attribute._defaultValueHandling;
				flag = true;
				property.NullValueHandling = attribute._nullValueHandling;
				property.ReferenceLoopHandling = attribute._referenceLoopHandling;
				property.ObjectCreationHandling = attribute._objectCreationHandling;
				property.TypeNameHandling = attribute._typeNameHandling;
				property.IsReference = attribute._isReference;
				property.ItemIsReference = attribute._itemIsReference;
				property.ItemConverter = ((attribute.ItemConverterType != null) ? JsonTypeReflector.CreateJsonConverterInstance(attribute.ItemConverterType, attribute.ItemConverterParameters) : null);
				property.ItemReferenceLoopHandling = attribute._itemReferenceLoopHandling;
				property.ItemTypeNameHandling = attribute._itemTypeNameHandling;
			}
			else
			{
				property.NullValueHandling = null;
				property.ReferenceLoopHandling = null;
				property.ObjectCreationHandling = null;
				property.TypeNameHandling = null;
				property.IsReference = null;
				property.ItemIsReference = null;
				property.ItemConverter = null;
				property.ItemReferenceLoopHandling = null;
				property.ItemTypeNameHandling = null;
				if (dataMemberAttribute != null)
				{
					property._required = (dataMemberAttribute.IsRequired ? Required.AllowNull : Required.Default);
					property.Order = ((dataMemberAttribute.Order != -1) ? new int?(dataMemberAttribute.Order) : ((int?)null));
					property.DefaultValueHandling = ((!dataMemberAttribute.EmitDefaultValue) ? new DefaultValueHandling?(DefaultValueHandling.Ignore) : ((DefaultValueHandling?)null));
					flag = true;
				}
			}
			if (attribute2 != null)
			{
				property._required = Required.Always;
				flag = true;
			}
			property.HasMemberAttribute = flag;
			bool flag2 = JsonTypeReflector.GetAttribute<JsonIgnoreAttribute>(attributeProvider) != null || JsonTypeReflector.GetAttribute<JsonExtensionDataAttribute>(attributeProvider) != null || JsonTypeReflector.IsNonSerializable(attributeProvider);
			if (memberSerialization != MemberSerialization.OptIn)
			{
				bool flag3 = false;
				flag3 = JsonTypeReflector.GetAttribute<IgnoreDataMemberAttribute>(attributeProvider) != null;
				property.Ignored = flag2 || flag3;
			}
			else
			{
				property.Ignored = flag2 || !flag;
			}
			property.Converter = JsonTypeReflector.GetJsonConverter(attributeProvider);
			DefaultValueAttribute attribute4 = JsonTypeReflector.GetAttribute<DefaultValueAttribute>(attributeProvider);
			if (attribute4 != null)
			{
				property.DefaultValue = attribute4.Value;
			}
			allowNonPublicAccess = false;
			if ((DefaultMembersSearchFlags & BindingFlags.NonPublic) == BindingFlags.NonPublic)
			{
				allowNonPublicAccess = true;
			}
			if (flag)
			{
				allowNonPublicAccess = true;
			}
			if (memberSerialization == MemberSerialization.Fields)
			{
				allowNonPublicAccess = true;
			}
		}

		private Predicate<object>? CreateShouldSerializeTest(MemberInfo member)
		{
			MethodInfo method = member.DeclaringType.GetMethod("ShouldSerialize" + member.Name, ReflectionUtils.EmptyTypes);
			if (method == null || method.ReturnType != typeof(bool))
			{
				return null;
			}
			MethodCall<object, object?> shouldSerializeCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
			return (object o) => (bool)shouldSerializeCall(o);
		}

		private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess)
		{
			MemberInfo memberInfo = member.DeclaringType.GetProperty(member.Name + "Specified", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if (memberInfo == null)
			{
				memberInfo = member.DeclaringType.GetField(member.Name + "Specified", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			}
			if (!(memberInfo == null) && !(ReflectionUtils.GetMemberUnderlyingType(memberInfo) != typeof(bool)))
			{
				Func<object, object> specifiedPropertyGet = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(memberInfo);
				property.GetIsSpecified = (object o) => (bool)specifiedPropertyGet(o);
				if (ReflectionUtils.CanSetMemberValue(memberInfo, allowNonPublicAccess, canSetReadOnly: false))
				{
					property.SetIsSpecified = JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(memberInfo);
				}
			}
		}

		protected virtual string ResolvePropertyName(string propertyName)
		{
			if (NamingStrategy != null)
			{
				return NamingStrategy.GetPropertyName(propertyName, hasSpecifiedName: false);
			}
			return propertyName;
		}

		protected virtual string ResolveExtensionDataName(string extensionDataName)
		{
			if (NamingStrategy != null)
			{
				return NamingStrategy.GetExtensionDataName(extensionDataName);
			}
			return extensionDataName;
		}

		protected virtual string ResolveDictionaryKey(string dictionaryKey)
		{
			if (NamingStrategy != null)
			{
				return NamingStrategy.GetDictionaryKey(dictionaryKey);
			}
			return ResolvePropertyName(dictionaryKey);
		}

		public string GetResolvedPropertyName(string propertyName)
		{
			return ResolvePropertyName(propertyName);
		}
	}
	internal class DefaultNamingStrategy : NamingStrategy
	{
		protected override string ResolvePropertyName(string name)
		{
			return name;
		}
	}
	internal class DefaultReferenceResolver : IReferenceResolver
	{
		private int _referenceCount;

		private BidirectionalDictionary<string, object> GetMappings(object context)
		{
			JsonSerializerInternalBase jsonSerializerInternalBase = context as JsonSerializerInternalBase;
			if (jsonSerializerInternalBase == null)
			{
				if (!(context is JsonSerializerProxy jsonSerializerProxy))
				{
					throw new JsonException("The DefaultReferenceResolver can only be used internally.");
				}
				jsonSerializerInternalBase = jsonSerializerProxy.GetInternalSerializer();
			}
			return jsonSerializerInternalBase.DefaultReferenceMappings;
		}

		public object ResolveReference(object context, string reference)
		{
			GetMappings(context).TryGetByFirst(reference, out var second);
			return second;
		}

		public string GetReference(object context, object value)
		{
			BidirectionalDictionary<string, object> mappings = GetMappings(context);
			if (!mappings.TryGetBySecond(value, out var first))
			{
				_referenceCount++;
				first = _referenceCount.ToString(CultureInfo.InvariantCulture);
				mappings.Set(first, value);
			}
			return first;
		}

		public void AddReference(object context, string reference, object value)
		{
			GetMappings(context).Set(reference, value);
		}

		public bool IsReferenced(object context, object value)
		{
			string first;
			return GetMappings(context).TryGetBySecond(value, out first);
		}
	}
	internal class DefaultSerializationBinder : SerializationBinder, ISerializationBinder
	{
		internal static readonly DefaultSerializationBinder Instance = new DefaultSerializationBinder();

		private readonly ThreadSafeStore<StructMultiKey<string?, string>, Type> _typeCache;

		public DefaultSerializationBinder()
		{
			_typeCache = new ThreadSafeStore<StructMultiKey<string, string>, Type>(GetTypeFromTypeNameKey);
		}

		private Type GetTypeFromTypeNameKey(StructMultiKey<string?, string> typeNameKey)
		{
			string value = typeNameKey.Value1;
			string value2 = typeNameKey.Value2;
			if (value != null)
			{
				Assembly assembly = Assembly.LoadWithPartialName(value);
				if (assembly == null)
				{
					Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
					foreach (Assembly assembly2 in assemblies)
					{
						if (assembly2.FullName == value || assembly2.GetName().Name == value)
						{
							assembly = assembly2;
							break;
						}
					}
				}
				if (assembly == null)
				{
					throw new JsonSerializationException("Could not load assembly '{0}'.".FormatWith(CultureInfo.InvariantCulture, value));
				}
				Type type = assembly.GetType(value2);
				if (type == null)
				{
					if (value2.IndexOf('`') >= 0)
					{
						try
						{
							type = GetGenericTypeFromTypeName(value2, assembly);
						}
						catch (Exception innerException)
						{
							throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith(CultureInfo.InvariantCulture, value2, assembly.FullName), innerException);
						}
					}
					if (type == null)
					{
						throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith(CultureInfo.InvariantCulture, value2, assembly.FullName));
					}
				}
				return type;
			}
			return Type.GetType(value2);
		}

		private Type? GetGenericTypeFromTypeName(string typeName, Assembly assembly)
		{
			Type result = null;
			int num = typeName.IndexOf('[');
			if (num >= 0)
			{
				string name = typeName.Substring(0, num);
				Type type = assembly.GetType(name);
				if (type != null)
				{
					List<Type> list = new List<Type>();
					int num2 = 0;
					int num3 = 0;
					int num4 = typeName.Length - 1;
					for (int i = num + 1; i < num4; i++)
					{
						switch (typeName[i])
						{
						case '[':
							if (num2 == 0)
							{
								num3 = i + 1;
							}
							num2++;
							break;
						case ']':
							num2--;
							if (num2 == 0)
							{
								StructMultiKey<string, string> typeNameKey = ReflectionUtils.SplitFullyQualifiedTypeName(typeName.Substring(num3, i - num3));
								list.Add(GetTypeByName(typeNameKey));
							}
							break;
						}
					}
					result = type.MakeGenericType(list.ToArray());
				}
			}
			return result;
		}

		private Type GetTypeByName(StructMultiKey<string?, string> typeNameKey)
		{
			return _typeCache.Get(typeNameKey);
		}

		public override Type BindToType(string? assemblyName, string typeName)
		{
			return GetTypeByName(new StructMultiKey<string, string>(assemblyName, typeName));
		}

		public override void BindToName(Type serializedType, out string? assemblyName, out string? typeName)
		{
			assemblyName = serializedType.Assembly.FullName;
			typeName = serializedType.FullName;
		}
	}
	internal class DiagnosticsTraceWriter : ITraceWriter
	{
		public TraceLevel LevelFilter { get; set; }

		private TraceEventType GetTraceEventType(TraceLevel level)
		{
			return level switch
			{
				TraceLevel.Error => TraceEventType.Error, 
				TraceLevel.Warning => TraceEventType.Warning, 
				TraceLevel.Info => TraceEventType.Information, 
				TraceLevel.Verbose => TraceEventType.Verbose, 
				_ => throw new ArgumentOutOfRangeException("level"), 
			};
		}

		public void Trace(TraceLevel level, string message, Exception? ex)
		{
			if (level == TraceLevel.Off)
			{
				return;
			}
			TraceEventCache eventCache = new TraceEventCache();
			TraceEventType traceEventType = GetTraceEventType(level);
			foreach (TraceListener listener in System.Diagnostics.Trace.Listeners)
			{
				if (!listener.IsThreadSafe)
				{
					lock (listener)
					{
						listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
					}
				}
				else
				{
					listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
				}
				if (System.Diagnostics.Trace.AutoFlush)
				{
					listener.Flush();
				}
			}
		}
	}
	internal class ErrorContext
	{
		internal bool Traced { get; set; }

		public Exception Error { get; }

		public object? OriginalObject { get; }

		public object? Member { get; }

		public string Path { get; }

		public bool Handled { get; set; }

		internal ErrorContext(object? originalObject, object? member, string path, Exception error)
		{
			OriginalObject = originalObject;
			Member = member;
			Error = error;
			Path = path;
		}
	}
	internal class ErrorEventArgs : EventArgs
	{
		public object? CurrentObject { get; }

		public ErrorContext ErrorContext { get; }

		public ErrorEventArgs(object? currentObject, ErrorContext errorContext)
		{
			CurrentObject = currentObject;
			ErrorContext = errorContext;
		}
	}
	internal interface IAttributeProvider
	{
		IList<Attribute> GetAttributes(bool inherit);

		IList<Attribute> GetAttributes(Type attributeType, bool inherit);
	}
	internal interface IContractResolver
	{
		JsonContract ResolveContract(Type type);
	}
	internal interface IReferenceResolver
	{
		object ResolveReference(object context, string reference);

		string GetReference(object context, object value);

		bool IsReferenced(object context, object value);

		void AddReference(object context, string reference, object value);
	}
	internal interface ISerializationBinder
	{
		Type BindToType(string? assemblyName, string typeName);

		void BindToName(Type serializedType, out string? assemblyName, out string? typeName);
	}
	internal interface ITraceWriter
	{
		TraceLevel LevelFilter { get; }

		void Trace(TraceLevel level, string message, Exception? ex);
	}
	internal interface IValueProvider
	{
		void SetValue(object target, object? value);

		object? GetValue(object target);
	}
	internal class JsonArrayContract : JsonContainerContract
	{
		private readonly Type? _genericCollectionDefinitionType;

		private Type? _genericWrapperType;

		private ObjectConstructor<object>? _genericWrapperCreator;

		private Func<object>? _genericTemporaryCollectionCreator;

		private readonly ConstructorInfo? _parameterizedConstructor;

		private ObjectConstructor<object>? _parameterizedCreator;

		private ObjectConstructor<object>? _overrideCreator;

		public Type? CollectionItemType { get; }

		public bool IsMultidimensionalArray { get; }

		internal bool IsArray { get; }

		internal bool ShouldCreateWrapper { get; }

		internal bool CanDeserialize { get; private set; }

		internal ObjectConstructor<object>? ParameterizedCreator
		{
			get
			{
				if (_parameterizedCreator == null && _parameterizedConstructor != null)
				{
					_parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(_parameterizedConstructor);
				}
				return _parameterizedCreator;
			}
		}

		public ObjectConstructor<object>? OverrideCreator
		{
			get
			{
				return _overrideCreator;
			}
			set
			{
				_overrideCreator = value;
				CanDeserialize = true;
			}
		}

		public bool HasParameterizedCreator { get; set; }

		internal bool HasParameterizedCreatorInternal
		{
			get
			{
				if (!HasParameterizedCreator && _parameterizedCreator == null)
				{
					return _parameterizedConstructor != null;
				}
				return true;
			}
		}

		public JsonArrayContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Array;
			IsArray = base.CreatedType.IsArray || (NonNullableUnderlyingType.IsGenericType() && NonNullableUnderlyingType.GetGenericTypeDefinition().FullName == "System.Linq.EmptyPartition`1");
			bool canDeserialize;
			Type implementingType;
			if (IsArray)
			{
				CollectionItemType = ReflectionUtils.GetCollectionItemType(base.UnderlyingType);
				IsReadOnlyOrFixedSize = true;
				_genericCollectionDefinitionType = typeof(List<>).MakeGenericType(CollectionItemType);
				canDeserialize = true;
				IsMultidimensionalArray = base.CreatedType.IsArray && base.UnderlyingType.GetArrayRank() > 1;
			}
			else if (typeof(IList).IsAssignableFrom(NonNullableUnderlyingType))
			{
				if (ReflectionUtils.ImplementsGenericDefinition(NonNullableUnderlyingType, typeof(ICollection<>), out _genericCollectionDefinitionType))
				{
					CollectionItemType = _genericCollectionDefinitionType.GetGenericArguments()[0];
				}
				else
				{
					CollectionItemType = ReflectionUtils.GetCollectionItemType(NonNullableUnderlyingType);
				}
				if (NonNullableUnderlyingType == typeof(IList))
				{
					base.CreatedType = typeof(List<object>);
				}
				if (CollectionItemType != null)
				{
					_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(NonNullableUnderlyingType, CollectionItemType);
				}
				IsReadOnlyOrFixedSize = ReflectionUtils.InheritsGenericDefinition(NonNullableUnderlyingType, typeof(ReadOnlyCollection<>));
				canDeserialize = true;
			}
			else if (ReflectionUtils.ImplementsGenericDefinition(NonNullableUnderlyingType, typeof(ICollection<>), out _genericCollectionDefinitionType))
			{
				CollectionItemType = _genericCollectionDefinitionType.GetGenericArguments()[0];
				if (ReflectionUtils.IsGenericDefinition(NonNullableUnderlyingType, typeof(ICollection<>)) || ReflectionUtils.IsGenericDefinition(NonNullableUnderlyingType, typeof(IList<>)))
				{
					base.CreatedType = typeof(List<>).MakeGenericType(CollectionItemType);
				}
				if (ReflectionUtils.IsGenericDefinition(NonNullableUnderlyingType, typeof(ISet<>)))
				{
					base.CreatedType = typeof(HashSet<>).MakeGenericType(CollectionItemType);
				}
				_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(NonNullableUnderlyingType, CollectionItemType);
				canDeserialize = true;
				ShouldCreateWrapper = true;
			}
			else if (ReflectionUtils.ImplementsGenericDefinition(NonNullableUnderlyingType, typeof(IReadOnlyCollection<>), out implementingType))
			{
				CollectionItemType = implementingType.GetGenericArguments()[0];
				if (ReflectionUtils.IsGenericDefinition(NonNullableUnderlyingType, typeof(IReadOnlyCollection<>)) || ReflectionUtils.IsGenericDefinition(NonNullableUnderlyingType, typeof(IReadOnlyList<>)))
				{
					base.CreatedType = typeof(ReadOnlyCollection<>).MakeGenericType(CollectionItemType);
				}
				_genericCollectionDefinitionType = typeof(List<>).MakeGenericType(CollectionItemType);
				_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(base.CreatedType, CollectionItemType);
				StoreFSharpListCreatorIfNecessary(NonNullableUnderlyingType);
				IsReadOnlyOrFixedSize = true;
				canDeserialize = HasParameterizedCreatorInternal;
			}
			else if (ReflectionUtils.ImplementsGenericDefinition(NonNullableUnderlyingType, typeof(IEnumerable<>), out implementingType))
			{
				CollectionItemType = implementingType.GetGenericArguments()[0];
				if (ReflectionUtils.IsGenericDefinition(base.UnderlyingType, typeof(IEnumerable<>)))
				{
					base.CreatedType = typeof(List<>).MakeGenericType(CollectionItemType);
				}
				_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(NonNullableUnderlyingType, CollectionItemType);
				StoreFSharpListCreatorIfNecessary(NonNullableUnderlyingType);
				if (NonNullableUnderlyingType.IsGenericType() && NonNullableUnderlyingType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
				{
					_genericCollectionDefinitionType = implementingType;
					IsReadOnlyOrFixedSize = false;
					ShouldCreateWrapper = false;
					canDeserialize = true;
				}
				else
				{
					_genericCollectionDefinitionType = typeof(List<>).MakeGenericType(CollectionItemType);
					IsReadOnlyOrFixedSize = true;
					ShouldCreateWrapper = true;
					canDeserialize = HasParameterizedCreatorInternal;
				}
			}
			else
			{
				canDeserialize = false;
				ShouldCreateWrapper = true;
			}
			CanDeserialize = canDeserialize;
			if (CollectionItemType != null && ImmutableCollectionsUtils.TryBuildImmutableForArrayContract(NonNullableUnderlyingType, CollectionItemType, out Type createdType, out ObjectConstructor<object> parameterizedCreator))
			{
				base.CreatedType = createdType;
				_parameterizedCreator = parameterizedCreator;
				IsReadOnlyOrFixedSize = true;
				CanDeserialize = true;
			}
		}

		internal IWrappedCollection CreateWrapper(object list)
		{
			if (_genericWrapperCreator == null)
			{
				_genericWrapperType = typeof(CollectionWrapper<>).MakeGenericType(CollectionItemType);
				Type type = ((!ReflectionUtils.InheritsGenericDefinition(_genericCollectionDefinitionType, typeof(List<>)) && !(_genericCollectionDefinitionType.GetGenericTypeDefinition() == typeof(IEnumerable<>))) ? _genericCollectionDefinitionType : typeof(ICollection<>).MakeGenericType(CollectionItemType));
				ConstructorInfo constructor = _genericWrapperType.GetConstructor(new Type[1] { type });
				_genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(constructor);
			}
			return (IWrappedCollection)_genericWrapperCreator(list);
		}

		internal IList CreateTemporaryCollection()
		{
			if (_genericTemporaryCollectionCreator == null)
			{
				Type type = ((IsMultidimensionalArray || CollectionItemType == null) ? typeof(object) : CollectionItemType);
				Type type2 = typeof(List<>).MakeGenericType(type);
				_genericTemporaryCollectionCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type2);
			}
			return (IList)_genericTemporaryCollectionCreator();
		}

		private void StoreFSharpListCreatorIfNecessary(Type underlyingType)
		{
			if (!HasParameterizedCreatorInternal && underlyingType.Name == "FSharpList`1")
			{
				FSharpUtils.EnsureInitialized(underlyingType.Assembly());
				_parameterizedCreator = FSharpUtils.Instance.CreateSeq(CollectionItemType);
			}
		}
	}
	internal class JsonContainerContract : JsonContract
	{
		private JsonContract? _itemContract;

		private JsonContract? _finalItemContract;

		internal JsonContract? ItemContract
		{
			get
			{
				return _itemContract;
			}
			set
			{
				_itemContract = value;
				if (_itemContract != null)
				{
					_finalItemContract = (_itemContract.UnderlyingType.IsSealed() ? _itemContract : null);
				}
				else
				{
					_finalItemContract = null;
				}
			}
		}

		internal JsonContract? FinalItemContract => _finalItemContract;

		public JsonConverter? ItemConverter { get; set; }

		public bool? ItemIsReference { get; set; }

		public ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }

		public TypeNameHandling? ItemTypeNameHandling { get; set; }

		internal JsonContainerContract(Type underlyingType)
			: base(underlyingType)
		{
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(underlyingType);
			if (cachedAttribute != null)
			{
				if (cachedAttribute.ItemConverterType != null)
				{
					ItemConverter = JsonTypeReflector.CreateJsonConverterInstance(cachedAttribute.ItemConverterType, cachedAttribute.ItemConverterParameters);
				}
				ItemIsReference = cachedAttribute._itemIsReference;
				ItemReferenceLoopHandling = cachedAttribute._itemReferenceLoopHandling;
				ItemTypeNameHandling = cachedAttribute._itemTypeNameHandling;
			}
		}
	}
	internal enum JsonContractType
	{
		None,
		Object,
		Array,
		Primitive,
		String,
		Dictionary,
		Dynamic,
		Serializable,
		Linq
	}
	internal delegate void SerializationCallback(object o, StreamingContext context);
	internal delegate void SerializationErrorCallback(object o, StreamingContext context, ErrorContext errorContext);
	internal delegate void ExtensionDataSetter(object o, string key, object? value);
	internal delegate IEnumerable<KeyValuePair<object, object>>? ExtensionDataGetter(object o);
	internal abstract class JsonContract
	{
		internal bool IsNullable;

		internal bool IsConvertable;

		internal bool IsEnum;

		internal Type NonNullableUnderlyingType;

		internal ReadType InternalReadType;

		internal JsonContractType ContractType;

		internal bool IsReadOnlyOrFixedSize;

		internal bool IsSealed;

		internal bool IsInstantiable;

		private List<SerializationCallback>? _onDeserializedCallbacks;

		private List<SerializationCallback>? _onDeserializingCallbacks;

		private List<SerializationCallback>? _onSerializedCallbacks;

		private List<SerializationCallback>? _onSerializingCallbacks;

		private List<SerializationErrorCallback>? _onErrorCallbacks;

		private Type _createdType;

		public Type UnderlyingType { get; }

		public Type CreatedType
		{
			get
			{
				return _createdType;
			}
			set
			{
				ValidationUtils.ArgumentNotNull(value, "value");
				_createdType = value;
				IsSealed = _createdType.IsSealed();
				IsInstantiable = !_createdType.IsInterface() && !_createdType.IsAbstract();
			}
		}

		public bool? IsReference { get; set; }

		public JsonConverter? Converter { get; set; }

		public JsonConverter? InternalConverter { get; internal set; }

		public IList<SerializationCallback> OnDeserializedCallbacks
		{
			get
			{
				if (_onDeserializedCallbacks == null)
				{
					_onDeserializedCallbacks = new List<SerializationCallback>();
				}
				return _onDeserializedCallbacks;
			}
		}

		public IList<SerializationCallback> OnDeserializingCallbacks
		{
			get
			{
				if (_onDeserializingCallbacks == null)
				{
					_onDeserializingCallbacks = new List<SerializationCallback>();
				}
				return _onDeserializingCallbacks;
			}
		}

		public IList<SerializationCallback> OnSerializedCallbacks
		{
			get
			{
				if (_onSerializedCallbacks == null)
				{
					_onSerializedCallbacks = new List<SerializationCallback>();
				}
				return _onSerializedCallbacks;
			}
		}

		public IList<SerializationCallback> OnSerializingCallbacks
		{
			get
			{
				if (_onSerializingCallbacks == null)
				{
					_onSerializingCallbacks = new List<SerializationCallback>();
				}
				return _onSerializingCallbacks;
			}
		}

		public IList<SerializationErrorCallback> OnErrorCallbacks
		{
			get
			{
				if (_onErrorCallbacks == null)
				{
					_onErrorCallbacks = new List<SerializationErrorCallback>();
				}
				return _onErrorCallbacks;
			}
		}

		public Func<object>? DefaultCreator { get; set; }

		public bool DefaultCreatorNonPublic { get; set; }

		internal JsonContract(Type underlyingType)
		{
			ValidationUtils.ArgumentNotNull(underlyingType, "underlyingType");
			UnderlyingType = underlyingType;
			underlyingType = ReflectionUtils.EnsureNotByRefType(underlyingType);
			IsNullable = ReflectionUtils.IsNullable(underlyingType);
			NonNullableUnderlyingType = ((IsNullable && ReflectionUtils.IsNullableType(underlyingType)) ? Nullable.GetUnderlyingType(underlyingType) : underlyingType);
			_createdType = (CreatedType = NonNullableUnderlyingType);
			IsConvertable = ConvertUtils.IsConvertible(NonNullableUnderlyingType);
			IsEnum = NonNullableUnderlyingType.IsEnum();
			InternalReadType = ReadType.Read;
		}

		internal void InvokeOnSerializing(object o, StreamingContext context)
		{
			if (_onSerializingCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onSerializingCallback in _onSerializingCallbacks)
			{
				onSerializingCallback(o, context);
			}
		}

		internal void InvokeOnSerialized(object o, StreamingContext context)
		{
			if (_onSerializedCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onSerializedCallback in _onSerializedCallbacks)
			{
				onSerializedCallback(o, context);
			}
		}

		internal void InvokeOnDeserializing(object o, StreamingContext context)
		{
			if (_onDeserializingCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onDeserializingCallback in _onDeserializingCallbacks)
			{
				onDeserializingCallback(o, context);
			}
		}

		internal void InvokeOnDeserialized(object o, StreamingContext context)
		{
			if (_onDeserializedCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onDeserializedCallback in _onDeserializedCallbacks)
			{
				onDeserializedCallback(o, context);
			}
		}

		internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext)
		{
			if (_onErrorCallbacks == null)
			{
				return;
			}
			foreach (SerializationErrorCallback onErrorCallback in _onErrorCallbacks)
			{
				onErrorCallback(o, context, errorContext);
			}
		}

		internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo)
		{
			return delegate(object o, StreamingContext context)
			{
				callbackMethodInfo.Invoke(o, new object[1] { context });
			};
		}

		internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo)
		{
			return delegate(object o, StreamingContext context, ErrorContext econtext)
			{
				callbackMethodInfo.Invoke(o, new object[2] { context, econtext });
			};
		}
	}
	internal class JsonDictionaryContract : JsonContainerContract
	{
		private readonly Type? _genericCollectionDefinitionType;

		private Type? _genericWrapperType;

		private ObjectConstructor<object>? _genericWrapperCreator;

		private Func<object>? _genericTemporaryDictionaryCreator;

		private readonly ConstructorInfo? _parameterizedConstructor;

		private ObjectConstructor<object>? _overrideCreator;

		private ObjectConstructor<object>? _parameterizedCreator;

		public Func<string, string>? DictionaryKeyResolver { get; set; }

		public Type? DictionaryKeyType { get; }

		public Type? DictionaryValueType { get; }

		internal JsonContract? KeyContract { get; set; }

		internal bool ShouldCreateWrapper { get; }

		internal ObjectConstructor<object>? ParameterizedCreator
		{
			get
			{
				if (_parameterizedCreator == null && _parameterizedConstructor != null)
				{
					_parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(_parameterizedConstructor);
				}
				return _parameterizedCreator;
			}
		}

		public ObjectConstructor<object>? OverrideCreator
		{
			get
			{
				return _overrideCreator;
			}
			set
			{
				_overrideCreator = value;
			}
		}

		public bool HasParameterizedCreator { get; set; }

		internal bool HasParameterizedCreatorInternal
		{
			get
			{
				if (!HasParameterizedCreator && _parameterizedCreator == null)
				{
					return _parameterizedConstructor != null;
				}
				return true;
			}
		}

		public JsonDictionaryContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Dictionary;
			Type keyType;
			Type valueType;
			if (ReflectionUtils.ImplementsGenericDefinition(NonNullableUnderlyingType, typeof(IDictionary<, >), out _genericCollectionDefinitionType))
			{
				keyType = _genericCollectionDefinitionType.GetGenericArguments()[0];
				valueType = _genericCollectionDefinitionType.GetGenericArguments()[1];
				if (ReflectionUtils.IsGenericDefinition(NonNullableUnderlyingType, typeof(IDictionary<, >)))
				{
					base.CreatedType = typeof(Dictionary<, >).MakeGenericType(keyType, valueType);
				}
				else if (NonNullableUnderlyingType.IsGenericType() && NonNullableUnderlyingType.GetGenericTypeDefinition().FullName == "System.Collections.Concurrent.ConcurrentDictionary`2")
				{
					ShouldCreateWrapper = true;
				}
				IsReadOnlyOrFixedSize = ReflectionUtils.InheritsGenericDefinition(NonNullableUnderlyingType, typeof(ReadOnlyDictionary<, >));
			}
			else if (ReflectionUtils.ImplementsGenericDefinition(NonNullableUnderlyingType, typeof(IReadOnlyDictionary<, >), out _genericCollectionDefinitionType))
			{
				keyType = _genericCollectionDefinitionType.GetGenericArguments()[0];
				valueType = _genericCollectionDefinitionType.GetGenericArguments()[1];
				if (ReflectionUtils.IsGenericDefinition(NonNullableUnderlyingType, typeof(IReadOnlyDictionary<, >)))
				{
					base.CreatedType = typeof(ReadOnlyDictionary<, >).MakeGenericType(keyType, valueType);
				}
				IsReadOnlyOrFixedSize = true;
			}
			else
			{
				ReflectionUtils.GetDictionaryKeyValueTypes(NonNullableUnderlyingType, out keyType, out valueType);
				if (NonNullableUnderlyingType == typeof(IDictionary))
				{
					base.CreatedType = typeof(Dictionary<object, object>);
				}
			}
			if (keyType != null && valueType != null)
			{
				_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(base.CreatedType, typeof(KeyValuePair<, >).MakeGenericType(keyType, valueType), typeof(IDictionary<, >).MakeGenericType(keyType, valueType));
				if (!HasParameterizedCreatorInternal && NonNullableUnderlyingType.Name == "FSharpMap`2")
				{
					FSharpUtils.EnsureInitialized(NonNullableUnderlyingType.Assembly());
					_parameterizedCreator = FSharpUtils.Instance.CreateMap(keyType, valueType);
				}
			}
			if (!typeof(IDictionary).IsAssignableFrom(base.CreatedType))
			{
				ShouldCreateWrapper = true;
			}
			DictionaryKeyType = keyType;
			DictionaryValueType = valueType;
			if (DictionaryKeyType != null && DictionaryValueType != null && ImmutableCollectionsUtils.TryBuildImmutableForDictionaryContract(NonNullableUnderlyingType, DictionaryKeyType, DictionaryValueType, out Type createdType, out ObjectConstructor<object> parameterizedCreator))
			{
				base.CreatedType = createdType;
				_parameterizedCreator = parameterizedCreator;
				IsReadOnlyOrFixedSize = true;
			}
		}

		internal IWrappedDictionary CreateWrapper(object dictionary)
		{
			if (_genericWrapperCreator == null)
			{
				_genericWrapperType = typeof(DictionaryWrapper<, >).MakeGenericType(DictionaryKeyType, DictionaryValueType);
				ConstructorInfo constructor = _genericWrapperType.GetConstructor(new Type[1] { _genericCollectionDefinitionType });
				_genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(constructor);
			}
			return (IWrappedDictionary)_genericWrapperCreator(dictionary);
		}

		internal IDictionary CreateTemporaryDictionary()
		{
			if (_genericTemporaryDictionaryCreator == null)
			{
				Type type = typeof(Dictionary<, >).MakeGenericType(DictionaryKeyType ?? typeof(object), DictionaryValueType ?? typeof(object));
				_genericTemporaryDictionaryCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type);
			}
			return (IDictionary)_genericTemporaryDictionaryCreator();
		}
	}
	internal class JsonDynamicContract : JsonContainerContract
	{
		private readonly ThreadSafeStore<string, CallSite<Func<CallSite, object, object>>> _callSiteGetters = new ThreadSafeStore<string, CallSite<Func<CallSite, object, object>>>(CreateCallSiteGetter);

		private readonly ThreadSafeStore<string, CallSite<Func<CallSite, object, object?, object>>> _callSiteSetters = new ThreadSafeStore<string, CallSite<Func<CallSite, object, object, object>>>(CreateCallSiteSetter);

		public JsonPropertyCollection Properties { get; }

		public Func<string, string>? PropertyNameResolver { get; set; }

		private static CallSite<Func<CallSite, object, object>> CreateCallSiteGetter(string name)
		{
			return CallSite<Func<CallSite, object, object>>.Create(new NoThrowGetBinderMember((GetMemberBinder)DynamicUtils.BinderWrapper.GetMember(name, typeof(DynamicUtils))));
		}

		private static CallSite<Func<CallSite, object, object?, object>> CreateCallSiteSetter(string name)
		{
			return CallSite<Func<CallSite, object, object, object>>.Create(new NoThrowSetBinderMember((SetMemberBinder)DynamicUtils.BinderWrapper.SetMember(name, typeof(DynamicUtils))));
		}

		public JsonDynamicContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Dynamic;
			Properties = new JsonPropertyCollection(base.UnderlyingType);
		}

		internal bool TryGetMember(IDynamicMetaObjectProvider dynamicProvider, string name, out object? value)
		{
			ValidationUtils.ArgumentNotNull(dynamicProvider, "dynamicProvider");
			CallSite<Func<CallSite, object, object>> callSite = _callSiteGetters.Get(name);
			object obj = callSite.Target(callSite, dynamicProvider);
			if (obj != NoThrowExpressionVisitor.ErrorResult)
			{
				value = obj;
				return true;
			}
			value = null;
			return false;
		}

		internal bool TrySetMember(IDynamicMetaObjectProvider dynamicProvider, string name, object? value)
		{
			ValidationUtils.ArgumentNotNull(dynamicProvider, "dynamicProvider");
			CallSite<Func<CallSite, object, object, object>> callSite = _callSiteSetters.Get(name);
			return callSite.Target(callSite, dynamicProvider, value) != NoThrowExpressionVisitor.ErrorResult;
		}
	}
	internal class JsonFormatterConverter : IFormatterConverter
	{
		private readonly JsonSerializerInternalReader _reader;

		private readonly JsonISerializableContract _contract;

		private readonly JsonProperty? _member;

		public JsonFormatterConverter(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty? member)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			ValidationUtils.ArgumentNotNull(contract, "contract");
			_reader = reader;
			_contract = contract;
			_member = member;
		}

		private T GetTokenValue<T>(object value)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			return (T)System.Convert.ChangeType(((JValue)value).Value, typeof(T), CultureInfo.InvariantCulture);
		}

		public object? Convert(object value, Type type)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			if (!(value is JToken token))
			{
				throw new ArgumentException("Value is not a JToken.", "value");
			}
			return _reader.CreateISerializableItem(token, type, _contract, _member);
		}

		public object Convert(object value, TypeCode typeCode)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			return System.Convert.ChangeType((value is JValue jValue) ? jValue.Value : value, typeCode, CultureInfo.InvariantCulture);
		}

		public bool ToBoolean(object value)
		{
			return GetTokenValue<bool>(value);
		}

		public byte ToByte(object value)
		{
			return GetTokenValue<byte>(value);
		}

		public char ToChar(object value)
		{
			return GetTokenValue<char>(value);
		}

		public DateTime ToDateTime(object value)
		{
			return GetTokenValue<DateTime>(value);
		}

		public decimal ToDecimal(object value)
		{
			return GetTokenValue<decimal>(value);
		}

		public double ToDouble(object value)
		{
			return GetTokenValue<double>(value);
		}

		public short ToInt16(object value)
		{
			return GetTokenValue<short>(value);
		}

		public int ToInt32(object value)
		{
			return GetTokenValue<int>(value);
		}

		public long ToInt64(object value)
		{
			return GetTokenValue<long>(value);
		}

		public sbyte ToSByte(object value)
		{
			return GetTokenValue<sbyte>(value);
		}

		public float ToSingle(object value)
		{
			return GetTokenValue<float>(value);
		}

		public string ToString(object value)
		{
			return GetTokenValue<string>(value);
		}

		public ushort ToUInt16(object value)
		{
			return GetTokenValue<ushort>(value);
		}

		public uint ToUInt32(object value)
		{
			return GetTokenValue<uint>(value);
		}

		public ulong ToUInt64(object value)
		{
			return GetTokenValue<ulong>(value);
		}
	}
	internal class JsonISerializableContract : JsonContainerContract
	{
		public ObjectConstructor<object>? ISerializableCreator { get; set; }

		public JsonISerializableContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Serializable;
		}
	}
	internal class JsonLinqContract : JsonContract
	{
		public JsonLinqContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Linq;
		}
	}
	internal class JsonObjectContract : JsonContainerContract
	{
		internal bool ExtensionDataIsJToken;

		private bool? _hasRequiredOrDefaultValueProperties;

		private ObjectConstructor<object>? _overrideCreator;

		private ObjectConstructor<object>? _parameterizedCreator;

		private JsonPropertyCollection? _creatorParameters;

		private Type? _extensionDataValueType;

		public MemberSerialization MemberSerialization { get; set; }

		public MissingMemberHandling? MissingMemberHandling { get; set; }

		public Required? ItemRequired { get; set; }

		public NullValueHandling? ItemNullValueHandling { get; set; }

		public JsonPropertyCollection Properties { get; }

		public JsonPropertyCollection CreatorParameters
		{
			get
			{
				if (_creatorParameters == null)
				{
					_creatorParameters = new JsonPropertyCollection(base.UnderlyingType);
				}
				return _creatorParameters;
			}
		}

		public ObjectConstructor<object>? OverrideCreator
		{
			get
			{
				return _overrideCreator;
			}
			set
			{
				_overrideCreator = value;
			}
		}

		internal ObjectConstructor<object>? ParameterizedCreator
		{
			get
			{
				return _parameterizedCreator;
			}
			set
			{
				_parameterizedCreator = value;
			}
		}

		public ExtensionDataSetter? ExtensionDataSetter { get; set; }

		public ExtensionDataGetter? ExtensionDataGetter { get; set; }

		public Type? ExtensionDataValueType
		{
			get
			{
				return _extensionDataValueType;
			}
			set
			{
				_extensionDataValueType = value;
				ExtensionDataIsJToken = value != null && typeof(JToken).IsAssignableFrom(value);
			}
		}

		public Func<string, string>? ExtensionDataNameResolver { get; set; }

		internal bool HasRequiredOrDefaultValueProperties
		{
			get
			{
				if (!_hasRequiredOrDefaultValueProperties.HasValue)
				{
					_hasRequiredOrDefaultValueProperties = false;
					if ((ItemRequired ?? Required.Default) != Required.Default)
					{
						_hasRequiredOrDefaultValueProperties = true;
					}
					else
					{
						foreach (JsonProperty property in Properties)
						{
							if (property.Required != Required.Default || ((uint?)property.DefaultValueHandling & 2u) == 2)
							{
								_hasRequiredOrDefaultValueProperties = true;
								break;
							}
						}
					}
				}
				return _hasRequiredOrDefaultValueProperties == true;
			}
		}

		public JsonObjectContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Object;
			Properties = new JsonPropertyCollection(base.UnderlyingType);
		}

		[SecuritySafeCritical]
		internal object GetUninitializedObject()
		{
			if (!JsonTypeReflector.FullyTrusted)
			{
				throw new JsonException("Insufficient permissions. Creating an uninitialized '{0}' type requires full trust.".FormatWith(CultureInfo.InvariantCulture, NonNullableUnderlyingType));
			}
			return FormatterServices.GetUninitializedObject(NonNullableUnderlyingType);
		}
	}
	internal class JsonPrimitiveContract : JsonContract
	{
		private static readonly Dictionary<Type, ReadType> ReadTypeMap = new Dictionary<Type, ReadType>
		{
			[typeof(byte[])] = ReadType.ReadAsBytes,
			[typeof(byte)] = ReadType.ReadAsInt32,
			[typeof(short)] = ReadType.ReadAsInt32,
			[typeof(int)] = ReadType.ReadAsInt32,
			[typeof(decimal)] = ReadType.ReadAsDecimal,
			[typeof(bool)] = ReadType.ReadAsBoolean,
			[typeof(string)] = ReadType.ReadAsString,
			[typeof(DateTime)] = ReadType.ReadAsDateTime,
			[typeof(DateTimeOffset)] = ReadType.ReadAsDateTimeOffset,
			[typeof(float)] = ReadType.ReadAsDouble,
			[typeof(double)] = ReadType.ReadAsDouble,
			[typeof(long)] = ReadType.ReadAsInt64
		};

		internal PrimitiveTypeCode TypeCode { get; set; }

		public JsonPrimitiveContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Primitive;
			TypeCode = ConvertUtils.GetTypeCode(underlyingType);
			IsReadOnlyOrFixedSize = true;
			if (ReadTypeMap.TryGetValue(NonNullableUnderlyingType, out var value))
			{
				InternalReadType = value;
			}
		}
	}
	internal class JsonProperty
	{
		internal Required? _required;

		internal bool _hasExplicitDefaultValue;

		private object? _defaultValue;

		private bool _hasGeneratedDefaultValue;

		private string? _propertyName;

		internal bool _skipPropertyNameEscape;

		private Type? _propertyType;

		internal JsonContract? PropertyContract { get; set; }

		public string? PropertyName
		{
			get
			{
				return _propertyName;
			}
			set
			{
				_propertyName = value;
				_skipPropertyNameEscape = !JavaScriptUtils.ShouldEscapeJavaScriptString(_propertyName, JavaScriptUtils.HtmlCharEscapeFlags);
			}
		}

		public Type? DeclaringType { get; set; }

		public int? Order { get; set; }

		public string? UnderlyingName { get; set; }

		public IValueProvider? ValueProvider { get; set; }

		public IAttributeProvider? AttributeProvider { get; set; }

		public Type? PropertyType
		{
			get
			{
				return _propertyType;
			}
			set
			{
				if (_propertyType != value)
				{
					_propertyType = value;
					_hasGeneratedDefaultValue = false;
				}
			}
		}

		public JsonConverter? Converter { get; set; }

		[Obsolete("MemberConverter is obsolete. Use Converter instead.")]
		public JsonConverter? MemberConverter
		{
			get
			{
				return Converter;
			}
			set
			{
				Converter = value;
			}
		}

		public bool Ignored { get; set; }

		public bool Readable { get; set; }

		public bool Writable { get; set; }

		public bool HasMemberAttribute { get; set; }

		public object? DefaultValue
		{
			get
			{
				if (!_hasExplicitDefaultValue)
				{
					return null;
				}
				return _defaultValue;
			}
			set
			{
				_hasExplicitDefaultValue = true;
				_defaultValue = value;
			}
		}

		public Required Required
		{
			get
			{
				return _required.GetValueOrDefault();
			}
			set
			{
				_required = value;
			}
		}

		public bool IsRequiredSpecified => _required.HasValue;

		public bool? IsReference { get; set; }

		public NullValueHandling? NullValueHandling { get; set; }

		public DefaultValueHandling? DefaultValueHandling { get; set; }

		public ReferenceLoopHandling? ReferenceLoopHandling { get; set; }

		public ObjectCreationHandling? ObjectCreationHandling { get; set; }

		public TypeNameHandling? TypeNameHandling { get; set; }

		public Predicate<object>? ShouldSerialize { get; set; }

		public Predicate<object>? ShouldDeserialize { get; set; }

		public Predicate<object>? GetIsSpecified { get; set; }

		public Action<object, object?>? SetIsSpecified { get; set; }

		public JsonConverter? ItemConverter { get; set; }

		public bool? ItemIsReference { get; set; }

		public TypeNameHandling? ItemTypeNameHandling { get; set; }

		public ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }

		internal object? GetResolvedDefaultValue()
		{
			if (_propertyType == null)
			{
				return null;
			}
			if (!_hasExplicitDefaultValue && !_hasGeneratedDefaultValue)
			{
				_defaultValue = ReflectionUtils.GetDefaultValue(_propertyType);
				_hasGeneratedDefaultValue = true;
			}
			return _defaultValue;
		}

		public override string ToString()
		{
			return PropertyName ?? string.Empty;
		}

		internal void WritePropertyName(JsonWriter writer)
		{
			string propertyName = PropertyName;
			if (_skipPropertyNameEscape)
			{
				writer.WritePropertyName(propertyName, escape: false);
			}
			else
			{
				writer.WritePropertyName(propertyName);
			}
		}
	}
	internal class JsonPropertyCollection : KeyedCollection<string, JsonProperty>
	{
		private readonly Type _type;

		private readonly List<JsonProperty> _list;

		public JsonPropertyCollection(Type type)
			: base((IEqualityComparer<string>)StringComparer.Ordinal)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			_type = type;
			_list = (List<JsonProperty>)base.Items;
		}

		protected override string GetKeyForItem(JsonProperty item)
		{
			return item.PropertyName;
		}

		public void AddProperty(JsonProperty property)
		{
			if (Contains(property.PropertyName))
			{
				if (property.Ignored)
				{
					return;
				}
				JsonProperty jsonProperty = base[property.PropertyName];
				bool flag = true;
				if (jsonProperty.Ignored)
				{
					Remove(jsonProperty);
					flag = false;
				}
				else if (property.DeclaringType != null && jsonProperty.DeclaringType != null)
				{
					if (property.DeclaringType.IsSubclassOf(jsonProperty.DeclaringType) || (jsonProperty.DeclaringType.IsInterface() && property.DeclaringType.ImplementInterface(jsonProperty.DeclaringType)))
					{
						Remove(jsonProperty);
						flag = false;
					}
					if (jsonProperty.DeclaringType.IsSubclassOf(property.DeclaringType) || (property.DeclaringType.IsInterface() && jsonProperty.DeclaringType.ImplementInterface(property.DeclaringType)) || (_type.ImplementInterface(jsonProperty.DeclaringType) && _type.ImplementInterface(property.DeclaringType)))
					{
						return;
					}
				}
				if (flag)
				{
					throw new JsonSerializationException("A member with the name '{0}' already exists on '{1}'. Use the JsonPropertyAttribute to specify another name.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, _type));
				}
			}
			Add(property);
		}

		public JsonProperty? GetClosestMatchProperty(string propertyName)
		{
			JsonProperty property = GetProperty(propertyName, StringComparison.Ordinal);
			if (property == null)
			{
				property = GetProperty(propertyName, StringComparison.OrdinalIgnoreCase);
			}
			return property;
		}

		private new bool TryGetValue(string key, [NotNullWhen(true)] out JsonProperty? item)
		{
			if (base.Dictionary == null)
			{
				item = null;
				return false;
			}
			return base.Dictionary.TryGetValue(key, out item);
		}

		public JsonProperty? GetProperty(string propertyName, StringComparison comparisonType)
		{
			if (comparisonType == StringComparison.Ordinal)
			{
				if (TryGetValue(propertyName, out JsonProperty item))
				{
					return item;
				}
				return null;
			}
			for (int i = 0; i < _list.Count; i++)
			{
				JsonProperty jsonProperty = _list[i];
				if (string.Equals(propertyName, jsonProperty.PropertyName, comparisonType))
				{
					return jsonProperty;
				}
			}
			return null;
		}
	}
	internal abstract class JsonSerializerInternalBase
	{
		private class ReferenceEqualsEqualityComparer : IEqualityComparer<object>
		{
			bool IEqualityComparer<object>.Equals(object x, object y)
			{
				return x == y;
			}

			int IEqualityComparer<object>.GetHashCode(object obj)
			{
				return RuntimeHelpers.GetHashCode(obj);
			}
		}

		private ErrorContext? _currentErrorContext;

		private BidirectionalDictionary<string, object>? _mappings;

		internal readonly JsonSerializer Serializer;

		internal readonly ITraceWriter? TraceWriter;

		protected JsonSerializerProxy? InternalSerializer;

		internal BidirectionalDictionary<string, object> DefaultReferenceMappings
		{
			get
			{
				if (_mappings == null)
				{
					_mappings = new BidirectionalDictionary<string, object>(EqualityComparer<string>.Default, new ReferenceEqualsEqualityComparer(), "A different value already has the Id '{0}'.", "A different Id has already been assigned for value '{0}'. This error may be caused by an object being reused multiple times during deserialization and can be fixed with the setting ObjectCreationHandling.Replace.");
				}
				return _mappings;
			}
		}

		protected JsonSerializerInternalBase(JsonSerializer serializer)
		{
			ValidationUtils.ArgumentNotNull(serializer, "serializer");
			Serializer = serializer;
			TraceWriter = serializer.TraceWriter;
		}

		protected NullValueHandling ResolvedNullValueHandling(JsonObjectContract? containerContract, JsonProperty property)
		{
			return property.NullValueHandling ?? containerContract?.ItemNullValueHandling ?? Serializer._nullValueHandling;
		}

		private ErrorContext GetErrorContext(object? currentObject, object? member, string path, Exception error)
		{
			if (_currentErrorContext == null)
			{
				_currentErrorContext = new ErrorContext(currentObject, member, path, error);
			}
			if (_currentErrorContext.Error != error)
			{
				throw new InvalidOperationException("Current error context error is different to requested error.");
			}
			return _currentErrorContext;
		}

		protected void ClearErrorContext()
		{
			if (_currentErrorContext == null)
			{
				throw new InvalidOperationException("Could not clear error context. Error context is already null.");
			}
			_currentErrorContext = null;
		}

		protected bool IsErrorHandled(object? currentObject, JsonContract? contract, object? keyValue, IJsonLineInfo? lineInfo, string path, Exception ex)
		{
			ErrorContext errorContext = GetErrorContext(currentObject, keyValue, path, ex);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Error && !errorContext.Traced)
			{
				errorContext.Traced = true;
				string text = ((GetType() == typeof(JsonSerializerInternalWriter)) ? "Error serializing" : "Error deserializing");
				if (contract != null)
				{
					text = text + " " + contract.UnderlyingType;
				}
				text = text + ". " + ex.Message;
				if (!(ex is JsonException))
				{
					text = JsonPosition.FormatMessage(lineInfo, path, text);
				}
				TraceWriter.Trace(TraceLevel.Error, text, ex);
			}
			if (contract != null && currentObject != null)
			{
				contract.InvokeOnError(currentObject, Serializer.Context, errorContext);
			}
			if (!errorContext.Handled)
			{
				Serializer.OnError(new ErrorEventArgs(currentObject, errorContext));
			}
			return errorContext.Handled;
		}
	}
	internal class JsonSerializerInternalReader : JsonSerializerInternalBase
	{
		internal enum PropertyPresence
		{
			None,
			Null,
			Value
		}

		internal class CreatorPropertyContext
		{
			public readonly string Name;

			public JsonProperty? Property;

			public JsonProperty? ConstructorProperty;

			public PropertyPresence? Presence;

			public object? Value;

			public bool Used;

			public CreatorPropertyContext(string name)
			{
				Name = name;
			}
		}

		public JsonSerializerInternalReader(JsonSerializer serializer)
			: base(serializer)
		{
		}

		public void Populate(JsonReader reader, object target)
		{
			ValidationUtils.ArgumentNotNull(target, "target");
			Type type = target.GetType();
			JsonContract jsonContract = Serializer._contractResolver.ResolveContract(type);
			if (!reader.MoveToContent())
			{
				throw JsonSerializationException.Create(reader, "No JSON content found.");
			}
			if (reader.TokenType == JsonToken.StartArray)
			{
				if (jsonContract.ContractType == JsonContractType.Array)
				{
					JsonArrayContract jsonArrayContract = (JsonArrayContract)jsonContract;
					object list;
					if (!jsonArrayContract.ShouldCreateWrapper)
					{
						list = (IList)target;
					}
					else
					{
						IList list2 = jsonArrayContract.CreateWrapper(target);
						list = list2;
					}
					PopulateList((IList)list, reader, jsonArrayContract, null, null);
					return;
				}
				throw JsonSerializationException.Create(reader, "Cannot populate JSON array onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture, type));
			}
			if (reader.TokenType == JsonToken.StartObject)
			{
				reader.ReadAndAssert();
				string id = null;
				if (Serializer.MetadataPropertyHandling != MetadataPropertyHandling.Ignore && reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$id", StringComparison.Ordinal))
				{
					reader.ReadAndAssert();
					id = reader.Value?.ToString();
					reader.ReadAndAssert();
				}
				if (jsonContract.ContractType == JsonContractType.Dictionary)
				{
					JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)jsonContract;
					object dictionary;
					if (!jsonDictionaryContract.ShouldCreateWrapper)
					{
						dictionary = (IDictionary)target;
					}
					else
					{
						IDictionary dictionary2 = jsonDictionaryContract.CreateWrapper(target);
						dictionary = dictionary2;
					}
					PopulateDictionary((IDictionary)dictionary, reader, jsonDictionaryContract, null, id);
				}
				else
				{
					if (jsonContract.ContractType != JsonContractType.Object)
					{
						throw JsonSerializationException.Create(reader, "Cannot populate JSON object onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture, type));
					}
					PopulateObject(target, reader, (JsonObjectContract)jsonContract, null, id);
				}
				return;
			}
			throw JsonSerializationException.Create(reader, "Unexpected initial token '{0}' when populating object. Expected JSON object or array.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}

		private JsonContract? GetContractSafe(Type? type)
		{
			if (type == null)
			{
				return null;
			}
			return GetContract(type);
		}

		private JsonContract GetContract(Type type)
		{
			return Serializer._contractResolver.ResolveContract(type);
		}

		public object? Deserialize(JsonReader reader, Type? objectType, bool checkAdditionalContent)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			JsonContract contractSafe = GetContractSafe(objectType);
			try
			{
				JsonConverter converter = GetConverter(contractSafe, null, null, null);
				if (reader.TokenType == JsonToken.None && !reader.ReadForType(contractSafe, converter != null))
				{
					if (contractSafe != null && !contractSafe.IsNullable)
					{
						throw JsonSerializationException.Create(reader, "No JSON content found and type '{0}' is not nullable.".FormatWith(CultureInfo.InvariantCulture, contractSafe.UnderlyingType));
					}
					return null;
				}
				object result = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, objectType, contractSafe, null, null, null, null) : DeserializeConvertable(converter, reader, objectType, null));
				if (checkAdditionalContent)
				{
					while (reader.Read())
					{
						if (reader.TokenType != JsonToken.Comment)
						{
							throw JsonSerializationException.Create(reader, "Additional text found in JSON string after finishing deserializing object.");
						}
					}
				}
				return result;
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(null, contractSafe, null, reader as IJsonLineInfo, reader.Path, ex))
				{
					HandleError(reader, readPastError: false, 0);
					return null;
				}
				ClearErrorContext();
				throw;
			}
		}

		private JsonSerializerProxy GetInternalSerializer()
		{
			if (InternalSerializer == null)
			{
				InternalSerializer = new JsonSerializerProxy(this);
			}
			return InternalSerializer;
		}

		private JToken? CreateJToken(JsonReader reader, JsonContract? contract)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			if (contract != null)
			{
				if (contract.UnderlyingType == typeof(JRaw))
				{
					return JRaw.Create(reader);
				}
				if (reader.TokenType == JsonToken.Null && !(contract.UnderlyingType == typeof(JValue)) && !(contract.UnderlyingType == typeof(JToken)))
				{
					return null;
				}
			}
			JToken token;
			using (JTokenWriter jTokenWriter = new JTokenWriter())
			{
				jTokenWriter.WriteToken(reader);
				token = jTokenWriter.Token;
			}
			if (contract != null && token != null && !contract.UnderlyingType.IsAssignableFrom(token.GetType()))
			{
				throw JsonSerializationException.Create(reader, "Deserialized JSON type '{0}' is not compatible with expected type '{1}'.".FormatWith(CultureInfo.InvariantCulture, token.GetType().FullName, contract.UnderlyingType.FullName));
			}
			return token;
		}

		private JToken CreateJObject(JsonReader reader)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			using JTokenWriter jTokenWriter = new JTokenWriter();
			jTokenWriter.WriteStartObject();
			do
			{
				if (reader.TokenType == JsonToken.PropertyName)
				{
					string text = (string)reader.Value;
					if (!reader.ReadAndMoveToContent())
					{
						break;
					}
					if (!CheckPropertyName(reader, text))
					{
						jTokenWriter.WritePropertyName(text);
						jTokenWriter.WriteToken(reader, writeChildren: true, writeDateConstructorAsDate: true, writeComments: false);
					}
				}
				else if (reader.TokenType != JsonToken.Comment)
				{
					jTokenWriter.WriteEndObject();
					return jTokenWriter.Token;
				}
			}
			while (reader.Read());
			throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
		}

		private object? CreateValueInternal(JsonReader reader, Type? objectType, JsonContract? contract, JsonProperty? member, JsonContainerContract? containerContract, JsonProperty? containerMember, object? existingValue)
		{
			if (contract != null && contract.ContractType == JsonContractType.Linq)
			{
				return CreateJToken(reader, contract);
			}
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.StartObject:
					return CreateObject(reader, objectType, contract, member, containerContract, containerMember, existingValue);
				case JsonToken.StartArray:
					return CreateList(reader, objectType, contract, member, existingValue, null);
				case JsonToken.Integer:
				case JsonToken.Float:
				case JsonToken.Boolean:
				case JsonToken.Date:
				case JsonToken.Bytes:
					return EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
				case JsonToken.String:
				{
					string text = (string)reader.Value;
					if (objectType == typeof(byte[]))
					{
						return Convert.FromBase64String(text);
					}
					if (CoerceEmptyStringToNull(objectType, contract, text))
					{
						return null;
					}
					return EnsureType(reader, text, CultureInfo.InvariantCulture, contract, objectType);
				}
				case JsonToken.StartConstructor:
				{
					string value = reader.Value.ToString();
					return EnsureType(reader, value, CultureInfo.InvariantCulture, contract, objectType);
				}
				case JsonToken.Null:
				case JsonToken.Undefined:
					if (objectType == typeof(DBNull))
					{
						return DBNull.Value;
					}
					return EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
				case JsonToken.Raw:
					return new JRaw((string)reader.Value);
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token while deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (reader.Read());
			throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
		}

		private static bool CoerceEmptyStringToNull(Type? objectType, JsonContract? contract, string s)
		{
			if (StringUtils.IsNullOrEmpty(s) && objectType != null && objectType != typeof(string) && objectType != typeof(object) && contract != null)
			{
				return contract.IsNullable;
			}
			return false;
		}

		internal string GetExpectedDescription(JsonContract contract)
		{
			switch (contract.ContractType)
			{
			case JsonContractType.Object:
			case JsonContractType.Dictionary:
			case JsonContractType.Dynamic:
			case JsonContractType.Serializable:
				return "JSON object (e.g. {\"name\":\"value\"})";
			case JsonContractType.Array:
				return "JSON array (e.g. [1,2,3])";
			case JsonContractType.Primitive:
				return "JSON primitive value (e.g. string, number, boolean, null)";
			case JsonContractType.String:
				return "JSON string value";
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		private JsonConverter? GetConverter(JsonContract? contract, JsonConverter? memberConverter, JsonContainerContract? containerContract, JsonProperty? containerProperty)
		{
			JsonConverter result = null;
			if (memberConverter != null)
			{
				result = memberConverter;
			}
			else if (containerProperty?.ItemConverter != null)
			{
				result = containerProperty.ItemConverter;
			}
			else if (containerContract?.ItemConverter != null)
			{
				result = containerContract.ItemConverter;
			}
			else if (contract != null)
			{
				if (contract.Converter != null)
				{
					result = contract.Converter;
				}
				else
				{
					JsonConverter matchingConverter = Serializer.GetMatchingConverter(contract.UnderlyingType);
					if (matchingConverter != null)
					{
						result = matchingConverter;
					}
					else if (contract.InternalConverter != null)
					{
						result = contract.InternalConverter;
					}
				}
			}
			return result;
		}

		private object? CreateObject(JsonReader reader, Type? objectType, JsonContract? contract, JsonProperty? member, JsonContainerContract? containerContract, JsonProperty? containerMember, object? existingValue)
		{
			Type objectType2 = objectType;
			string id;
			if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.Ignore)
			{
				reader.ReadAndAssert();
				id = null;
			}
			else if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.ReadAhead)
			{
				JTokenReader jTokenReader = reader as JTokenReader;
				if (jTokenReader == null)
				{
					jTokenReader = (JTokenReader)JToken.ReadFrom(reader).CreateReader();
					jTokenReader.Culture = reader.Culture;
					jTokenReader.DateFormatString = reader.DateFormatString;
					jTokenReader.DateParseHandling = reader.DateParseHandling;
					jTokenReader.DateTimeZoneHandling = reader.DateTimeZoneHandling;
					jTokenReader.FloatParseHandling = reader.FloatParseHandling;
					jTokenReader.SupportMultipleContent = reader.SupportMultipleContent;
					jTokenReader.ReadAndAssert();
					reader = jTokenReader;
				}
				if (ReadMetadataPropertiesToken(jTokenReader, ref objectType2, ref contract, member, containerContract, containerMember, existingValue, out object newValue, out id))
				{
					return newValue;
				}
			}
			else
			{
				reader.ReadAndAssert();
				if (ReadMetadataProperties(reader, ref objectType2, ref contract, member, containerContract, containerMember, existingValue, out object newValue2, out id))
				{
					return newValue2;
				}
			}
			if (HasNoDefinedType(contract))
			{
				return CreateJObject(reader);
			}
			switch (contract.ContractType)
			{
			case JsonContractType.Object:
			{
				bool createdFromNonDefaultCreator2 = false;
				JsonObjectContract jsonObjectContract = (JsonObjectContract)contract;
				object obj = ((existingValue == null || (!(objectType2 == objectType) && !objectType2.IsAssignableFrom(existingValue.GetType()))) ? CreateNewObject(reader, jsonObjectContract, member, containerMember, id, out createdFromNonDefaultCreator2) : existingValue);
				if (createdFromNonDefaultCreator2)
				{
					return obj;
				}
				return PopulateObject(obj, reader, jsonObjectContract, member, id);
			}
			case JsonContractType.Primitive:
			{
				JsonPrimitiveContract contract4 = (JsonPrimitiveContract)contract;
				if (Serializer.MetadataPropertyHandling != MetadataPropertyHandling.Ignore && reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$value", StringComparison.Ordinal))
				{
					reader.ReadAndAssert();
					if (reader.TokenType == JsonToken.StartObject)
					{
						throw JsonSerializationException.Create(reader, "Unexpected token when deserializing primitive value: " + reader.TokenType);
					}
					object? result = CreateValueInternal(reader, objectType2, contract4, member, null, null, existingValue);
					reader.ReadAndAssert();
					return result;
				}
				break;
			}
			case JsonContractType.Dictionary:
			{
				JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)contract;
				if (existingValue == null)
				{
					bool createdFromNonDefaultCreator;
					IDictionary dictionary = CreateNewDictionary(reader, jsonDictionaryContract, out createdFromNonDefaultCreator);
					if (createdFromNonDefaultCreator)
					{
						if (id != null)
						{
							throw JsonSerializationException.Create(reader, "Cannot preserve reference to readonly dictionary, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
						if (contract.OnSerializingCallbacks.Count > 0)
						{
							throw JsonSerializationException.Create(reader, "Cannot call OnSerializing on readonly dictionary, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
						if (contract.OnErrorCallbacks.Count > 0)
						{
							throw JsonSerializationException.Create(reader, "Cannot call OnError on readonly list, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
						if (!jsonDictionaryContract.HasParameterizedCreatorInternal)
						{
							throw JsonSerializationException.Create(reader, "Cannot deserialize readonly or fixed size dictionary: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
					}
					PopulateDictionary(dictionary, reader, jsonDictionaryContract, member, id);
					if (createdFromNonDefaultCreator)
					{
						return (jsonDictionaryContract.OverrideCreator ?? jsonDictionaryContract.ParameterizedCreator)(dictionary);
					}
					if (dictionary is IWrappedDictionary wrappedDictionary)
					{
						return wrappedDictionary.UnderlyingDictionary;
					}
					return dictionary;
				}
				object dictionary2;
				if (!jsonDictionaryContract.ShouldCreateWrapper && existingValue is IDictionary)
				{
					dictionary2 = (IDictionary)existingValue;
				}
				else
				{
					IDictionary dictionary3 = jsonDictionaryContract.CreateWrapper(existingValue);
					dictionary2 = dictionary3;
				}
				return PopulateDictionary((IDictionary)dictionary2, reader, jsonDictionaryContract, member, id);
			}
			case JsonContractType.Dynamic:
			{
				JsonDynamicContract contract3 = (JsonDynamicContract)contract;
				return CreateDynamic(reader, contract3, member, id);
			}
			case JsonContractType.Serializable:
			{
				JsonISerializableContract contract2 = (JsonISerializableContract)contract;
				return CreateISerializable(reader, contract2, member, id);
			}
			}
			string format = "Cannot deserialize the current JSON object (e.g. {{\"name\":\"value\"}}) into type '{0}' because the type requires a {1} to deserialize correctly." + Environment.NewLine + "To fix this error either change the JSON to a {1} or change the deserialized type so that it is a normal .NET type (e.g. not a primitive type like integer, not a collection type like an array or List<T>) that can be deserialized from a JSON object. JsonObjectAttribute can also be added to the type to force it to deserialize from a JSON object." + Environment.NewLine;
			format = format.FormatWith(CultureInfo.InvariantCulture, objectType2, GetExpectedDescription(contract));
			throw JsonSerializationException.Create(reader, format);
		}

		private bool ReadMetadataPropertiesToken(JTokenReader reader, ref Type? objectType, ref JsonContract? contract, JsonProperty? member, JsonContainerContract? containerContract, JsonProperty? containerMember, object? existingValue, out object? newValue, out string? id)
		{
			id = null;
			newValue = null;
			if (reader.TokenType == JsonToken.StartObject)
			{
				JObject jObject = (JObject)reader.CurrentToken;
				JProperty jProperty = jObject.Property("$ref", StringComparison.Ordinal);
				if (jProperty != null)
				{
					JToken value = jProperty.Value;
					if (value.Type != JTokenType.String && value.Type != JTokenType.Null)
					{
						throw JsonSerializationException.Create(value, value.Path, "JSON reference {0} property must have a string or null value.".FormatWith(CultureInfo.InvariantCulture, "$ref"), null);
					}
					string text = (string?)(JToken?)jProperty;
					if (text != null)
					{
						JToken jToken = jProperty.Next ?? jProperty.Previous;
						if (jToken != null)
						{
							throw JsonSerializationException.Create(jToken, jToken.Path, "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith(CultureInfo.InvariantCulture, "$ref"), null);
						}
						newValue = Serializer.GetReferenceResolver().ResolveReference(this, text);
						if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
						{
							TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader, reader.Path, "Resolved object reference '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, text, newValue.GetType())), null);
						}
						reader.Skip();
						return true;
					}
				}
				JToken jToken2 = jObject["$type"];
				if (jToken2 != null)
				{
					string qualifiedTypeName = (string?)jToken2;
					JsonReader jsonReader = jToken2.CreateReader();
					jsonReader.ReadAndAssert();
					ResolveTypeName(jsonReader, ref objectType, ref contract, member, containerContract, containerMember, qualifiedTypeName);
					if (jObject["$value"] != null)
					{
						while (true)
						{
							reader.ReadAndAssert();
							if (reader.TokenType == JsonToken.PropertyName && (string)reader.Value == "$value")
							{
								break;
							}
							reader.ReadAndAssert();
							reader.Skip();
						}
						return false;
					}
				}
				JToken jToken3 = jObject["$id"];
				if (jToken3 != null)
				{
					id = (string?)jToken3;
				}
				JToken jToken4 = jObject["$values"];
				if (jToken4 != null)
				{
					JsonReader jsonReader2 = jToken4.CreateReader();
					jsonReader2.ReadAndAssert();
					newValue = CreateList(jsonReader2, objectType, contract, member, existingValue, id);
					reader.Skip();
					return true;
				}
			}
			reader.ReadAndAssert();
			return false;
		}

		private bool ReadMetadataProperties(JsonReader reader, ref Type? objectType, ref JsonContract? contract, JsonProperty? member, JsonContainerContract? containerContract, JsonProperty? containerMember, object? existingValue, out object? newValue, out string? id)
		{
			id = null;
			newValue = null;
			if (reader.TokenType == JsonToken.PropertyName)
			{
				string text = reader.Value.ToString();
				if (text.Length > 0 && text[0] == '$')
				{
					bool flag;
					do
					{
						text = reader.Value.ToString();
						if (string.Equals(text, "$ref", StringComparison.Ordinal))
						{
							reader.ReadAndAssert();
							if (reader.TokenType != JsonToken.String && reader.TokenType != JsonToken.Null)
							{
								throw JsonSerializationException.Create(reader, "JSON reference {0} property must have a string or null value.".FormatWith(CultureInfo.InvariantCulture, "$ref"));
							}
							string text2 = reader.Value?.ToString();
							reader.ReadAndAssert();
							if (text2 != null)
							{
								if (reader.TokenType == JsonToken.PropertyName)
								{
									throw JsonSerializationException.Create(reader, "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith(CultureInfo.InvariantCulture, "$ref"));
								}
								newValue = Serializer.GetReferenceResolver().ResolveReference(this, text2);
								if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
								{
									TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved object reference '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, text2, newValue.GetType())), null);
								}
								return true;
							}
							flag = true;
						}
						else if (string.Equals(text, "$type", StringComparison.Ordinal))
						{
							reader.ReadAndAssert();
							string qualifiedTypeName = reader.Value.ToString();
							ResolveTypeName(reader, ref objectType, ref contract, member, containerContract, containerMember, qualifiedTypeName);
							reader.ReadAndAssert();
							flag = true;
						}
						else if (string.Equals(text, "$id", StringComparison.Ordinal))
						{
							reader.ReadAndAssert();
							id = reader.Value?.ToString();
							reader.ReadAndAssert();
							flag = true;
						}
						else
						{
							if (string.Equals(text, "$values", StringComparison.Ordinal))
							{
								reader.ReadAndAssert();
								object obj = CreateList(reader, objectType, contract, member, existingValue, id);
								reader.ReadAndAssert();
								newValue = obj;
								return true;
							}
							flag = false;
						}
					}
					while (flag && reader.TokenType == JsonToken.PropertyName);
				}
			}
			return false;
		}

		private void ResolveTypeName(JsonReader reader, ref Type? objectType, ref JsonContract? contract, JsonProperty? member, JsonContainerContract? containerContract, JsonProperty? containerMember, string qualifiedTypeName)
		{
			if ((member?.TypeNameHandling ?? containerContract?.ItemTypeNameHandling ?? containerMember?.ItemTypeNameHandling ?? Serializer._typeNameHandling) != TypeNameHandling.None)
			{
				StructMultiKey<string, string> structMultiKey = ReflectionUtils.SplitFullyQualifiedTypeName(qualifiedTypeName);
				Type type;
				try
				{
					type = Serializer._serializationBinder.BindToType(structMultiKey.Value1, structMultiKey.Value2);
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error resolving type specified in JSON '{0}'.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName), ex);
				}
				if (type == null)
				{
					throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' was not resolved.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName));
				}
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
				{
					TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved type '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName, type)), null);
				}
				if (objectType != null && objectType != typeof(IDynamicMetaObjectProvider) && !objectType.IsAssignableFrom(type))
				{
					throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' is not compatible with '{1}'.".FormatWith(CultureInfo.InvariantCulture, type.AssemblyQualifiedName, objectType.AssemblyQualifiedName));
				}
				objectType = type;
				contract = GetContract(type);
			}
		}

		private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract)
		{
			if (contract == null)
			{
				throw JsonSerializationException.Create(reader, "Could not resolve type '{0}' to a JsonContract.".FormatWith(CultureInfo.InvariantCulture, objectType));
			}
			JsonArrayContract obj = contract as JsonArrayContract;
			if (obj == null)
			{
				string format = "Cannot deserialize the current JSON array (e.g. [1,2,3]) into type '{0}' because the type requires a {1} to deserialize correctly." + Environment.NewLine + "To fix this error either change the JSON to a {1} or change the deserialized type to an array or a type that implements a collection interface (e.g. ICollection, IList) like List<T> that can be deserialized from a JSON array. JsonArrayAttribute can also be added to the type to force it to deserialize from a JSON array." + Environment.NewLine;
				format = format.FormatWith(CultureInfo.InvariantCulture, objectType, GetExpectedDescription(contract));
				throw JsonSerializationException.Create(reader, format);
			}
			return obj;
		}

		private object? CreateList(JsonReader reader, Type? objectType, JsonContract? contract, JsonProperty? member, object? existingValue, string? id)
		{
			if (HasNoDefinedType(contract))
			{
				return CreateJToken(reader, contract);
			}
			JsonArrayContract jsonArrayContract = EnsureArrayContract(reader, objectType, contract);
			if (existingValue == null)
			{
				bool createdFromNonDefaultCreator;
				IList list = CreateNewList(reader, jsonArrayContract, out createdFromNonDefaultCreator);
				if (createdFromNonDefaultCreator)
				{
					if (id != null)
					{
						throw JsonSerializationException.Create(reader, "Cannot preserve reference to array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (contract.OnSerializingCallbacks.Count > 0)
					{
						throw JsonSerializationException.Create(reader, "Cannot call OnSerializing on an array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (contract.OnErrorCallbacks.Count > 0)
					{
						throw JsonSerializationException.Create(reader, "Cannot call OnError on an array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (!jsonArrayContract.HasParameterizedCreatorInternal && !jsonArrayContract.IsArray)
					{
						throw JsonSerializationException.Create(reader, "Cannot deserialize readonly or fixed size list: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
				}
				if (!jsonArrayContract.IsMultidimensionalArray)
				{
					PopulateList(list, reader, jsonArrayContract, member, id);
				}
				else
				{
					PopulateMultidimensionalArray(list, reader, jsonArrayContract, member, id);
				}
				if (createdFromNonDefaultCreator)
				{
					if (jsonArrayContract.IsMultidimensionalArray)
					{
						list = CollectionUtils.ToMultidimensionalArray(list, jsonArrayContract.CollectionItemType, contract.CreatedType.GetArrayRank());
					}
					else
					{
						if (!jsonArrayContract.IsArray)
						{
							return (jsonArrayContract.OverrideCreator ?? jsonArrayContract.ParameterizedCreator)(list);
						}
						Array array = Array.CreateInstance(jsonArrayContract.CollectionItemType, list.Count);
						list.CopyTo(array, 0);
						list = array;
					}
				}
				else if (list is IWrappedCollection wrappedCollection)
				{
					return wrappedCollection.UnderlyingCollection;
				}
				return list;
			}
			if (!jsonArrayContract.CanDeserialize)
			{
				throw JsonSerializationException.Create(reader, "Cannot populate list type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.CreatedType));
			}
			IList list3;
			if (!jsonArrayContract.ShouldCreateWrapper && existingValue is IList list2)
			{
				list3 = list2;
			}
			else
			{
				IList list4 = jsonArrayContract.CreateWrapper(existingValue);
				list3 = list4;
			}
			return PopulateList(list3, reader, jsonArrayContract, member, id);
		}

		private bool HasNoDefinedType(JsonContract? contract)
		{
			if (contract != null && !(contract.UnderlyingType == typeof(object)) && contract.ContractType != JsonContractType.Linq)
			{
				return contract.UnderlyingType == typeof(IDynamicMetaObjectProvider);
			}
			return true;
		}

		private object? EnsureType(JsonReader reader, object? value, CultureInfo culture, JsonContract? contract, Type? targetType)
		{
			if (targetType == null)
			{
				return value;
			}
			if (ReflectionUtils.GetObjectType(value) != targetType)
			{
				if (value == null && contract.IsNullable)
				{
					return null;
				}
				try
				{
					if (contract.IsConvertable)
					{
						JsonPrimitiveContract jsonPrimitiveContract = (JsonPrimitiveContract)contract;
						DateTime dt;
						if (contract.IsEnum)
						{
							if (value is string value2)
							{
								return EnumUtils.ParseEnum(contract.NonNullableUnderlyingType, null, value2, disallowNumber: false);
							}
							if (ConvertUtils.IsInteger(jsonPrimitiveContract.TypeCode))
							{
								return Enum.ToObject(contract.NonNullableUnderlyingType, value);
							}
						}
						else if (contract.NonNullableUnderlyingType == typeof(DateTime) && value is string s && DateTimeUtils.TryParseDateTime(s, reader.DateTimeZoneHandling, reader.DateFormatString, reader.Culture, out dt))
						{
							return DateTimeUtils.EnsureDateTime(dt, reader.DateTimeZoneHandling);
						}
						if (value is BigInteger i)
						{
							return ConvertUtils.FromBigInteger(i, contract.NonNullableUnderlyingType);
						}
						return Convert.ChangeType(value, contract.NonNullableUnderlyingType, culture);
					}
					return ConvertUtils.ConvertOrCast(value, culture, contract.NonNullableUnderlyingType);
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error converting value {0} to type '{1}'.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(value), targetType), ex);
				}
			}
			return value;
		}

		private bool SetPropertyValue(JsonProperty property, JsonConverter? propertyConverter, JsonContainerContract? containerContract, JsonProperty? containerProperty, JsonReader reader, object target)
		{
			if (CalculatePropertyDetails(property, ref propertyConverter, containerContract, containerProperty, reader, target, out bool useExistingValue, out object currentValue, out JsonContract propertyContract, out bool gottenCurrentValue, out bool ignoredValue))
			{
				if (ignoredValue)
				{
					return true;
				}
				return false;
			}
			object obj;
			if (propertyConverter != null && propertyConverter.CanRead)
			{
				if (!gottenCurrentValue && property.Readable)
				{
					currentValue = property.ValueProvider.GetValue(target);
				}
				obj = DeserializeConvertable(propertyConverter, reader, property.PropertyType, currentValue);
			}
			else
			{
				obj = CreateValueInternal(reader, property.PropertyType, propertyContract, property, containerContract, containerProperty, useExistingValue ? currentValue : null);
			}
			if ((!useExistingValue || obj != currentValue) && ShouldSetPropertyValue(property, containerContract as JsonObjectContract, obj))
			{
				property.ValueProvider.SetValue(target, obj);
				if (property.SetIsSpecified != null)
				{
					if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
					{
						TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "IsSpecified for property '{0}' on {1} set to true.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType)), null);
					}
					property.SetIsSpecified(target, true);
				}
				return true;
			}
			return useExistingValue;
		}

		private bool CalculatePropertyDetails(JsonProperty property, ref JsonConverter? propertyConverter, JsonContainerContract? containerContract, JsonProperty? containerProperty, JsonReader reader, object target, out bool useExistingValue, out object? currentValue, out JsonContract? propertyContract, out bool gottenCurrentValue, out bool ignoredValue)
		{
			currentValue = null;
			useExistingValue = false;
			propertyContract = null;
			gottenCurrentValue = false;
			ignoredValue = false;
			if (property.Ignored)
			{
				return true;
			}
			JsonToken tokenType = reader.TokenType;
			if (property.PropertyContract == null)
			{
				property.PropertyContract = GetContractSafe(property.PropertyType);
			}
			if (property.ObjectCreationHandling.GetValueOrDefault(Serializer._objectCreationHandling) != ObjectCreationHandling.Replace && (tokenType == JsonToken.StartArray || tokenType == JsonToken.StartObject || propertyConverter != null) && property.Readable)
			{
				currentValue = property.ValueProvider.GetValue(target);
				gottenCurrentValue = true;
				if (currentValue != null)
				{
					propertyContract = GetContract(currentValue.GetType());
					useExistingValue = !propertyContract.IsReadOnlyOrFixedSize && !propertyContract.UnderlyingType.IsValueType();
				}
			}
			if (!property.Writable && !useExistingValue)
			{
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
				{
					TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Unable to deserialize value to non-writable property '{0}' on {1}.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType)), null);
				}
				return true;
			}
			if (tokenType == JsonToken.Null && ResolvedNullValueHandling(containerContract as JsonObjectContract, property) == NullValueHandling.Ignore)
			{
				ignoredValue = true;
				return true;
			}
			if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && !HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && JsonTokenUtils.IsPrimitiveToken(tokenType) && MiscellaneousUtils.ValueEquals(reader.Value, property.GetResolvedDefaultValue()))
			{
				ignoredValue = true;
				return true;
			}
			if (currentValue == null)
			{
				propertyContract = property.PropertyContract;
			}
			else
			{
				propertyContract = GetContract(currentValue.GetType());
				if (propertyContract != property.PropertyContract)
				{
					propertyConverter = GetConverter(propertyContract, property.Converter, containerContract, containerProperty);
				}
			}
			return false;
		}

		private void AddReference(JsonReader reader, string id, object value)
		{
			try
			{
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
				{
					TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Read object reference Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, id, value.GetType())), null);
				}
				Serializer.GetReferenceResolver().AddReference(this, id, value);
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(reader, "Error reading object reference '{0}'.".FormatWith(CultureInfo.InvariantCulture, id), ex);
			}
		}

		private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool ShouldSetPropertyValue(JsonProperty property, JsonObjectContract? contract, object? value)
		{
			if (value == null && ResolvedNullValueHandling(contract, property) == NullValueHandling.Ignore)
			{
				return false;
			}
			if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && !HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && MiscellaneousUtils.ValueEquals(value, property.GetResolvedDefaultValue()))
			{
				return false;
			}
			if (!property.Writable)
			{
				return false;
			}
			return true;
		}

		private IList CreateNewList(JsonReader reader, JsonArrayContract contract, out bool createdFromNonDefaultCreator)
		{
			if (!contract.CanDeserialize)
			{
				throw JsonSerializationException.Create(reader, "Cannot create and populate list type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.CreatedType));
			}
			if (contract.OverrideCreator != null)
			{
				if (contract.HasParameterizedCreator)
				{
					createdFromNonDefaultCreator = true;
					return contract.CreateTemporaryCollection();
				}
				object obj = contract.OverrideCreator();
				if (contract.ShouldCreateWrapper)
				{
					obj = contract.CreateWrapper(obj);
				}
				createdFromNonDefaultCreator = false;
				return (IList)obj;
			}
			if (contract.IsReadOnlyOrFixedSize)
			{
				createdFromNonDefaultCreator = true;
				IList list = contract.CreateTemporaryCollection();
				if (contract.ShouldCreateWrapper)
				{
					list = contract.CreateWrapper(list);
				}
				return list;
			}
			if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
			{
				object obj2 = contract.DefaultCreator();
				if (contract.ShouldCreateWrapper)
				{
					obj2 = contract.CreateWrapper(obj2);
				}
				createdFromNonDefaultCreator = false;
				return (IList)obj2;
			}
			if (contract.HasParameterizedCreatorInternal)
			{
				createdFromNonDefaultCreator = true;
				return contract.CreateTemporaryCollection();
			}
			if (!contract.IsInstantiable)
			{
				throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
			}
			throw JsonSerializationException.Create(reader, "Unable to find a constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
		}

		private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, out bool createdFromNonDefaultCreator)
		{
			if (contract.OverrideCreator != null)
			{
				if (contract.HasParameterizedCreator)
				{
					createdFromNonDefaultCreator = true;
					return contract.CreateTemporaryDictionary();
				}
				createdFromNonDefaultCreator = false;
				return (IDictionary)contract.OverrideCreator();
			}
			if (contract.IsReadOnlyOrFixedSize)
			{
				createdFromNonDefaultCreator = true;
				return contract.CreateTemporaryDictionary();
			}
			if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
			{
				object obj = contract.DefaultCreator();
				if (contract.ShouldCreateWrapper)
				{
					obj = contract.CreateWrapper(obj);
				}
				createdFromNonDefaultCreator = false;
				return (IDictionary)obj;
			}
			if (contract.HasParameterizedCreatorInternal)
			{
				createdFromNonDefaultCreator = true;
				return contract.CreateTemporaryDictionary();
			}
			if (!contract.IsInstantiable)
			{
				throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
			}
			throw JsonSerializationException.Create(reader, "Unable to find a default constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
		}

		private void OnDeserializing(JsonReader reader, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnDeserializing(value, Serializer._context);
		}

		private void OnDeserialized(JsonReader reader, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnDeserialized(value, Serializer._context);
		}

		private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty? containerProperty, string? id)
		{
			object obj = ((dictionary is IWrappedDictionary wrappedDictionary) ? wrappedDictionary.UnderlyingDictionary : dictionary);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			OnDeserializing(reader, contract, obj);
			int depth = reader.Depth;
			if (contract.KeyContract == null)
			{
				contract.KeyContract = GetContractSafe(contract.DictionaryKeyType);
			}
			if (contract.ItemContract == null)
			{
				contract.ItemContract = GetContractSafe(contract.DictionaryValueType);
			}
			JsonConverter jsonConverter = contract.ItemConverter ?? GetConverter(contract.ItemContract, null, contract, containerProperty);
			PrimitiveTypeCode primitiveTypeCode = ((contract.KeyContract is JsonPrimitiveContract jsonPrimitiveContract) ? jsonPrimitiveContract.TypeCode : PrimitiveTypeCode.Empty);
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					object obj2 = reader.Value;
					if (CheckPropertyName(reader, obj2.ToString()))
					{
						break;
					}
					try
					{
						try
						{
							switch (primitiveTypeCode)
							{
							case PrimitiveTypeCode.DateTime:
							case PrimitiveTypeCode.DateTimeNullable:
							{
								obj2 = (DateTimeUtils.TryParseDateTime(obj2.ToString(), reader.DateTimeZoneHandling, reader.DateFormatString, reader.Culture, out var dt2) ? ((object)dt2) : EnsureType(reader, obj2, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType));
								break;
							}
							case PrimitiveTypeCode.DateTimeOffset:
							case PrimitiveTypeCode.DateTimeOffsetNullable:
							{
								obj2 = (DateTimeUtils.TryParseDateTimeOffset(obj2.ToString(), reader.DateFormatString, reader.Culture, out var dt) ? ((object)dt) : EnsureType(reader, obj2, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType));
								break;
							}
							default:
								obj2 = ((contract.KeyContract != null && contract.KeyContract.IsEnum) ? EnumUtils.ParseEnum(contract.KeyContract.NonNullableUnderlyingType, (Serializer._contractResolver as DefaultContractResolver)?.NamingStrategy, obj2.ToString(), disallowNumber: false) : EnsureType(reader, obj2, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType));
								break;
							}
						}
						catch (Exception ex)
						{
							throw JsonSerializationException.Create(reader, "Could not convert string '{0}' to dictionary key type '{1}'. Create a TypeConverter to convert from the string to the key type object.".FormatWith(CultureInfo.InvariantCulture, reader.Value, contract.DictionaryKeyType), ex);
						}
						if (!reader.ReadForType(contract.ItemContract, jsonConverter != null))
						{
							throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
						}
						object value = ((jsonConverter == null || !jsonConverter.CanRead) ? CreateValueInternal(reader, contract.DictionaryValueType, contract.ItemContract, null, contract, containerProperty, null) : DeserializeConvertable(jsonConverter, reader, contract.DictionaryValueType, null));
						dictionary[obj2] = value;
					}
					catch (Exception ex2)
					{
						if (IsErrorHandled(obj, contract, obj2, reader as IJsonLineInfo, reader.Path, ex2))
						{
							HandleError(reader, readPastError: true, depth);
							break;
						}
						throw;
					}
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, obj, "Unexpected end when deserializing object.");
			}
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty? containerProperty, string? id)
		{
			int arrayRank = contract.UnderlyingType.GetArrayRank();
			if (id != null)
			{
				AddReference(reader, id, list);
			}
			OnDeserializing(reader, contract, list);
			JsonContract contractSafe = GetContractSafe(contract.CollectionItemType);
			JsonConverter converter = GetConverter(contractSafe, null, contract, containerProperty);
			int? num = null;
			Stack<IList> stack = new Stack<IList>();
			stack.Push(list);
			IList list2 = list;
			bool flag = false;
			do
			{
				int depth = reader.Depth;
				if (stack.Count == arrayRank)
				{
					try
					{
						if (reader.ReadForType(contractSafe, converter != null))
						{
							switch (reader.TokenType)
							{
							case JsonToken.EndArray:
								stack.Pop();
								list2 = stack.Peek();
								num = null;
								break;
							default:
							{
								object value = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, contract.CollectionItemType, contractSafe, null, contract, containerProperty, null) : DeserializeConvertable(converter, reader, contract.CollectionItemType, null));
								list2.Add(value);
								break;
							}
							case JsonToken.Comment:
								break;
							}
							continue;
						}
					}
					catch (Exception ex)
					{
						JsonPosition position = reader.GetPosition(depth);
						if (IsErrorHandled(list, contract, position.Position, reader as IJsonLineInfo, reader.Path, ex))
						{
							HandleError(reader, readPastError: true, depth + 1);
							if (num.HasValue && num == position.Position)
							{
								throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
							}
							num = position.Position;
							continue;
						}
						throw;
					}
					break;
				}
				if (!reader.Read())
				{
					break;
				}
				switch (reader.TokenType)
				{
				case JsonToken.StartArray:
				{
					IList list3 = new List<object>();
					list2.Add(list3);
					stack.Push(list3);
					list2 = list3;
					break;
				}
				case JsonToken.EndArray:
					stack.Pop();
					if (stack.Count > 0)
					{
						list2 = stack.Peek();
					}
					else
					{
						flag = true;
					}
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing multidimensional array: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag);
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, list, "Unexpected end when deserializing array.");
			}
			OnDeserialized(reader, contract, list);
			return list;
		}

		private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object? currentObject, string message)
		{
			try
			{
				throw JsonSerializationException.Create(reader, message);
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(currentObject, contract, null, reader as IJsonLineInfo, reader.Path, ex))
				{
					HandleError(reader, readPastError: false, 0);
					return;
				}
				throw;
			}
		}

		private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty? containerProperty, string? id)
		{
			object obj = ((list is IWrappedCollection wrappedCollection) ? wrappedCollection.UnderlyingCollection : list);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			if (list.IsFixedSize)
			{
				reader.Skip();
				return obj;
			}
			OnDeserializing(reader, contract, obj);
			int depth = reader.Depth;
			if (contract.ItemContract == null)
			{
				contract.ItemContract = GetContractSafe(contract.CollectionItemType);
			}
			JsonConverter converter = GetConverter(contract.ItemContract, null, contract, containerProperty);
			int? num = null;
			bool flag = false;
			do
			{
				try
				{
					if (reader.ReadForType(contract.ItemContract, converter != null))
					{
						switch (reader.TokenType)
						{
						case JsonToken.EndArray:
							flag = true;
							break;
						default:
						{
							object value = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, contract.CollectionItemType, contract.ItemContract, null, contract, containerProperty, null) : DeserializeConvertable(converter, reader, contract.CollectionItemType, null));
							list.Add(value);
							break;
						}
						case JsonToken.Comment:
							break;
						}
						continue;
					}
				}
				catch (Exception ex)
				{
					JsonPosition position = reader.GetPosition(depth);
					if (IsErrorHandled(obj, contract, position.Position, reader as IJsonLineInfo, reader.Path, ex))
					{
						HandleError(reader, readPastError: true, depth + 1);
						if (num.HasValue && num == position.Position)
						{
							throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
						}
						num = position.Position;
						continue;
					}
					throw;
				}
				break;
			}
			while (!flag);
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, obj, "Unexpected end when deserializing array.");
			}
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty? member, string? id)
		{
			Type underlyingType = contract.UnderlyingType;
			if (!JsonTypeReflector.FullyTrusted)
			{
				string format = "Type '{0}' implements ISerializable but cannot be deserialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data." + Environment.NewLine + "To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true." + Environment.NewLine;
				format = format.FormatWith(CultureInfo.InvariantCulture, underlyingType);
				throw JsonSerializationException.Create(reader, format);
			}
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using ISerializable constructor.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, new JsonFormatterConverter(this, contract, member));
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					if (!reader.Read())
					{
						throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
					}
					serializationInfo.AddValue(text, JToken.ReadFrom(reader));
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, serializationInfo, "Unexpected end when deserializing object.");
			}
			if (!contract.IsInstantiable)
			{
				throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
			}
			if (contract.ISerializableCreator == null)
			{
				throw JsonSerializationException.Create(reader, "ISerializable type '{0}' does not have a valid constructor. To correctly implement ISerializable a constructor that takes SerializationInfo and StreamingContext parameters should be present.".FormatWith(CultureInfo.InvariantCulture, underlyingType));
			}
			object obj = contract.ISerializableCreator(serializationInfo, Serializer._context);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			OnDeserializing(reader, contract, obj);
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		internal object? CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty? member)
		{
			JsonContract contractSafe = GetContractSafe(type);
			JsonConverter converter = GetConverter(contractSafe, null, contract, member);
			JsonReader jsonReader = token.CreateReader();
			jsonReader.ReadAndAssert();
			if (converter != null && converter.CanRead)
			{
				return DeserializeConvertable(converter, jsonReader, type, null);
			}
			return CreateValueInternal(jsonReader, type, contractSafe, null, contract, member, null);
		}

		private object CreateDynamic(JsonReader reader, JsonDynamicContract contract, JsonProperty? member, string? id)
		{
			if (!contract.IsInstantiable)
			{
				throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
			}
			if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
			{
				IDynamicMetaObjectProvider dynamicMetaObjectProvider = (IDynamicMetaObjectProvider)contract.DefaultCreator();
				if (id != null)
				{
					AddReference(reader, id, dynamicMetaObjectProvider);
				}
				OnDeserializing(reader, contract, dynamicMetaObjectProvider);
				int depth = reader.Depth;
				bool flag = false;
				do
				{
					switch (reader.TokenType)
					{
					case JsonToken.PropertyName:
					{
						string text = reader.Value.ToString();
						try
						{
							if (!reader.Read())
							{
								throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
							}
							JsonProperty closestMatchProperty = contract.Properties.GetClosestMatchProperty(text);
							if (closestMatchProperty != null && closestMatchProperty.Writable && !closestMatchProperty.Ignored)
							{
								if (closestMatchProperty.PropertyContract == null)
								{
									closestMatchProperty.PropertyContract = GetContractSafe(closestMatchProperty.PropertyType);
								}
								JsonConverter converter = GetConverter(closestMatchProperty.PropertyContract, closestMatchProperty.Converter, null, null);
								if (!SetPropertyValue(closestMatchProperty, converter, null, member, reader, dynamicMetaObjectProvider))
								{
									reader.Skip();
								}
							}
							else
							{
								Type type = (JsonTokenUtils.IsPrimitiveToken(reader.TokenType) ? reader.ValueType : typeof(IDynamicMetaObjectProvider));
								JsonContract contractSafe = GetContractSafe(type);
								JsonConverter converter2 = GetConverter(contractSafe, null, null, member);
								object value = ((converter2 == null || !converter2.CanRead) ? CreateValueInternal(reader, type, contractSafe, null, null, member, null) : DeserializeConvertable(converter2, reader, type, null));
								contract.TrySetMember(dynamicMetaObjectProvider, text, value);
							}
						}
						catch (Exception ex)
						{
							if (IsErrorHandled(dynamicMetaObjectProvider, contract, text, reader as IJsonLineInfo, reader.Path, ex))
							{
								HandleError(reader, readPastError: true, depth);
								break;
							}
							throw;
						}
						break;
					}
					case JsonToken.EndObject:
						flag = true;
						break;
					default:
						throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
					}
				}
				while (!flag && reader.Read());
				if (!flag)
				{
					ThrowUnexpectedEndException(reader, contract, dynamicMetaObjectProvider, "Unexpected end when deserializing object.");
				}
				OnDeserialized(reader, contract, dynamicMetaObjectProvider);
				return dynamicMetaObjectProvider;
			}
			throw JsonSerializationException.Create(reader, "Unable to find a default constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
		}

		private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty? containerProperty, ObjectConstructor<object> creator, string? id)
		{
			ValidationUtils.ArgumentNotNull(creator, "creator");
			bool flag = contract.HasRequiredOrDefaultValueProperties || HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Populate);
			Type underlyingType = contract.UnderlyingType;
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				string arg = string.Join(", ", contract.CreatorParameters.Select((JsonProperty p) => p.PropertyName));
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using creator with parameters: {1}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType, arg)), null);
			}
			List<CreatorPropertyContext> list = ResolvePropertyAndCreatorValues(contract, containerProperty, reader, underlyingType);
			if (flag)
			{
				foreach (JsonProperty property in contract.Properties)
				{
					if (!property.Ignored && list.All((CreatorPropertyContext p) => p.Property != property))
					{
						list.Add(new CreatorPropertyContext(property.PropertyName)
						{
							Property = property,
							Presence = PropertyPresence.None
						});
					}
				}
			}
			object[] array = new object[contract.CreatorParameters.Count];
			foreach (CreatorPropertyContext item in list)
			{
				if (flag && item.Property != null && !item.Presence.HasValue)
				{
					object value = item.Value;
					PropertyPresence value2 = ((value == null) ? PropertyPresence.Null : ((!(value is string s)) ? PropertyPresence.Value : (CoerceEmptyStringToNull(item.Property.PropertyType, item.Property.PropertyContract, s) ? PropertyPresence.Null : PropertyPresence.Value)));
					item.Presence = value2;
				}
				JsonProperty jsonProperty = item.ConstructorProperty;
				if (jsonProperty == null && item.Property != null)
				{
					jsonProperty = contract.CreatorParameters.ForgivingCaseSensitiveFind((JsonProperty p) => p.PropertyName, item.Property.UnderlyingName);
				}
				if (jsonProperty == null || jsonProperty.Ignored)
				{
					continue;
				}
				if (flag && (item.Presence == PropertyPresence.None || item.Presence == PropertyPresence.Null))
				{
					if (jsonProperty.PropertyContract == null)
					{
						jsonProperty.PropertyContract = GetContractSafe(jsonProperty.PropertyType);
					}
					if (HasFlag(jsonProperty.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate))
					{
						item.Value = EnsureType(reader, jsonProperty.GetResolvedDefaultValue(), CultureInfo.InvariantCulture, jsonProperty.PropertyContract, jsonProperty.PropertyType);
					}
				}
				int num = contract.CreatorParameters.IndexOf(jsonProperty);
				array[num] = item.Value;
				item.Used = true;
			}
			object obj = creator(array);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			OnDeserializing(reader, contract, obj);
			foreach (CreatorPropertyContext item2 in list)
			{
				if (item2.Used || item2.Property == null || item2.Property.Ignored || item2.Presence == PropertyPresence.None)
				{
					continue;
				}
				JsonProperty property2 = item2.Property;
				object value3 = item2.Value;
				if (ShouldSetPropertyValue(property2, contract, value3))
				{
					property2.ValueProvider.SetValue(obj, value3);
					item2.Used = true;
				}
				else
				{
					if (property2.Writable || value3 == null)
					{
						continue;
					}
					JsonContract jsonContract = Serializer._contractResolver.ResolveContract(property2.PropertyType);
					if (jsonContract.ContractType == JsonContractType.Array)
					{
						JsonArrayContract jsonArrayContract = (JsonArrayContract)jsonContract;
						if (jsonArrayContract.CanDeserialize && !jsonArrayContract.IsReadOnlyOrFixedSize)
						{
							object value4 = property2.ValueProvider.GetValue(obj);
							if (value4 != null)
							{
								jsonArrayContract = (JsonArrayContract)GetContract(value4.GetType());
								object obj2;
								if (!jsonArrayContract.ShouldCreateWrapper)
								{
									obj2 = (IList)value4;
								}
								else
								{
									IList list2 = jsonArrayContract.CreateWrapper(value4);
									obj2 = list2;
								}
								IList list3 = (IList)obj2;
								if (!list3.IsFixedSize)
								{
									object obj3;
									if (!jsonArrayContract.ShouldCreateWrapper)
									{
										obj3 = (IList)value3;
									}
									else
									{
										IList list2 = jsonArrayContract.CreateWrapper(value3);
										obj3 = list2;
									}
									foreach (object item3 in (IEnumerable)obj3)
									{
										list3.Add(item3);
									}
								}
							}
						}
					}
					else if (jsonContract.ContractType == JsonContractType.Dictionary)
					{
						JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)jsonContract;
						if (!jsonDictionaryContract.IsReadOnlyOrFixedSize)
						{
							object value5 = property2.ValueProvider.GetValue(obj);
							if (value5 != null)
							{
								object obj4;
								if (!jsonDictionaryContract.ShouldCreateWrapper)
								{
									obj4 = (IDictionary)value5;
								}
								else
								{
									IDictionary dictionary = jsonDictionaryContract.CreateWrapper(value5);
									obj4 = dictionary;
								}
								IDictionary dictionary2 = (IDictionary)obj4;
								object obj5;
								if (!jsonDictionaryContract.ShouldCreateWrapper)
								{
									obj5 = (IDictionary)value3;
								}
								else
								{
									IDictionary dictionary = jsonDictionaryContract.CreateWrapper(value3);
									obj5 = dictionary;
								}
								foreach (DictionaryEntry item4 in (IDictionary)obj5)
								{
									dictionary2[item4.Key] = item4.Value;
								}
							}
						}
					}
					item2.Used = true;
				}
			}
			if (contract.ExtensionDataSetter != null)
			{
				foreach (CreatorPropertyContext item5 in list)
				{
					if (!item5.Used && item5.Presence != PropertyPresence.None)
					{
						contract.ExtensionDataSetter(obj, item5.Name, item5.Value);
					}
				}
			}
			if (flag)
			{
				foreach (CreatorPropertyContext item6 in list)
				{
					if (item6.Property != null)
					{
						EndProcessProperty(obj, reader, contract, reader.Depth, item6.Property, item6.Presence.GetValueOrDefault(), !item6.Used);
					}
				}
			}
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		private object? DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object? existingValue)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, objectType, converter.GetType())), null);
			}
			object? result = converter.ReadJson(reader, objectType, existingValue, GetInternalSerializer());
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, objectType, converter.GetType())), null);
			}
			return result;
		}

		private List<CreatorPropertyContext> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty? containerProperty, JsonReader reader, Type objectType)
		{
			List<CreatorPropertyContext> list = new List<CreatorPropertyContext>();
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					CreatorPropertyContext creatorPropertyContext = new CreatorPropertyContext(text)
					{
						ConstructorProperty = contract.CreatorParameters.GetClosestMatchProperty(text),
						Property = contract.Properties.GetClosestMatchProperty(text)
					};
					list.Add(creatorPropertyContext);
					JsonProperty jsonProperty = creatorPropertyContext.ConstructorProperty ?? creatorPropertyContext.Property;
					if (jsonProperty != null)
					{
						if (!jsonProperty.Ignored)
						{
							if (jsonProperty.PropertyContract == null)
							{
								jsonProperty.PropertyContract = GetContractSafe(jsonProperty.PropertyType);
							}
							JsonConverter converter = GetConverter(jsonProperty.PropertyContract, jsonProperty.Converter, contract, containerProperty);
							if (!reader.ReadForType(jsonProperty.PropertyContract, converter != null))
							{
								throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
							}
							if (converter != null && converter.CanRead)
							{
								creatorPropertyContext.Value = DeserializeConvertable(converter, reader, jsonProperty.PropertyType, null);
							}
							else
							{
								creatorPropertyContext.Value = CreateValueInternal(reader, jsonProperty.PropertyType, jsonProperty.PropertyContract, jsonProperty, contract, containerProperty, null);
							}
							break;
						}
					}
					else
					{
						if (!reader.Read())
						{
							throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
						}
						if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
						{
							TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}.".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType)), null);
						}
						if ((contract.MissingMemberHandling ?? Serializer._missingMemberHandling) == MissingMemberHandling.Error)
						{
							throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture, text, objectType.Name));
						}
					}
					if (contract.ExtensionDataSetter != null)
					{
						creatorPropertyContext.Value = ReadExtensionDataValue(contract, containerProperty, reader);
					}
					else
					{
						reader.Skip();
					}
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, null, "Unexpected end when deserializing object.");
			}
			return list;
		}

		public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty? containerMember, JsonProperty? containerProperty, string? id, out bool createdFromNonDefaultCreator)
		{
			object obj = null;
			if (objectContract.OverrideCreator != null)
			{
				if (objectContract.CreatorParameters.Count > 0)
				{
					createdFromNonDefaultCreator = true;
					return CreateObjectUsingCreatorWithParameters(reader, objectContract, containerMember, objectContract.OverrideCreator, id);
				}
				obj = objectContract.OverrideCreator(CollectionUtils.ArrayEmpty<object>());
			}
			else if (objectContract.DefaultCreator != null && (!objectContract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor || objectContract.ParameterizedCreator == null))
			{
				obj = objectContract.DefaultCreator();
			}
			else if (objectContract.ParameterizedCreator != null)
			{
				createdFromNonDefaultCreator = true;
				return CreateObjectUsingCreatorWithParameters(reader, objectContract, containerMember, objectContract.ParameterizedCreator, id);
			}
			if (obj == null)
			{
				if (!objectContract.IsInstantiable)
				{
					throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, objectContract.UnderlyingType));
				}
				throw JsonSerializationException.Create(reader, "Unable to find a constructor to use for type {0}. A class should either have a default constructor, one constructor with arguments or a constructor marked with the JsonConstructor attribute.".FormatWith(CultureInfo.InvariantCulture, objectContract.UnderlyingType));
			}
			createdFromNonDefaultCreator = false;
			return obj;
		}

		private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty? member, string? id)
		{
			OnDeserializing(reader, contract, newObject);
			Dictionary<JsonProperty, PropertyPresence> dictionary = ((contract.HasRequiredOrDefaultValueProperties || HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Populate)) ? contract.Properties.ToDictionary((JsonProperty m) => m, (JsonProperty m) => PropertyPresence.None) : null);
			if (id != null)
			{
				AddReference(reader, id, newObject);
			}
			int depth = reader.Depth;
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					if (CheckPropertyName(reader, text))
					{
						break;
					}
					try
					{
						JsonProperty closestMatchProperty = contract.Properties.GetClosestMatchProperty(text);
						if (closestMatchProperty == null)
						{
							if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
							{
								TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType)), null);
							}
							if ((contract.MissingMemberHandling ?? Serializer._missingMemberHandling) == MissingMemberHandling.Error)
							{
								throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType.Name));
							}
							if (reader.Read())
							{
								SetExtensionData(contract, member, reader, text, newObject);
							}
							break;
						}
						if (closestMatchProperty.Ignored || !ShouldDeserialize(reader, closestMatchProperty, newObject))
						{
							if (reader.Read())
							{
								SetPropertyPresence(reader, closestMatchProperty, dictionary);
								SetExtensionData(contract, member, reader, text, newObject);
							}
							break;
						}
						if (closestMatchProperty.PropertyContract == null)
						{
							closestMatchProperty.PropertyContract = GetContractSafe(closestMatchProperty.PropertyType);
						}
						JsonConverter converter = GetConverter(closestMatchProperty.PropertyContract, closestMatchProperty.Converter, contract, member);
						if (!reader.ReadForType(closestMatchProperty.PropertyContract, converter != null))
						{
							throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
						}
						SetPropertyPresence(reader, closestMatchProperty, dictionary);
						if (!SetPropertyValue(closestMatchProperty, converter, contract, member, reader, newObject))
						{
							SetExtensionData(contract, member, reader, text, newObject);
						}
					}
					catch (Exception ex)
					{
						if (IsErrorHandled(newObject, contract, text, reader as IJsonLineInfo, reader.Path, ex))
						{
							HandleError(reader, readPastError: true, depth);
							break;
						}
						throw;
					}
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, newObject, "Unexpected end when deserializing object.");
			}
			if (dictionary != null)
			{
				foreach (KeyValuePair<JsonProperty, PropertyPresence> item in dictionary)
				{
					JsonProperty key = item.Key;
					PropertyPresence value = item.Value;
					EndProcessProperty(newObject, reader, contract, depth, key, value, setDefaultValue: true);
				}
			}
			OnDeserialized(reader, contract, newObject);
			return newObject;
		}

		private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target)
		{
			if (property.ShouldDeserialize == null)
			{
				return true;
			}
			bool flag = property.ShouldDeserialize(target);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, reader.Path, "ShouldDeserialize result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, flag)), null);
			}
			return flag;
		}

		private bool CheckPropertyName(JsonReader reader, string memberName)
		{
			if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.ReadAhead)
			{
				switch (memberName)
				{
				case "$id":
				case "$ref":
				case "$type":
				case "$values":
					reader.Skip();
					return true;
				}
			}
			return false;
		}

		private void SetExtensionData(JsonObjectContract contract, JsonProperty? member, JsonReader reader, string memberName, object o)
		{
			if (contract.ExtensionDataSetter != null)
			{
				try
				{
					object value = ReadExtensionDataValue(contract, member, reader);
					contract.ExtensionDataSetter(o, memberName, value);
					return;
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error setting value in extension data for type '{0}'.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType), ex);
				}
			}
			reader.Skip();
		}

		private object? ReadExtensionDataValue(JsonObjectContract contract, JsonProperty? member, JsonReader reader)
		{
			if (contract.ExtensionDataIsJToken)
			{
				return JToken.ReadFrom(reader);
			}
			return CreateValueInternal(reader, null, null, null, contract, member, null);
		}

		private void EndProcessProperty(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, JsonProperty property, PropertyPresence presence, bool setDefaultValue)
		{
			if (presence != PropertyPresence.None && presence != PropertyPresence.Null)
			{
				return;
			}
			try
			{
				Required required = ((!property.Ignored) ? (property._required ?? contract.ItemRequired.GetValueOrDefault()) : Required.Default);
				switch (presence)
				{
				case PropertyPresence.None:
					if (required == Required.AllowNull || required == Required.Always)
					{
						throw JsonSerializationException.Create(reader, "Required property '{0}' not found in JSON.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName));
					}
					if (setDefaultValue && !property.Ignored)
					{
						if (property.PropertyContract == null)
						{
							property.PropertyContract = GetContractSafe(property.PropertyType);
						}
						if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && property.Writable)
						{
							property.ValueProvider.SetValue(newObject, EnsureType(reader, property.GetResolvedDefaultValue(), CultureInfo.InvariantCulture, property.PropertyContract, property.PropertyType));
						}
					}
					break;
				case PropertyPresence.Null:
					switch (required)
					{
					case Required.Always:
						throw JsonSerializationException.Create(reader, "Required property '{0}' expects a value but got null.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName));
					case Required.DisallowNull:
						throw JsonSerializationException.Create(reader, "Required property '{0}' expects a non-null value.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName));
					}
					break;
				}
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(newObject, contract, property.PropertyName, reader as IJsonLineInfo, reader.Path, ex))
				{
					HandleError(reader, readPastError: true, initialDepth);
					return;
				}
				throw;
			}
		}

		private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary<JsonProperty, PropertyPresence>? requiredProperties)
		{
			if (property != null && requiredProperties != null)
			{
				PropertyPresence value;
				switch (reader.TokenType)
				{
				case JsonToken.String:
					value = (CoerceEmptyStringToNull(property.PropertyType, property.PropertyContract, (string)reader.Value) ? PropertyPresence.Null : PropertyPresence.Value);
					break;
				case JsonToken.Null:
				case JsonToken.Undefined:
					value = PropertyPresence.Null;
					break;
				default:
					value = PropertyPresence.Value;
					break;
				}
				requiredProperties[property] = value;
			}
		}

		private void HandleError(JsonReader reader, bool readPastError, int initialDepth)
		{
			ClearErrorContext();
			if (readPastError)
			{
				reader.Skip();
				while (reader.Depth > initialDepth && reader.Read())
				{
				}
			}
		}
	}
	internal class JsonSerializerInternalWriter : JsonSerializerInternalBase
	{
		private Type? _rootType;

		private int _rootLevel;

		private readonly List<object> _serializeStack = new List<object>();

		public JsonSerializerInternalWriter(JsonSerializer serializer)
			: base(serializer)
		{
		}

		public void Serialize(JsonWriter jsonWriter, object? value, Type? objectType)
		{
			if (jsonWriter == null)
			{
				throw new ArgumentNullException("jsonWriter");
			}
			_rootType = objectType;
			_rootLevel = _serializeStack.Count + 1;
			JsonContract contractSafe = GetContractSafe(value);
			try
			{
				if (ShouldWriteReference(value, null, contractSafe, null, null))
				{
					WriteReference(jsonWriter, value);
				}
				else
				{
					SerializeValue(jsonWriter, value, contractSafe, null, null, null);
				}
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(null, contractSafe, null, null, jsonWriter.Path, ex))
				{
					HandleError(jsonWriter, 0);
					return;
				}
				ClearErrorContext();
				throw;
			}
			finally
			{
				_rootType = null;
			}
		}

		private JsonSerializerProxy GetInternalSerializer()
		{
			if (InternalSerializer == null)
			{
				InternalSerializer = new JsonSerializerProxy(this);
			}
			return InternalSerializer;
		}

		private JsonContract? GetContractSafe(object? value)
		{
			if (value == null)
			{
				return null;
			}
			return GetContract(value);
		}

		private JsonContract GetContract(object value)
		{
			return Serializer._contractResolver.ResolveContract(value.GetType());
		}

		private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty? member, JsonContainerContract? containerContract, JsonProperty? containerProperty)
		{
			if (contract.TypeCode == PrimitiveTypeCode.Bytes && ShouldWriteType(TypeNameHandling.Objects, contract, member, containerContract, containerProperty))
			{
				writer.WriteStartObject();
				WriteTypeProperty(writer, contract.CreatedType);
				writer.WritePropertyName("$value", escape: false);
				JsonWriter.WriteValue(writer, contract.TypeCode, value);
				writer.WriteEndObject();
			}
			else
			{
				JsonWriter.WriteValue(writer, contract.TypeCode, value);
			}
		}

		private void SerializeValue(JsonWriter writer, object? value, JsonContract? valueContract, JsonProperty? member, JsonContainerContract? containerContract, JsonProperty? containerProperty)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			JsonConverter jsonConverter = member?.Converter ?? containerProperty?.ItemConverter ?? containerContract?.ItemConverter ?? valueContract.Converter ?? Serializer.GetMatchingConverter(valueContract.UnderlyingType) ?? valueContract.InternalConverter;
			if (jsonConverter != null && jsonConverter.CanWrite)
			{
				SerializeConvertable(writer, jsonConverter, value, valueContract, containerContract, containerProperty);
				return;
			}
			switch (valueContract.ContractType)
			{
			case JsonContractType.Object:
				SerializeObject(writer, value, (JsonObjectContract)valueContract, member, containerContract, containerProperty);
				break;
			case JsonContractType.Array:
			{
				JsonArrayContract jsonArrayContract = (JsonArrayContract)valueContract;
				if (!jsonArrayContract.IsMultidimensionalArray)
				{
					SerializeList(writer, (IEnumerable)value, jsonArrayContract, member, containerContract, containerProperty);
				}
				else
				{
					SerializeMultidimensionalArray(writer, (Array)value, jsonArrayContract, member, containerContract, containerProperty);
				}
				break;
			}
			case JsonContractType.Primitive:
				SerializePrimitive(writer, value, (JsonPrimitiveContract)valueContract, member, containerContract, containerProperty);
				break;
			case JsonContractType.String:
				SerializeString(writer, value, (JsonStringContract)valueContract);
				break;
			case JsonContractType.Dictionary:
			{
				JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)valueContract;
				IDictionary values;
				if (!(value is IDictionary dictionary))
				{
					IDictionary dictionary2 = jsonDictionaryContract.CreateWrapper(value);
					values = dictionary2;
				}
				else
				{
					values = dictionary;
				}
				SerializeDictionary(writer, values, jsonDictionaryContract, member, containerContract, containerProperty);
				break;
			}
			case JsonContractType.Dynamic:
				SerializeDynamic(writer, (IDynamicMetaObjectProvider)value, (JsonDynamicContract)valueContract, member, containerContract, containerProperty);
				break;
			case JsonContractType.Serializable:
				SerializeISerializable(writer, (ISerializable)value, (JsonISerializableContract)valueContract, member, containerContract, containerProperty);
				break;
			case JsonContractType.Linq:
				((JToken)value).WriteTo(writer, Serializer.Converters.ToArray());
				break;
			}
		}

		private bool? ResolveIsReference(JsonContract contract, JsonProperty? property, JsonContainerContract? collectionContract, JsonProperty? containerProperty)
		{
			bool? result = null;
			if (property != null)
			{
				result = property.IsReference;
			}
			if (!result.HasValue && containerProperty != null)
			{
				result = containerProperty.ItemIsReference;
			}
			if (!result.HasValue && collectionContract != null)
			{
				result = collectionContract.ItemIsReference;
			}
			if (!result.HasValue)
			{
				result = contract.IsReference;
			}
			return result;
		}

		private bool ShouldWriteReference(object? value, JsonProperty? property, JsonContract? valueContract, JsonContainerContract? collectionContract, JsonProperty? containerProperty)
		{
			if (value == null)
			{
				return false;
			}
			if (valueContract.ContractType == JsonContractType.Primitive || valueContract.ContractType == JsonContractType.String)
			{
				return false;
			}
			bool? flag = ResolveIsReference(valueContract, property, collectionContract, containerProperty);
			if (!flag.HasValue)
			{
				flag = ((valueContract.ContractType != JsonContractType.Array) ? new bool?(HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Objects)) : new bool?(HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Arrays)));
			}
			if (flag != true)
			{
				return false;
			}
			return Serializer.GetReferenceResolver().IsReferenced(this, value);
		}

		private bool ShouldWriteProperty(object? memberValue, JsonObjectContract? containerContract, JsonProperty property)
		{
			if (memberValue == null && ResolvedNullValueHandling(containerContract, property) == NullValueHandling.Ignore)
			{
				return false;
			}
			if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && MiscellaneousUtils.ValueEquals(memberValue, property.GetResolvedDefaultValue()))
			{
				return false;
			}
			return true;
		}

		private bool CheckForCircularReference(JsonWriter writer, object? value, JsonProperty? property, JsonContract? contract, JsonContainerContract? containerContract, JsonProperty? containerProperty)
		{
			if (value == null)
			{
				return true;
			}
			if (contract.ContractType == JsonContractType.Primitive || contract.ContractType == JsonContractType.String)
			{
				return true;
			}
			ReferenceLoopHandling? referenceLoopHandling = null;
			if (property != null)
			{
				referenceLoopHandling = property.ReferenceLoopHandling;
			}
			if (!referenceLoopHandling.HasValue && containerProperty != null)
			{
				referenceLoopHandling = containerProperty.ItemReferenceLoopHandling;
			}
			if (!referenceLoopHandling.HasValue && containerContract != null)
			{
				referenceLoopHandling = containerContract.ItemReferenceLoopHandling;
			}
			if ((Serializer._equalityComparer != null) ? _serializeStack.Contains(value, Serializer._equalityComparer) : _serializeStack.Contains(value))
			{
				string text = "Self referencing loop detected";
				if (property != null)
				{
					text += " for property '{0}'".FormatWith(CultureInfo.InvariantCulture, property.PropertyName);
				}
				text += " with type '{0}'.".FormatWith(CultureInfo.InvariantCulture, value.GetType());
				switch (referenceLoopHandling.GetValueOrDefault(Serializer._referenceLoopHandling))
				{
				case ReferenceLoopHandling.Error:
					throw JsonSerializationException.Create(null, writer.ContainerPath, text, null);
				case ReferenceLoopHandling.Ignore:
					if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
					{
						TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, text + ". Skipping serializing self referenced value."), null);
					}
					return false;
				case ReferenceLoopHandling.Serialize:
					if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
					{
						TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, text + ". Serializing self referenced value."), null);
					}
					return true;
				}
			}
			return true;
		}

		private void WriteReference(JsonWriter writer, object value)
		{
			string reference = GetReference(writer, value);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Writing object reference to Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, reference, value.GetType())), null);
			}
			writer.WriteStartObject();
			writer.WritePropertyName("$ref", escape: false);
			writer.WriteValue(reference);
			writer.WriteEndObject();
		}

		private string GetReference(JsonWriter writer, object value)
		{
			try
			{
				return Serializer.GetReferenceResolver().GetReference(this, value);
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(null, writer.ContainerPath, "Error writing object reference for '{0}'.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), ex);
			}
		}

		internal static bool TryConvertToString(object value, Type type, [NotNullWhen(true)] out string? s)
		{
			if (JsonTypeReflector.CanTypeDescriptorConvertString(type, out var typeConverter))
			{
				s = typeConverter.ConvertToInvariantString(value);
				return true;
			}
			if (value is Type type2)
			{
				s = type2.AssemblyQualifiedName;
				return true;
			}
			s = null;
			return false;
		}

		private void SerializeString(JsonWriter writer, object value, JsonStringContract contract)
		{
			OnSerializing(writer, contract, value);
			TryConvertToString(value, contract.UnderlyingType, out string s);
			writer.WriteValue(s);
			OnSerialized(writer, contract, value);
		}

		private void OnSerializing(JsonWriter writer, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Started serializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnSerializing(value, Serializer._context);
		}

		private void OnSerialized(JsonWriter writer, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Finished serializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnSerialized(value, Serializer._context);
		}

		private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty? member, JsonContainerContract? collectionContract, JsonProperty? containerProperty)
		{
			OnSerializing(writer, contract, value);
			_serializeStack.Add(value);
			WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);
			int top = writer.Top;
			for (int i = 0; i < contract.Properties.Count; i++)
			{
				JsonProperty jsonProperty = contract.Properties[i];
				try
				{
					if (CalculatePropertyValues(writer, value, contract, member, jsonProperty, out JsonContract memberContract, out object memberValue))
					{
						jsonProperty.WritePropertyName(writer);
						SerializeValue(writer, memberValue, memberContract, jsonProperty, contract, member);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(value, contract, jsonProperty.PropertyName, null, writer.ContainerPath, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
			}
			IEnumerable<KeyValuePair<object, object>> enumerable = contract.ExtensionDataGetter?.Invoke(value);
			if (enumerable != null)
			{
				foreach (KeyValuePair<object, object> item in enumerable)
				{
					JsonContract contract2 = GetContract(item.Key);
					JsonContract contractSafe = GetContractSafe(item.Value);
					string propertyName = GetPropertyName(writer, item.Key, contract2, out var _);
					propertyName = ((contract.ExtensionDataNameResolver != null) ? contract.ExtensionDataNameResolver(propertyName) : propertyName);
					if (ShouldWriteReference(item.Value, null, contractSafe, contract, member))
					{
						writer.WritePropertyName(propertyName);
						WriteReference(writer, item.Value);
					}
					else if (CheckForCircularReference(writer, item.Value, null, contractSafe, contract, member))
					{
						writer.WritePropertyName(propertyName);
						SerializeValue(writer, item.Value, contractSafe, null, contract, member);
					}
				}
			}
			writer.WriteEndObject();
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, value);
		}

		private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty? member, JsonProperty property, [NotNullWhen(true)] out JsonContract? memberContract, out object? memberValue)
		{
			if (!property.Ignored && property.Readable && ShouldSerialize(writer, property, value) && IsSpecified(writer, property, value))
			{
				if (property.PropertyContract == null)
				{
					property.PropertyContract = Serializer._contractResolver.ResolveContract(property.PropertyType);
				}
				memberValue = property.ValueProvider.GetValue(value);
				memberContract = (property.PropertyContract.IsSealed ? property.PropertyContract : GetContractSafe(memberValue));
				if (ShouldWriteProperty(memberValue, contract as JsonObjectContract, property))
				{
					if (ShouldWriteReference(memberValue, property, memberContract, contract, member))
					{
						property.WritePropertyName(writer);
						WriteReference(writer, memberValue);
						return false;
					}
					if (!CheckForCircularReference(writer, memberValue, property, memberContract, contract, member))
					{
						return false;
					}
					if (memberValue == null)
					{
						JsonObjectContract jsonObjectContract = contract as JsonObjectContract;
						switch (property._required ?? (jsonObjectContract?.ItemRequired).GetValueOrDefault())
						{
						case Required.Always:
							throw JsonSerializationException.Create(null, writer.ContainerPath, "Cannot write a null value for property '{0}'. Property requires a value.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName), null);
						case Required.DisallowNull:
							throw JsonSerializationException.Create(null, writer.ContainerPath, "Cannot write a null value for property '{0}'. Property requires a non-null value.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName), null);
						}
					}
					return true;
				}
			}
			memberContract = null;
			memberValue = null;
			return false;
		}

		private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty? member, JsonContainerContract? collectionContract, JsonProperty? containerProperty)
		{
			writer.WriteStartObject();
			if ((ResolveIsReference(contract, member, collectionContract, containerProperty) ?? HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Objects)) && (member == null || member.Writable || HasCreatorParameter(collectionContract, member)))
			{
				WriteReferenceIdProperty(writer, contract.UnderlyingType, value);
			}
			if (ShouldWriteType(TypeNameHandling.Objects, contract, member, collectionContract, containerProperty))
			{
				WriteTypeProperty(writer, contract.UnderlyingType);
			}
		}

		private bool HasCreatorParameter(JsonContainerContract? contract, JsonProperty property)
		{
			if (!(contract is JsonObjectContract jsonObjectContract))
			{
				return false;
			}
			return jsonObjectContract.CreatorParameters.Contains(property.PropertyName);
		}

		private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value)
		{
			string reference = GetReference(writer, value);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "Writing object reference Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, reference, type)), null);
			}
			writer.WritePropertyName("$id", escape: false);
			writer.WriteValue(reference);
		}

		private void WriteTypeProperty(JsonWriter writer, Type type)
		{
			string typeName = ReflectionUtils.GetTypeName(type, Serializer._typeNameAssemblyFormatHandling, Serializer._serializationBinder);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "Writing type name '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, typeName, type)), null);
			}
			writer.WritePropertyName("$type", escape: false);
			writer.WriteValue(typeName);
		}

		private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool HasFlag(TypeNameHandling value, TypeNameHandling flag)
		{
			return (value & flag) == flag;
		}

		private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract? collectionContract, JsonProperty? containerProperty)
		{
			if (ShouldWriteReference(value, null, contract, collectionContract, containerProperty))
			{
				WriteReference(writer, value);
			}
			else if (CheckForCircularReference(writer, value, null, contract, collectionContract, containerProperty))
			{
				_serializeStack.Add(value);
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
				{
					TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Started serializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, value.GetType(), converter.GetType())), null);
				}
				converter.WriteJson(writer, value, GetInternalSerializer());
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
				{
					TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Finished serializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, value.GetType(), converter.GetType())), null);
				}
				_serializeStack.RemoveAt(_serializeStack.Count - 1);
			}
		}

		private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty? member, JsonContainerContract? collectionContract, JsonProperty? containerProperty)
		{
			object obj = ((values is IWrappedCollection wrappedCollection) ? wrappedCollection.UnderlyingCollection : values);
			OnSerializing(writer, contract, obj);
			_serializeStack.Add(obj);
			bool flag = WriteStartArray(writer, obj, contract, member, collectionContract, containerProperty);
			writer.WriteStartArray();
			int top = writer.Top;
			int num = 0;
			foreach (object value in values)
			{
				try
				{
					JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
					if (ShouldWriteReference(value, null, jsonContract, contract, member))
					{
						WriteReference(writer, value);
					}
					else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
					{
						SerializeValue(writer, value, jsonContract, null, contract, member);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(obj, contract, num, null, writer.ContainerPath, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
				finally
				{
					num++;
				}
			}
			writer.WriteEndArray();
			if (flag)
			{
				writer.WriteEndObject();
			}
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, obj);
		}

		private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty? member, JsonContainerContract? collectionContract, JsonProperty? containerProperty)
		{
			OnSerializing(writer, contract, values);
			_serializeStack.Add(values);
			bool num = WriteStartArray(writer, values, contract, member, collectionContract, containerProperty);
			SerializeMultidimensionalArray(writer, values, contract, member, writer.Top, CollectionUtils.ArrayEmpty<int>());
			if (num)
			{
				writer.WriteEndObject();
			}
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, values);
		}

		private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty? member, int initialDepth, int[] indices)
		{
			int num = indices.Length;
			int[] array = new int[num + 1];
			for (int i = 0; i < num; i++)
			{
				array[i] = indices[i];
			}
			writer.WriteStartArray();
			for (int j = values.GetLowerBound(num); j <= values.GetUpperBound(num); j++)
			{
				array[num] = j;
				if (array.Length == values.Rank)
				{
					object value = values.GetValue(array);
					try
					{
						JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
						if (ShouldWriteReference(value, null, jsonContract, contract, member))
						{
							WriteReference(writer, value);
						}
						else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
						{
							SerializeValue(writer, value, jsonContract, null, contract, member);
						}
					}
					catch (Exception ex)
					{
						if (IsErrorHandled(values, contract, j, null, writer.ContainerPath, ex))
						{
							HandleError(writer, initialDepth + 1);
							continue;
						}
						throw;
					}
				}
				else
				{
					SerializeMultidimensionalArray(writer, values, contract, member, initialDepth + 1, array);
				}
			}
			writer.WriteEndArray();
		}

		private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty? member, JsonContainerContract? containerContract, JsonProperty? containerProperty)
		{
			bool flag = (ResolveIsReference(contract, member, containerContract, containerProperty) ?? HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Arrays)) && (member == null || member.Writable || HasCreatorParameter(containerContract, member));
			bool flag2 = ShouldWriteType(TypeNameHandling.Arrays, contract, member, containerContract, containerProperty);
			bool num = flag || flag2;
			if (num)
			{
				writer.WriteStartObject();
				if (flag)
				{
					WriteReferenceIdProperty(writer, contract.UnderlyingType, values);
				}
				if (flag2)
				{
					WriteTypeProperty(writer, values.GetType());
				}
				writer.WritePropertyName("$values", escape: false);
			}
			if (contract.ItemContract == null)
			{
				contract.ItemContract = Serializer._contractResolver.ResolveContract(contract.CollectionItemType ?? typeof(object));
			}
			return num;
		}

		[SecuritySafeCritical]
		private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty? member, JsonContainerContract? collectionContract, JsonProperty? containerProperty)
		{
			if (!JsonTypeReflector.FullyTrusted)
			{
				string format = "Type '{0}' implements ISerializable but cannot be serialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data." + Environment.NewLine + "To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true." + Environment.NewLine;
				format = format.FormatWith(CultureInfo.InvariantCulture, value.GetType());
				throw JsonSerializationException.Create(null, writer.ContainerPath, format, null);
			}
			OnSerializing(writer, contract, value);
			_serializeStack.Add(value);
			WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);
			SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, new FormatterConverter());
			value.GetObjectData(serializationInfo, Serializer._context);
			SerializationInfoEnumerator enumerator = serializationInfo.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				JsonContract contractSafe = GetContractSafe(current.Value);
				if (ShouldWriteReference(current.Value, null, contractSafe, contract, member))
				{
					writer.WritePropertyName(current.Name);
					WriteReference(writer, current.Value);
				}
				else if (CheckForCircularReference(writer, current.Value, null, contractSafe, contract, member))
				{
					writer.WritePropertyName(current.Name);
					SerializeValue(writer, current.Value, contractSafe, null, contract, member);
				}
			}
			writer.WriteEndObject();
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, value);
		}

		private void SerializeDynamic(JsonWriter writer, IDynamicMetaObjectProvider value, JsonDynamicContract contract, JsonProperty? member, JsonContainerContract? collectionContract, JsonProperty? containerProperty)
		{
			OnSerializing(writer, contract, value);
			_serializeStack.Add(value);
			WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);
			int top = writer.Top;
			for (int i = 0; i < contract.Properties.Count; i++)
			{
				JsonProperty jsonProperty = contract.Properties[i];
				if (!jsonProperty.HasMemberAttribute)
				{
					continue;
				}
				try
				{
					if (CalculatePropertyValues(writer, value, contract, member, jsonProperty, out JsonContract memberContract, out object memberValue))
					{
						jsonProperty.WritePropertyName(writer);
						SerializeValue(writer, memberValue, memberContract, jsonProperty, contract, member);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(value, contract, jsonProperty.PropertyName, null, writer.ContainerPath, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
			}
			foreach (string dynamicMemberName in value.GetDynamicMemberNames())
			{
				if (!contract.TryGetMember(value, dynamicMemberName, out object value2))
				{
					continue;
				}
				try
				{
					JsonContract contractSafe = GetContractSafe(value2);
					if (ShouldWriteDynamicProperty(value2) && CheckForCircularReference(writer, value2, null, contractSafe, contract, member))
					{
						string name = ((contract.PropertyNameResolver != null) ? contract.PropertyNameResolver(dynamicMemberName) : dynamicMemberName);
						writer.WritePropertyName(name);
						SerializeValue(writer, value2, contractSafe, null, contract, member);
					}
				}
				catch (Exception ex2)
				{
					if (IsErrorHandled(value, contract, dynamicMemberName, null, writer.ContainerPath, ex2))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
			}
			writer.WriteEndObject();
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, value);
		}

		private bool ShouldWriteDynamicProperty(object? memberValue)
		{
			if (Serializer._nullValueHandling == NullValueHandling.Ignore && memberValue == null)
			{
				return false;
			}
			if (HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Ignore) && (memberValue == null || MiscellaneousUtils.ValueEquals(memberValue, ReflectionUtils.GetDefaultValue(memberValue.GetType()))))
			{
				return false;
			}
			return true;
		}

		private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty? member, JsonContainerContract? containerContract, JsonProperty? containerProperty)
		{
			TypeNameHandling value = member?.TypeNameHandling ?? containerProperty?.ItemTypeNameHandling ?? containerContract?.ItemTypeNameHandling ?? Serializer._typeNameHandling;
			if (HasFlag(value, typeNameHandlingFlag))
			{
				return true;
			}
			if (HasFlag(value, TypeNameHandling.Auto))
			{
				if (member != null)
				{
					if (contract.NonNullableUnderlyingType != member.PropertyContract.CreatedType)
					{
						return true;
					}
				}
				else if (containerContract != null)
				{
					if (containerContract.ItemContract == null || contract.NonNullableUnderlyingType != containerContract.ItemContract.CreatedType)
					{
						return true;
					}
				}
				else if (_rootType != null && _serializeStack.Count == _rootLevel)
				{
					JsonContract jsonContract = Serializer._contractResolver.ResolveContract(_rootType);
					if (contract.NonNullableUnderlyingType != jsonContract.CreatedType)
					{
						return true;
					}
				}
			}
			return false;
		}

		private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty? member, JsonContainerContract? collectionContract, JsonProperty? containerProperty)
		{
			object obj = ((values is IWrappedDictionary wrappedDictionary) ? wrappedDictionary.UnderlyingDictionary : values);
			OnSerializing(writer, contract, obj);
			_serializeStack.Add(obj);
			WriteObjectStart(writer, obj, contract, member, collectionContract, containerProperty);
			if (contract.ItemContract == null)
			{
				contract.ItemContract = Serializer._contractResolver.ResolveContract(contract.DictionaryValueType ?? typeof(object));
			}
			if (contract.KeyContract == null)
			{
				contract.KeyContract = Serializer._contractResolver.ResolveContract(contract.DictionaryKeyType ?? typeof(object));
			}
			int top = writer.Top;
			foreach (DictionaryEntry value2 in values)
			{
				string propertyName = GetPropertyName(writer, value2.Key, contract.KeyContract, out var escape);
				propertyName = ((contract.DictionaryKeyResolver != null) ? contract.DictionaryKeyResolver(propertyName) : propertyName);
				try
				{
					object value = value2.Value;
					JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
					if (ShouldWriteReference(value, null, jsonContract, contract, member))
					{
						writer.WritePropertyName(propertyName, escape);
						WriteReference(writer, value);
					}
					else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
					{
						writer.WritePropertyName(propertyName, escape);
						SerializeValue(writer, value, jsonContract, null, contract, member);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(obj, contract, propertyName, null, writer.ContainerPath, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
			}
			writer.WriteEndObject();
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, obj);
		}

		private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, out bool escape)
		{
			if (contract.ContractType == JsonContractType.Primitive)
			{
				JsonPrimitiveContract jsonPrimitiveContract = (JsonPrimitiveContract)contract;
				switch (jsonPrimitiveContract.TypeCode)
				{
				case PrimitiveTypeCode.DateTime:
				case PrimitiveTypeCode.DateTimeNullable:
				{
					DateTime value = DateTimeUtils.EnsureDateTime((DateTime)name, writer.DateTimeZoneHandling);
					escape = false;
					StringWriter stringWriter2 = new StringWriter(CultureInfo.InvariantCulture);
					DateTimeUtils.WriteDateTimeString(stringWriter2, value, writer.DateFormatHandling, writer.DateFormatString, writer.Culture);
					return stringWriter2.ToString();
				}
				case PrimitiveTypeCode.DateTimeOffset:
				case PrimitiveTypeCode.DateTimeOffsetNullable:
				{
					escape = false;
					StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
					DateTimeUtils.WriteDateTimeOffsetString(stringWriter, (DateTimeOffset)name, writer.DateFormatHandling, writer.DateFormatString, writer.Culture);
					return stringWriter.ToString();
				}
				case PrimitiveTypeCode.Double:
				case PrimitiveTypeCode.DoubleNullable:
				{
					double num = (double)name;
					escape = false;
					return num.ToString("R", CultureInfo.InvariantCulture);
				}
				case PrimitiveTypeCode.Single:
				case PrimitiveTypeCode.SingleNullable:
				{
					float num2 = (float)name;
					escape = false;
					return num2.ToString("R", CultureInfo.InvariantCulture);
				}
				default:
				{
					escape = true;
					if (jsonPrimitiveContract.IsEnum && EnumUtils.TryToString(jsonPrimitiveContract.NonNullableUnderlyingType, name, null, out string name2))
					{
						return name2;
					}
					return Convert.ToString(name, CultureInfo.InvariantCulture);
				}
				}
			}
			if (TryConvertToString(name, name.GetType(), out string s))
			{
				escape = true;
				return s;
			}
			escape = true;
			return name.ToString();
		}

		private void HandleError(JsonWriter writer, int initialDepth)
		{
			ClearErrorContext();
			if (writer.WriteState == WriteState.Property)
			{
				writer.WriteNull();
			}
			while (writer.Top > initialDepth)
			{
				writer.WriteEnd();
			}
		}

		private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target)
		{
			if (property.ShouldSerialize == null)
			{
				return true;
			}
			bool flag = property.ShouldSerialize(target);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "ShouldSerialize result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, flag)), null);
			}
			return flag;
		}

		private bool IsSpecified(JsonWriter writer, JsonProperty property, object target)
		{
			if (property.GetIsSpecified == null)
			{
				return true;
			}
			bool flag = property.GetIsSpecified(target);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "IsSpecified result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, flag)), null);
			}
			return flag;
		}
	}
	internal class JsonSerializerProxy : JsonSerializer
	{
		private readonly JsonSerializerInternalReader? _serializerReader;

		private readonly JsonSerializerInternalWriter? _serializerWriter;

		private readonly JsonSerializer _serializer;

		public override IReferenceResolver? ReferenceResolver
		{
			get
			{
				return _serializer.ReferenceResolver;
			}
			set
			{
				_serializer.ReferenceResolver = value;
			}
		}

		public override ITraceWriter? TraceWriter
		{
			get
			{
				return _serializer.TraceWriter;
			}
			set
			{
				_serializer.TraceWriter = value;
			}
		}

		public override IEqualityComparer? EqualityComparer
		{
			get
			{
				return _serializer.EqualityComparer;
			}
			set
			{
				_serializer.EqualityComparer = value;
			}
		}

		public override JsonConverterCollection Converters => _serializer.Converters;

		public override DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _serializer.DefaultValueHandling;
			}
			set
			{
				_serializer.DefaultValueHandling = value;
			}
		}

		public override IContractResolver ContractResolver
		{
			get
			{
				return _serializer.ContractResolver;
			}
			set
			{
				_serializer.ContractResolver = value;
			}
		}

		public override MissingMemberHandling MissingMemberHandling
		{
			get
			{
				return _serializer.MissingMemberHandling;
			}
			set
			{
				_serializer.MissingMemberHandling = value;
			}
		}

		public override NullValueHandling NullValueHandling
		{
			get
			{
				return _serializer.NullValueHandling;
			}
			set
			{
				_serializer.NullValueHandling = value;
			}
		}

		public override ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _serializer.ObjectCreationHandling;
			}
			set
			{
				_serializer.ObjectCreationHandling = value;
			}
		}

		public override ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _serializer.ReferenceLoopHandling;
			}
			set
			{
				_serializer.ReferenceLoopHandling = value;
			}
		}

		public override PreserveReferencesHandling PreserveReferencesHandling
		{
			get
			{
				return _serializer.PreserveReferencesHandling;
			}
			set
			{
				_serializer.PreserveReferencesHandling = value;
			}
		}

		public override TypeNameHandling TypeNameHandling
		{
			get
			{
				return _serializer.TypeNameHandling;
			}
			set
			{
				_serializer.TypeNameHandling = value;
			}
		}

		public override MetadataPropertyHandling MetadataPropertyHandling
		{
			get
			{
				return _serializer.MetadataPropertyHandling;
			}
			set
			{
				_serializer.MetadataPropertyHandling = value;
			}
		}

		[Obsolete("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
		public override FormatterAssemblyStyle TypeNameAssemblyFormat
		{
			get
			{
				return _serializer.TypeNameAssemblyFormat;
			}
			set
			{
				_serializer.TypeNameAssemblyFormat = value;
			}
		}

		public override TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling
		{
			get
			{
				return _serializer.TypeNameAssemblyFormatHandling;
			}
			set
			{
				_serializer.TypeNameAssemblyFormatHandling = value;
			}
		}

		public override ConstructorHandling ConstructorHandling
		{
			get
			{
				return _serializer.ConstructorHandling;
			}
			set
			{
				_serializer.ConstructorHandling = value;
			}
		}

		[Obsolete("Binder is obsolete. Use SerializationBinder instead.")]
		public override SerializationBinder Binder
		{
			get
			{
				return _serializer.Binder;
			}
			set
			{
				_serializer.Binder = value;
			}
		}

		public override ISerializationBinder SerializationBinder
		{
			get
			{
				return _serializer.SerializationBinder;
			}
			set
			{
				_serializer.SerializationBinder = value;
			}
		}

		public override StreamingContext Context
		{
			get
			{
				return _serializer.Context;
			}
			set
			{
				_serializer.Context = value;
			}
		}

		public override Formatting Formatting
		{
			get
			{
				return _serializer.Formatting;
			}
			set
			{
				_serializer.Formatting = value;
			}
		}

		public override DateFormatHandling DateFormatHandling
		{
			get
			{
				return _serializer.DateFormatHandling;
			}
			set
			{
				_serializer.DateFormatHandling = value;
			}
		}

		public override DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _serializer.DateTimeZoneHandling;
			}
			set
			{
				_serializer.DateTimeZoneHandling = value;
			}
		}

		public override DateParseHandling DateParseHandling
		{
			get
			{
				return _serializer.DateParseHandling;
			}
			set
			{
				_serializer.DateParseHandling = value;
			}
		}

		public override FloatFormatHandling FloatFormatHandling
		{
			get
			{
				return _serializer.FloatFormatHandling;
			}
			set
			{
				_serializer.FloatFormatHandling = value;
			}
		}

		public override FloatParseHandling FloatParseHandling
		{
			get
			{
				return _serializer.FloatParseHandling;
			}
			set
			{
				_serializer.FloatParseHandling = value;
			}
		}

		public override StringEscapeHandling StringEscapeHandling
		{
			get
			{
				return _serializer.StringEscapeHandling;
			}
			set
			{
				_serializer.StringEscapeHandling = value;
			}
		}

		public override string DateFormatString
		{
			get
			{
				return _serializer.DateFormatString;
			}
			set
			{
				_serializer.DateFormatString = value;
			}
		}

		public override CultureInfo Culture
		{
			get
			{
				return _serializer.Culture;
			}
			set
			{
				_serializer.Culture = value;
			}
		}

		public override int? MaxDepth
		{
			get
			{
				return _serializer.MaxDepth;
			}
			set
			{
				_serializer.MaxDepth = value;
			}
		}

		public override bool CheckAdditionalContent
		{
			get
			{
				return _serializer.CheckAdditionalContent;
			}
			set
			{
				_serializer.CheckAdditionalContent = value;
			}
		}

		public override event EventHandler<ErrorEventArgs>? Error
		{
			add
			{
				_serializer.Error += value;
			}
			remove
			{
				_serializer.Error -= value;
			}
		}

		internal JsonSerializerInternalBase GetInternalSerializer()
		{
			if (_serializerReader != null)
			{
				return _serializerReader;
			}
			return _serializerWriter;
		}

		public JsonSerializerProxy(JsonSerializerInternalReader serializerReader)
		{
			ValidationUtils.ArgumentNotNull(serializerReader, "serializerReader");
			_serializerReader = serializerReader;
			_serializer = serializerReader.Serializer;
		}

		public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter)
		{
			ValidationUtils.ArgumentNotNull(serializerWriter, "serializerWriter");
			_serializerWriter = serializerWriter;
			_serializer = serializerWriter.Serializer;
		}

		internal override object? DeserializeInternal(JsonReader reader, Type? objectType)
		{
			if (_serializerReader != null)
			{
				return _serializerReader.Deserialize(reader, objectType, checkAdditionalContent: false);
			}
			return _serializer.Deserialize(reader, objectType);
		}

		internal override void PopulateInternal(JsonReader reader, object target)
		{
			if (_serializerReader != null)
			{
				_serializerReader.Populate(reader, target);
			}
			else
			{
				_serializer.Populate(reader, target);
			}
		}

		internal override void SerializeInternal(JsonWriter jsonWriter, object? value, Type? rootType)
		{
			if (_serializerWriter != null)
			{
				_serializerWriter.Serialize(jsonWriter, value, rootType);
			}
			else
			{
				_serializer.Serialize(jsonWriter, value);
			}
		}
	}
	internal class JsonStringContract : JsonPrimitiveContract
	{
		public JsonStringContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.String;
		}
	}
	internal static class JsonTypeReflector
	{
		private static bool? _dynamicCodeGeneration;

		private static bool? _fullyTrusted;

		public const string IdPropertyName = "$id";

		public const string RefPropertyName = "$ref";

		public const string TypePropertyName = "$type";

		public const string ValuePropertyName = "$value";

		public const string ArrayValuesPropertyName = "$values";

		public const string ShouldSerializePrefix = "ShouldSerialize";

		public const string SpecifiedPostfix = "Specified";

		public const string ConcurrentDictionaryTypeName = "System.Collections.Concurrent.ConcurrentDictionary`2";

		private static readonly ThreadSafeStore<Type, Func<object[]?, object>> CreatorCache = new ThreadSafeStore<Type, Func<object[], object>>(GetCreator);

		private static readonly ThreadSafeStore<Type, Type?> AssociatedMetadataTypesCache = new ThreadSafeStore<Type, Type>(GetAssociateMetadataTypeFromAttribute);

		private static ReflectionObject? _metadataTypeAttributeReflectionObject;

		public static bool DynamicCodeGeneration
		{
			[SecuritySafeCritical]
			get
			{
				if (!_dynamicCodeGeneration.HasValue)
				{
					_dynamicCodeGeneration = false;
				}
				return _dynamicCodeGeneration == true;
			}
		}

		public static bool FullyTrusted
		{
			get
			{
				if (!_fullyTrusted.HasValue)
				{
					AppDomain currentDomain = AppDomain.CurrentDomain;
					_fullyTrusted = currentDomain.IsHomogenous && currentDomain.IsFullyTrusted;
				}
				return _fullyTrusted == true;
			}
		}

		public static ReflectionDelegateFactory ReflectionDelegateFactory => LateBoundReflectionDelegateFactory.Instance;

		public static T? GetCachedAttribute<T>(object attributeProvider) where T : Attribute
		{
			return CachedAttributeGetter<T>.GetAttribute(attributeProvider);
		}

		public static bool CanTypeDescriptorConvertString(Type type, out TypeConverter typeConverter)
		{
			typeConverter = TypeDescriptor.GetConverter(type);
			if (typeConverter != null)
			{
				Type type2 = typeConverter.GetType();
				if (!string.Equals(type2.FullName, "System.ComponentModel.ComponentConverter", StringComparison.Ordinal) && !string.Equals(type2.FullName, "System.ComponentModel.ReferenceConverter", StringComparison.Ordinal) && !string.Equals(type2.FullName, "System.Windows.Forms.Design.DataSourceConverter", StringComparison.Ordinal) && type2 != typeof(TypeConverter))
				{
					return typeConverter.CanConvertTo(typeof(string));
				}
			}
			return false;
		}

		public static DataContractAttribute? GetDataContractAttribute(Type type)
		{
			Type type2 = type;
			while (type2 != null)
			{
				DataContractAttribute attribute = CachedAttributeGetter<DataContractAttribute>.GetAttribute(type2);
				if (attribute != null)
				{
					return attribute;
				}
				type2 = type2.BaseType();
			}
			return null;
		}

		public static DataMemberAttribute? GetDataMemberAttribute(MemberInfo memberInfo)
		{
			if (memberInfo.MemberType() == MemberTypes.Field)
			{
				return CachedAttributeGetter<DataMemberAttribute>.GetAttribute(memberInfo);
			}
			PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
			DataMemberAttribute attribute = CachedAttributeGetter<DataMemberAttribute>.GetAttribute(propertyInfo);
			if (attribute == null && propertyInfo.IsVirtual())
			{
				Type type = propertyInfo.DeclaringType;
				while (attribute == null && type != null)
				{
					PropertyInfo propertyInfo2 = (PropertyInfo)ReflectionUtils.GetMemberInfoFromType(type, propertyInfo);
					if (propertyInfo2 != null && propertyInfo2.IsVirtual())
					{
						attribute = CachedAttributeGetter<DataMemberAttribute>.GetAttribute(propertyInfo2);
					}
					type = type.BaseType();
				}
			}
			return attribute;
		}

		public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute)
		{
			JsonObjectAttribute cachedAttribute = GetCachedAttribute<JsonObjectAttribute>(objectType);
			if (cachedAttribute != null)
			{
				return cachedAttribute.MemberSerialization;
			}
			if (GetDataContractAttribute(objectType) != null)
			{
				return MemberSerialization.OptIn;
			}
			if (!ignoreSerializableAttribute && IsSerializable(objectType))
			{
				return MemberSerialization.Fields;
			}
			return MemberSerialization.OptOut;
		}

		public static JsonConverter? GetJsonConverter(object attributeProvider)
		{
			JsonConverterAttribute cachedAttribute = GetCachedAttribute<JsonConverterAttribute>(attributeProvider);
			if (cachedAttribute != null)
			{
				Func<object[], object> func = CreatorCache.Get(cachedAttribute.ConverterType);
				if (func != null)
				{
					return (JsonConverter)func(cachedAttribute.ConverterParameters);
				}
			}
			return null;
		}

		public static JsonConverter CreateJsonConverterInstance(Type converterType, object[]? args)
		{
			return (JsonConverter)CreatorCache.Get(converterType)(args);
		}

		public static NamingStrategy CreateNamingStrategyInstance(Type namingStrategyType, object[]? args)
		{
			return (NamingStrategy)CreatorCache.Get(namingStrategyType)(args);
		}

		public static NamingStrategy? GetContainerNamingStrategy(JsonContainerAttribute containerAttribute)
		{
			if (containerAttribute.NamingStrategyInstance == null)
			{
				if (containerAttribute.NamingStrategyType == null)
				{
					return null;
				}
				containerAttribute.NamingStrategyInstance = CreateNamingStrategyInstance(containerAttribute.NamingStrategyType, containerAttribute.NamingStrategyParameters);
			}
			return containerAttribute.NamingStrategyInstance;
		}

		private static Func<object[]?, object> GetCreator(Type type)
		{
			Func<object> defaultConstructor = (ReflectionUtils.HasDefaultConstructor(type, nonPublic: false) ? ReflectionDelegateFactory.CreateDefaultConstructor<object>(type) : null);
			return delegate(object[]? parameters)
			{
				try
				{
					if (parameters != null)
					{
						Type[] types = parameters.Select(delegate(object param)
						{
							if (param == null)
							{
								throw new InvalidOperationException("Cannot pass a null parameter to the constructor.");
							}
							return param.GetType();
						}).ToArray();
						ConstructorInfo constructor = type.GetConstructor(types);
						if (!(constructor != null))
						{
							throw new JsonException("No matching parameterized constructor found for '{0}'.".FormatWith(CultureInfo.InvariantCulture, type));
						}
						return ReflectionDelegateFactory.CreateParameterizedConstructor(constructor)(parameters);
					}
					if (defaultConstructor == null)
					{
						throw new JsonException("No parameterless constructor defined for '{0}'.".FormatWith(CultureInfo.InvariantCulture, type));
					}
					return defaultConstructor();
				}
				catch (Exception innerException)
				{
					throw new JsonException("Error creating '{0}'.".FormatWith(CultureInfo.InvariantCulture, type), innerException);
				}
			};
		}

		private static Type? GetAssociatedMetadataType(Type type)
		{
			return AssociatedMetadataTypesCache.Get(type);
		}

		private static Type? GetAssociateMetadataTypeFromAttribute(Type type)
		{
			Attribute[] attributes = ReflectionUtils.GetAttributes(type, null, inherit: true);
			foreach (Attribute attribute in attributes)
			{
				Type type2 = attribute.GetType();
				if (string.Equals(type2.FullName, "System.ComponentModel.DataAnnotations.MetadataTypeAttribute", StringComparison.Ordinal))
				{
					if (_metadataTypeAttributeReflectionObject == null)
					{
						_metadataTypeAttributeReflectionObject = ReflectionObject.Create(type2, "MetadataClassType");
					}
					return (Type)_metadataTypeAttributeReflectionObject.GetValue(attribute, "MetadataClassType");
				}
			}
			return null;
		}

		private static T? GetAttribute<T>(Type type) where T : Attribute
		{
			Type associatedMetadataType = GetAssociatedMetadataType(type);
			T attribute;
			if (associatedMetadataType != null)
			{
				attribute = ReflectionUtils.GetAttribute<T>(associatedMetadataType, inherit: true);
				if (attribute != null)
				{
					return attribute;
				}
			}
			attribute = ReflectionUtils.GetAttribute<T>(type, inherit: true);
			if (attribute != null)
			{
				return attribute;
			}
			Type[] interfaces = type.GetInterfaces();
			for (int i = 0; i < interfaces.Length; i++)
			{
				attribute = ReflectionUtils.GetAttribute<T>(interfaces[i], inherit: true);
				if (attribute != null)
				{
					return attribute;
				}
			}
			return null;
		}

		private static T? GetAttribute<T>(MemberInfo memberInfo) where T : Attribute
		{
			Type associatedMetadataType = GetAssociatedMetadataType(memberInfo.DeclaringType);
			T attribute;
			if (associatedMetadataType != null)
			{
				MemberInfo memberInfoFromType = ReflectionUtils.GetMemberInfoFromType(associatedMetadataType, memberInfo);
				if (memberInfoFromType != null)
				{
					attribute = ReflectionUtils.GetAttribute<T>(memberInfoFromType, inherit: true);
					if (attribute != null)
					{
						return attribute;
					}
				}
			}
			attribute = ReflectionUtils.GetAttribute<T>(memberInfo, inherit: true);
			if (attribute != null)
			{
				return attribute;
			}
			if (memberInfo.DeclaringType != null)
			{
				Type[] interfaces = memberInfo.DeclaringType.GetInterfaces();
				for (int i = 0; i < interfaces.Length; i++)
				{
					MemberInfo memberInfoFromType2 = ReflectionUtils.GetMemberInfoFromType(interfaces[i], memberInfo);
					if (memberInfoFromType2 != null)
					{
						attribute = ReflectionUtils.GetAttribute<T>(memberInfoFromType2, inherit: true);
						if (attribute != null)
						{
							return attribute;
						}
					}
				}
			}
			return null;
		}

		public static bool IsNonSerializable(object provider)
		{
			return ReflectionUtils.GetAttribute<NonSerializedAttribute>(provider, inherit: false) != null;
		}

		public static bool IsSerializable(object provider)
		{
			return ReflectionUtils.GetAttribute<SerializableAttribute>(provider, inherit: false) != null;
		}

		public static T? GetAttribute<T>(object provider) where T : Attribute
		{
			if (provider is Type type)
			{
				return GetAttribute<T>(type);
			}
			if (provider is MemberInfo memberInfo)
			{
				return GetAttribute<T>(memberInfo);
			}
			return ReflectionUtils.GetAttribute<T>(provider, inherit: true);
		}
	}
	internal class KebabCaseNamingStrategy : NamingStrategy
	{
		public KebabCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames)
		{
			base.ProcessDictionaryKeys = processDictionaryKeys;
			base.OverrideSpecifiedNames = overrideSpecifiedNames;
		}

		public KebabCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames)
			: this(processDictionaryKeys, overrideSpecifiedNames)
		{
			base.ProcessExtensionDataNames = processExtensionDataNames;
		}

		public KebabCaseNamingStrategy()
		{
		}

		protected override string ResolvePropertyName(string name)
		{
			return StringUtils.ToKebabCase(name);
		}
	}
	internal class MemoryTraceWriter : ITraceWriter
	{
		private readonly Queue<string> _traceMessages;

		private readonly object _lock;

		public TraceLevel LevelFilter { get; set; }

		public MemoryTraceWriter()
		{
			LevelFilter = TraceLevel.Verbose;
			_traceMessages = new Queue<string>();
			_lock = new object();
		}

		public void Trace(TraceLevel level, string message, Exception? ex)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(DateTime.Now.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff", CultureInfo.InvariantCulture));
			stringBuilder.Append(' ');
			stringBuilder.Append(level.ToString("g"));
			stringBuilder.Append(' ');
			stringBuilder.Append(message);
			string item = stringBuilder.ToString();
			lock (_lock)
			{
				if (_traceMessages.Count >= 1000)
				{
					_traceMessages.Dequeue();
				}
				_traceMessages.Enqueue(item);
			}
		}

		public IEnumerable<string> GetTraceMessages()
		{
			return _traceMessages;
		}

		public override string ToString()
		{
			lock (_lock)
			{
				StringBuilder stringBuilder = new StringBuilder();
				foreach (string traceMessage in _traceMessages)
				{
					if (stringBuilder.Length > 0)
					{
						stringBuilder.AppendLine();
					}
					stringBuilder.Append(traceMessage);
				}
				return stringBuilder.ToString();
			}
		}
	}
	internal abstract class NamingStrategy
	{
		public bool ProcessDictionaryKeys { get; set; }

		public bool ProcessExtensionDataNames { get; set; }

		public bool OverrideSpecifiedNames { get; set; }

		public virtual string GetPropertyName(string name, bool hasSpecifiedName)
		{
			if (hasSpecifiedName && !OverrideSpecifiedNames)
			{
				return name;
			}
			return ResolvePropertyName(name);
		}

		public virtual string GetExtensionDataName(string name)
		{
			if (!ProcessExtensionDataNames)
			{
				return name;
			}
			return ResolvePropertyName(name);
		}

		public virtual string GetDictionaryKey(string key)
		{
			if (!ProcessDictionaryKeys)
			{
				return key;
			}
			return ResolvePropertyName(key);
		}

		protected abstract string ResolvePropertyName(string name);

		public override int GetHashCode()
		{
			return (((((GetType().GetHashCode() * 397) ^ ProcessDictionaryKeys.GetHashCode()) * 397) ^ ProcessExtensionDataNames.GetHashCode()) * 397) ^ OverrideSpecifiedNames.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			return Equals(obj as NamingStrategy);
		}

		protected bool Equals(NamingStrategy? other)
		{
			if (other == null)
			{
				return false;
			}
			if (GetType() == other.GetType() && ProcessDictionaryKeys == other.ProcessDictionaryKeys && ProcessExtensionDataNames == other.ProcessExtensionDataNames)
			{
				return OverrideSpecifiedNames == other.OverrideSpecifiedNames;
			}
			return false;
		}
	}
	internal delegate object ObjectConstructor<T>(params object?[] args);
	[AttributeUsage(AttributeTargets.Method, Inherited = false)]
	internal sealed class OnErrorAttribute : Attribute
	{
	}
	internal class ReflectionAttributeProvider : IAttributeProvider
	{
		private readonly object _attributeProvider;

		public ReflectionAttributeProvider(object attributeProvider)
		{
			ValidationUtils.ArgumentNotNull(attributeProvider, "attributeProvider");
			_attributeProvider = attributeProvider;
		}

		public IList<Attribute> GetAttributes(bool inherit)
		{
			return ReflectionUtils.GetAttributes(_attributeProvider, null, inherit);
		}

		public IList<Attribute> GetAttributes(Type attributeType, bool inherit)
		{
			return ReflectionUtils.GetAttributes(_attributeProvider, attributeType, inherit);
		}
	}
	internal class ReflectionValueProvider : IValueProvider
	{
		private readonly MemberInfo _memberInfo;

		public ReflectionValueProvider(MemberInfo memberInfo)
		{
			ValidationUtils.ArgumentNotNull(memberInfo, "memberInfo");
			_memberInfo = memberInfo;
		}

		public void SetValue(object target, object? value)
		{
			try
			{
				ReflectionUtils.SetMemberValue(_memberInfo, target, value);
			}
			catch (Exception innerException)
			{
				throw new JsonSerializationException("Error setting value to '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), innerException);
			}
		}

		public object? GetValue(object target)
		{
			try
			{
				if (_memberInfo is PropertyInfo propertyInfo && propertyInfo.PropertyType.IsByRef)
				{
					throw new InvalidOperationException("Could not create getter for {0}. ByRef return values are not supported.".FormatWith(CultureInfo.InvariantCulture, propertyInfo));
				}
				return ReflectionUtils.GetMemberValue(_memberInfo, target);
			}
			catch (Exception innerException)
			{
				throw new JsonSerializationException("Error getting value from '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), innerException);
			}
		}
	}
	internal class SerializationBinderAdapter : ISerializationBinder
	{
		public readonly SerializationBinder SerializationBinder;

		public SerializationBinderAdapter(SerializationBinder serializationBinder)
		{
			SerializationBinder = serializationBinder;
		}

		public Type BindToType(string? assemblyName, string typeName)
		{
			return SerializationBinder.BindToType(assemblyName, typeName);
		}

		public void BindToName(Type serializedType, out string? assemblyName, out string? typeName)
		{
			SerializationBinder.BindToName(serializedType, out assemblyName, out typeName);
		}
	}
	internal class SnakeCaseNamingStrategy : NamingStrategy
	{
		public SnakeCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames)
		{
			base.ProcessDictionaryKeys = processDictionaryKeys;
			base.OverrideSpecifiedNames = overrideSpecifiedNames;
		}

		public SnakeCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames)
			: this(processDictionaryKeys, overrideSpecifiedNames)
		{
			base.ProcessExtensionDataNames = processExtensionDataNames;
		}

		public SnakeCaseNamingStrategy()
		{
		}

		protected override string ResolvePropertyName(string name)
		{
			return StringUtils.ToSnakeCase(name);
		}
	}
	internal class TraceJsonReader : JsonReader, IJsonLineInfo
	{
		private readonly JsonReader _innerReader;

		private readonly JsonTextWriter _textWriter;

		private readonly StringWriter _sw;

		public override int Depth => _innerReader.Depth;

		public override string Path => _innerReader.Path;

		public override char QuoteChar
		{
			get
			{
				return _innerReader.QuoteChar;
			}
			protected internal set
			{
				_innerReader.QuoteChar = value;
			}
		}

		public override JsonToken TokenType => _innerReader.TokenType;

		public override object? Value => _innerReader.Value;

		public override Type? ValueType => _innerReader.ValueType;

		int IJsonLineInfo.LineNumber
		{
			get
			{
				if (!(_innerReader is IJsonLineInfo jsonLineInfo))
				{
					return 0;
				}
				return jsonLineInfo.LineNumber;
			}
		}

		int IJsonLineInfo.LinePosition
		{
			get
			{
				if (!(_innerReader is IJsonLineInfo jsonLineInfo))
				{
					return 0;
				}
				return jsonLineInfo.LinePosition;
			}
		}

		public TraceJsonReader(JsonReader innerReader)
		{
			_innerReader = innerReader;
			_sw = new StringWriter(CultureInfo.InvariantCulture);
			_sw.Write("Deserialized JSON: " + Environment.NewLine);
			_textWriter = new JsonTextWriter(_sw);
			_textWriter.Formatting = Formatting.Indented;
		}

		public string GetDeserializedJsonMessage()
		{
			return _sw.ToString();
		}

		public override bool Read()
		{
			bool result = _innerReader.Read();
			WriteCurrentToken();
			return result;
		}

		public override int? ReadAsInt32()
		{
			int? result = _innerReader.ReadAsInt32();
			WriteCurrentToken();
			return result;
		}

		public override string? ReadAsString()
		{
			string? result = _innerReader.ReadAsString();
			WriteCurrentToken();
			return result;
		}

		public override byte[]? ReadAsBytes()
		{
			byte[]? result = _innerReader.ReadAsBytes();
			WriteCurrentToken();
			return result;
		}

		public override decimal? ReadAsDecimal()
		{
			decimal? result = _innerReader.ReadAsDecimal();
			WriteCurrentToken();
			return result;
		}

		public override double? ReadAsDouble()
		{
			double? result = _innerReader.ReadAsDouble();
			WriteCurrentToken();
			return result;
		}

		public override bool? ReadAsBoolean()
		{
			bool? result = _innerReader.ReadAsBoolean();
			WriteCurrentToken();
			return result;
		}

		public override DateTime? ReadAsDateTime()
		{
			DateTime? result = _innerReader.ReadAsDateTime();
			WriteCurrentToken();
			return result;
		}

		public override DateTimeOffset? ReadAsDateTimeOffset()
		{
			DateTimeOffset? result = _innerReader.ReadAsDateTimeOffset();
			WriteCurrentToken();
			return result;
		}

		public void WriteCurrentToken()
		{
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
		}

		public override void Close()
		{
			_innerReader.Close();
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			if (_innerReader is IJsonLineInfo jsonLineInfo)
			{
				return jsonLineInfo.HasLineInfo();
			}
			return false;
		}
	}
	internal class TraceJsonWriter : JsonWriter
	{
		private readonly JsonWriter _innerWriter;

		private readonly JsonTextWriter _textWriter;

		private readonly StringWriter _sw;

		public TraceJsonWriter(JsonWriter innerWriter)
		{
			_innerWriter = innerWriter;
			_sw = new StringWriter(CultureInfo.InvariantCulture);
			_sw.Write("Serialized JSON: " + Environment.NewLine);
			_textWriter = new JsonTextWriter(_sw);
			_textWriter.Formatting = Formatting.Indented;
			_textWriter.Culture = innerWriter.Culture;
			_textWriter.DateFormatHandling = innerWriter.DateFormatHandling;
			_textWriter.DateFormatString = innerWriter.DateFormatString;
			_textWriter.DateTimeZoneHandling = innerWriter.DateTimeZoneHandling;
			_textWriter.FloatFormatHandling = innerWriter.FloatFormatHandling;
		}

		public string GetSerializedJsonMessage()
		{
			return _sw.ToString();
		}

		public override void WriteValue(decimal value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(decimal? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(bool value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(bool? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value == true);
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(byte value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(byte? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(char value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(char? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(byte[]? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value == null)
			{
				base.WriteUndefined();
			}
			else
			{
				base.WriteValue(value);
			}
		}

		public override void WriteValue(DateTime value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(DateTime? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(DateTimeOffset value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(DateTimeOffset? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(double value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(double? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteUndefined()
		{
			_textWriter.WriteUndefined();
			_innerWriter.WriteUndefined();
			base.WriteUndefined();
		}

		public override void WriteNull()
		{
			_textWriter.WriteNull();
			_innerWriter.WriteNull();
			base.WriteUndefined();
		}

		public override void WriteValue(float value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(float? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(Guid value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(Guid? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(int value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(int? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(long value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(long? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(object? value)
		{
			if (value is BigInteger)
			{
				_textWriter.WriteValue(value);
				_innerWriter.WriteValue(value);
				InternalWriteValue(JsonToken.Integer);
				return;
			}
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value == null)
			{
				base.WriteUndefined();
			}
			else
			{
				InternalWriteValue(JsonToken.String);
			}
		}

		public override void WriteValue(sbyte value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(sbyte? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(short value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(short? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(string? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(TimeSpan value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(TimeSpan? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(uint value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(uint? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(ulong value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(ulong? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteValue(Uri? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value == null)
			{
				base.WriteUndefined();
			}
			else
			{
				base.WriteValue(value);
			}
		}

		public override void WriteValue(ushort value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(ushort? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			if (value.HasValue)
			{
				base.WriteValue(value.GetValueOrDefault());
			}
			else
			{
				base.WriteUndefined();
			}
		}

		public override void WriteWhitespace(string ws)
		{
			_textWriter.WriteWhitespace(ws);
			_innerWriter.WriteWhitespace(ws);
			base.WriteWhitespace(ws);
		}

		public override void WriteComment(string? text)
		{
			_textWriter.WriteComment(text);
			_innerWriter.WriteComment(text);
			base.WriteComment(text);
		}

		public override void WriteStartArray()
		{
			_textWriter.WriteStartArray();
			_innerWriter.WriteStartArray();
			base.WriteStartArray();
		}

		public override void WriteEndArray()
		{
			_textWriter.WriteEndArray();
			_innerWriter.WriteEndArray();
			base.WriteEndArray();
		}

		public override void WriteStartConstructor(string name)
		{
			_textWriter.WriteStartConstructor(name);
			_innerWriter.WriteStartConstructor(name);
			base.WriteStartConstructor(name);
		}

		public override void WriteEndConstructor()
		{
			_textWriter.WriteEndConstructor();
			_innerWriter.WriteEndConstructor();
			base.WriteEndConstructor();
		}

		public override void WritePropertyName(string name)
		{
			_textWriter.WritePropertyName(name);
			_innerWriter.WritePropertyName(name);
			base.WritePropertyName(name);
		}

		public override void WritePropertyName(string name, bool escape)
		{
			_textWriter.WritePropertyName(name, escape);
			_innerWriter.WritePropertyName(name, escape);
			base.WritePropertyName(name);
		}

		public override void WriteStartObject()
		{
			_textWriter.WriteStartObject();
			_innerWriter.WriteStartObject();
			base.WriteStartObject();
		}

		public override void WriteEndObject()
		{
			_textWriter.WriteEndObject();
			_innerWriter.WriteEndObject();
			base.WriteEndObject();
		}

		public override void WriteRawValue(string? json)
		{
			_textWriter.WriteRawValue(json);
			_innerWriter.WriteRawValue(json);
			InternalWriteValue(JsonToken.Undefined);
		}

		public override void WriteRaw(string? json)
		{
			_textWriter.WriteRaw(json);
			_innerWriter.WriteRaw(json);
			base.WriteRaw(json);
		}

		public override void Close()
		{
			_textWriter.Close();
			_innerWriter.Close();
			base.Close();
		}

		public override void Flush()
		{
			_textWriter.Flush();
			_innerWriter.Flush();
		}
	}
}
namespace Microsoft.Identity.Json.Schema
{
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal static class Extensions
	{
		[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
		public static bool IsValid(this JToken source, JsonSchema schema)
		{
			bool valid = true;
			source.Validate(schema, delegate
			{
				valid = false;
			});
			return valid;
		}

		[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
		public static bool IsValid(this JToken source, JsonSchema schema, out IList<string> errorMessages)
		{
			IList<string> errors = new List<string>();
			source.Validate(schema, delegate(object sender, ValidationEventArgs args)
			{
				errors.Add(args.Message);
			});
			errorMessages = errors;
			return errorMessages.Count == 0;
		}

		[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
		public static void Validate(this JToken source, JsonSchema schema)
		{
			source.Validate(schema, null);
		}

		[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
		public static void Validate(this JToken source, JsonSchema schema, ValidationEventHandler validationEventHandler)
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			ValidationUtils.ArgumentNotNull(schema, "schema");
			using JsonValidatingReader jsonValidatingReader = new JsonValidatingReader(source.CreateReader());
			jsonValidatingReader.Schema = schema;
			if (validationEventHandler != null)
			{
				jsonValidatingReader.ValidationEventHandler += validationEventHandler;
			}
			while (jsonValidatingReader.Read())
			{
			}
		}
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class JsonSchema
	{
		private readonly string _internalId = Guid.NewGuid().ToString("N");

		public string Id { get; set; }

		public string Title { get; set; }

		public bool? Required { get; set; }

		public bool? ReadOnly { get; set; }

		public bool? Hidden { get; set; }

		public bool? Transient { get; set; }

		public string Description { get; set; }

		public JsonSchemaType? Type { get; set; }

		public string Pattern { get; set; }

		public int? MinimumLength { get; set; }

		public int? MaximumLength { get; set; }

		public double? DivisibleBy { get; set; }

		public double? Minimum { get; set; }

		public double? Maximum { get; set; }

		public bool? ExclusiveMinimum { get; set; }

		public bool? ExclusiveMaximum { get; set; }

		public int? MinimumItems { get; set; }

		public int? MaximumItems { get; set; }

		public IList<JsonSchema> Items { get; set; }

		public bool PositionalItemsValidation { get; set; }

		public JsonSchema AdditionalItems { get; set; }

		public bool AllowAdditionalItems { get; set; }

		public bool UniqueItems { get; set; }

		public IDictionary<string, JsonSchema> Properties { get; set; }

		public JsonSchema AdditionalProperties { get; set; }

		public IDictionary<string, JsonSchema> PatternProperties { get; set; }

		public bool AllowAdditionalProperties { get; set; }

		public string Requires { get; set; }

		public IList<JToken> Enum { get; set; }

		public JsonSchemaType? Disallow { get; set; }

		public JToken Default { get; set; }

		public IList<JsonSchema> Extends { get; set; }

		public string Format { get; set; }

		internal string Location { get; set; }

		internal string InternalId => _internalId;

		internal string DeferredReference { get; set; }

		internal bool ReferencesResolved { get; set; }

		public JsonSchema()
		{
			AllowAdditionalProperties = true;
			AllowAdditionalItems = true;
		}

		public static JsonSchema Read(JsonReader reader)
		{
			return Read(reader, new JsonSchemaResolver());
		}

		public static JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			ValidationUtils.ArgumentNotNull(resolver, "resolver");
			return new JsonSchemaBuilder(resolver).Read(reader);
		}

		public static JsonSchema Parse(string json)
		{
			return Parse(json, new JsonSchemaResolver());
		}

		public static JsonSchema Parse(string json, JsonSchemaResolver resolver)
		{
			ValidationUtils.ArgumentNotNull(json, "json");
			using JsonReader reader = new JsonTextReader(new StringReader(json));
			return Read(reader, resolver);
		}

		public void WriteTo(JsonWriter writer)
		{
			WriteTo(writer, new JsonSchemaResolver());
		}

		public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver)
		{
			ValidationUtils.ArgumentNotNull(writer, "writer");
			ValidationUtils.ArgumentNotNull(resolver, "resolver");
			new JsonSchemaWriter(writer, resolver).WriteSchema(this);
		}

		public override string ToString()
		{
			StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			WriteTo(new JsonTextWriter(stringWriter)
			{
				Formatting = Formatting.Indented
			});
			return stringWriter.ToString();
		}
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class JsonSchemaBuilder
	{
		private readonly IList<JsonSchema> _stack;

		private readonly JsonSchemaResolver _resolver;

		private readonly IDictionary<string, JsonSchema> _documentSchemas;

		private JsonSchema _currentSchema;

		private JObject _rootSchema;

		private JsonSchema CurrentSchema => _currentSchema;

		public JsonSchemaBuilder(JsonSchemaResolver resolver)
		{
			_stack = new List<JsonSchema>();
			_documentSchemas = new Dictionary<string, JsonSchema>();
			_resolver = resolver;
		}

		private void Push(JsonSchema value)
		{
			_currentSchema = value;
			_stack.Add(value);
			_resolver.LoadedSchemas.Add(value);
			_documentSchemas.Add(value.Location, value);
		}

		private JsonSchema Pop()
		{
			JsonSchema currentSchema = _currentSchema;
			_stack.RemoveAt(_stack.Count - 1);
			_currentSchema = _stack.LastOrDefault();
			return currentSchema;
		}

		internal JsonSchema Read(JsonReader reader)
		{
			JToken jToken = JToken.ReadFrom(reader);
			_rootSchema = jToken as JObject;
			JsonSchema jsonSchema = BuildSchema(jToken);
			ResolveReferences(jsonSchema);
			return jsonSchema;
		}

		private string UnescapeReference(string reference)
		{
			return Uri.UnescapeDataString(reference).Replace("~1", "/").Replace("~0", "~");
		}

		private JsonSchema ResolveReferences(JsonSchema schema)
		{
			if (schema.DeferredReference != null)
			{
				string text = schema.DeferredReference;
				bool flag = text.StartsWith("#", StringComparison.Ordinal);
				if (flag)
				{
					text = UnescapeReference(text);
				}
				JsonSchema jsonSchema = _resolver.GetSchema(text);
				if (jsonSchema == null)
				{
					if (flag)
					{
						string[] array = schema.DeferredReference.TrimStart(new char[1] { '#' }).Split(new char[1] { '/' }, StringSplitOptions.RemoveEmptyEntries);
						JToken jToken = _rootSchema;
						string[] array2 = array;
						foreach (string reference in array2)
						{
							string text2 = UnescapeReference(reference);
							if (jToken.Type == JTokenType.Object)
							{
								jToken = jToken[text2];
							}
							else if (jToken.Type == JTokenType.Array || jToken.Type == JTokenType.Constructor)
							{
								jToken = ((!int.TryParse(text2, out var result) || result < 0 || result >= jToken.Count()) ? null : jToken[result]);
							}
							if (jToken == null)
							{
								break;
							}
						}
						if (jToken != null)
						{
							jsonSchema = BuildSchema(jToken);
						}
					}
					if (jsonSchema == null)
					{
						throw new JsonException("Could not resolve schema reference '{0}'.".FormatWith(CultureInfo.InvariantCulture, schema.DeferredReference));
					}
				}
				schema = jsonSchema;
			}
			if (schema.ReferencesResolved)
			{
				return schema;
			}
			schema.ReferencesResolved = true;
			if (schema.Extends != null)
			{
				for (int j = 0; j < schema.Extends.Count; j++)
				{
					schema.Extends[j] = ResolveReferences(schema.Extends[j]);
				}
			}
			if (schema.Items != null)
			{
				for (int k = 0; k < schema.Items.Count; k++)
				{
					schema.Items[k] = ResolveReferences(schema.Items[k]);
				}
			}
			if (schema.AdditionalItems != null)
			{
				schema.AdditionalItems = ResolveReferences(schema.AdditionalItems);
			}
			if (schema.PatternProperties != null)
			{
				foreach (KeyValuePair<string, JsonSchema> item in schema.PatternProperties.ToList())
				{
					schema.PatternProperties[item.Key] = ResolveReferences(item.Value);
				}
			}
			if (schema.Properties != null)
			{
				foreach (KeyValuePair<string, JsonSchema> item2 in schema.Properties.ToList())
				{
					schema.Properties[item2.Key] = ResolveReferences(item2.Value);
				}
			}
			if (schema.AdditionalProperties != null)
			{
				schema.AdditionalProperties = ResolveReferences(schema.AdditionalProperties);
			}
			return schema;
		}

		private JsonSchema BuildSchema(JToken token)
		{
			if (!(token is JObject jObject))
			{
				throw JsonException.Create(token, token.Path, "Expected object while parsing schema object, got {0}.".FormatWith(CultureInfo.InvariantCulture, token.Type));
			}
			if (jObject.TryGetValue("$ref", out JToken value))
			{
				return new JsonSchema
				{
					DeferredReference = (string?)value
				};
			}
			string text = token.Path.Replace(".", "/").Replace("[", "/").Replace("]", string.Empty);
			if (!StringUtils.IsNullOrEmpty(text))
			{
				text = "/" + text;
			}
			text = "#" + text;
			if (_documentSchemas.TryGetValue(text, out var value2))
			{
				return value2;
			}
			Push(new JsonSchema
			{
				Location = text
			});
			ProcessSchemaProperties(jObject);
			return Pop();
		}

		private void ProcessSchemaProperties(JObject schemaObject)
		{
			foreach (KeyValuePair<string, JToken> item in schemaObject)
			{
				switch (item.Key)
				{
				case "type":
					CurrentSchema.Type = ProcessType(item.Value);
					break;
				case "id":
					CurrentSchema.Id = (string?)item.Value;
					break;
				case "title":
					CurrentSchema.Title = (string?)item.Value;
					break;
				case "description":
					CurrentSchema.Description = (string?)item.Value;
					break;
				case "properties":
					CurrentSchema.Properties = ProcessProperties(item.Value);
					break;
				case "items":
					ProcessItems(item.Value);
					break;
				case "additionalProperties":
					ProcessAdditionalProperties(item.Value);
					break;
				case "additionalItems":
					ProcessAdditionalItems(item.Value);
					break;
				case "patternProperties":
					CurrentSchema.PatternProperties = ProcessProperties(item.Value);
					break;
				case "required":
					CurrentSchema.Required = (bool)item.Value;
					break;
				case "requires":
					CurrentSchema.Requires = (string?)item.Value;
					break;
				case "minimum":
					CurrentSchema.Minimum = (double)item.Value;
					break;
				case "maximum":
					CurrentSchema.Maximum = (double)item.Value;
					break;
				case "exclusiveMinimum":
					CurrentSchema.ExclusiveMinimum = (bool)item.Value;
					break;
				case "exclusiveMaximum":
					CurrentSchema.ExclusiveMaximum = (bool)item.Value;
					break;
				case "maxLength":
					CurrentSchema.MaximumLength = (int)item.Value;
					break;
				case "minLength":
					CurrentSchema.MinimumLength = (int)item.Value;
					break;
				case "maxItems":
					CurrentSchema.MaximumItems = (int)item.Value;
					break;
				case "minItems":
					CurrentSchema.MinimumItems = (int)item.Value;
					break;
				case "divisibleBy":
					CurrentSchema.DivisibleBy = (double)item.Value;
					break;
				case "disallow":
					CurrentSchema.Disallow = ProcessType(item.Value);
					break;
				case "default":
					CurrentSchema.Default = item.Value.DeepClone();
					break;
				case "hidden":
					CurrentSchema.Hidden = (bool)item.Value;
					break;
				case "readonly":
					CurrentSchema.ReadOnly = (bool)item.Value;
					break;
				case "format":
					CurrentSchema.Format = (string?)item.Value;
					break;
				case "pattern":
					CurrentSchema.Pattern = (string?)item.Value;
					break;
				case "enum":
					ProcessEnum(item.Value);
					break;
				case "extends":
					ProcessExtends(item.Value);
					break;
				case "uniqueItems":
					CurrentSchema.UniqueItems = (bool)item.Value;
					break;
				}
			}
		}

		private void ProcessExtends(JToken token)
		{
			IList<JsonSchema> list = new List<JsonSchema>();
			if (token.Type == JTokenType.Array)
			{
				foreach (JToken item in (IEnumerable<JToken>)token)
				{
					list.Add(BuildSchema(item));
				}
			}
			else
			{
				JsonSchema jsonSchema = BuildSchema(token);
				if (jsonSchema != null)
				{
					list.Add(jsonSchema);
				}
			}
			if (list.Count > 0)
			{
				CurrentSchema.Extends = list;
			}
		}

		private void ProcessEnum(JToken token)
		{
			if (token.Type != JTokenType.Array)
			{
				throw JsonException.Create(token, token.Path, "Expected Array token while parsing enum values, got {0}.".FormatWith(CultureInfo.InvariantCulture, token.Type));
			}
			CurrentSchema.Enum = new List<JToken>();
			foreach (JToken item in (IEnumerable<JToken>)token)
			{
				CurrentSchema.Enum.Add(item.DeepClone());
			}
		}

		private void ProcessAdditionalProperties(JToken token)
		{
			if (token.Type == JTokenType.Boolean)
			{
				CurrentSchema.AllowAdditionalProperties = (bool)token;
			}
			else
			{
				CurrentSchema.AdditionalProperties = BuildSchema(token);
			}
		}

		private void ProcessAdditionalItems(JToken token)
		{
			if (token.Type == JTokenType.Boolean)
			{
				CurrentSchema.AllowAdditionalItems = (bool)token;
			}
			else
			{
				CurrentSchema.AdditionalItems = BuildSchema(token);
			}
		}

		private IDictionary<string, JsonSchema> ProcessProperties(JToken token)
		{
			IDictionary<string, JsonSchema> dictionary = new Dictionary<string, JsonSchema>();
			if (token.Type != JTokenType.Object)
			{
				throw JsonException.Create(token, token.Path, "Expected Object token while parsing schema properties, got {0}.".FormatWith(CultureInfo.InvariantCulture, token.Type));
			}
			foreach (JProperty item in (IEnumerable<JToken>)token)
			{
				if (dictionary.ContainsKey(item.Name))
				{
					throw new JsonException("Property {0} has already been defined in schema.".FormatWith(CultureInfo.InvariantCulture, item.Name));
				}
				dictionary.Add(item.Name, BuildSchema(item.Value));
			}
			return dictionary;
		}

		private void ProcessItems(JToken token)
		{
			CurrentSchema.Items = new List<JsonSchema>();
			switch (token.Type)
			{
			case JTokenType.Object:
				CurrentSchema.Items.Add(BuildSchema(token));
				CurrentSchema.PositionalItemsValidation = false;
				break;
			case JTokenType.Array:
				CurrentSchema.PositionalItemsValidation = true;
				{
					foreach (JToken item in (IEnumerable<JToken>)token)
					{
						CurrentSchema.Items.Add(BuildSchema(item));
					}
					break;
				}
			default:
				throw JsonException.Create(token, token.Path, "Expected array or JSON schema object, got {0}.".FormatWith(CultureInfo.InvariantCulture, token.Type));
			}
		}

		private JsonSchemaType? ProcessType(JToken token)
		{
			switch (token.Type)
			{
			case JTokenType.Array:
			{
				JsonSchemaType? jsonSchemaType = JsonSchemaType.None;
				{
					foreach (JToken item in (IEnumerable<JToken>)token)
					{
						if (item.Type != JTokenType.String)
						{
							throw JsonException.Create(item, item.Path, "Expected JSON schema type string token, got {0}.".FormatWith(CultureInfo.InvariantCulture, token.Type));
						}
						jsonSchemaType |= MapType((string?)item);
					}
					return jsonSchemaType;
				}
			}
			case JTokenType.String:
				return MapType((string?)token);
			default:
				throw JsonException.Create(token, token.Path, "Expected array or JSON schema type string token, got {0}.".FormatWith(CultureInfo.InvariantCulture, token.Type));
			}
		}

		internal static JsonSchemaType MapType(string type)
		{
			if (!JsonSchemaConstants.JsonSchemaTypeMapping.TryGetValue(type, out var value))
			{
				throw new JsonException("Invalid JSON schema type: {0}".FormatWith(CultureInfo.InvariantCulture, type));
			}
			return value;
		}

		internal static string MapType(JsonSchemaType type)
		{
			return JsonSchemaConstants.JsonSchemaTypeMapping.Single((KeyValuePair<string, JsonSchemaType> kv) => kv.Value == type).Key;
		}
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal static class JsonSchemaConstants
	{
		public const string TypePropertyName = "type";

		public const string PropertiesPropertyName = "properties";

		public const string ItemsPropertyName = "items";

		public const string AdditionalItemsPropertyName = "additionalItems";

		public const string RequiredPropertyName = "required";

		public const string PatternPropertiesPropertyName = "patternProperties";

		public const string AdditionalPropertiesPropertyName = "additionalProperties";

		public const string RequiresPropertyName = "requires";

		public const string MinimumPropertyName = "minimum";

		public const string MaximumPropertyName = "maximum";

		public const string ExclusiveMinimumPropertyName = "exclusiveMinimum";

		public const string ExclusiveMaximumPropertyName = "exclusiveMaximum";

		public const string MinimumItemsPropertyName = "minItems";

		public const string MaximumItemsPropertyName = "maxItems";

		public const string PatternPropertyName = "pattern";

		public const string MaximumLengthPropertyName = "maxLength";

		public const string MinimumLengthPropertyName = "minLength";

		public const string EnumPropertyName = "enum";

		public const string ReadOnlyPropertyName = "readonly";

		public const string TitlePropertyName = "title";

		public const string DescriptionPropertyName = "description";

		public const string FormatPropertyName = "format";

		public const string DefaultPropertyName = "default";

		public const string TransientPropertyName = "transient";

		public const string DivisibleByPropertyName = "divisibleBy";

		public const string HiddenPropertyName = "hidden";

		public const string DisallowPropertyName = "disallow";

		public const string ExtendsPropertyName = "extends";

		public const string IdPropertyName = "id";

		public const string UniqueItemsPropertyName = "uniqueItems";

		public const string OptionValuePropertyName = "value";

		public const string OptionLabelPropertyName = "label";

		public static readonly IDictionary<string, JsonSchemaType> JsonSchemaTypeMapping = new Dictionary<string, JsonSchemaType>
		{
			{
				"string",
				JsonSchemaType.String
			},
			{
				"object",
				JsonSchemaType.Object
			},
			{
				"integer",
				JsonSchemaType.Integer
			},
			{
				"number",
				JsonSchemaType.Float
			},
			{
				"null",
				JsonSchemaType.Null
			},
			{
				"boolean",
				JsonSchemaType.Boolean
			},
			{
				"array",
				JsonSchemaType.Array
			},
			{
				"any",
				JsonSchemaType.Any
			}
		};
	}
	[Serializable]
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class JsonSchemaException : JsonException
	{
		public int LineNumber { get; }

		public int LinePosition { get; }

		public string Path { get; }

		public JsonSchemaException()
		{
		}

		public JsonSchemaException(string message)
			: base(message)
		{
		}

		public JsonSchemaException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonSchemaException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		internal JsonSchemaException(string message, Exception innerException, string path, int lineNumber, int linePosition)
			: base(message, innerException)
		{
			Path = path;
			LineNumber = lineNumber;
			LinePosition = linePosition;
		}
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class JsonSchemaGenerator
	{
		private class TypeSchema
		{
			public Type Type { get; }

			public JsonSchema Schema { get; }

			public TypeSchema(Type type, JsonSchema schema)
			{
				ValidationUtils.ArgumentNotNull(type, "type");
				ValidationUtils.ArgumentNotNull(schema, "schema");
				Type = type;
				Schema = schema;
			}
		}

		private IContractResolver _contractResolver;

		private JsonSchemaResolver _resolver;

		private readonly IList<TypeSchema> _stack = new List<TypeSchema>();

		private JsonSchema _currentSchema;

		public UndefinedSchemaIdHandling UndefinedSchemaIdHandling { get; set; }

		public IContractResolver ContractResolver
		{
			get
			{
				if (_contractResolver == null)
				{
					return DefaultContractResolver.Instance;
				}
				return _contractResolver;
			}
			set
			{
				_contractResolver = value;
			}
		}

		private JsonSchema CurrentSchema => _currentSchema;

		private void Push(TypeSchema typeSchema)
		{
			_currentSchema = typeSchema.Schema;
			_stack.Add(typeSchema);
			_resolver.LoadedSchemas.Add(typeSchema.Schema);
		}

		private TypeSchema Pop()
		{
			TypeSchema result = _stack[_stack.Count - 1];
			_stack.RemoveAt(_stack.Count - 1);
			TypeSchema typeSchema = _stack.LastOrDefault();
			if (typeSchema != null)
			{
				_currentSchema = typeSchema.Schema;
				return result;
			}
			_currentSchema = null;
			return result;
		}

		public JsonSchema Generate(Type type)
		{
			return Generate(type, new JsonSchemaResolver(), rootSchemaNullable: false);
		}

		public JsonSchema Generate(Type type, JsonSchemaResolver resolver)
		{
			return Generate(type, resolver, rootSchemaNullable: false);
		}

		public JsonSchema Generate(Type type, bool rootSchemaNullable)
		{
			return Generate(type, new JsonSchemaResolver(), rootSchemaNullable);
		}

		public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			ValidationUtils.ArgumentNotNull(resolver, "resolver");
			_resolver = resolver;
			return GenerateInternal(type, (!rootSchemaNullable) ? Required.Always : Required.Default, required: false);
		}

		private string GetTitle(Type type)
		{
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(type);
			if (!StringUtils.IsNullOrEmpty(cachedAttribute?.Title))
			{
				return cachedAttribute.Title;
			}
			return null;
		}

		private string GetDescription(Type type)
		{
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(type);
			if (!StringUtils.IsNullOrEmpty(cachedAttribute?.Description))
			{
				return cachedAttribute.Description;
			}
			return ReflectionUtils.GetAttribute<DescriptionAttribute>(type)?.Description;
		}

		private string GetTypeId(Type type, bool explicitOnly)
		{
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(type);
			if (!StringUtils.IsNullOrEmpty(cachedAttribute?.Id))
			{
				return cachedAttribute.Id;
			}
			if (explicitOnly)
			{
				return null;
			}
			return UndefinedSchemaIdHandling switch
			{
				UndefinedSchemaIdHandling.UseTypeName => type.FullName, 
				UndefinedSchemaIdHandling.UseAssemblyQualifiedName => type.AssemblyQualifiedName, 
				_ => null, 
			};
		}

		private JsonSchema GenerateInternal(Type type, Required valueRequired, bool required)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			string typeId = GetTypeId(type, explicitOnly: false);
			string typeId2 = GetTypeId(type, explicitOnly: true);
			if (!StringUtils.IsNullOrEmpty(typeId))
			{
				JsonSchema schema = _resolver.GetSchema(typeId);
				if (schema != null)
				{
					if (valueRequired != Required.Always && !HasFlag(schema.Type, JsonSchemaType.Null))
					{
						schema.Type |= JsonSchemaType.Null;
					}
					if (required && schema.Required != true)
					{
						schema.Required = true;
					}
					return schema;
				}
			}
			if (_stack.Any((TypeSchema tc) => tc.Type == type))
			{
				throw new JsonException("Unresolved circular reference for type '{0}'. Explicitly define an Id for the type using a JsonObject/JsonArray attribute or automatically generate a type Id using the UndefinedSchemaIdHandling property.".FormatWith(CultureInfo.InvariantCulture, type));
			}
			JsonContract jsonContract = ContractResolver.ResolveContract(type);
			JsonConverter? obj = jsonContract.Converter ?? jsonContract.InternalConverter;
			Push(new TypeSchema(type, new JsonSchema()));
			if (typeId2 != null)
			{
				CurrentSchema.Id = typeId2;
			}
			if (required)
			{
				CurrentSchema.Required = true;
			}
			CurrentSchema.Title = GetTitle(type);
			CurrentSchema.Description = GetDescription(type);
			if (obj != null)
			{
				CurrentSchema.Type = JsonSchemaType.Any;
			}
			else
			{
				switch (jsonContract.ContractType)
				{
				case JsonContractType.Object:
					CurrentSchema.Type = AddNullType(JsonSchemaType.Object, valueRequired);
					CurrentSchema.Id = GetTypeId(type, explicitOnly: false);
					GenerateObjectSchema(type, (JsonObjectContract)jsonContract);
					break;
				case JsonContractType.Array:
				{
					CurrentSchema.Type = AddNullType(JsonSchemaType.Array, valueRequired);
					CurrentSchema.Id = GetTypeId(type, explicitOnly: false);
					bool flag = JsonTypeReflector.GetCachedAttribute<JsonArrayAttribute>(type)?.AllowNullItems ?? true;
					Type collectionItemType = ReflectionUtils.GetCollectionItemType(type);
					if (collectionItemType != null)
					{
						CurrentSchema.Items = new List<JsonSchema>();
						CurrentSchema.Items.Add(GenerateInternal(collectionItemType, (!flag) ? Required.Always : Required.Default, required: false));
					}
					break;
				}
				case JsonContractType.Primitive:
					CurrentSchema.Type = GetJsonSchemaType(type, valueRequired);
					if (CurrentSchema.Type == JsonSchemaType.Integer && type.IsEnum() && !type.IsDefined(typeof(FlagsAttribute), inherit: true))
					{
						CurrentSchema.Enum = new List<JToken>();
						EnumInfo enumValuesAndNames = EnumUtils.GetEnumValuesAndNames(type);
						for (int num = 0; num < enumValuesAndNames.Names.Length; num++)
						{
							ulong value = enumValuesAndNames.Values[num];
							JToken item = JToken.FromObject(Enum.ToObject(type, value));
							CurrentSchema.Enum.Add(item);
						}
					}
					break;
				case JsonContractType.String:
				{
					JsonSchemaType value2 = ((!ReflectionUtils.IsNullable(jsonContract.UnderlyingType)) ? JsonSchemaType.String : AddNullType(JsonSchemaType.String, valueRequired));
					CurrentSchema.Type = value2;
					break;
				}
				case JsonContractType.Dictionary:
				{
					CurrentSchema.Type = AddNullType(JsonSchemaType.Object, valueRequired);
					ReflectionUtils.GetDictionaryKeyValueTypes(type, out Type keyType, out Type valueType);
					if (keyType != null && ContractResolver.ResolveContract(keyType).ContractType == JsonContractType.Primitive)
					{
						CurrentSchema.AdditionalProperties = GenerateInternal(valueType, Required.Default, required: false);
					}
					break;
				}
				case JsonContractType.Serializable:
					CurrentSchema.Type = AddNullType(JsonSchemaType.Object, valueRequired);
					CurrentSchema.Id = GetTypeId(type, explicitOnly: false);
					GenerateISerializableContract(type, (JsonISerializableContract)jsonContract);
					break;
				case JsonContractType.Dynamic:
				case JsonContractType.Linq:
					CurrentSchema.Type = JsonSchemaType.Any;
					break;
				default:
					throw new JsonException("Unexpected contract type: {0}".FormatWith(CultureInfo.InvariantCulture, jsonContract));
				}
			}
			return Pop().Schema;
		}

		private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired)
		{
			if (valueRequired != Required.Always)
			{
				return type | JsonSchemaType.Null;
			}
			return type;
		}

		private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
		{
			return (value & flag) == flag;
		}

		private void GenerateObjectSchema(Type type, JsonObjectContract contract)
		{
			CurrentSchema.Properties = new Dictionary<string, JsonSchema>();
			foreach (JsonProperty property in contract.Properties)
			{
				if (!property.Ignored)
				{
					bool flag = property.NullValueHandling == NullValueHandling.Ignore || HasFlag(property.DefaultValueHandling.GetValueOrDefault(), DefaultValueHandling.Ignore) || property.ShouldSerialize != null || property.GetIsSpecified != null;
					JsonSchema jsonSchema = GenerateInternal(property.PropertyType, property.Required, !flag);
					if (property.DefaultValue != null)
					{
						jsonSchema.Default = JToken.FromObject(property.DefaultValue);
					}
					CurrentSchema.Properties.Add(property.PropertyName, jsonSchema);
				}
			}
			if (type.IsSealed())
			{
				CurrentSchema.AllowAdditionalProperties = false;
			}
		}

		private void GenerateISerializableContract(Type type, JsonISerializableContract contract)
		{
			CurrentSchema.AllowAdditionalProperties = true;
		}

		internal static bool HasFlag(JsonSchemaType? value, JsonSchemaType flag)
		{
			if (!value.HasValue)
			{
				return true;
			}
			if ((value & flag) == flag)
			{
				return true;
			}
			if (flag == JsonSchemaType.Integer && ((uint?)value & 2u) == 2)
			{
				return true;
			}
			return false;
		}

		private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired)
		{
			JsonSchemaType jsonSchemaType = JsonSchemaType.None;
			if (valueRequired != Required.Always && ReflectionUtils.IsNullable(type))
			{
				jsonSchemaType = JsonSchemaType.Null;
				if (ReflectionUtils.IsNullableType(type))
				{
					type = Nullable.GetUnderlyingType(type);
				}
			}
			PrimitiveTypeCode typeCode = ConvertUtils.GetTypeCode(type);
			switch (typeCode)
			{
			case PrimitiveTypeCode.Empty:
			case PrimitiveTypeCode.Object:
				return jsonSchemaType | JsonSchemaType.String;
			case PrimitiveTypeCode.DBNull:
				return jsonSchemaType | JsonSchemaType.Null;
			case PrimitiveTypeCode.Boolean:
				return jsonSchemaType | JsonSchemaType.Boolean;
			case PrimitiveTypeCode.Char:
				return jsonSchemaType | JsonSchemaType.String;
			case PrimitiveTypeCode.SByte:
			case PrimitiveTypeCode.Int16:
			case PrimitiveTypeCode.UInt16:
			case PrimitiveTypeCode.Int32:
			case PrimitiveTypeCode.Byte:
			case PrimitiveTypeCode.UInt32:
			case PrimitiveTypeCode.Int64:
			case PrimitiveTypeCode.UInt64:
			case PrimitiveTypeCode.BigInteger:
				return jsonSchemaType | JsonSchemaType.Integer;
			case PrimitiveTypeCode.Single:
			case PrimitiveTypeCode.Double:
			case PrimitiveTypeCode.Decimal:
				return jsonSchemaType | JsonSchemaType.Float;
			case PrimitiveTypeCode.DateTime:
			case PrimitiveTypeCode.DateTimeOffset:
				return jsonSchemaType | JsonSchemaType.String;
			case PrimitiveTypeCode.Guid:
			case PrimitiveTypeCode.TimeSpan:
			case PrimitiveTypeCode.Uri:
			case PrimitiveTypeCode.String:
			case PrimitiveTypeCode.Bytes:
				return jsonSchemaType | JsonSchemaType.String;
			default:
				throw new JsonException("Unexpected type code '{0}' for type '{1}'.".FormatWith(CultureInfo.InvariantCulture, typeCode, type));
			}
		}
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class JsonSchemaModel
	{
		public bool Required { get; set; }

		public JsonSchemaType Type { get; set; }

		public int? MinimumLength { get; set; }

		public int? MaximumLength { get; set; }

		public double? DivisibleBy { get; set; }

		public double? Minimum { get; set; }

		public double? Maximum { get; set; }

		public bool ExclusiveMinimum { get; set; }

		public bool ExclusiveMaximum { get; set; }

		public int? MinimumItems { get; set; }

		public int? MaximumItems { get; set; }

		public IList<string> Patterns { get; set; }

		public IList<JsonSchemaModel> Items { get; set; }

		public IDictionary<string, JsonSchemaModel> Properties { get; set; }

		public IDictionary<string, JsonSchemaModel> PatternProperties { get; set; }

		public JsonSchemaModel AdditionalProperties { get; set; }

		public JsonSchemaModel AdditionalItems { get; set; }

		public bool PositionalItemsValidation { get; set; }

		public bool AllowAdditionalProperties { get; set; }

		public bool AllowAdditionalItems { get; set; }

		public bool UniqueItems { get; set; }

		public IList<JToken> Enum { get; set; }

		public JsonSchemaType Disallow { get; set; }

		public JsonSchemaModel()
		{
			Type = JsonSchemaType.Any;
			AllowAdditionalProperties = true;
			AllowAdditionalItems = true;
			Required = false;
		}

		public static JsonSchemaModel Create(IList<JsonSchema> schemata)
		{
			JsonSchemaModel jsonSchemaModel = new JsonSchemaModel();
			foreach (JsonSchema schematum in schemata)
			{
				Combine(jsonSchemaModel, schematum);
			}
			return jsonSchemaModel;
		}

		private static void Combine(JsonSchemaModel model, JsonSchema schema)
		{
			model.Required = model.Required || schema.Required == true;
			model.Type &= schema.Type ?? JsonSchemaType.Any;
			model.MinimumLength = MathUtils.Max(model.MinimumLength, schema.MinimumLength);
			model.MaximumLength = MathUtils.Min(model.MaximumLength, schema.MaximumLength);
			model.DivisibleBy = MathUtils.Max(model.DivisibleBy, schema.DivisibleBy);
			model.Minimum = MathUtils.Max(model.Minimum, schema.Minimum);
			model.Maximum = MathUtils.Max(model.Maximum, schema.Maximum);
			model.ExclusiveMinimum = model.ExclusiveMinimum || schema.ExclusiveMinimum == true;
			model.ExclusiveMaximum = model.ExclusiveMaximum || schema.ExclusiveMaximum == true;
			model.MinimumItems = MathUtils.Max(model.MinimumItems, schema.MinimumItems);
			model.MaximumItems = MathUtils.Min(model.MaximumItems, schema.MaximumItems);
			model.PositionalItemsValidation = model.PositionalItemsValidation || schema.PositionalItemsValidation;
			model.AllowAdditionalProperties = model.AllowAdditionalProperties && schema.AllowAdditionalProperties;
			model.AllowAdditionalItems = model.AllowAdditionalItems && schema.AllowAdditionalItems;
			model.UniqueItems = model.UniqueItems || schema.UniqueItems;
			if (schema.Enum != null)
			{
				if (model.Enum == null)
				{
					model.Enum = new List<JToken>();
				}
				model.Enum.AddRangeDistinct(schema.Enum, JToken.EqualityComparer);
			}
			model.Disallow |= schema.Disallow.GetValueOrDefault();
			if (schema.Pattern != null)
			{
				if (model.Patterns == null)
				{
					model.Patterns = new List<string>();
				}
				model.Patterns.AddDistinct(schema.Pattern);
			}
		}
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class JsonSchemaModelBuilder
	{
		private JsonSchemaNodeCollection _nodes = new JsonSchemaNodeCollection();

		private Dictionary<JsonSchemaNode, JsonSchemaModel> _nodeModels = new Dictionary<JsonSchemaNode, JsonSchemaModel>();

		private JsonSchemaNode _node;

		public JsonSchemaModel Build(JsonSchema schema)
		{
			_nodes = new JsonSchemaNodeCollection();
			_node = AddSchema(null, schema);
			_nodeModels = new Dictionary<JsonSchemaNode, JsonSchemaModel>();
			return BuildNodeModel(_node);
		}

		public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema)
		{
			string id;
			if (existingNode != null)
			{
				if (existingNode.Schemas.Contains(schema))
				{
					return existingNode;
				}
				id = JsonSchemaNode.GetId(existingNode.Schemas.Union(new JsonSchema[1] { schema }));
			}
			else
			{
				id = JsonSchemaNode.GetId(new JsonSchema[1] { schema });
			}
			if (_nodes.Contains(id))
			{
				return _nodes[id];
			}
			JsonSchemaNode jsonSchemaNode = ((existingNode != null) ? existingNode.Combine(schema) : new JsonSchemaNode(schema));
			_nodes.Add(jsonSchemaNode);
			AddProperties(schema.Properties, jsonSchemaNode.Properties);
			AddProperties(schema.PatternProperties, jsonSchemaNode.PatternProperties);
			if (schema.Items != null)
			{
				for (int i = 0; i < schema.Items.Count; i++)
				{
					AddItem(jsonSchemaNode, i, schema.Items[i]);
				}
			}
			if (schema.AdditionalItems != null)
			{
				AddAdditionalItems(jsonSchemaNode, schema.AdditionalItems);
			}
			if (schema.AdditionalProperties != null)
			{
				AddAdditionalProperties(jsonSchemaNode, schema.AdditionalProperties);
			}
			if (schema.Extends != null)
			{
				foreach (JsonSchema extend in schema.Extends)
				{
					jsonSchemaNode = AddSchema(jsonSchemaNode, extend);
				}
			}
			return jsonSchemaNode;
		}

		public void AddProperties(IDictionary<string, JsonSchema> source, IDictionary<string, JsonSchemaNode> target)
		{
			if (source == null)
			{
				return;
			}
			foreach (KeyValuePair<string, JsonSchema> item in source)
			{
				AddProperty(target, item.Key, item.Value);
			}
		}

		public void AddProperty(IDictionary<string, JsonSchemaNode> target, string propertyName, JsonSchema schema)
		{
			target.TryGetValue(propertyName, out var value);
			target[propertyName] = AddSchema(value, schema);
		}

		public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema)
		{
			JsonSchemaNode existingNode = ((parentNode.Items.Count > index) ? parentNode.Items[index] : null);
			JsonSchemaNode jsonSchemaNode = AddSchema(existingNode, schema);
			if (parentNode.Items.Count <= index)
			{
				parentNode.Items.Add(jsonSchemaNode);
			}
			else
			{
				parentNode.Items[index] = jsonSchemaNode;
			}
		}

		public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema)
		{
			parentNode.AdditionalProperties = AddSchema(parentNode.AdditionalProperties, schema);
		}

		public void AddAdditionalItems(JsonSchemaNode parentNode, JsonSchema schema)
		{
			parentNode.AdditionalItems = AddSchema(parentNode.AdditionalItems, schema);
		}

		private JsonSchemaModel BuildNodeModel(JsonSchemaNode node)
		{
			if (_nodeModels.TryGetValue(node, out var value))
			{
				return value;
			}
			value = JsonSchemaModel.Create(node.Schemas);
			_nodeModels[node] = value;
			foreach (KeyValuePair<string, JsonSchemaNode> property in node.Properties)
			{
				if (value.Properties == null)
				{
					value.Properties = new Dictionary<string, JsonSchemaModel>();
				}
				value.Properties[property.Key] = BuildNodeModel(property.Value);
			}
			foreach (KeyValuePair<string, JsonSchemaNode> patternProperty in node.PatternProperties)
			{
				if (value.PatternProperties == null)
				{
					value.PatternProperties = new Dictionary<string, JsonSchemaModel>();
				}
				value.PatternProperties[patternProperty.Key] = BuildNodeModel(patternProperty.Value);
			}
			foreach (JsonSchemaNode item in node.Items)
			{
				if (value.Items == null)
				{
					value.Items = new List<JsonSchemaModel>();
				}
				value.Items.Add(BuildNodeModel(item));
			}
			if (node.AdditionalProperties != null)
			{
				value.AdditionalProperties = BuildNodeModel(node.AdditionalProperties);
			}
			if (node.AdditionalItems != null)
			{
				value.AdditionalItems = BuildNodeModel(node.AdditionalItems);
			}
			return value;
		}
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class JsonSchemaNode
	{
		public string Id { get; }

		public ReadOnlyCollection<JsonSchema> Schemas { get; }

		public Dictionary<string, JsonSchemaNode> Properties { get; }

		public Dictionary<string, JsonSchemaNode> PatternProperties { get; }

		public List<JsonSchemaNode> Items { get; }

		public JsonSchemaNode AdditionalProperties { get; set; }

		public JsonSchemaNode AdditionalItems { get; set; }

		public JsonSchemaNode(JsonSchema schema)
		{
			Schemas = new ReadOnlyCollection<JsonSchema>(new JsonSchema[1] { schema });
			Properties = new Dictionary<string, JsonSchemaNode>();
			PatternProperties = new Dictionary<string, JsonSchemaNode>();
			Items = new List<JsonSchemaNode>();
			Id = GetId(Schemas);
		}

		private JsonSchemaNode(JsonSchemaNode source, JsonSchema schema)
		{
			Schemas = new ReadOnlyCollection<JsonSchema>(source.Schemas.Union(new JsonSchema[1] { schema }).ToList());
			Properties = new Dictionary<string, JsonSchemaNode>(source.Properties);
			PatternProperties = new Dictionary<string, JsonSchemaNode>(source.PatternProperties);
			Items = new List<JsonSchemaNode>(source.Items);
			AdditionalProperties = source.AdditionalProperties;
			AdditionalItems = source.AdditionalItems;
			Id = GetId(Schemas);
		}

		public JsonSchemaNode Combine(JsonSchema schema)
		{
			return new JsonSchemaNode(this, schema);
		}

		public static string GetId(IEnumerable<JsonSchema> schemata)
		{
			return string.Join("-", schemata.Select((JsonSchema s) => s.InternalId).OrderBy((string id) => id, StringComparer.Ordinal));
		}
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class JsonSchemaNodeCollection : KeyedCollection<string, JsonSchemaNode>
	{
		protected override string GetKeyForItem(JsonSchemaNode item)
		{
			return item.Id;
		}
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class JsonSchemaResolver
	{
		public IList<JsonSchema> LoadedSchemas { get; protected set; }

		public JsonSchemaResolver()
		{
			LoadedSchemas = new List<JsonSchema>();
		}

		public virtual JsonSchema GetSchema(string reference)
		{
			JsonSchema jsonSchema = LoadedSchemas.SingleOrDefault((JsonSchema s) => string.Equals(s.Id, reference, StringComparison.Ordinal));
			if (jsonSchema == null)
			{
				jsonSchema = LoadedSchemas.SingleOrDefault((JsonSchema s) => string.Equals(s.Location, reference, StringComparison.Ordinal));
			}
			return jsonSchema;
		}
	}
	[Flags]
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal enum JsonSchemaType
	{
		None = 0,
		String = 1,
		Float = 2,
		Integer = 4,
		Boolean = 8,
		Object = 0x10,
		Array = 0x20,
		Null = 0x40,
		Any = 0x7F
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class JsonSchemaWriter
	{
		private readonly JsonWriter _writer;

		private readonly JsonSchemaResolver _resolver;

		public JsonSchemaWriter(JsonWriter writer, JsonSchemaResolver resolver)
		{
			ValidationUtils.ArgumentNotNull(writer, "writer");
			_writer = writer;
			_resolver = resolver;
		}

		private void ReferenceOrWriteSchema(JsonSchema schema)
		{
			if (schema.Id != null && _resolver.GetSchema(schema.Id) != null)
			{
				_writer.WriteStartObject();
				_writer.WritePropertyName("$ref");
				_writer.WriteValue(schema.Id);
				_writer.WriteEndObject();
			}
			else
			{
				WriteSchema(schema);
			}
		}

		public void WriteSchema(JsonSchema schema)
		{
			ValidationUtils.ArgumentNotNull(schema, "schema");
			if (!_resolver.LoadedSchemas.Contains(schema))
			{
				_resolver.LoadedSchemas.Add(schema);
			}
			_writer.WriteStartObject();
			WritePropertyIfNotNull(_writer, "id", schema.Id);
			WritePropertyIfNotNull(_writer, "title", schema.Title);
			WritePropertyIfNotNull(_writer, "description", schema.Description);
			WritePropertyIfNotNull(_writer, "required", schema.Required);
			WritePropertyIfNotNull(_writer, "readonly", schema.ReadOnly);
			WritePropertyIfNotNull(_writer, "hidden", schema.Hidden);
			WritePropertyIfNotNull(_writer, "transient", schema.Transient);
			if (schema.Type.HasValue)
			{
				WriteType("type", _writer, schema.Type.GetValueOrDefault());
			}
			if (!schema.AllowAdditionalProperties)
			{
				_writer.WritePropertyName("additionalProperties");
				_writer.WriteValue(schema.AllowAdditionalProperties);
			}
			else if (schema.AdditionalProperties != null)
			{
				_writer.WritePropertyName("additionalProperties");
				ReferenceOrWriteSchema(schema.AdditionalProperties);
			}
			if (!schema.AllowAdditionalItems)
			{
				_writer.WritePropertyName("additionalItems");
				_writer.WriteValue(schema.AllowAdditionalItems);
			}
			else if (schema.AdditionalItems != null)
			{
				_writer.WritePropertyName("additionalItems");
				ReferenceOrWriteSchema(schema.AdditionalItems);
			}
			WriteSchemaDictionaryIfNotNull(_writer, "properties", schema.Properties);
			WriteSchemaDictionaryIfNotNull(_writer, "patternProperties", schema.PatternProperties);
			WriteItems(schema);
			WritePropertyIfNotNull(_writer, "minimum", schema.Minimum);
			WritePropertyIfNotNull(_writer, "maximum", schema.Maximum);
			WritePropertyIfNotNull(_writer, "exclusiveMinimum", schema.ExclusiveMinimum);
			WritePropertyIfNotNull(_writer, "exclusiveMaximum", schema.ExclusiveMaximum);
			WritePropertyIfNotNull(_writer, "minLength", schema.MinimumLength);
			WritePropertyIfNotNull(_writer, "maxLength", schema.MaximumLength);
			WritePropertyIfNotNull(_writer, "minItems", schema.MinimumItems);
			WritePropertyIfNotNull(_writer, "maxItems", schema.MaximumItems);
			WritePropertyIfNotNull(_writer, "divisibleBy", schema.DivisibleBy);
			WritePropertyIfNotNull(_writer, "format", schema.Format);
			WritePropertyIfNotNull(_writer, "pattern", schema.Pattern);
			if (schema.Enum != null)
			{
				_writer.WritePropertyName("enum");
				_writer.WriteStartArray();
				foreach (JToken item in schema.Enum)
				{
					item.WriteTo(_writer);
				}
				_writer.WriteEndArray();
			}
			if (schema.Default != null)
			{
				_writer.WritePropertyName("default");
				schema.Default.WriteTo(_writer);
			}
			if (schema.Disallow.HasValue)
			{
				WriteType("disallow", _writer, schema.Disallow.GetValueOrDefault());
			}
			if (schema.Extends != null && schema.Extends.Count > 0)
			{
				_writer.WritePropertyName("extends");
				if (schema.Extends.Count == 1)
				{
					ReferenceOrWriteSchema(schema.Extends[0]);
				}
				else
				{
					_writer.WriteStartArray();
					foreach (JsonSchema extend in schema.Extends)
					{
						ReferenceOrWriteSchema(extend);
					}
					_writer.WriteEndArray();
				}
			}
			_writer.WriteEndObject();
		}

		private void WriteSchemaDictionaryIfNotNull(JsonWriter writer, string propertyName, IDictionary<string, JsonSchema> properties)
		{
			if (properties == null)
			{
				return;
			}
			writer.WritePropertyName(propertyName);
			writer.WriteStartObject();
			foreach (KeyValuePair<string, JsonSchema> property in properties)
			{
				writer.WritePropertyName(property.Key);
				ReferenceOrWriteSchema(property.Value);
			}
			writer.WriteEndObject();
		}

		private void WriteItems(JsonSchema schema)
		{
			if (schema.Items == null && !schema.PositionalItemsValidation)
			{
				return;
			}
			_writer.WritePropertyName("items");
			if (!schema.PositionalItemsValidation)
			{
				if (schema.Items != null && schema.Items.Count > 0)
				{
					ReferenceOrWriteSchema(schema.Items[0]);
					return;
				}
				_writer.WriteStartObject();
				_writer.WriteEndObject();
				return;
			}
			_writer.WriteStartArray();
			if (schema.Items != null)
			{
				foreach (JsonSchema item in schema.Items)
				{
					ReferenceOrWriteSchema(item);
				}
			}
			_writer.WriteEndArray();
		}

		private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type)
		{
			if (Enum.IsDefined(typeof(JsonSchemaType), type))
			{
				writer.WritePropertyName(propertyName);
				writer.WriteValue(JsonSchemaBuilder.MapType(type));
				return;
			}
			IEnumerator<JsonSchemaType> enumerator = (from v in EnumUtils.GetFlagsValues(type)
				where v != JsonSchemaType.None
				select v).GetEnumerator();
			if (!enumerator.MoveNext())
			{
				return;
			}
			writer.WritePropertyName(propertyName);
			JsonSchemaType current = enumerator.Current;
			if (enumerator.MoveNext())
			{
				writer.WriteStartArray();
				writer.WriteValue(JsonSchemaBuilder.MapType(current));
				do
				{
					writer.WriteValue(JsonSchemaBuilder.MapType(enumerator.Current));
				}
				while (enumerator.MoveNext());
				writer.WriteEndArray();
			}
			else
			{
				writer.WriteValue(JsonSchemaBuilder.MapType(current));
			}
		}

		private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value)
		{
			if (value != null)
			{
				writer.WritePropertyName(propertyName);
				writer.WriteValue(value);
			}
		}
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal enum UndefinedSchemaIdHandling
	{
		None,
		UseTypeName,
		UseAssemblyQualifiedName
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal class ValidationEventArgs : EventArgs
	{
		private readonly JsonSchemaException _ex;

		public JsonSchemaException Exception => _ex;

		public string Path => _ex.Path;

		public string Message => _ex.Message;

		internal ValidationEventArgs(JsonSchemaException ex)
		{
			ValidationUtils.ArgumentNotNull(ex, "ex");
			_ex = ex;
		}
	}
	[Obsolete("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
	internal delegate void ValidationEventHandler(object sender, ValidationEventArgs e);
}
namespace Microsoft.Identity.Json.Linq
{
	internal enum CommentHandling
	{
		Ignore,
		Load
	}
	internal enum DuplicatePropertyNameHandling
	{
		Replace,
		Ignore,
		Error
	}
	internal static class Extensions
	{
		public static IJEnumerable<JToken> Ancestors<T>(this IEnumerable<T> source) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((T j) => j.Ancestors()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> AncestorsAndSelf<T>(this IEnumerable<T> source) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((T j) => j.AncestorsAndSelf()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Descendants<T>(this IEnumerable<T> source) where T : JContainer
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((T j) => j.Descendants()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> DescendantsAndSelf<T>(this IEnumerable<T> source) where T : JContainer
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((T j) => j.DescendantsAndSelf()).AsJEnumerable();
		}

		public static IJEnumerable<JProperty> Properties(this IEnumerable<JObject> source)
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((JObject d) => d.Properties()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source, object? key)
		{
			return source.Values<JToken, JToken>(key).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source)
		{
			return source.Values(null);
		}

		public static IEnumerable<U?> Values<U>(this IEnumerable<JToken> source, object key)
		{
			return source.Values<JToken, U>(key);
		}

		public static IEnumerable<U?> Values<U>(this IEnumerable<JToken> source)
		{
			return source.Values<JToken, U>(null);
		}

		public static U? Value<U>(this IEnumerable<JToken> value)
		{
			return value.Value<JToken, U>();
		}

		public static U? Value<T, U>(this IEnumerable<T> value) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			return ((value as JToken) ?? throw new ArgumentException("Source value must be a JToken.")).Convert<JToken, U>();
		}

		internal static IEnumerable<U?> Values<T, U>(this IEnumerable<T> source, object? key) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			if (key == null)
			{
				foreach (T item in source)
				{
					if (item is JValue token)
					{
						yield return token.Convert<JValue, U>();
						continue;
					}
					foreach (JToken item2 in item.Children())
					{
						yield return item2.Convert<JToken, U>();
					}
				}
				yield break;
			}
			foreach (T item3 in source)
			{
				JToken jToken = item3[key];
				if (jToken != null)
				{
					yield return jToken.Convert<JToken, U>();
				}
			}
		}

		public static IJEnumerable<JToken> Children<T>(this IEnumerable<T> source) where T : JToken
		{
			return source.Children<T, JToken>().AsJEnumerable();
		}

		public static IEnumerable<U?> Children<T, U>(this IEnumerable<T> source) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((T c) => c.Children()).Convert<JToken, U>();
		}

		internal static IEnumerable<U?> Convert<T, U>(this IEnumerable<T> source) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			foreach (T item in source)
			{
				yield return item.Convert<JToken, U>();
			}
		}

		internal static U? Convert<T, U>(this T token) where T : JToken?
		{
			if (token == null)
			{
				return default(U);
			}
			if (token is U result && typeof(U) != typeof(IComparable) && typeof(U) != typeof(IFormattable))
			{
				return result;
			}
			if (!(token is JValue jValue))
			{
				throw new InvalidCastException("Cannot cast {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, token.GetType(), typeof(T)));
			}
			object value = jValue.Value;
			if (value is U)
			{
				return (U)value;
			}
			Type type = typeof(U);
			if (ReflectionUtils.IsNullableType(type))
			{
				if (jValue.Value == null)
				{
					return default(U);
				}
				type = Nullable.GetUnderlyingType(type);
			}
			return (U)System.Convert.ChangeType(jValue.Value, type, CultureInfo.InvariantCulture);
		}

		public static IJEnumerable<JToken> AsJEnumerable(this IEnumerable<JToken> source)
		{
			return source.AsJEnumerable<JToken>();
		}

		public static IJEnumerable<T> AsJEnumerable<T>(this IEnumerable<T> source) where T : JToken
		{
			if (source == null)
			{
				return null;
			}
			if (source is IJEnumerable<T> result)
			{
				return result;
			}
			return new JEnumerable<T>(source);
		}
	}
	internal interface IJEnumerable<out T> : IEnumerable<T>, IEnumerable where T : JToken
	{
		IJEnumerable<JToken> this[object key] { get; }
	}
	internal class JArray : JContainer, IList<JToken>, ICollection<JToken>, IEnumerable<JToken>, IEnumerable
	{
		private readonly List<JToken> _values = new List<JToken>();

		protected override IList<JToken> ChildrenTokens => _values;

		public override JTokenType Type => JTokenType.Array;

		public override JToken? this[object key]
		{
			get
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is int))
				{
					throw new ArgumentException("Accessed JArray values with invalid key value: {0}. Int32 array index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				return GetItem((int)key);
			}
			set
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is int))
				{
					throw new ArgumentException("Set JArray values with invalid key value: {0}. Int32 array index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				SetItem((int)key, value);
			}
		}

		public JToken this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, value);
			}
		}

		public bool IsReadOnly => false;

		public override async Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, params JsonConverter[] converters)
		{
			await writer.WriteStartArrayAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			for (int i = 0; i < _values.Count; i++)
			{
				await _values[i].WriteToAsync(writer, cancellationToken, converters).ConfigureAwait(continueOnCapturedContext: false);
			}
			await writer.WriteEndArrayAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public new static Task<JArray> LoadAsync(JsonReader reader, CancellationToken cancellationToken = default(CancellationToken))
		{
			return LoadAsync(reader, null, cancellationToken);
		}

		public new static async Task<JArray> LoadAsync(JsonReader reader, JsonLoadSettings? settings, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (reader.TokenType == JsonToken.None && !(await reader.ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
			{
				throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader.");
			}
			await reader.MoveToContentAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (reader.TokenType != JsonToken.StartArray)
			{
				throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader. Current JsonReader item is not an array: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JArray a = new JArray();
			a.SetLineInfo(reader as IJsonLineInfo, settings);
			await a.ReadTokenFromAsync(reader, settings, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return a;
		}

		public JArray()
		{
		}

		public JArray(JArray other)
			: base(other)
		{
		}

		public JArray(params object[] content)
			: this((object)content)
		{
		}

		public JArray(object content)
		{
			Add(content);
		}

		internal override bool DeepEquals(JToken node)
		{
			if (node is JArray container)
			{
				return ContentsEqual(container);
			}
			return false;
		}

		internal override JToken CloneToken()
		{
			return new JArray(this);
		}

		public new static JArray Load(JsonReader reader)
		{
			return Load(reader, null);
		}

		public new static JArray Load(JsonReader reader, JsonLoadSettings? settings)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader.");
			}
			reader.MoveToContent();
			if (reader.TokenType != JsonToken.StartArray)
			{
				throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader. Current JsonReader item is not an array: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JArray jArray = new JArray();
			jArray.SetLineInfo(reader as IJsonLineInfo, settings);
			jArray.ReadTokenFrom(reader, settings);
			return jArray;
		}

		public new static JArray Parse(string json)
		{
			return Parse(json, null);
		}

		public new static JArray Parse(string json, JsonLoadSettings? settings)
		{
			using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
			JArray result = Load(jsonReader, settings);
			while (jsonReader.Read())
			{
			}
			return result;
		}

		public new static JArray FromObject(object o)
		{
			return FromObject(o, JsonSerializer.CreateDefault());
		}

		public new static JArray FromObject(object o, JsonSerializer jsonSerializer)
		{
			JToken jToken = JToken.FromObjectInternal(o, jsonSerializer);
			if (jToken.Type != JTokenType.Array)
			{
				throw new ArgumentException("Object serialized to {0}. JArray instance expected.".FormatWith(CultureInfo.InvariantCulture, jToken.Type));
			}
			return (JArray)jToken;
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartArray();
			for (int i = 0; i < _values.Count; i++)
			{
				_values[i].WriteTo(writer, converters);
			}
			writer.WriteEndArray();
		}

		internal override int IndexOfItem(JToken? item)
		{
			if (item == null)
			{
				return -1;
			}
			return _values.IndexOfReference(item);
		}

		internal override void MergeItem(object content, JsonMergeSettings? settings)
		{
			IEnumerable enumerable = ((IsMultiContent(content) || content is JArray) ? ((IEnumerable)content) : null);
			if (enumerable != null)
			{
				JContainer.MergeEnumerableContent(this, enumerable, settings);
			}
		}

		public int IndexOf(JToken item)
		{
			return IndexOfItem(item);
		}

		public void Insert(int index, JToken item)
		{
			InsertItem(index, item, skipParentCheck: false);
		}

		public void RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		public IEnumerator<JToken> GetEnumerator()
		{
			return Children().GetEnumerator();
		}

		public void Add(JToken item)
		{
			Add((object?)item);
		}

		public void Clear()
		{
			ClearItems();
		}

		public bool Contains(JToken item)
		{
			return ContainsItem(item);
		}

		public void CopyTo(JToken[] array, int arrayIndex)
		{
			CopyItemsTo(array, arrayIndex);
		}

		public bool Remove(JToken item)
		{
			return RemoveItem(item);
		}

		internal override int GetDeepHashCode()
		{
			return ContentsHashCode();
		}
	}
	internal class JConstructor : JContainer
	{
		private string? _name;

		private readonly List<JToken> _values = new List<JToken>();

		protected override IList<JToken> ChildrenTokens => _values;

		public string? Name
		{
			get
			{
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		public override JTokenType Type => JTokenType.Constructor;

		public override JToken? this[object key]
		{
			get
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is int index))
				{
					throw new ArgumentException("Accessed JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				return GetItem(index);
			}
			set
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is int index))
				{
					throw new ArgumentException("Set JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				SetItem(index, value);
			}
		}

		public override async Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, params JsonConverter[] converters)
		{
			await writer.WriteStartConstructorAsync(_name ?? string.Empty, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			for (int i = 0; i < _values.Count; i++)
			{
				await _values[i].WriteToAsync(writer, cancellationToken, converters).ConfigureAwait(continueOnCapturedContext: false);
			}
			await writer.WriteEndConstructorAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public new static Task<JConstructor> LoadAsync(JsonReader reader, CancellationToken cancellationToken = default(CancellationToken))
		{
			return LoadAsync(reader, null, cancellationToken);
		}

		public new static async Task<JConstructor> LoadAsync(JsonReader reader, JsonLoadSettings? settings, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (reader.TokenType == JsonToken.None && !(await reader.ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
			{
				throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader.");
			}
			await reader.MoveToContentAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (reader.TokenType != JsonToken.StartConstructor)
			{
				throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader. Current JsonReader item is not a constructor: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JConstructor c = new JConstructor((string)reader.Value);
			c.SetLineInfo(reader as IJsonLineInfo, settings);
			await c.ReadTokenFromAsync(reader, settings, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return c;
		}

		internal override int IndexOfItem(JToken? item)
		{
			if (item == null)
			{
				return -1;
			}
			return _values.IndexOfReference(item);
		}

		internal override void MergeItem(object content, JsonMergeSettings? settings)
		{
			if (content is JConstructor jConstructor)
			{
				if (jConstructor.Name != null)
				{
					Name = jConstructor.Name;
				}
				JContainer.MergeEnumerableContent(this, jConstructor, settings);
			}
		}

		public JConstructor()
		{
		}

		public JConstructor(JConstructor other)
			: base(other)
		{
			_name = other.Name;
		}

		public JConstructor(string name, params object[] content)
			: this(name, (object)content)
		{
		}

		public JConstructor(string name, object content)
			: this(name)
		{
			Add(content);
		}

		public JConstructor(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (name.Length == 0)
			{
				throw new ArgumentException("Constructor name cannot be empty.", "name");
			}
			_name = name;
		}

		internal override bool DeepEquals(JToken node)
		{
			if (node is JConstructor jConstructor && _name == jConstructor.Name)
			{
				return ContentsEqual(jConstructor);
			}
			return false;
		}

		internal override JToken CloneToken()
		{
			return new JConstructor(this);
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartConstructor(_name);
			int count = _values.Count;
			for (int i = 0; i < count; i++)
			{
				_values[i].WriteTo(writer, converters);
			}
			writer.WriteEndConstructor();
		}

		internal override int GetDeepHashCode()
		{
			return (_name?.GetHashCode() ?? 0) ^ ContentsHashCode();
		}

		public new static JConstructor Load(JsonReader reader)
		{
			return Load(reader, null);
		}

		public new static JConstructor Load(JsonReader reader, JsonLoadSettings? settings)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader.");
			}
			reader.MoveToContent();
			if (reader.TokenType != JsonToken.StartConstructor)
			{
				throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader. Current JsonReader item is not a constructor: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JConstructor jConstructor = new JConstructor((string)reader.Value);
			jConstructor.SetLineInfo(reader as IJsonLineInfo, settings);
			jConstructor.ReadTokenFrom(reader, settings);
			return jConstructor;
		}
	}
	internal abstract class JContainer : JToken, IList<JToken>, ICollection<JToken>, IEnumerable<JToken>, IEnumerable, ITypedList, IBindingList, ICollection, IList, INotifyCollectionChanged
	{
		internal ListChangedEventHandler? _listChanged;

		internal AddingNewEventHandler? _addingNew;

		internal NotifyCollectionChangedEventHandler? _collectionChanged;

		private object? _syncRoot;

		private bool _busy;

		protected abstract IList<JToken> ChildrenTokens { get; }

		public override bool HasValues => ChildrenTokens.Count > 0;

		public override JToken? First
		{
			get
			{
				IList<JToken> childrenTokens = ChildrenTokens;
				if (childrenTokens.Count <= 0)
				{
					return null;
				}
				return childrenTokens[0];
			}
		}

		public override JToken? Last
		{
			get
			{
				IList<JToken> childrenTokens = ChildrenTokens;
				int count = childrenTokens.Count;
				if (count <= 0)
				{
					return null;
				}
				return childrenTokens[count - 1];
			}
		}

		JToken IList<JToken>.this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, value);
			}
		}

		bool ICollection<JToken>.IsReadOnly => false;

		bool IList.IsFixedSize => false;

		bool IList.IsReadOnly => false;

		object IList.this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, EnsureValue(value));
			}
		}

		public int Count => ChildrenTokens.Count;

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		bool IBindingList.AllowEdit => true;

		bool IBindingList.AllowNew => true;

		bool IBindingList.AllowRemove => true;

		bool IBindingList.IsSorted => false;

		ListSortDirection IBindingList.SortDirection => ListSortDirection.Ascending;

		PropertyDescriptor? IBindingList.SortProperty => null;

		bool IBindingList.SupportsChangeNotification => true;

		bool IBindingList.SupportsSearching => false;

		bool IBindingList.SupportsSorting => false;

		public event ListChangedEventHandler ListChanged
		{
			add
			{
				_listChanged = (ListChangedEventHandler)Delegate.Combine(_listChanged, value);
			}
			remove
			{
				_listChanged = (ListChangedEventHandler)Delegate.Remove(_listChanged, value);
			}
		}

		public event AddingNewEventHandler AddingNew
		{
			add
			{
				_addingNew = (AddingNewEventHandler)Delegate.Combine(_addingNew, value);
			}
			remove
			{
				_addingNew = (AddingNewEventHandler)Delegate.Remove(_addingNew, value);
			}
		}

		public event NotifyCollectionChangedEventHandler CollectionChanged
		{
			add
			{
				_collectionChanged = (NotifyCollectionChangedEventHandler)Delegate.Combine(_collectionChanged, value);
			}
			remove
			{
				_collectionChanged = (NotifyCollectionChangedEventHandler)Delegate.Remove(_collectionChanged, value);
			}
		}

		internal async Task ReadTokenFromAsync(JsonReader reader, JsonLoadSettings? options, CancellationToken cancellationToken = default(CancellationToken))
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			int startDepth = reader.Depth;
			if (!(await reader.ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
			{
				throw JsonReaderException.Create(reader, "Error reading {0} from JsonReader.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));
			}
			await ReadContentFromAsync(reader, options, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (reader.Depth > startDepth)
			{
				throw JsonReaderException.Create(reader, "Unexpected end of content while loading {0}.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));
			}
		}

		private async Task ReadContentFromAsync(JsonReader reader, JsonLoadSettings? settings, CancellationToken cancellationToken = default(CancellationToken))
		{
			IJsonLineInfo lineInfo = reader as IJsonLineInfo;
			JContainer parent = this;
			do
			{
				if (parent is JProperty { Value: not null })
				{
					if (parent == this)
					{
						break;
					}
					parent = parent.Parent;
				}
				switch (reader.TokenType)
				{
				case JsonToken.StartArray:
				{
					JArray jArray = new JArray();
					jArray.SetLineInfo(lineInfo, settings);
					parent.Add(jArray);
					parent = jArray;
					break;
				}
				case JsonToken.EndArray:
					if (parent == this)
					{
						return;
					}
					parent = parent.Parent;
					break;
				case JsonToken.StartObject:
				{
					JObject jObject = new JObject();
					jObject.SetLineInfo(lineInfo, settings);
					parent.Add(jObject);
					parent = jObject;
					break;
				}
				case JsonToken.EndObject:
					if (parent == this)
					{
						return;
					}
					parent = parent.Parent;
					break;
				case JsonToken.StartConstructor:
				{
					JConstructor jConstructor = new JConstructor(reader.Value.ToString());
					jConstructor.SetLineInfo(lineInfo, settings);
					parent.Add(jConstructor);
					parent = jConstructor;
					break;
				}
				case JsonToken.EndConstructor:
					if (parent == this)
					{
						return;
					}
					parent = parent.Parent;
					break;
				case JsonToken.Integer:
				case JsonToken.Float:
				case JsonToken.String:
				case JsonToken.Boolean:
				case JsonToken.Date:
				case JsonToken.Bytes:
				{
					JValue jValue = new JValue(reader.Value);
					jValue.SetLineInfo(lineInfo, settings);
					parent.Add(jValue);
					break;
				}
				case JsonToken.Comment:
					if (settings != null && settings.CommentHandling == CommentHandling.Load)
					{
						JValue jValue = JValue.CreateComment(reader.Value.ToString());
						jValue.SetLineInfo(lineInfo, settings);
						parent.Add(jValue);
					}
					break;
				case JsonToken.Null:
				{
					JValue jValue = JValue.CreateNull();
					jValue.SetLineInfo(lineInfo, settings);
					parent.Add(jValue);
					break;
				}
				case JsonToken.Undefined:
				{
					JValue jValue = JValue.CreateUndefined();
					jValue.SetLineInfo(lineInfo, settings);
					parent.Add(jValue);
					break;
				}
				case JsonToken.PropertyName:
				{
					JProperty jProperty2 = ReadProperty(reader, settings, lineInfo, parent);
					if (jProperty2 != null)
					{
						parent = jProperty2;
					}
					else
					{
						await reader.SkipAsync().ConfigureAwait(continueOnCapturedContext: false);
					}
					break;
				}
				default:
					throw new InvalidOperationException("The JsonReader should not be on a token of type {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
				case JsonToken.None:
					break;
				}
			}
			while (await reader.ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		internal JContainer()
		{
		}

		internal JContainer(JContainer other)
			: this()
		{
			ValidationUtils.ArgumentNotNull(other, "other");
			int num = 0;
			foreach (JToken item in (IEnumerable<JToken>)other)
			{
				TryAddInternal(num, item, skipParentCheck: false);
				num++;
			}
			CopyAnnotations(this, other);
		}

		internal void CheckReentrancy()
		{
			if (_busy)
			{
				throw new InvalidOperationException("Cannot change {0} during a collection change event.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		internal virtual IList<JToken> CreateChildrenCollection()
		{
			return new List<JToken>();
		}

		protected virtual void OnAddingNew(AddingNewEventArgs e)
		{
			_addingNew?.Invoke(this, e);
		}

		protected virtual void OnListChanged(ListChangedEventArgs e)
		{
			ListChangedEventHandler listChanged = _listChanged;
			if (listChanged != null)
			{
				_busy = true;
				try
				{
					listChanged(this, e);
				}
				finally
				{
					_busy = false;
				}
			}
		}

		protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e)
		{
			NotifyCollectionChangedEventHandler collectionChanged = _collectionChanged;
			if (collectionChanged != null)
			{
				_busy = true;
				try
				{
					collectionChanged(this, e);
				}
				finally
				{
					_busy = false;
				}
			}
		}

		internal bool ContentsEqual(JContainer container)
		{
			if (container == this)
			{
				return true;
			}
			IList<JToken> childrenTokens = ChildrenTokens;
			IList<JToken> childrenTokens2 = container.ChildrenTokens;
			if (childrenTokens.Count != childrenTokens2.Count)
			{
				return false;
			}
			for (int i = 0; i < childrenTokens.Count; i++)
			{
				if (!childrenTokens[i].DeepEquals(childrenTokens2[i]))
				{
					return false;
				}
			}
			return true;
		}

		public override JEnumerable<JToken> Children()
		{
			return new JEnumerable<JToken>(ChildrenTokens);
		}

		public override IEnumerable<T?> Values<T>()
		{
			return ChildrenTokens.Convert<JToken, T>();
		}

		public IEnumerable<JToken> Descendants()
		{
			return GetDescendants(self: false);
		}

		public IEnumerable<JToken> DescendantsAndSelf()
		{
			return GetDescendants(self: true);
		}

		internal IEnumerable<JToken> GetDescendants(bool self)
		{
			if (self)
			{
				yield return this;
			}
			foreach (JToken o in ChildrenTokens)
			{
				yield return o;
				if (!(o is JContainer jContainer))
				{
					continue;
				}
				foreach (JToken item in jContainer.Descendants())
				{
					yield return item;
				}
			}
		}

		internal bool IsMultiContent([NotNullWhen(true)] object? content)
		{
			if (content is IEnumerable && !(content is string) && !(content is JToken))
			{
				return !(content is byte[]);
			}
			return false;
		}

		internal JToken EnsureParentToken(JToken? item, bool skipParentCheck)
		{
			if (item == null)
			{
				return JValue.CreateNull();
			}
			if (skipParentCheck)
			{
				return item;
			}
			if (item.Parent != null || item == this || (item.HasValues && base.Root == item))
			{
				item = item.CloneToken();
			}
			return item;
		}

		internal abstract int IndexOfItem(JToken? item);

		internal virtual bool InsertItem(int index, JToken? item, bool skipParentCheck)
		{
			IList<JToken> childrenTokens = ChildrenTokens;
			if (index > childrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index must be within the bounds of the List.");
			}
			CheckReentrancy();
			item = EnsureParentToken(item, skipParentCheck);
			JToken jToken = ((index == 0) ? null : childrenTokens[index - 1]);
			JToken jToken2 = ((index == childrenTokens.Count) ? null : childrenTokens[index]);
			ValidateToken(item, null);
			item.Parent = this;
			item.Previous = jToken;
			if (jToken != null)
			{
				jToken.Next = item;
			}
			item.Next = jToken2;
			if (jToken2 != null)
			{
				jToken2.Previous = item;
			}
			childrenTokens.Insert(index, item);
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemAdded, index));
			}
			if (_collectionChanged != null)
			{
				OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item, index));
			}
			return true;
		}

		internal virtual void RemoveItemAt(int index)
		{
			IList<JToken> childrenTokens = ChildrenTokens;
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
			}
			if (index >= childrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");
			}
			CheckReentrancy();
			JToken jToken = childrenTokens[index];
			JToken jToken2 = ((index == 0) ? null : childrenTokens[index - 1]);
			JToken jToken3 = ((index == childrenTokens.Count - 1) ? null : childrenTokens[index + 1]);
			if (jToken2 != null)
			{
				jToken2.Next = jToken3;
			}
			if (jToken3 != null)
			{
				jToken3.Previous = jToken2;
			}
			jToken.Parent = null;
			jToken.Previous = null;
			jToken.Next = null;
			childrenTokens.RemoveAt(index);
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, index));
			}
			if (_collectionChanged != null)
			{
				OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, jToken, index));
			}
		}

		internal virtual bool RemoveItem(JToken? item)
		{
			if (item != null)
			{
				int num = IndexOfItem(item);
				if (num >= 0)
				{
					RemoveItemAt(num);
					return true;
				}
			}
			return false;
		}

		internal virtual JToken GetItem(int index)
		{
			return ChildrenTokens[index];
		}

		internal virtual void SetItem(int index, JToken? item)
		{
			IList<JToken> childrenTokens = ChildrenTokens;
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
			}
			if (index >= childrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");
			}
			JToken jToken = childrenTokens[index];
			if (!IsTokenUnchanged(jToken, item))
			{
				CheckReentrancy();
				item = EnsureParentToken(item, skipParentCheck: false);
				ValidateToken(item, jToken);
				JToken jToken2 = ((index == 0) ? null : childrenTokens[index - 1]);
				JToken jToken3 = ((index == childrenTokens.Count - 1) ? null : childrenTokens[index + 1]);
				item.Parent = this;
				item.Previous = jToken2;
				if (jToken2 != null)
				{
					jToken2.Next = item;
				}
				item.Next = jToken3;
				if (jToken3 != null)
				{
					jToken3.Previous = item;
				}
				childrenTokens[index] = item;
				jToken.Parent = null;
				jToken.Previous = null;
				jToken.Next = null;
				if (_listChanged != null)
				{
					OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, index));
				}
				if (_collectionChanged != null)
				{
					OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace, item, jToken, index));
				}
			}
		}

		internal virtual void ClearItems()
		{
			CheckReentrancy();
			IList<JToken> childrenTokens = ChildrenTokens;
			foreach (JToken item in childrenTokens)
			{
				item.Parent = null;
				item.Previous = null;
				item.Next = null;
			}
			childrenTokens.Clear();
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));
			}
			if (_collectionChanged != null)
			{
				OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
			}
		}

		internal virtual void ReplaceItem(JToken existing, JToken replacement)
		{
			if (existing != null && existing.Parent == this)
			{
				int index = IndexOfItem(existing);
				SetItem(index, replacement);
			}
		}

		internal virtual bool ContainsItem(JToken? item)
		{
			return IndexOfItem(item) != -1;
		}

		internal virtual void CopyItemsTo(Array array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (arrayIndex < 0)
			{
				throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
			}
			if (arrayIndex >= array.Length && arrayIndex != 0)
			{
				throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
			}
			if (Count > array.Length - arrayIndex)
			{
				throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
			}
			int num = 0;
			foreach (JToken childrenToken in ChildrenTokens)
			{
				array.SetValue(childrenToken, arrayIndex + num);
				num++;
			}
		}

		internal static bool IsTokenUnchanged(JToken currentValue, JToken? newValue)
		{
			if (currentValue is JValue jValue)
			{
				if (newValue == null)
				{
					return jValue.Type == JTokenType.Null;
				}
				return jValue.Equals(newValue);
			}
			return false;
		}

		internal virtual void ValidateToken(JToken o, JToken? existing)
		{
			ValidationUtils.ArgumentNotNull(o, "o");
			if (o.Type == JTokenType.Property)
			{
				throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, o.GetType(), GetType()));
			}
		}

		public virtual void Add(object? content)
		{
			TryAddInternal(ChildrenTokens.Count, content, skipParentCheck: false);
		}

		internal bool TryAdd(object? content)
		{
			return TryAddInternal(ChildrenTokens.Count, content, skipParentCheck: false);
		}

		internal void AddAndSkipParentCheck(JToken token)
		{
			TryAddInternal(ChildrenTokens.Count, token, skipParentCheck: true);
		}

		public void AddFirst(object? content)
		{
			TryAddInternal(0, content, skipParentCheck: false);
		}

		internal bool TryAddInternal(int index, object? content, bool skipParentCheck)
		{
			if (IsMultiContent(content))
			{
				IEnumerable obj = (IEnumerable)content;
				int num = index;
				foreach (object item2 in obj)
				{
					TryAddInternal(num, item2, skipParentCheck);
					num++;
				}
				return true;
			}
			JToken item = CreateFromContent(content);
			return InsertItem(index, item, skipParentCheck);
		}

		internal static JToken CreateFromContent(object? content)
		{
			if (content is JToken result)
			{
				return result;
			}
			return new JValue(content);
		}

		public JsonWriter CreateWriter()
		{
			return new JTokenWriter(this);
		}

		public void ReplaceAll(object content)
		{
			ClearItems();
			Add(content);
		}

		public void RemoveAll()
		{
			ClearItems();
		}

		internal abstract void MergeItem(object content, JsonMergeSettings? settings);

		public void Merge(object content)
		{
			MergeItem(content, null);
		}

		public void Merge(object content, JsonMergeSettings? settings)
		{
			MergeItem(content, settings);
		}

		internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings? options)
		{
			int depth = reader.Depth;
			if (!reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading {0} from JsonReader.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));
			}
			ReadContentFrom(reader, options);
			if (reader.Depth > depth)
			{
				throw JsonReaderException.Create(reader, "Unexpected end of content while loading {0}.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));
			}
		}

		internal void ReadContentFrom(JsonReader r, JsonLoadSettings? settings)
		{
			ValidationUtils.ArgumentNotNull(r, "r");
			IJsonLineInfo lineInfo = r as IJsonLineInfo;
			JContainer jContainer = this;
			do
			{
				if (jContainer is JProperty { Value: not null })
				{
					if (jContainer == this)
					{
						break;
					}
					jContainer = jContainer.Parent;
				}
				switch (r.TokenType)
				{
				case JsonToken.StartArray:
				{
					JArray jArray = new JArray();
					jArray.SetLineInfo(lineInfo, settings);
					jContainer.Add(jArray);
					jContainer = jArray;
					break;
				}
				case JsonToken.EndArray:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.StartObject:
				{
					JObject jObject = new JObject();
					jObject.SetLineInfo(lineInfo, settings);
					jContainer.Add(jObject);
					jContainer = jObject;
					break;
				}
				case JsonToken.EndObject:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.StartConstructor:
				{
					JConstructor jConstructor = new JConstructor(r.Value.ToString());
					jConstructor.SetLineInfo(lineInfo, settings);
					jContainer.Add(jConstructor);
					jContainer = jConstructor;
					break;
				}
				case JsonToken.EndConstructor:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.Integer:
				case JsonToken.Float:
				case JsonToken.String:
				case JsonToken.Boolean:
				case JsonToken.Date:
				case JsonToken.Bytes:
				{
					JValue jValue = new JValue(r.Value);
					jValue.SetLineInfo(lineInfo, settings);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.Comment:
					if (settings != null && settings.CommentHandling == CommentHandling.Load)
					{
						JValue jValue = JValue.CreateComment(r.Value.ToString());
						jValue.SetLineInfo(lineInfo, settings);
						jContainer.Add(jValue);
					}
					break;
				case JsonToken.Null:
				{
					JValue jValue = JValue.CreateNull();
					jValue.SetLineInfo(lineInfo, settings);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.Undefined:
				{
					JValue jValue = JValue.CreateUndefined();
					jValue.SetLineInfo(lineInfo, settings);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.PropertyName:
				{
					JProperty jProperty2 = ReadProperty(r, settings, lineInfo, jContainer);
					if (jProperty2 != null)
					{
						jContainer = jProperty2;
					}
					else
					{
						r.Skip();
					}
					break;
				}
				default:
					throw new InvalidOperationException("The JsonReader should not be on a token of type {0}.".FormatWith(CultureInfo.InvariantCulture, r.TokenType));
				case JsonToken.None:
					break;
				}
			}
			while (r.Read());
		}

		private static JProperty? ReadProperty(JsonReader r, JsonLoadSettings? settings, IJsonLineInfo? lineInfo, JContainer parent)
		{
			DuplicatePropertyNameHandling duplicatePropertyNameHandling = settings?.DuplicatePropertyNameHandling ?? DuplicatePropertyNameHandling.Replace;
			JObject obj = (JObject)parent;
			string text = r.Value.ToString();
			JProperty jProperty = obj.Property(text, StringComparison.Ordinal);
			if (jProperty != null)
			{
				switch (duplicatePropertyNameHandling)
				{
				case DuplicatePropertyNameHandling.Ignore:
					return null;
				case DuplicatePropertyNameHandling.Error:
					throw JsonReaderException.Create(r, "Property with the name '{0}' already exists in the current JSON object.".FormatWith(CultureInfo.InvariantCulture, text));
				}
			}
			JProperty jProperty2 = new JProperty(text);
			jProperty2.SetLineInfo(lineInfo, settings);
			if (jProperty == null)
			{
				parent.Add(jProperty2);
			}
			else
			{
				jProperty.Replace(jProperty2);
			}
			return jProperty2;
		}

		internal int ContentsHashCode()
		{
			int num = 0;
			foreach (JToken childrenToken in ChildrenTokens)
			{
				num ^= childrenToken.GetDeepHashCode();
			}
			return num;
		}

		string ITypedList.GetListName(PropertyDescriptor[] listAccessors)
		{
			return string.Empty;
		}

		PropertyDescriptorCollection? ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors)
		{
			return (First as ICustomTypeDescriptor)?.GetProperties();
		}

		int IList<JToken>.IndexOf(JToken item)
		{
			return IndexOfItem(item);
		}

		void IList<JToken>.Insert(int index, JToken item)
		{
			InsertItem(index, item, skipParentCheck: false);
		}

		void IList<JToken>.RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		void ICollection<JToken>.Add(JToken item)
		{
			Add(item);
		}

		void ICollection<JToken>.Clear()
		{
			ClearItems();
		}

		bool ICollection<JToken>.Contains(JToken item)
		{
			return ContainsItem(item);
		}

		void ICollection<JToken>.CopyTo(JToken[] array, int arrayIndex)
		{
			CopyItemsTo(array, arrayIndex);
		}

		bool ICollection<JToken>.Remove(JToken item)
		{
			return RemoveItem(item);
		}

		private JToken? EnsureValue(object value)
		{
			if (value == null)
			{
				return null;
			}
			if (value is JToken result)
			{
				return result;
			}
			throw new ArgumentException("Argument is not a JToken.");
		}

		int IList.Add(object value)
		{
			Add(EnsureValue(value));
			return Count - 1;
		}

		void IList.Clear()
		{
			ClearItems();
		}

		bool IList.Contains(object value)
		{
			return ContainsItem(EnsureValue(value));
		}

		int IList.IndexOf(object value)
		{
			return IndexOfItem(EnsureValue(value));
		}

		void IList.Insert(int index, object value)
		{
			InsertItem(index, EnsureValue(value), skipParentCheck: false);
		}

		void IList.Remove(object value)
		{
			RemoveItem(EnsureValue(value));
		}

		void IList.RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		void ICollection.CopyTo(Array array, int index)
		{
			CopyItemsTo(array, index);
		}

		void IBindingList.AddIndex(PropertyDescriptor property)
		{
		}

		object IBindingList.AddNew()
		{
			AddingNewEventArgs e = new AddingNewEventArgs();
			OnAddingNew(e);
			if (e.NewObject == null)
			{
				throw new JsonException("Could not determine new value to add to '{0}'.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
			if (!(e.NewObject is JToken jToken))
			{
				throw new JsonException("New item to be added to collection must be compatible with {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JToken)));
			}
			Add(jToken);
			return jToken;
		}

		void IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction)
		{
			throw new NotSupportedException();
		}

		int IBindingList.Find(PropertyDescriptor property, object key)
		{
			throw new NotSupportedException();
		}

		void IBindingList.RemoveIndex(PropertyDescriptor property)
		{
		}

		void IBindingList.RemoveSort()
		{
			throw new NotSupportedException();
		}

		internal static void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings? settings)
		{
			switch (settings?.MergeArrayHandling ?? MergeArrayHandling.Concat)
			{
			case MergeArrayHandling.Concat:
			{
				foreach (JToken item in content)
				{
					target.Add(item);
				}
				break;
			}
			case MergeArrayHandling.Union:
			{
				HashSet<JToken> hashSet = new HashSet<JToken>(target, JToken.EqualityComparer);
				{
					foreach (JToken item2 in content)
					{
						if (hashSet.Add(item2))
						{
							target.Add(item2);
						}
					}
					break;
				}
			}
			case MergeArrayHandling.Replace:
				if (target == content)
				{
					break;
				}
				target.ClearItems();
				{
					foreach (JToken item3 in content)
					{
						target.Add(item3);
					}
					break;
				}
			case MergeArrayHandling.Merge:
			{
				int num = 0;
				{
					foreach (object item4 in content)
					{
						if (num < target.Count)
						{
							if (target[num] is JContainer jContainer)
							{
								jContainer.Merge(item4, settings);
							}
							else if (item4 != null)
							{
								JToken jToken = CreateFromContent(item4);
								if (jToken.Type != JTokenType.Null)
								{
									target[num] = jToken;
								}
							}
						}
						else
						{
							target.Add(item4);
						}
						num++;
					}
					break;
				}
			}
			default:
				throw new ArgumentOutOfRangeException("settings", "Unexpected merge array handling when merging JSON.");
			}
		}
	}
	internal readonly struct JEnumerable<T> : IJEnumerable<T>, IEnumerable<T>, IEnumerable, IEquatable<JEnumerable<T>> where T : JToken
	{
		public static readonly JEnumerable<T> Empty = new JEnumerable<T>(Enumerable.Empty<T>());

		private readonly IEnumerable<T> _enumerable;

		public IJEnumerable<JToken> this[object key]
		{
			get
			{
				if (_enumerable == null)
				{
					return JEnumerable<JToken>.Empty;
				}
				return new JEnumerable<JToken>(_enumerable.Values<T, JToken>(key));
			}
		}

		public JEnumerable(IEnumerable<T> enumerable)
		{
			ValidationUtils.ArgumentNotNull(enumerable, "enumerable");
			_enumerable = enumerable;
		}

		public IEnumerator<T> GetEnumerator()
		{
			return ((IEnumerable<T>)(_enumerable ?? ((object)Empty))).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public bool Equals(JEnumerable<T> other)
		{
			return object.Equals(_enumerable, other._enumerable);
		}

		public override bool Equals(object obj)
		{
			if (obj is JEnumerable<T> other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			if (_enumerable == null)
			{
				return 0;
			}
			return _enumerable.GetHashCode();
		}
	}
	internal class JObject : JContainer, IDictionary<string, JToken?>, ICollection<KeyValuePair<string, JToken?>>, IEnumerable<KeyValuePair<string, JToken?>>, IEnumerable, INotifyPropertyChanged, ICustomTypeDescriptor, INotifyPropertyChanging
	{
		private class JObjectDynamicProxy : DynamicProxy<JObject>
		{
			public override bool TryGetMember(JObject instance, GetMemberBinder binder, out object? result)
			{
				result = instance[binder.Name];
				return true;
			}

			public override bool TrySetMember(JObject instance, SetMemberBinder binder, object value)
			{
				JToken jToken = value as JToken;
				if (jToken == null)
				{
					jToken = new JValue(value);
				}
				instance[binder.Name] = jToken;
				return true;
			}

			public override IEnumerable<string> GetDynamicMemberNames(JObject instance)
			{
				return from p in instance.Properties()
					select p.Name;
			}
		}

		private readonly JPropertyKeyedCollection _properties = new JPropertyKeyedCollection();

		protected override IList<JToken> ChildrenTokens => _properties;

		public override JTokenType Type => JTokenType.Object;

		public override JToken? this[object key]
		{
			get
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is string propertyName))
				{
					throw new ArgumentException("Accessed JObject values with invalid key value: {0}. Object property name expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				return this[propertyName];
			}
			set
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is string propertyName))
				{
					throw new ArgumentException("Set JObject values with invalid key value: {0}. Object property name expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				this[propertyName] = value;
			}
		}

		public JToken? this[string propertyName]
		{
			get
			{
				ValidationUtils.ArgumentNotNull(propertyName, "propertyName");
				return Property(propertyName, StringComparison.Ordinal)?.Value;
			}
			set
			{
				JProperty jProperty = Property(propertyName, StringComparison.Ordinal);
				if (jProperty != null)
				{
					jProperty.Value = value;
					return;
				}
				OnPropertyChanging(propertyName);
				Add(propertyName, value);
				OnPropertyChanged(propertyName);
			}
		}

		ICollection<string> IDictionary<string, JToken>.Keys => _properties.Keys;

		ICollection<JToken?> IDictionary<string, JToken>.Values
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		bool ICollection<KeyValuePair<string, JToken>>.IsReadOnly => false;

		public event PropertyChangedEventHandler? PropertyChanged;

		public event PropertyChangingEventHandler? PropertyChanging;

		public override Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, params JsonConverter[] converters)
		{
			Task task = writer.WriteStartObjectAsync(cancellationToken);
			if (!task.IsCompletedSucessfully())
			{
				return AwaitProperties(task, 0, writer, cancellationToken, converters);
			}
			for (int i = 0; i < _properties.Count; i++)
			{
				task = _properties[i].WriteToAsync(writer, cancellationToken, converters);
				if (!task.IsCompletedSucessfully())
				{
					return AwaitProperties(task, i + 1, writer, cancellationToken, converters);
				}
			}
			return writer.WriteEndObjectAsync(cancellationToken);
			async Task AwaitProperties(Task task2, int num, JsonWriter Writer, CancellationToken CancellationToken, JsonConverter[] Converters)
			{
				await task2.ConfigureAwait(continueOnCapturedContext: false);
				while (num < _properties.Count)
				{
					await _properties[num].WriteToAsync(Writer, CancellationToken, Converters).ConfigureAwait(continueOnCapturedContext: false);
					num++;
				}
				await Writer.WriteEndObjectAsync(CancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		public new static Task<JObject> LoadAsync(JsonReader reader, CancellationToken cancellationToken = default(CancellationToken))
		{
			return LoadAsync(reader, null, cancellationToken);
		}

		public new static async Task<JObject> LoadAsync(JsonReader reader, JsonLoadSettings? settings, CancellationToken cancellationToken = default(CancellationToken))
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			if (reader.TokenType == JsonToken.None && !(await reader.ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
			{
				throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader.");
			}
			await reader.MoveToContentAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (reader.TokenType != JsonToken.StartObject)
			{
				throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader. Current JsonReader item is not an object: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JObject o = new JObject();
			o.SetLineInfo(reader as IJsonLineInfo, settings);
			await o.ReadTokenFromAsync(reader, settings, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return o;
		}

		public JObject()
		{
		}

		public JObject(JObject other)
			: base(other)
		{
		}

		public JObject(params object[] content)
			: this((object)content)
		{
		}

		public JObject(object content)
		{
			Add(content);
		}

		internal override bool DeepEquals(JToken node)
		{
			if (!(node is JObject jObject))
			{
				return false;
			}
			return _properties.Compare(jObject._properties);
		}

		internal override int IndexOfItem(JToken? item)
		{
			if (item == null)
			{
				return -1;
			}
			return _properties.IndexOfReference(item);
		}

		internal override bool InsertItem(int index, JToken? item, bool skipParentCheck)
		{
			if (item != null && item.Type == JTokenType.Comment)
			{
				return false;
			}
			return base.InsertItem(index, item, skipParentCheck);
		}

		internal override void ValidateToken(JToken o, JToken? existing)
		{
			ValidationUtils.ArgumentNotNull(o, "o");
			if (o.Type != JTokenType.Property)
			{
				throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, o.GetType(), GetType()));
			}
			JProperty jProperty = (JProperty)o;
			if (existing != null)
			{
				JProperty jProperty2 = (JProperty)existing;
				if (jProperty.Name == jProperty2.Name)
				{
					return;
				}
			}
			if (_properties.TryGetValue(jProperty.Name, out existing))
			{
				throw new ArgumentException("Can not add property {0} to {1}. Property with the same name already exists on object.".FormatWith(CultureInfo.InvariantCulture, jProperty.Name, GetType()));
			}
		}

		internal override void MergeItem(object content, JsonMergeSettings? settings)
		{
			if (!(content is JObject jObject))
			{
				return;
			}
			foreach (KeyValuePair<string, JToken> item in jObject)
			{
				JProperty jProperty = Property(item.Key, settings?.PropertyNameComparison ?? StringComparison.Ordinal);
				if (jProperty == null)
				{
					Add(item.Key, item.Value);
				}
				else
				{
					if (item.Value == null)
					{
						continue;
					}
					if (!(jProperty.Value is JContainer jContainer) || jContainer.Type != item.Value.Type)
					{
						if (!IsNull(item.Value) || (settings != null && settings.MergeNullValueHandling == MergeNullValueHandling.Merge))
						{
							jProperty.Value = item.Value;
						}
					}
					else
					{
						jContainer.Merge(item.Value, settings);
					}
				}
			}
		}

		private static bool IsNull(JToken token)
		{
			if (token.Type == JTokenType.Null)
			{
				return true;
			}
			if (token is JValue { Value: null })
			{
				return true;
			}
			return false;
		}

		internal void InternalPropertyChanged(JProperty childProperty)
		{
			OnPropertyChanged(childProperty.Name);
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, IndexOfItem(childProperty)));
			}
			if (_collectionChanged != null)
			{
				OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace, childProperty, childProperty, IndexOfItem(childProperty)));
			}
		}

		internal void InternalPropertyChanging(JProperty childProperty)
		{
			OnPropertyChanging(childProperty.Name);
		}

		internal override JToken CloneToken()
		{
			return new JObject(this);
		}

		public IEnumerable<JProperty> Properties()
		{
			return _properties.Cast<JProperty>();
		}

		public JProperty? Property(string name)
		{
			return Property(name, StringComparison.Ordinal);
		}

		public JProperty? Property(string name, StringComparison comparison)
		{
			if (name == null)
			{
				return null;
			}
			if (_properties.TryGetValue(name, out JToken value))
			{
				return (JProperty)value;
			}
			if (comparison != StringComparison.Ordinal)
			{
				for (int i = 0; i < _properties.Count; i++)
				{
					JProperty jProperty = (JProperty)_properties[i];
					if (string.Equals(jProperty.Name, name, comparison))
					{
						return jProperty;
					}
				}
			}
			return null;
		}

		public JEnumerable<JToken> PropertyValues()
		{
			return new JEnumerable<JToken>(from p in Properties()
				select p.Value);
		}

		public new static JObject Load(JsonReader reader)
		{
			return Load(reader, null);
		}

		public new static JObject Load(JsonReader reader, JsonLoadSettings? settings)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader.");
			}
			reader.MoveToContent();
			if (reader.TokenType != JsonToken.StartObject)
			{
				throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader. Current JsonReader item is not an object: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JObject jObject = new JObject();
			jObject.SetLineInfo(reader as IJsonLineInfo, settings);
			jObject.ReadTokenFrom(reader, settings);
			return jObject;
		}

		public new static JObject Parse(string json)
		{
			return Parse(json, null);
		}

		public new static JObject Parse(string json, JsonLoadSettings? settings)
		{
			using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
			JObject result = Load(jsonReader, settings);
			while (jsonReader.Read())
			{
			}
			return result;
		}

		public new static JObject FromObject(object o)
		{
			return FromObject(o, JsonSerializer.CreateDefault());
		}

		public new static JObject FromObject(object o, JsonSerializer jsonSerializer)
		{
			JToken jToken = JToken.FromObjectInternal(o, jsonSerializer);
			if (jToken.Type != JTokenType.Object)
			{
				throw new ArgumentException("Object serialized to {0}. JObject instance expected.".FormatWith(CultureInfo.InvariantCulture, jToken.Type));
			}
			return (JObject)jToken;
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartObject();
			for (int i = 0; i < _properties.Count; i++)
			{
				_properties[i].WriteTo(writer, converters);
			}
			writer.WriteEndObject();
		}

		public JToken? GetValue(string? propertyName)
		{
			return GetValue(propertyName, StringComparison.Ordinal);
		}

		public JToken? GetValue(string? propertyName, StringComparison comparison)
		{
			if (propertyName == null)
			{
				return null;
			}
			return Property(propertyName, comparison)?.Value;
		}

		public bool TryGetValue(string propertyName, StringComparison comparison, [NotNullWhen(true)] out JToken? value)
		{
			value = GetValue(propertyName, comparison);
			return value != null;
		}

		public void Add(string propertyName, JToken? value)
		{
			Add(new JProperty(propertyName, value));
		}

		public bool ContainsKey(string propertyName)
		{
			ValidationUtils.ArgumentNotNull(propertyName, "propertyName");
			return _properties.Contains(propertyName);
		}

		public bool Remove(string propertyName)
		{
			JProperty jProperty = Property(propertyName, StringComparison.Ordinal);
			if (jProperty == null)
			{
				return false;
			}
			jProperty.Remove();
			return true;
		}

		public bool TryGetValue(string propertyName, [NotNullWhen(true)] out JToken? value)
		{
			JProperty jProperty = Property(propertyName, StringComparison.Ordinal);
			if (jProperty == null)
			{
				value = null;
				return false;
			}
			value = jProperty.Value;
			return true;
		}

		void ICollection<KeyValuePair<string, JToken>>.Add(KeyValuePair<string, JToken?> item)
		{
			Add(new JProperty(item.Key, item.Value));
		}

		void ICollection<KeyValuePair<string, JToken>>.Clear()
		{
			RemoveAll();
		}

		bool ICollection<KeyValuePair<string, JToken>>.Contains(KeyValuePair<string, JToken?> item)
		{
			JProperty jProperty = Property(item.Key, StringComparison.Ordinal);
			if (jProperty == null)
			{
				return false;
			}
			return jProperty.Value == item.Value;
		}

		void ICollection<KeyValuePair<string, JToken>>.CopyTo(KeyValuePair<string, JToken?>[] array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (arrayIndex < 0)
			{
				throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
			}
			if (arrayIndex >= array.Length && arrayIndex != 0)
			{
				throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
			}
			if (base.Count > array.Length - arrayIndex)
			{
				throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
			}
			int num = 0;
			foreach (JProperty property in _properties)
			{
				array[arrayIndex + num] = new KeyValuePair<string, JToken>(property.Name, property.Value);
				num++;
			}
		}

		bool ICollection<KeyValuePair<string, JToken>>.Remove(KeyValuePair<string, JToken?> item)
		{
			if (!((ICollection<KeyValuePair<string, JToken>>)this).Contains(item))
			{
				return false;
			}
			((IDictionary<string, JToken>)this).Remove(item.Key);
			return true;
		}

		internal override int GetDeepHashCode()
		{
			return ContentsHashCode();
		}

		public IEnumerator<KeyValuePair<string, JToken?>> GetEnumerator()
		{
			foreach (JProperty property in _properties)
			{
				yield return new KeyValuePair<string, JToken>(property.Name, property.Value);
			}
		}

		protected virtual void OnPropertyChanged(string propertyName)
		{
			this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		}

		protected virtual void OnPropertyChanging(string propertyName)
		{
			this.PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(propertyName));
		}

		PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties()
		{
			return ((ICustomTypeDescriptor)this).GetProperties((Attribute[])null);
		}

		PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes)
		{
			PropertyDescriptor[] array = new PropertyDescriptor[base.Count];
			int num = 0;
			using (IEnumerator<KeyValuePair<string, JToken>> enumerator = GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					array[num] = new JPropertyDescriptor(enumerator.Current.Key);
					num++;
				}
			}
			return new PropertyDescriptorCollection(array);
		}

		AttributeCollection ICustomTypeDescriptor.GetAttributes()
		{
			return AttributeCollection.Empty;
		}

		string? ICustomTypeDescriptor.GetClassName()
		{
			return null;
		}

		string? ICustomTypeDescriptor.GetComponentName()
		{
			return null;
		}

		TypeConverter ICustomTypeDescriptor.GetConverter()
		{
			return new TypeConverter();
		}

		EventDescriptor? ICustomTypeDescriptor.GetDefaultEvent()
		{
			return null;
		}

		PropertyDescriptor? ICustomTypeDescriptor.GetDefaultProperty()
		{
			return null;
		}

		object? ICustomTypeDescriptor.GetEditor(Type editorBaseType)
		{
			return null;
		}

		EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes)
		{
			return EventDescriptorCollection.Empty;
		}

		EventDescriptorCollection ICustomTypeDescriptor.GetEvents()
		{
			return EventDescriptorCollection.Empty;
		}

		object? ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd)
		{
			if (pd is JPropertyDescriptor)
			{
				return this;
			}
			return null;
		}

		protected override DynamicMetaObject GetMetaObject(Expression parameter)
		{
			return new DynamicProxyMetaObject<JObject>(parameter, this, new JObjectDynamicProxy());
		}
	}
	internal class JProperty : JContainer
	{
		private class JPropertyList : IList<JToken>, ICollection<JToken>, IEnumerable<JToken>, IEnumerable
		{
			internal JToken? _token;

			public int Count => (_token != null) ? 1 : 0;

			public bool IsReadOnly => false;

			public JToken this[int index]
			{
				get
				{
					if (index != 0)
					{
						throw new IndexOutOfRangeException();
					}
					return _token;
				}
				set
				{
					if (index != 0)
					{
						throw new IndexOutOfRangeException();
					}
					_token = value;
				}
			}

			public IEnumerator<JToken> GetEnumerator()
			{
				if (_token != null)
				{
					yield return _token;
				}
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			public void Add(JToken item)
			{
				_token = item;
			}

			public void Clear()
			{
				_token = null;
			}

			public bool Contains(JToken item)
			{
				return _token == item;
			}

			public void CopyTo(JToken[] array, int arrayIndex)
			{
				if (_token != null)
				{
					array[arrayIndex] = _token;
				}
			}

			public bool Remove(JToken item)
			{
				if (_token == item)
				{
					_token = null;
					return true;
				}
				return false;
			}

			public int IndexOf(JToken item)
			{
				if (_token != item)
				{
					return -1;
				}
				return 0;
			}

			public void Insert(int index, JToken item)
			{
				if (index == 0)
				{
					_token = item;
				}
			}

			public void RemoveAt(int index)
			{
				if (index == 0)
				{
					_token = null;
				}
			}
		}

		private readonly JPropertyList _content = new JPropertyList();

		private readonly string _name;

		protected override IList<JToken> ChildrenTokens => _content;

		public string Name
		{
			[DebuggerStepThrough]
			get
			{
				return _name;
			}
		}

		public new JToken Value
		{
			[DebuggerStepThrough]
			get
			{
				return _content._token;
			}
			set
			{
				CheckReentrancy();
				JToken item = value ?? JValue.CreateNull();
				if (_content._token == null)
				{
					InsertItem(0, item, skipParentCheck: false);
				}
				else
				{
					SetItem(0, item);
				}
			}
		}

		public override JTokenType Type
		{
			[DebuggerStepThrough]
			get
			{
				return JTokenType.Property;
			}
		}

		public override Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, params JsonConverter[] converters)
		{
			Task task = writer.WritePropertyNameAsync(_name, cancellationToken);
			if (task.IsCompletedSucessfully())
			{
				return WriteValueAsync(writer, cancellationToken, converters);
			}
			return WriteToAsync(task, writer, cancellationToken, converters);
		}

		private async Task WriteToAsync(Task task, JsonWriter writer, CancellationToken cancellationToken, params JsonConverter[] converters)
		{
			await task.ConfigureAwait(continueOnCapturedContext: false);
			await WriteValueAsync(writer, cancellationToken, converters).ConfigureAwait(continueOnCapturedContext: false);
		}

		private Task WriteValueAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters)
		{
			JToken value = Value;
			if (value == null)
			{
				return writer.WriteNullAsync(cancellationToken);
			}
			return value.WriteToAsync(writer, cancellationToken, converters);
		}

		public new static Task<JProperty> LoadAsync(JsonReader reader, CancellationToken cancellationToken = default(CancellationToken))
		{
			return LoadAsync(reader, null, cancellationToken);
		}

		public new static async Task<JProperty> LoadAsync(JsonReader reader, JsonLoadSettings? settings, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (reader.TokenType == JsonToken.None && !(await reader.ReadAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)))
			{
				throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader.");
			}
			await reader.MoveToContentAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (reader.TokenType != JsonToken.PropertyName)
			{
				throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader. Current JsonReader item is not a property: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JProperty p = new JProperty((string)reader.Value);
			p.SetLineInfo(reader as IJsonLineInfo, settings);
			await p.ReadTokenFromAsync(reader, settings, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return p;
		}

		public JProperty(JProperty other)
			: base(other)
		{
			_name = other.Name;
		}

		internal override JToken GetItem(int index)
		{
			if (index != 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			return Value;
		}

		internal override void SetItem(int index, JToken? item)
		{
			if (index != 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			if (!JContainer.IsTokenUnchanged(Value, item))
			{
				((JObject)base.Parent)?.InternalPropertyChanging(this);
				base.SetItem(0, item);
				((JObject)base.Parent)?.InternalPropertyChanged(this);
			}
		}

		internal override bool RemoveItem(JToken? item)
		{
			throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override void RemoveItemAt(int index)
		{
			throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override int IndexOfItem(JToken? item)
		{
			if (item == null)
			{
				return -1;
			}
			return _content.IndexOf(item);
		}

		internal override bool InsertItem(int index, JToken? item, bool skipParentCheck)
		{
			if (item != null && item.Type == JTokenType.Comment)
			{
				return false;
			}
			if (Value != null)
			{
				throw new JsonException("{0} cannot have multiple values.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
			}
			return base.InsertItem(0, item, skipParentCheck: false);
		}

		internal override bool ContainsItem(JToken? item)
		{
			return Value == item;
		}

		internal override void MergeItem(object content, JsonMergeSettings? settings)
		{
			JToken jToken = (content as JProperty)?.Value;
			if (jToken != null && jToken.Type != JTokenType.Null)
			{
				Value = jToken;
			}
		}

		internal override void ClearItems()
		{
			throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override bool DeepEquals(JToken node)
		{
			if (node is JProperty jProperty && _name == jProperty.Name)
			{
				return ContentsEqual(jProperty);
			}
			return false;
		}

		internal override JToken CloneToken()
		{
			return new JProperty(this);
		}

		internal JProperty(string name)
		{
			ValidationUtils.ArgumentNotNull(name, "name");
			_name = name;
		}

		public JProperty(string name, params object[] content)
			: this(name, (object?)content)
		{
		}

		public JProperty(string name, object? content)
		{
			ValidationUtils.ArgumentNotNull(name, "name");
			_name = name;
			Value = (IsMultiContent(content) ? new JArray(content) : JContainer.CreateFromContent(content));
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WritePropertyName(_name);
			JToken value = Value;
			if (value != null)
			{
				value.WriteTo(writer, converters);
			}
			else
			{
				writer.WriteNull();
			}
		}

		internal override int GetDeepHashCode()
		{
			return _name.GetHashCode() ^ (Value?.GetDeepHashCode() ?? 0);
		}

		public new static JProperty Load(JsonReader reader)
		{
			return Load(reader, null);
		}

		public new static JProperty Load(JsonReader reader, JsonLoadSettings? settings)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader.");
			}
			reader.MoveToContent();
			if (reader.TokenType != JsonToken.PropertyName)
			{
				throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader. Current JsonReader item is not a property: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JProperty jProperty = new JProperty((string)reader.Value);
			jProperty.SetLineInfo(reader as IJsonLineInfo, settings);
			jProperty.ReadTokenFrom(reader, settings);
			return jProperty;
		}
	}
	internal class JPropertyDescriptor : PropertyDescriptor
	{
		public override Type ComponentType => typeof(JObject);

		public override bool IsReadOnly => false;

		public override Type PropertyType => typeof(object);

		protected override int NameHashCode => base.NameHashCode;

		public JPropertyDescriptor(string name)
			: base(name, null)
		{
		}

		private static JObject CastInstance(object instance)
		{
			return (JObject)instance;
		}

		public override bool CanResetValue(object component)
		{
			return false;
		}

		public override object? GetValue(object component)
		{
			return (component as JObject)?[Name];
		}

		public override void ResetValue(object component)
		{
		}

		public override void SetValue(object component, object value)
		{
			if (component is JObject jObject)
			{
				JToken value2 = (value as JToken) ?? new JValue(value);
				jObject[Name] = value2;
			}
		}

		public override bool ShouldSerializeValue(object component)
		{
			return false;
		}
	}
	internal class JPropertyKeyedCollection : Collection<JToken>
	{
		private static readonly IEqualityComparer<string> Comparer = StringComparer.Ordinal;

		private Dictionary<string, JToken>? _dictionary;

		public JToken this[string key]
		{
			get
			{
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				if (_dictionary != null)
				{
					return _dictionary[key];
				}
				throw new KeyNotFoundException();
			}
		}

		public ICollection<string> Keys
		{
			get
			{
				EnsureDictionary();
				return _dictionary.Keys;
			}
		}

		public ICollection<JToken> Values
		{
			get
			{
				EnsureDictionary();
				return _dictionary.Values;
			}
		}

		public JPropertyKeyedCollection()
			: base((IList<JToken>)new List<JToken>())
		{
		}

		private void AddKey(string key, JToken item)
		{
			EnsureDictionary();
			_dictionary[key] = item;
		}

		protected void ChangeItemKey(JToken item, string newKey)
		{
			if (!ContainsItem(item))
			{
				throw new ArgumentException("The specified item does not exist in this KeyedCollection.");
			}
			string keyForItem = GetKeyForItem(item);
			if (!Comparer.Equals(keyForItem, newKey))
			{
				if (newKey != null)
				{
					AddKey(newKey, item);
				}
				if (keyForItem != null)
				{
					RemoveKey(keyForItem);
				}
			}
		}

		protected override void ClearItems()
		{
			base.ClearItems();
			_dictionary?.Clear();
		}

		public bool Contains(string key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (_dictionary != null)
			{
				return _dictionary.ContainsKey(key);
			}
			return false;
		}

		private bool ContainsItem(JToken item)
		{
			if (_dictionary == null)
			{
				return false;
			}
			string keyForItem = GetKeyForItem(item);
			JToken value;
			return _dictionary.TryGetValue(keyForItem, out value);
		}

		private void EnsureDictionary()
		{
			if (_dictionary == null)
			{
				_dictionary = new Dictionary<string, JToken>(Comparer);
			}
		}

		private string GetKeyForItem(JToken item)
		{
			return ((JProperty)item).Name;
		}

		protected override void InsertItem(int index, JToken item)
		{
			AddKey(GetKeyForItem(item), item);
			base.InsertItem(index, item);
		}

		public bool Remove(string key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (_dictionary != null)
			{
				if (_dictionary.TryGetValue(key, out var value))
				{
					return Remove(value);
				}
				return false;
			}
			return false;
		}

		protected override void RemoveItem(int index)
		{
			string keyForItem = GetKeyForItem(base.Items[index]);
			RemoveKey(keyForItem);
			base.RemoveItem(index);
		}

		private void RemoveKey(string key)
		{
			_dictionary?.Remove(key);
		}

		protected override void SetItem(int index, JToken item)
		{
			string keyForItem = GetKeyForItem(item);
			string keyForItem2 = GetKeyForItem(base.Items[index]);
			if (Comparer.Equals(keyForItem2, keyForItem))
			{
				if (_dictionary != null)
				{
					_dictionary[keyForItem] = item;
				}
			}
			else
			{
				AddKey(keyForItem, item);
				if (keyForItem2 != null)
				{
					RemoveKey(keyForItem2);
				}
			}
			base.SetItem(index, item);
		}

		public bool TryGetValue(string key, [NotNullWhen(true)] out JToken? value)
		{
			if (_dictionary == null)
			{
				value = null;
				return false;
			}
			return _dictionary.TryGetValue(key, out value);
		}

		public int IndexOfReference(JToken t)
		{
			return ((List<JToken>)base.Items).IndexOfReference(t);
		}

		public bool Compare(JPropertyKeyedCollection other)
		{
			if (this == other)
			{
				return true;
			}
			Dictionary<string, JToken> dictionary = _dictionary;
			Dictionary<string, JToken> dictionary2 = other._dictionary;
			if (dictionary == null && dictionary2 == null)
			{
				return true;
			}
			if (dictionary == null)
			{
				return dictionary2.Count == 0;
			}
			if (dictionary2 == null)
			{
				return dictionary.Count == 0;
			}
			if (dictionary.Count != dictionary2.Count)
			{
				return false;
			}
			foreach (KeyValuePair<string, JToken> item in dictionary)
			{
				if (!dictionary2.TryGetValue(item.Key, out var value))
				{
					return false;
				}
				JProperty jProperty = (JProperty)item.Value;
				JProperty jProperty2 = (JProperty)value;
				if (jProperty.Value == null)
				{
					return jProperty2.Value == null;
				}
				if (!jProperty.Value.DeepEquals(jProperty2.Value))
				{
					return false;
				}
			}
			return true;
		}
	}
	internal class JRaw : JValue
	{
		public static async Task<JRaw> CreateAsync(JsonReader reader, CancellationToken cancellationToken = default(CancellationToken))
		{
			using StringWriter sw = new StringWriter(CultureInfo.InvariantCulture);
			using JsonTextWriter jsonWriter = new JsonTextWriter(sw);
			await jsonWriter.WriteTokenSyncReadingAsync(reader, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return new JRaw(sw.ToString());
		}

		public JRaw(JRaw other)
			: base(other)
		{
		}

		public JRaw(object? rawJson)
			: base(rawJson, JTokenType.Raw)
		{
		}

		public static JRaw Create(JsonReader reader)
		{
			using StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			using JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter);
			jsonTextWriter.WriteToken(reader);
			return new JRaw(stringWriter.ToString());
		}

		internal override JToken CloneToken()
		{
			return new JRaw(this);
		}
	}
	internal class JsonLoadSettings
	{
		private CommentHandling _commentHandling;

		private LineInfoHandling _lineInfoHandling;

		private DuplicatePropertyNameHandling _duplicatePropertyNameHandling;

		public CommentHandling CommentHandling
		{
			get
			{
				return _commentHandling;
			}
			set
			{
				if (value < CommentHandling.Ignore || value > CommentHandling.Load)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_commentHandling = value;
			}
		}

		public LineInfoHandling LineInfoHandling
		{
			get
			{
				return _lineInfoHandling;
			}
			set
			{
				if (value < LineInfoHandling.Ignore || value > LineInfoHandling.Load)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_lineInfoHandling = value;
			}
		}

		public DuplicatePropertyNameHandling DuplicatePropertyNameHandling
		{
			get
			{
				return _duplicatePropertyNameHandling;
			}
			set
			{
				if (value < DuplicatePropertyNameHandling.Replace || value > DuplicatePropertyNameHandling.Error)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_duplicatePropertyNameHandling = value;
			}
		}

		public JsonLoadSettings()
		{
			_lineInfoHandling = LineInfoHandling.Load;
			_commentHandling = CommentHandling.Ignore;
			_duplicatePropertyNameHandling = DuplicatePropertyNameHandling.Replace;
		}
	}
	internal class JsonMergeSettings
	{
		private MergeArrayHandling _mergeArrayHandling;

		private MergeNullValueHandling _mergeNullValueHandling;

		private StringComparison _propertyNameComparison;

		public MergeArrayHandling MergeArrayHandling
		{
			get
			{
				return _mergeArrayHandling;
			}
			set
			{
				if (value < MergeArrayHandling.Concat || value > MergeArrayHandling.Merge)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_mergeArrayHandling = value;
			}
		}

		public MergeNullValueHandling MergeNullValueHandling
		{
			get
			{
				return _mergeNullValueHandling;
			}
			set
			{
				if (value < MergeNullValueHandling.Ignore || value > MergeNullValueHandling.Merge)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_mergeNullValueHandling = value;
			}
		}

		public StringComparison PropertyNameComparison
		{
			get
			{
				return _propertyNameComparison;
			}
			set
			{
				if (value < StringComparison.CurrentCulture || value > StringComparison.OrdinalIgnoreCase)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_propertyNameComparison = value;
			}
		}

		public JsonMergeSettings()
		{
			_propertyNameComparison = StringComparison.Ordinal;
		}
	}
	internal class JsonSelectSettings
	{
		public TimeSpan? RegexMatchTimeout { get; set; }

		public bool ErrorWhenNoMatch { get; set; }
	}
	internal abstract class JToken : IJEnumerable<JToken>, IEnumerable<JToken>, IEnumerable, IJsonLineInfo, ICloneable, IDynamicMetaObjectProvider
	{
		private class LineInfoAnnotation
		{
			internal readonly int LineNumber;

			internal readonly int LinePosition;

			public LineInfoAnnotation(int lineNumber, int linePosition)
			{
				LineNumber = lineNumber;
				LinePosition = linePosition;
			}
		}

		private static JTokenEqualityComparer? _equalityComparer;

		private JContainer? _parent;

		private JToken? _previous;

		private JToken? _next;

		private object? _annotations;

		private static readonly JTokenType[] BooleanTypes = new JTokenType[6]
		{
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Boolean
		};

		private static readonly JTokenType[] NumberTypes = new JTokenType[6]
		{
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Boolean
		};

		private static readonly JTokenType[] BigIntegerTypes = new JTokenType[7]
		{
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Boolean,
			JTokenType.Bytes
		};

		private static readonly JTokenType[] StringTypes = new JTokenType[11]
		{
			JTokenType.Date,
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Boolean,
			JTokenType.Bytes,
			JTokenType.Guid,
			JTokenType.TimeSpan,
			JTokenType.Uri
		};

		private static readonly JTokenType[] GuidTypes = new JTokenType[5]
		{
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Guid,
			JTokenType.Bytes
		};

		private static readonly JTokenType[] TimeSpanTypes = new JTokenType[4]
		{
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.TimeSpan
		};

		private static readonly JTokenType[] UriTypes = new JTokenType[4]
		{
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Uri
		};

		private static readonly JTokenType[] CharTypes = new JTokenType[5]
		{
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw
		};

		private static readonly JTokenType[] DateTimeTypes = new JTokenType[4]
		{
			JTokenType.Date,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw
		};

		private static readonly JTokenType[] BytesTypes = new JTokenType[5]
		{
			JTokenType.Bytes,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Integer
		};

		public static JTokenEqualityComparer EqualityComparer
		{
			get
			{
				if (_equalityComparer == null)
				{
					_equalityComparer = new JTokenEqualityComparer();
				}
				return _equalityComparer;
			}
		}

		public JContainer? Parent
		{
			[DebuggerStepThrough]
			get
			{
				return _parent;
			}
			internal set
			{
				_parent = value;
			}
		}

		public JToken Root
		{
			get
			{
				JContainer parent = Parent;
				if (parent == null)
				{
					return this;
				}
				while (parent.Parent != null)
				{
					parent = parent.Parent;
				}
				return parent;
			}
		}

		public abstract JTokenType Type { get; }

		public abstract bool HasValues { get; }

		public JToken? Next
		{
			get
			{
				return _next;
			}
			internal set
			{
				_next = value;
			}
		}

		public JToken? Previous
		{
			get
			{
				return _previous;
			}
			internal set
			{
				_previous = value;
			}
		}

		public string Path
		{
			get
			{
				if (Parent == null)
				{
					return string.Empty;
				}
				List<JsonPosition> list = new List<JsonPosition>();
				JToken jToken = null;
				for (JToken jToken2 = this; jToken2 != null; jToken2 = jToken2.Parent)
				{
					switch (jToken2.Type)
					{
					case JTokenType.Property:
					{
						JProperty jProperty = (JProperty)jToken2;
						list.Add(new JsonPosition(JsonContainerType.Object)
						{
							PropertyName = jProperty.Name
						});
						break;
					}
					case JTokenType.Array:
					case JTokenType.Constructor:
						if (jToken != null)
						{
							int position = ((IList<JToken>)jToken2).IndexOf(jToken);
							list.Add(new JsonPosition(JsonContainerType.Array)
							{
								Position = position
							});
						}
						break;
					}
					jToken = jToken2;
				}
				list.FastReverse();
				return JsonPosition.BuildPath(list, null);
			}
		}

		public virtual JToken? this[object key]
		{
			get
			{
				throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
			set
			{
				throw new InvalidOperationException("Cannot set child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		public virtual JToken? First
		{
			get
			{
				throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		public virtual JToken? Last
		{
			get
			{
				throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		IJEnumerable<JToken> IJEnumerable<JToken>.this[object key] => this[key];

		int IJsonLineInfo.LineNumber => Annotation<LineInfoAnnotation>()?.LineNumber ?? 0;

		int IJsonLineInfo.LinePosition => Annotation<LineInfoAnnotation>()?.LinePosition ?? 0;

		public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, params JsonConverter[] converters)
		{
			throw new NotImplementedException();
		}

		public Task WriteToAsync(JsonWriter writer, params JsonConverter[] converters)
		{
			return WriteToAsync(writer, default(CancellationToken), converters);
		}

		public static Task<JToken> ReadFromAsync(JsonReader reader, CancellationToken cancellationToken = default(CancellationToken))
		{
			return ReadFromAsync(reader, null, cancellationToken);
		}

		public static async Task<JToken> ReadFromAsync(JsonReader reader, JsonLoadSettings? settings, CancellationToken cancellationToken = default(CancellationToken))
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			if (reader.TokenType == JsonToken.None && !(await ((settings != null && settings.CommentHandling == CommentHandling.Ignore) ? reader.ReadAndMoveToContentAsync(cancellationToken) : reader.ReadAsync(cancellationToken)).ConfigureAwait(continueOnCapturedContext: false)))
			{
				throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader.");
			}
			IJsonLineInfo lineInfo = reader as IJsonLineInfo;
			switch (reader.TokenType)
			{
			case JsonToken.StartObject:
				return await JObject.LoadAsync(reader, settings, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			case JsonToken.StartArray:
				return await JArray.LoadAsync(reader, settings, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			case JsonToken.StartConstructor:
				return await JConstructor.LoadAsync(reader, settings, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			case JsonToken.PropertyName:
				return await JProperty.LoadAsync(reader, settings, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Date:
			case JsonToken.Bytes:
			{
				JValue jValue4 = new JValue(reader.Value);
				jValue4.SetLineInfo(lineInfo, settings);
				return jValue4;
			}
			case JsonToken.Comment:
			{
				JValue jValue3 = JValue.CreateComment(reader.Value?.ToString());
				jValue3.SetLineInfo(lineInfo, settings);
				return jValue3;
			}
			case JsonToken.Null:
			{
				JValue jValue2 = JValue.CreateNull();
				jValue2.SetLineInfo(lineInfo, settings);
				return jValue2;
			}
			case JsonToken.Undefined:
			{
				JValue jValue = JValue.CreateUndefined();
				jValue.SetLineInfo(lineInfo, settings);
				return jValue;
			}
			default:
				throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader. Unexpected token: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
		}

		public static Task<JToken> LoadAsync(JsonReader reader, CancellationToken cancellationToken = default(CancellationToken))
		{
			return LoadAsync(reader, null, cancellationToken);
		}

		public static Task<JToken> LoadAsync(JsonReader reader, JsonLoadSettings? settings, CancellationToken cancellationToken = default(CancellationToken))
		{
			return ReadFromAsync(reader, settings, cancellationToken);
		}

		internal abstract JToken CloneToken();

		internal abstract bool DeepEquals(JToken node);

		public static bool DeepEquals(JToken? t1, JToken? t2)
		{
			if (t1 != t2)
			{
				if (t1 != null && t2 != null)
				{
					return t1.DeepEquals(t2);
				}
				return false;
			}
			return true;
		}

		internal JToken()
		{
		}

		public void AddAfterSelf(object? content)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			int num = _parent.IndexOfItem(this);
			_parent.TryAddInternal(num + 1, content, skipParentCheck: false);
		}

		public void AddBeforeSelf(object? content)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			int index = _parent.IndexOfItem(this);
			_parent.TryAddInternal(index, content, skipParentCheck: false);
		}

		public IEnumerable<JToken> Ancestors()
		{
			return GetAncestors(self: false);
		}

		public IEnumerable<JToken> AncestorsAndSelf()
		{
			return GetAncestors(self: true);
		}

		internal IEnumerable<JToken> GetAncestors(bool self)
		{
			for (JToken current = (self ? this : Parent); current != null; current = current.Parent)
			{
				yield return current;
			}
		}

		public IEnumerable<JToken> AfterSelf()
		{
			if (Parent != null)
			{
				for (JToken o = Next; o != null; o = o.Next)
				{
					yield return o;
				}
			}
		}

		public IEnumerable<JToken> BeforeSelf()
		{
			if (Parent != null)
			{
				JToken o = Parent.First;
				while (o != this && o != null)
				{
					yield return o;
					o = o.Next;
				}
			}
		}

		public virtual T? Value<T>(object key)
		{
			JToken jToken = this[key];
			if (jToken != null)
			{
				return jToken.Convert<JToken, T>();
			}
			return default(T);
		}

		public virtual JEnumerable<JToken> Children()
		{
			return JEnumerable<JToken>.Empty;
		}

		public JEnumerable<T> Children<T>() where T : JToken
		{
			return new JEnumerable<T>(Children().OfType<T>());
		}

		public virtual IEnumerable<T?> Values<T>()
		{
			throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
		}

		public void Remove()
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			_parent.RemoveItem(this);
		}

		public void Replace(JToken value)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			_parent.ReplaceItem(this, value);
		}

		public abstract void WriteTo(JsonWriter writer, params JsonConverter[] converters);

		public override string ToString()
		{
			return ToString(Formatting.Indented);
		}

		public string ToString(Formatting formatting, params JsonConverter[] converters)
		{
			using StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter);
			jsonTextWriter.Formatting = formatting;
			WriteTo(jsonTextWriter, converters);
			return stringWriter.ToString();
		}

		private static JValue? EnsureValue(JToken value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (value is JProperty jProperty)
			{
				value = jProperty.Value;
			}
			return value as JValue;
		}

		private static string GetType(JToken token)
		{
			ValidationUtils.ArgumentNotNull(token, "token");
			if (token is JProperty jProperty)
			{
				token = jProperty.Value;
			}
			return token.Type.ToString();
		}

		private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable)
		{
			if (Array.IndexOf(validTypes, o.Type) == -1)
			{
				if (nullable)
				{
					if (o.Type != JTokenType.Null)
					{
						return o.Type == JTokenType.Undefined;
					}
					return true;
				}
				return false;
			}
			return true;
		}

		public static explicit operator bool(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, BooleanTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return Convert.ToBoolean((int)bigInteger);
			}
			return Convert.ToBoolean(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator DateTimeOffset(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to DateTimeOffset.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			object value2 = jValue.Value;
			if (value2 is DateTimeOffset)
			{
				return (DateTimeOffset)value2;
			}
			if (jValue.Value is string input)
			{
				return DateTimeOffset.Parse(input, CultureInfo.InvariantCulture);
			}
			return new DateTimeOffset(Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator bool?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, BooleanTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return Convert.ToBoolean((int)bigInteger);
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToBoolean(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator long(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Int64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (long)bigInteger;
			}
			return Convert.ToInt64(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator DateTime?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is DateTimeOffset dateTimeOffset)
			{
				return dateTimeOffset.DateTime;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator DateTimeOffset?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to DateTimeOffset.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			object value2 = jValue.Value;
			if (value2 is DateTimeOffset)
			{
				return (DateTimeOffset)value2;
			}
			if (jValue.Value is string input)
			{
				return DateTimeOffset.Parse(input, CultureInfo.InvariantCulture);
			}
			return new DateTimeOffset(Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator decimal?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (decimal)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToDecimal(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator double?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Double.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (double)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToDouble(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator char?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, CharTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Char.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (char)(ushort)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToChar(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator int(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Int32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (int)bigInteger;
			}
			return Convert.ToInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator short(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Int16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (short)bigInteger;
			}
			return Convert.ToInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator ushort(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (ushort)bigInteger;
			}
			return Convert.ToUInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator char(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, CharTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Char.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (char)(ushort)bigInteger;
			}
			return Convert.ToChar(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator byte(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Byte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (byte)bigInteger;
			}
			return Convert.ToByte(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator sbyte(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to SByte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (sbyte)bigInteger;
			}
			return Convert.ToSByte(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator int?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Int32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (int)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator short?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Int16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (short)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator ushort?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (ushort)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToUInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator byte?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Byte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (byte)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToByte(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator sbyte?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to SByte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (sbyte)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToSByte(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator DateTime(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is DateTimeOffset dateTimeOffset)
			{
				return dateTimeOffset.DateTime;
			}
			return Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator long?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Int64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (long)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToInt64(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator float?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Single.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (float)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToSingle(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator decimal(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (decimal)bigInteger;
			}
			return Convert.ToDecimal(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator uint?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (uint)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToUInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator ulong?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (ulong)bigInteger;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToUInt64(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator double(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Double.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (double)bigInteger;
			}
			return Convert.ToDouble(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator float(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Single.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (float)bigInteger;
			}
			return Convert.ToSingle(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator string?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, StringTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to String.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			if (jValue.Value is byte[] inArray)
			{
				return Convert.ToBase64String(inArray);
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return bigInteger.ToString(CultureInfo.InvariantCulture);
			}
			return Convert.ToString(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator uint(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (uint)bigInteger;
			}
			return Convert.ToUInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator ulong(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return (ulong)bigInteger;
			}
			return Convert.ToUInt64(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator byte[]?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, BytesTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to byte array.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is string)
			{
				return Convert.FromBase64String(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
			}
			if (jValue.Value is BigInteger bigInteger)
			{
				return bigInteger.ToByteArray();
			}
			if (jValue.Value is byte[] result)
			{
				return result;
			}
			throw new ArgumentException("Can not convert {0} to byte array.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}

		public static explicit operator Guid(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, GuidTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Guid.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is byte[] b)
			{
				return new Guid(b);
			}
			object value2 = jValue.Value;
			if (value2 is Guid)
			{
				return (Guid)value2;
			}
			return new Guid(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator Guid?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, GuidTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Guid.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			if (jValue.Value is byte[] b)
			{
				return new Guid(b);
			}
			return (jValue.Value is Guid guid) ? guid : new Guid(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator TimeSpan(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, TimeSpanTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			object value2 = jValue.Value;
			if (value2 is TimeSpan)
			{
				return (TimeSpan)value2;
			}
			return ConvertUtils.ParseTimeSpan(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator TimeSpan?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, TimeSpanTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return (jValue.Value is TimeSpan timeSpan) ? timeSpan : ConvertUtils.ParseTimeSpan(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator Uri?(JToken? value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, UriTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Uri.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			if (!(jValue.Value is Uri result))
			{
				return new Uri(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
			}
			return result;
		}

		private static BigInteger ToBigInteger(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, BigIntegerTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to BigInteger.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return ConvertUtils.ToBigInteger(jValue.Value);
		}

		private static BigInteger? ToBigIntegerNullable(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, BigIntegerTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to BigInteger.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return ConvertUtils.ToBigInteger(jValue.Value);
		}

		public static implicit operator JToken(bool value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTimeOffset value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(byte value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(byte? value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(sbyte value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(sbyte? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(bool? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(long value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTime? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTimeOffset? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(decimal? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(double? value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(short value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(ushort value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(int value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(int? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTime value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(long? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(float? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(decimal value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(short? value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(ushort? value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(uint? value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(ulong? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(double value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(float value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(string? value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(uint value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(ulong value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(byte[] value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(Uri? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(TimeSpan value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(TimeSpan? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(Guid value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(Guid? value)
		{
			return new JValue(value);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<JToken>)this).GetEnumerator();
		}

		IEnumerator<JToken> IEnumerable<JToken>.GetEnumerator()
		{
			return Children().GetEnumerator();
		}

		internal abstract int GetDeepHashCode();

		public JsonReader CreateReader()
		{
			return new JTokenReader(this);
		}

		internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer)
		{
			ValidationUtils.ArgumentNotNull(o, "o");
			ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");
			using JTokenWriter jTokenWriter = new JTokenWriter();
			jsonSerializer.Serialize(jTokenWriter, o);
			return jTokenWriter.Token;
		}

		public static JToken FromObject(object o)
		{
			return FromObjectInternal(o, JsonSerializer.CreateDefault());
		}

		public static JToken FromObject(object o, JsonSerializer jsonSerializer)
		{
			return FromObjectInternal(o, jsonSerializer);
		}

		public T? ToObject<T>()
		{
			return (T)ToObject(typeof(T));
		}

		public object? ToObject(Type objectType)
		{
			if (JsonConvert.DefaultSettings == null)
			{
				bool isEnum;
				PrimitiveTypeCode typeCode = ConvertUtils.GetTypeCode(objectType, out isEnum);
				if (isEnum)
				{
					if (Type == JTokenType.String)
					{
						try
						{
							return ToObject(objectType, JsonSerializer.CreateDefault());
						}
						catch (Exception innerException)
						{
							Type type = (objectType.IsEnum() ? objectType : Nullable.GetUnderlyingType(objectType));
							throw new ArgumentException("Could not convert '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, (string?)this, type.Name), innerException);
						}
					}
					if (Type == JTokenType.Integer)
					{
						return Enum.ToObject(objectType.IsEnum() ? objectType : Nullable.GetUnderlyingType(objectType), ((JValue)this).Value);
					}
				}
				switch (typeCode)
				{
				case PrimitiveTypeCode.BooleanNullable:
					return (bool?)this;
				case PrimitiveTypeCode.Boolean:
					return (bool)this;
				case PrimitiveTypeCode.CharNullable:
					return (char?)this;
				case PrimitiveTypeCode.Char:
					return (char)this;
				case PrimitiveTypeCode.SByte:
					return (sbyte)this;
				case PrimitiveTypeCode.SByteNullable:
					return (sbyte?)this;
				case PrimitiveTypeCode.ByteNullable:
					return (byte?)this;
				case PrimitiveTypeCode.Byte:
					return (byte)this;
				case PrimitiveTypeCode.Int16Nullable:
					return (short?)this;
				case PrimitiveTypeCode.Int16:
					return (short)this;
				case PrimitiveTypeCode.UInt16Nullable:
					return (ushort?)this;
				case PrimitiveTypeCode.UInt16:
					return (ushort)this;
				case PrimitiveTypeCode.Int32Nullable:
					return (int?)this;
				case PrimitiveTypeCode.Int32:
					return (int)this;
				case PrimitiveTypeCode.UInt32Nullable:
					return (uint?)this;
				case PrimitiveTypeCode.UInt32:
					return (uint)this;
				case PrimitiveTypeCode.Int64Nullable:
					return (long?)this;
				case PrimitiveTypeCode.Int64:
					return (long)this;
				case PrimitiveTypeCode.UInt64Nullable:
					return (ulong?)this;
				case PrimitiveTypeCode.UInt64:
					return (ulong)this;
				case PrimitiveTypeCode.SingleNullable:
					return (float?)this;
				case PrimitiveTypeCode.Single:
					return (float)this;
				case PrimitiveTypeCode.DoubleNullable:
					return (double?)this;
				case PrimitiveTypeCode.Double:
					return (double)this;
				case PrimitiveTypeCode.DecimalNullable:
					return (decimal?)this;
				case PrimitiveTypeCode.Decimal:
					return (decimal)this;
				case PrimitiveTypeCode.DateTimeNullable:
					return (DateTime?)this;
				case PrimitiveTypeCode.DateTime:
					return (DateTime)this;
				case PrimitiveTypeCode.DateTimeOffsetNullable:
					return (DateTimeOffset?)this;
				case PrimitiveTypeCode.DateTimeOffset:
					return (DateTimeOffset)this;
				case PrimitiveTypeCode.String:
					return (string?)this;
				case PrimitiveTypeCode.GuidNullable:
					return (Guid?)this;
				case PrimitiveTypeCode.Guid:
					return (Guid)this;
				case PrimitiveTypeCode.Uri:
					return (Uri?)this;
				case PrimitiveTypeCode.TimeSpanNullable:
					return (TimeSpan?)this;
				case PrimitiveTypeCode.TimeSpan:
					return (TimeSpan)this;
				case PrimitiveTypeCode.BigIntegerNullable:
					return ToBigIntegerNullable(this);
				case PrimitiveTypeCode.BigInteger:
					return ToBigInteger(this);
				}
			}
			return ToObject(objectType, JsonSerializer.CreateDefault());
		}

		public T? ToObject<T>(JsonSerializer jsonSerializer)
		{
			return (T)ToObject(typeof(T), jsonSerializer);
		}

		public object? ToObject(Type objectType, JsonSerializer jsonSerializer)
		{
			ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");
			using JTokenReader reader = new JTokenReader(this);
			return jsonSerializer.Deserialize(reader, objectType);
		}

		public static JToken ReadFrom(JsonReader reader)
		{
			return ReadFrom(reader, null);
		}

		public static JToken ReadFrom(JsonReader reader, JsonLoadSettings? settings)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			if (!((reader.TokenType == JsonToken.None) ? ((settings != null && settings.CommentHandling == CommentHandling.Ignore) ? reader.ReadAndMoveToContent() : reader.Read()) : (reader.TokenType != JsonToken.Comment || settings == null || settings.CommentHandling != CommentHandling.Ignore || reader.ReadAndMoveToContent())))
			{
				throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader.");
			}
			IJsonLineInfo lineInfo = reader as IJsonLineInfo;
			switch (reader.TokenType)
			{
			case JsonToken.StartObject:
				return JObject.Load(reader, settings);
			case JsonToken.StartArray:
				return JArray.Load(reader, settings);
			case JsonToken.StartConstructor:
				return JConstructor.Load(reader, settings);
			case JsonToken.PropertyName:
				return JProperty.Load(reader, settings);
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Date:
			case JsonToken.Bytes:
			{
				JValue jValue4 = new JValue(reader.Value);
				jValue4.SetLineInfo(lineInfo, settings);
				return jValue4;
			}
			case JsonToken.Comment:
			{
				JValue jValue3 = JValue.CreateComment(reader.Value.ToString());
				jValue3.SetLineInfo(lineInfo, settings);
				return jValue3;
			}
			case JsonToken.Null:
			{
				JValue jValue2 = JValue.CreateNull();
				jValue2.SetLineInfo(lineInfo, settings);
				return jValue2;
			}
			case JsonToken.Undefined:
			{
				JValue jValue = JValue.CreateUndefined();
				jValue.SetLineInfo(lineInfo, settings);
				return jValue;
			}
			default:
				throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader. Unexpected token: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
		}

		public static JToken Parse(string json)
		{
			return Parse(json, null);
		}

		public static JToken Parse(string json, JsonLoadSettings? settings)
		{
			using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
			JToken result = Load(jsonReader, settings);
			while (jsonReader.Read())
			{
			}
			return result;
		}

		public static JToken Load(JsonReader reader, JsonLoadSettings? settings)
		{
			return ReadFrom(reader, settings);
		}

		public static JToken Load(JsonReader reader)
		{
			return Load(reader, null);
		}

		internal void SetLineInfo(IJsonLineInfo? lineInfo, JsonLoadSettings? settings)
		{
			if ((settings == null || settings.LineInfoHandling == LineInfoHandling.Load) && lineInfo != null && lineInfo.HasLineInfo())
			{
				SetLineInfo(lineInfo.LineNumber, lineInfo.LinePosition);
			}
		}

		internal void SetLineInfo(int lineNumber, int linePosition)
		{
			AddAnnotation(new LineInfoAnnotation(lineNumber, linePosition));
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			return Annotation<LineInfoAnnotation>() != null;
		}

		public JToken? SelectToken(string path)
		{
			return SelectToken(path, null);
		}

		public JToken? SelectToken(string path, bool errorWhenNoMatch)
		{
			JsonSelectSettings settings = (errorWhenNoMatch ? new JsonSelectSettings
			{
				ErrorWhenNoMatch = true
			} : null);
			return SelectToken(path, settings);
		}

		public JToken? SelectToken(string path, JsonSelectSettings? settings)
		{
			JPath jPath = new JPath(path);
			JToken jToken = null;
			foreach (JToken item in jPath.Evaluate(this, this, settings))
			{
				if (jToken != null)
				{
					throw new JsonException("Path returned multiple tokens.");
				}
				jToken = item;
			}
			return jToken;
		}

		public IEnumerable<JToken> SelectTokens(string path)
		{
			return SelectTokens(path, null);
		}

		public IEnumerable<JToken> SelectTokens(string path, bool errorWhenNoMatch)
		{
			JsonSelectSettings settings = (errorWhenNoMatch ? new JsonSelectSettings
			{
				ErrorWhenNoMatch = true
			} : null);
			return SelectTokens(path, settings);
		}

		public IEnumerable<JToken> SelectTokens(string path, JsonSelectSettings? settings)
		{
			return new JPath(path).Evaluate(this, this, settings);
		}

		protected virtual DynamicMetaObject GetMetaObject(Expression parameter)
		{
			return new DynamicProxyMetaObject<JToken>(parameter, this, new DynamicProxy<JToken>());
		}

		DynamicMetaObject IDynamicMetaObjectProvider.GetMetaObject(Expression parameter)
		{
			return GetMetaObject(parameter);
		}

		object ICloneable.Clone()
		{
			return DeepClone();
		}

		public JToken DeepClone()
		{
			return CloneToken();
		}

		public void AddAnnotation(object annotation)
		{
			if (annotation == null)
			{
				throw new ArgumentNullException("annotation");
			}
			if (_annotations == null)
			{
				_annotations = ((!(annotation is object[])) ? annotation : new object[1] { annotation });
				return;
			}
			object[] array = _annotations as object[];
			if (array == null)
			{
				_annotations = new object[2] { _annotations, annotation };
				return;
			}
			int i;
			for (i = 0; i < array.Length && array[i] != null; i++)
			{
			}
			if (i == array.Length)
			{
				Array.Resize(ref array, i * 2);
				_annotations = array;
			}
			array[i] = annotation;
		}

		public T? Annotation<T>() where T : class
		{
			if (_annotations != null)
			{
				if (!(_annotations is object[] array))
				{
					return _annotations as T;
				}
				foreach (object obj in array)
				{
					if (obj == null)
					{
						break;
					}
					if (obj is T result)
					{
						return result;
					}
				}
			}
			return null;
		}

		public object? Annotation(Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (_annotations != null)
			{
				if (!(_annotations is object[] array))
				{
					if (type.IsInstanceOfType(_annotations))
					{
						return _annotations;
					}
				}
				else
				{
					foreach (object obj in array)
					{
						if (obj == null)
						{
							break;
						}
						if (type.IsInstanceOfType(obj))
						{
							return obj;
						}
					}
				}
			}
			return null;
		}

		public IEnumerable<T> Annotations<T>() where T : class
		{
			if (_annotations == null)
			{
				yield break;
			}
			object annotations = _annotations;
			if (annotations is object[] annotations2)
			{
				foreach (object obj in annotations2)
				{
					if (obj != null)
					{
						if (obj is T val)
						{
							yield return val;
						}
						continue;
					}
					break;
				}
			}
			else if (_annotations is T val2)
			{
				yield return val2;
			}
		}

		public IEnumerable<object> Annotations(Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (_annotations == null)
			{
				yield break;
			}
			object annotations = _annotations;
			if (annotations is object[] annotations2)
			{
				foreach (object obj in annotations2)
				{
					if (obj != null)
					{
						if (type.IsInstanceOfType(obj))
						{
							yield return obj;
						}
						continue;
					}
					break;
				}
			}
			else if (type.IsInstanceOfType(_annotations))
			{
				yield return _annotations;
			}
		}

		public void RemoveAnnotations<T>() where T : class
		{
			if (_annotations == null)
			{
				return;
			}
			if (!(_annotations is object[] array))
			{
				if (_annotations is T)
				{
					_annotations = null;
				}
				return;
			}
			int i = 0;
			int num = 0;
			for (; i < array.Length; i++)
			{
				object obj = array[i];
				if (obj == null)
				{
					break;
				}
				if (!(obj is T))
				{
					array[num++] = obj;
				}
			}
			if (num != 0)
			{
				while (num < i)
				{
					array[num++] = null;
				}
			}
			else
			{
				_annotations = null;
			}
		}

		public void RemoveAnnotations(Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (_annotations == null)
			{
				return;
			}
			if (!(_annotations is object[] array))
			{
				if (type.IsInstanceOfType(_annotations))
				{
					_annotations = null;
				}
				return;
			}
			int i = 0;
			int num = 0;
			for (; i < array.Length; i++)
			{
				object obj = array[i];
				if (obj == null)
				{
					break;
				}
				if (!type.IsInstanceOfType(obj))
				{
					array[num++] = obj;
				}
			}
			if (num != 0)
			{
				while (num < i)
				{
					array[num++] = null;
				}
			}
			else
			{
				_annotations = null;
			}
		}

		internal void CopyAnnotations(JToken target, JToken source)
		{
			if (source._annotations is object[] source2)
			{
				target._annotations = source2.ToArray();
			}
			else
			{
				target._annotations = source._annotations;
			}
		}
	}
	internal class JTokenEqualityComparer : IEqualityComparer<JToken>
	{
		public bool Equals(JToken x, JToken y)
		{
			return JToken.DeepEquals(x, y);
		}

		public int GetHashCode(JToken obj)
		{
			return obj?.GetDeepHashCode() ?? 0;
		}
	}
	internal class JTokenReader : JsonReader, IJsonLineInfo
	{
		private readonly JToken _root;

		private string? _initialPath;

		private JToken? _parent;

		private JToken? _current;

		public JToken? CurrentToken => _current;

		int IJsonLineInfo.LineNumber
		{
			get
			{
				if (base.CurrentState == State.Start)
				{
					return 0;
				}
				return ((IJsonLineInfo)_current)?.LineNumber ?? 0;
			}
		}

		int IJsonLineInfo.LinePosition
		{
			get
			{
				if (base.CurrentState == State.Start)
				{
					return 0;
				}
				return ((IJsonLineInfo)_current)?.LinePosition ?? 0;
			}
		}

		public override string Path
		{
			get
			{
				string text = base.Path;
				if (_initialPath == null)
				{
					_initialPath = _root.Path;
				}
				if (!StringUtils.IsNullOrEmpty(_initialPath))
				{
					if (StringUtils.IsNullOrEmpty(text))
					{
						return _initialPath;
					}
					text = ((!StringUtils.StartsWith(text, '[')) ? (_initialPath + "." + text) : (_initialPath + text));
				}
				return text;
			}
		}

		public JTokenReader(JToken token)
		{
			ValidationUtils.ArgumentNotNull(token, "token");
			_root = token;
		}

		public JTokenReader(JToken token, string initialPath)
			: this(token)
		{
			_initialPath = initialPath;
		}

		public override bool Read()
		{
			if (base.CurrentState != State.Start)
			{
				if (_current == null)
				{
					return false;
				}
				if (_current is JContainer jContainer && _parent != jContainer)
				{
					return ReadInto(jContainer);
				}
				return ReadOver(_current);
			}
			if (_current == _root)
			{
				return false;
			}
			_current = _root;
			SetToken(_current);
			return true;
		}

		private bool ReadOver(JToken t)
		{
			if (t == _root)
			{
				return ReadToEnd();
			}
			JToken next = t.Next;
			if (next == null || next == t || t == t.Parent.Last)
			{
				if (t.Parent == null)
				{
					return ReadToEnd();
				}
				return SetEnd(t.Parent);
			}
			_current = next;
			SetToken(_current);
			return true;
		}

		private bool ReadToEnd()
		{
			_current = null;
			SetToken(JsonToken.None);
			return false;
		}

		private JsonToken? GetEndToken(JContainer c)
		{
			return c.Type switch
			{
				JTokenType.Object => JsonToken.EndObject, 
				JTokenType.Array => JsonToken.EndArray, 
				JTokenType.Constructor => JsonToken.EndConstructor, 
				JTokenType.Property => null, 
				_ => throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", c.Type, "Unexpected JContainer type."), 
			};
		}

		private bool ReadInto(JContainer c)
		{
			JToken first = c.First;
			if (first == null)
			{
				return SetEnd(c);
			}
			SetToken(first);
			_current = first;
			_parent = c;
			return true;
		}

		private bool SetEnd(JContainer c)
		{
			JsonToken? endToken = GetEndToken(c);
			if (endToken.HasValue)
			{
				SetToken(endToken.GetValueOrDefault());
				_current = c;
				_parent = c;
				return true;
			}
			return ReadOver(c);
		}

		private void SetToken(JToken token)
		{
			switch (token.Type)
			{
			case JTokenType.Object:
				SetToken(JsonToken.StartObject);
				break;
			case JTokenType.Array:
				SetToken(JsonToken.StartArray);
				break;
			case JTokenType.Constructor:
				SetToken(JsonToken.StartConstructor, ((JConstructor)token).Name);
				break;
			case JTokenType.Property:
				SetToken(JsonToken.PropertyName, ((JProperty)token).Name);
				break;
			case JTokenType.Comment:
				SetToken(JsonToken.Comment, ((JValue)token).Value);
				break;
			case JTokenType.Integer:
				SetToken(JsonToken.Integer, ((JValue)token).Value);
				break;
			case JTokenType.Float:
				SetToken(JsonToken.Float, ((JValue)token).Value);
				break;
			case JTokenType.String:
				SetToken(JsonToken.String, ((JValue)token).Value);
				break;
			case JTokenType.Boolean:
				SetToken(JsonToken.Boolean, ((JValue)token).Value);
				break;
			case JTokenType.Null:
				SetToken(JsonToken.Null, ((JValue)token).Value);
				break;
			case JTokenType.Undefined:
				SetToken(JsonToken.Undefined, ((JValue)token).Value);
				break;
			case JTokenType.Date:
			{
				object obj = ((JValue)token).Value;
				if (obj is DateTime value2)
				{
					obj = DateTimeUtils.EnsureDateTime(value2, base.DateTimeZoneHandling);
				}
				SetToken(JsonToken.Date, obj);
				break;
			}
			case JTokenType.Raw:
				SetToken(JsonToken.Raw, ((JValue)token).Value);
				break;
			case JTokenType.Bytes:
				SetToken(JsonToken.Bytes, ((JValue)token).Value);
				break;
			case JTokenType.Guid:
				SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
				break;
			case JTokenType.Uri:
			{
				object value = ((JValue)token).Value;
				SetToken(JsonToken.String, (value is Uri uri) ? uri.OriginalString : SafeToString(value));
				break;
			}
			case JTokenType.TimeSpan:
				SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
				break;
			default:
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", token.Type, "Unexpected JTokenType.");
			}
		}

		private string? SafeToString(object? value)
		{
			return value?.ToString();
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			if (base.CurrentState == State.Start)
			{
				return false;
			}
			return ((IJsonLineInfo)_current)?.HasLineInfo() ?? false;
		}
	}
	internal enum JTokenType
	{
		None,
		Object,
		Array,
		Constructor,
		Property,
		Comment,
		Integer,
		Float,
		String,
		Boolean,
		Null,
		Undefined,
		Date,
		Raw,
		Bytes,
		Guid,
		Uri,
		TimeSpan
	}
	internal class JTokenWriter : JsonWriter
	{
		private JContainer? _token;

		private JContainer? _parent;

		private JValue? _value;

		private JToken? _current;

		public JToken? CurrentToken => _current;

		public JToken? Token
		{
			get
			{
				if (_token != null)
				{
					return _token;
				}
				return _value;
			}
		}

		internal override Task WriteTokenAsync(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments, CancellationToken cancellationToken)
		{
			if (reader is JTokenReader)
			{
				WriteToken(reader, writeChildren, writeDateConstructorAsDate, writeComments);
				return AsyncUtils.CompletedTask;
			}
			return WriteTokenSyncReadingAsync(reader, cancellationToken);
		}

		public JTokenWriter(JContainer container)
		{
			ValidationUtils.ArgumentNotNull(container, "container");
			_token = container;
			_parent = container;
		}

		public JTokenWriter()
		{
		}

		public override void Flush()
		{
		}

		public override void Close()
		{
			base.Close();
		}

		public override void WriteStartObject()
		{
			base.WriteStartObject();
			AddParent(new JObject());
		}

		private void AddParent(JContainer container)
		{
			if (_parent == null)
			{
				_token = container;
			}
			else
			{
				_parent.AddAndSkipParentCheck(container);
			}
			_parent = container;
			_current = container;
		}

		private void RemoveParent()
		{
			_current = _parent;
			_parent = _parent.Parent;
			if (_parent != null && _parent.Type == JTokenType.Property)
			{
				_parent = _parent.Parent;
			}
		}

		public override void WriteStartArray()
		{
			base.WriteStartArray();
			AddParent(new JArray());
		}

		public override void WriteStartConstructor(string name)
		{
			base.WriteStartConstructor(name);
			AddParent(new JConstructor(name));
		}

		protected override void WriteEnd(JsonToken token)
		{
			RemoveParent();
		}

		public override void WritePropertyName(string name)
		{
			(_parent as JObject)?.Remove(name);
			AddParent(new JProperty(name));
			base.WritePropertyName(name);
		}

		private void AddValue(object? value, JsonToken token)
		{
			AddValue(new JValue(value), token);
		}

		internal void AddValue(JValue? value, JsonToken token)
		{
			if (_parent != null)
			{
				if (_parent.TryAdd(value))
				{
					_current = _parent.Last;
					if (_parent.Type == JTokenType.Property)
					{
						_parent = _parent.Parent;
					}
				}
			}
			else
			{
				_value = value ?? JValue.CreateNull();
				_current = _value;
			}
		}

		public override void WriteValue(object? value)
		{
			if (value is BigInteger)
			{
				InternalWriteValue(JsonToken.Integer);
				AddValue(value, JsonToken.Integer);
			}
			else
			{
				base.WriteValue(value);
			}
		}

		public override void WriteNull()
		{
			base.WriteNull();
			AddValue(null, JsonToken.Null);
		}

		public override void WriteUndefined()
		{
			base.WriteUndefined();
			AddValue(null, JsonToken.Undefined);
		}

		public override void WriteRaw(string? json)
		{
			base.WriteRaw(json);
			AddValue(new JRaw(json), JsonToken.Raw);
		}

		public override void WriteComment(string? text)
		{
			base.WriteComment(text);
			AddValue(JValue.CreateComment(text), JsonToken.Comment);
		}

		public override void WriteValue(string? value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		public override void WriteValue(int value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(uint value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(long value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ulong value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(float value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(double value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(bool value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Boolean);
		}

		public override void WriteValue(short value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ushort value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(char value)
		{
			base.WriteValue(value);
			string value2 = value.ToString(CultureInfo.InvariantCulture);
			AddValue(value2, JsonToken.String);
		}

		public override void WriteValue(byte value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(sbyte value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(decimal value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(DateTime value)
		{
			base.WriteValue(value);
			value = DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
			AddValue(value, JsonToken.Date);
		}

		public override void WriteValue(DateTimeOffset value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Date);
		}

		public override void WriteValue(byte[]? value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Bytes);
		}

		public override void WriteValue(TimeSpan value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		public override void WriteValue(Guid value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		public override void WriteValue(Uri? value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		internal override void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments)
		{
			JTokenReader jTokenReader = reader as JTokenReader;
			if (jTokenReader != null && writeChildren && writeDateConstructorAsDate && writeComments)
			{
				if (jTokenReader.TokenType == JsonToken.None && !jTokenReader.Read())
				{
					return;
				}
				JToken jToken = jTokenReader.CurrentToken.CloneToken();
				if (_parent != null)
				{
					_parent.Add(jToken);
					_current = _parent.Last;
					if (_parent.Type == JTokenType.Property)
					{
						_parent = _parent.Parent;
						InternalWriteValue(JsonToken.Null);
					}
				}
				else
				{
					_current = jToken;
					if (_token == null && _value == null)
					{
						_token = jToken as JContainer;
						_value = jToken as JValue;
					}
				}
				jTokenReader.Skip();
			}
			else
			{
				base.WriteToken(reader, writeChildren, writeDateConstructorAsDate, writeComments);
			}
		}
	}
	internal class JValue : JToken, IEquatable<JValue>, IFormattable, IComparable, IComparable<JValue>, IConvertible
	{
		private class JValueDynamicProxy : DynamicProxy<JValue>
		{
			public override bool TryConvert(JValue instance, ConvertBinder binder, [NotNullWhen(true)] out object? result)
			{
				if (binder.Type == typeof(JValue) || binder.Type == typeof(JToken))
				{
					result = instance;
					return true;
				}
				object value = instance.Value;
				if (value == null)
				{
					result = null;
					return ReflectionUtils.IsNullable(binder.Type);
				}
				result = ConvertUtils.Convert(value, CultureInfo.InvariantCulture, binder.Type);
				return true;
			}

			public override bool TryBinaryOperation(JValue instance, BinaryOperationBinder binder, object arg, [NotNullWhen(true)] out object? result)
			{
				object objB = ((arg is JValue jValue) ? jValue.Value : arg);
				switch (binder.Operation)
				{
				case ExpressionType.Equal:
					result = Compare(instance.Type, instance.Value, objB) == 0;
					return true;
				case ExpressionType.NotEqual:
					result = Compare(instance.Type, instance.Value, objB) != 0;
					return true;
				case ExpressionType.GreaterThan:
					result = Compare(instance.Type, instance.Value, objB) > 0;
					return true;
				case ExpressionType.GreaterThanOrEqual:
					result = Compare(instance.Type, instance.Value, objB) >= 0;
					return true;
				case ExpressionType.LessThan:
					result = Compare(instance.Type, instance.Value, objB) < 0;
					return true;
				case ExpressionType.LessThanOrEqual:
					result = Compare(instance.Type, instance.Value, objB) <= 0;
					return true;
				case ExpressionType.Add:
				case ExpressionType.Divide:
				case ExpressionType.Multiply:
				case ExpressionType.Subtract:
				case ExpressionType.AddAssign:
				case ExpressionType.DivideAssign:
				case ExpressionType.MultiplyAssign:
				case ExpressionType.SubtractAssign:
					if (Operation(binder.Operation, instance.Value, objB, out result))
					{
						result = new JValue(result);
						return true;
					}
					break;
				}
				result = null;
				return false;
			}
		}

		private JTokenType _valueType;

		private object? _value;

		public override bool HasValues => false;

		public override JTokenType Type => _valueType;

		public new object? Value
		{
			get
			{
				return _value;
			}
			set
			{
				Type obj = _value?.GetType();
				Type type = value?.GetType();
				if (obj != type)
				{
					_valueType = GetValueType(_valueType, value);
				}
				_value = value;
			}
		}

		public override Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, params JsonConverter[] converters)
		{
			if (converters != null && converters.Length != 0 && _value != null)
			{
				JsonConverter matchingConverter = JsonSerializer.GetMatchingConverter(converters, _value.GetType());
				if (matchingConverter != null && matchingConverter.CanWrite)
				{
					matchingConverter.WriteJson(writer, _value, JsonSerializer.CreateDefault());
					return AsyncUtils.CompletedTask;
				}
			}
			switch (_valueType)
			{
			case JTokenType.Comment:
				return writer.WriteCommentAsync(_value?.ToString(), cancellationToken);
			case JTokenType.Raw:
				return writer.WriteRawValueAsync(_value?.ToString(), cancellationToken);
			case JTokenType.Null:
				return writer.WriteNullAsync(cancellationToken);
			case JTokenType.Undefined:
				return writer.WriteUndefinedAsync(cancellationToken);
			case JTokenType.Integer:
				if (_value is int value5)
				{
					return writer.WriteValueAsync(value5, cancellationToken);
				}
				if (_value is long value6)
				{
					return writer.WriteValueAsync(value6, cancellationToken);
				}
				if (_value is ulong value7)
				{
					return writer.WriteValueAsync(value7, cancellationToken);
				}
				if (_value is BigInteger bigInteger)
				{
					return writer.WriteValueAsync(bigInteger, cancellationToken);
				}
				return writer.WriteValueAsync(Convert.ToInt64(_value, CultureInfo.InvariantCulture), cancellationToken);
			case JTokenType.Float:
				if (_value is decimal value)
				{
					return writer.WriteValueAsync(value, cancellationToken);
				}
				if (_value is double value2)
				{
					return writer.WriteValueAsync(value2, cancellationToken);
				}
				if (_value is float value3)
				{
					return writer.WriteValueAsync(value3, cancellationToken);
				}
				return writer.WriteValueAsync(Convert.ToDouble(_value, CultureInfo.InvariantCulture), cancellationToken);
			case JTokenType.String:
				return writer.WriteValueAsync(_value?.ToString(), cancellationToken);
			case JTokenType.Boolean:
				return writer.WriteValueAsync(Convert.ToBoolean(_value, CultureInfo.InvariantCulture), cancellationToken);
			case JTokenType.Date:
				if (_value is DateTimeOffset value4)
				{
					return writer.WriteValueAsync(value4, cancellationToken);
				}
				return writer.WriteValueAsync(Convert.ToDateTime(_value, CultureInfo.InvariantCulture), cancellationToken);
			case JTokenType.Bytes:
				return writer.WriteValueAsync((byte[])_value, cancellationToken);
			case JTokenType.Guid:
				return writer.WriteValueAsync((_value != null) ? ((Guid?)_value) : ((Guid?)null), cancellationToken);
			case JTokenType.TimeSpan:
				return writer.WriteValueAsync((_value != null) ? ((TimeSpan?)_value) : ((TimeSpan?)null), cancellationToken);
			case JTokenType.Uri:
				return writer.WriteValueAsync((Uri)_value, cancellationToken);
			default:
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", _valueType, "Unexpected token type.");
			}
		}

		internal JValue(object? value, JTokenType type)
		{
			_value = value;
			_valueType = type;
		}

		public JValue(JValue other)
			: this(other.Value, other.Type)
		{
			CopyAnnotations(this, other);
		}

		public JValue(long value)
			: this(value, JTokenType.Integer)
		{
		}

		public JValue(decimal value)
			: this(value, JTokenType.Float)
		{
		}

		public JValue(char value)
			: this(value, JTokenType.String)
		{
		}

		[CLSCompliant(false)]
		public JValue(ulong value)
			: this(value, JTokenType.Integer)
		{
		}

		public JValue(double value)
			: this(value, JTokenType.Float)
		{
		}

		public JValue(float value)
			: this(value, JTokenType.Float)
		{
		}

		public JValue(DateTime value)
			: this(value, JTokenType.Date)
		{
		}

		public JValue(DateTimeOffset value)
			: this(value, JTokenType.Date)
		{
		}

		public JValue(bool value)
			: this(value, JTokenType.Boolean)
		{
		}

		public JValue(string? value)
			: this(value, JTokenType.String)
		{
		}

		public JValue(Guid value)
			: this(value, JTokenType.Guid)
		{
		}

		public JValue(Uri? value)
			: this(value, (value != null) ? JTokenType.Uri : JTokenType.Null)
		{
		}

		public JValue(TimeSpan value)
			: this(value, JTokenType.TimeSpan)
		{
		}

		public JValue(object? value)
			: this(value, GetValueType(null, value))
		{
		}

		internal override bool DeepEquals(JToken node)
		{
			if (!(node is JValue jValue))
			{
				return false;
			}
			if (jValue == this)
			{
				return true;
			}
			return ValuesEquals(this, jValue);
		}

		private static int CompareBigInteger(BigInteger i1, object i2)
		{
			int num = i1.CompareTo(ConvertUtils.ToBigInteger(i2));
			if (num != 0)
			{
				return num;
			}
			if (i2 is decimal num2)
			{
				decimal num3 = 0m;
				return num3.CompareTo(Math.Abs(num2 - Math.Truncate(num2)));
			}
			if (i2 is double || i2 is float)
			{
				double num4 = Convert.ToDouble(i2, CultureInfo.InvariantCulture);
				return 0.0.CompareTo(Math.Abs(num4 - Math.Truncate(num4)));
			}
			return num;
		}

		internal static int Compare(JTokenType valueType, object? objA, object? objB)
		{
			if (objA == objB)
			{
				return 0;
			}
			if (objB == null)
			{
				return 1;
			}
			if (objA == null)
			{
				return -1;
			}
			switch (valueType)
			{
			case JTokenType.Integer:
				if (objA is BigInteger i3)
				{
					return CompareBigInteger(i3, objB);
				}
				if (objB is BigInteger i4)
				{
					return -CompareBigInteger(i4, objA);
				}
				if (objA is ulong || objB is ulong || objA is decimal || objB is decimal)
				{
					return Convert.ToDecimal(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToDecimal(objB, CultureInfo.InvariantCulture));
				}
				if (objA is float || objB is float || objA is double || objB is double)
				{
					return CompareFloat(objA, objB);
				}
				return Convert.ToInt64(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToInt64(objB, CultureInfo.InvariantCulture));
			case JTokenType.Float:
				if (objA is BigInteger i)
				{
					return CompareBigInteger(i, objB);
				}
				if (objB is BigInteger i2)
				{
					return -CompareBigInteger(i2, objA);
				}
				if (objA is ulong || objB is ulong || objA is decimal || objB is decimal)
				{
					return Convert.ToDecimal(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToDecimal(objB, CultureInfo.InvariantCulture));
				}
				return CompareFloat(objA, objB);
			case JTokenType.Comment:
			case JTokenType.String:
			case JTokenType.Raw:
			{
				string strA = Convert.ToString(objA, CultureInfo.InvariantCulture);
				string strB = Convert.ToString(objB, CultureInfo.InvariantCulture);
				return string.CompareOrdinal(strA, strB);
			}
			case JTokenType.Boolean:
			{
				bool flag = Convert.ToBoolean(objA, CultureInfo.InvariantCulture);
				bool value4 = Convert.ToBoolean(objB, CultureInfo.InvariantCulture);
				return flag.CompareTo(value4);
			}
			case JTokenType.Date:
			{
				if (objA is DateTime dateTime)
				{
					DateTime value2 = ((!(objB is DateTimeOffset dateTimeOffset)) ? Convert.ToDateTime(objB, CultureInfo.InvariantCulture) : dateTimeOffset.DateTime);
					return dateTime.CompareTo(value2);
				}
				DateTimeOffset dateTimeOffset2 = (DateTimeOffset)objA;
				DateTimeOffset other = ((!(objB is DateTimeOffset)) ? new DateTimeOffset(Convert.ToDateTime(objB, CultureInfo.InvariantCulture)) : ((DateTimeOffset)objB));
				return dateTimeOffset2.CompareTo(other);
			}
			case JTokenType.Bytes:
				if (!(objB is byte[] a))
				{
					throw new ArgumentException("Object must be of type byte[].");
				}
				return MiscellaneousUtils.ByteArrayCompare(objA as byte[], a);
			case JTokenType.Guid:
			{
				if (!(objB is Guid))
				{
					throw new ArgumentException("Object must be of type Guid.");
				}
				Guid guid = (Guid)objA;
				Guid value3 = (Guid)objB;
				return guid.CompareTo(value3);
			}
			case JTokenType.Uri:
			{
				Uri uri = objB as Uri;
				if (uri == null)
				{
					throw new ArgumentException("Object must be of type Uri.");
				}
				Uri uri2 = (Uri)objA;
				return Comparer<string>.Default.Compare(uri2.ToString(), uri.ToString());
			}
			case JTokenType.TimeSpan:
			{
				if (!(objB is TimeSpan))
				{
					throw new ArgumentException("Object must be of type TimeSpan.");
				}
				TimeSpan timeSpan = (TimeSpan)objA;
				TimeSpan value = (TimeSpan)objB;
				return timeSpan.CompareTo(value);
			}
			default:
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException("valueType", valueType, "Unexpected value type: {0}".FormatWith(CultureInfo.InvariantCulture, valueType));
			}
		}

		private static int CompareFloat(object objA, object objB)
		{
			double d = Convert.ToDouble(objA, CultureInfo.InvariantCulture);
			double num = Convert.ToDouble(objB, CultureInfo.InvariantCulture);
			if (MathUtils.ApproxEquals(d, num))
			{
				return 0;
			}
			return d.CompareTo(num);
		}

		private static bool Operation(ExpressionType operation, object? objA, object? objB, out object? result)
		{
			if ((objA is string || objB is string) && (operation == ExpressionType.Add || operation == ExpressionType.AddAssign))
			{
				result = objA?.ToString() + objB;
				return true;
			}
			if (objA is BigInteger || objB is BigInteger)
			{
				if (objA == null || objB == null)
				{
					result = null;
					return true;
				}
				BigInteger bigInteger = ConvertUtils.ToBigInteger(objA);
				BigInteger bigInteger2 = ConvertUtils.ToBigInteger(objB);
				switch (operation)
				{
				case ExpressionType.Add:
				case ExpressionType.AddAssign:
					result = bigInteger + bigInteger2;
					return true;
				case ExpressionType.Subtract:
				case ExpressionType.SubtractAssign:
					result = bigInteger - bigInteger2;
					return true;
				case ExpressionType.Multiply:
				case ExpressionType.MultiplyAssign:
					result = bigInteger * bigInteger2;
					return true;
				case ExpressionType.Divide:
				case ExpressionType.DivideAssign:
					result = bigInteger / bigInteger2;
					return true;
				}
			}
			else if (objA is ulong || objB is ulong || objA is decimal || objB is decimal)
			{
				if (objA == null || objB == null)
				{
					result = null;
					return true;
				}
				decimal num = Convert.ToDecimal(objA, CultureInfo.InvariantCulture);
				decimal num2 = Convert.ToDecimal(objB, CultureInfo.InvariantCulture);
				switch (operation)
				{
				case ExpressionType.Add:
				case ExpressionType.AddAssign:
					result = num + num2;
					return true;
				case ExpressionType.Subtract:
				case ExpressionType.SubtractAssign:
					result = num - num2;
					return true;
				case ExpressionType.Multiply:
				case ExpressionType.MultiplyAssign:
					result = num * num2;
					return true;
				case ExpressionType.Divide:
				case ExpressionType.DivideAssign:
					result = num / num2;
					return true;
				}
			}
			else if (objA is float || objB is float || objA is double || objB is double)
			{
				if (objA == null || objB == null)
				{
					result = null;
					return true;
				}
				double num3 = Convert.ToDouble(objA, CultureInfo.InvariantCulture);
				double num4 = Convert.ToDouble(objB, CultureInfo.InvariantCulture);
				switch (operation)
				{
				case ExpressionType.Add:
				case ExpressionType.AddAssign:
					result = num3 + num4;
					return true;
				case ExpressionType.Subtract:
				case ExpressionType.SubtractAssign:
					result = num3 - num4;
					return true;
				case ExpressionType.Multiply:
				case ExpressionType.MultiplyAssign:
					result = num3 * num4;
					return true;
				case ExpressionType.Divide:
				case ExpressionType.DivideAssign:
					result = num3 / num4;
					return true;
				}
			}
			else if (objA is int || objA is uint || objA is long || objA is short || objA is ushort || objA is sbyte || objA is byte || objB is int || objB is uint || objB is long || objB is short || objB is ushort || objB is sbyte || objB is byte)
			{
				if (objA == null || objB == null)
				{
					result = null;
					return true;
				}
				long num5 = Convert.ToInt64(objA, CultureInfo.InvariantCulture);
				long num6 = Convert.ToInt64(objB, CultureInfo.InvariantCulture);
				switch (operation)
				{
				case ExpressionType.Add:
				case ExpressionType.AddAssign:
					result = num5 + num6;
					return true;
				case ExpressionType.Subtract:
				case ExpressionType.SubtractAssign:
					result = num5 - num6;
					return true;
				case ExpressionType.Multiply:
				case ExpressionType.MultiplyAssign:
					result = num5 * num6;
					return true;
				case ExpressionType.Divide:
				case ExpressionType.DivideAssign:
					result = num5 / num6;
					return true;
				}
			}
			result = null;
			return false;
		}

		internal override JToken CloneToken()
		{
			return new JValue(this);
		}

		public static JValue CreateComment(string? value)
		{
			return new JValue(value, JTokenType.Comment);
		}

		public static JValue CreateString(string? value)
		{
			return new JValue(value, JTokenType.String);
		}

		public static JValue CreateNull()
		{
			return new JValue(null, JTokenType.Null);
		}

		public static JValue CreateUndefined()
		{
			return new JValue(null, JTokenType.Undefined);
		}

		private static JTokenType GetValueType(JTokenType? current, object? value)
		{
			if (value == null)
			{
				return JTokenType.Null;
			}
			if (value == DBNull.Value)
			{
				return JTokenType.Null;
			}
			if (value is string)
			{
				return GetStringValueType(current);
			}
			if (value is long || value is int || value is short || value is sbyte || value is ulong || value is uint || value is ushort || value is byte)
			{
				return JTokenType.Integer;
			}
			if (value is Enum)
			{
				return JTokenType.Integer;
			}
			if (value is BigInteger)
			{
				return JTokenType.Integer;
			}
			if (value is double || value is float || value is decimal)
			{
				return JTokenType.Float;
			}
			if (value is DateTime)
			{
				return JTokenType.Date;
			}
			if (value is DateTimeOffset)
			{
				return JTokenType.Date;
			}
			if (value is byte[])
			{
				return JTokenType.Bytes;
			}
			if (value is bool)
			{
				return JTokenType.Boolean;
			}
			if (value is Guid)
			{
				return JTokenType.Guid;
			}
			if (value is Uri)
			{
				return JTokenType.Uri;
			}
			if (value is TimeSpan)
			{
				return JTokenType.TimeSpan;
			}
			throw new ArgumentException("Could not determine JSON object type for type {0}.".FormatWith(CultureInfo.InvariantCulture, value.GetType()));
		}

		private static JTokenType GetStringValueType(JTokenType? current)
		{
			if (!current.HasValue)
			{
				return JTokenType.String;
			}
			JTokenType valueOrDefault = current.GetValueOrDefault();
			if (valueOrDefault == JTokenType.Comment || valueOrDefault == JTokenType.String || valueOrDefault == JTokenType.Raw)
			{
				return current.GetValueOrDefault();
			}
			return JTokenType.String;
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			if (converters != null && converters.Length != 0 && _value != null)
			{
				JsonConverter matchingConverter = JsonSerializer.GetMatchingConverter(converters, _value.GetType());
				if (matchingConverter != null && matchingConverter.CanWrite)
				{
					matchingConverter.WriteJson(writer, _value, JsonSerializer.CreateDefault());
					return;
				}
			}
			switch (_valueType)
			{
			case JTokenType.Comment:
				writer.WriteComment(_value?.ToString());
				break;
			case JTokenType.Raw:
				writer.WriteRawValue(_value?.ToString());
				break;
			case JTokenType.Null:
				writer.WriteNull();
				break;
			case JTokenType.Undefined:
				writer.WriteUndefined();
				break;
			case JTokenType.Integer:
				if (_value is int value5)
				{
					writer.WriteValue(value5);
				}
				else if (_value is long value6)
				{
					writer.WriteValue(value6);
				}
				else if (_value is ulong value7)
				{
					writer.WriteValue(value7);
				}
				else if (_value is BigInteger bigInteger)
				{
					writer.WriteValue(bigInteger);
				}
				else
				{
					writer.WriteValue(Convert.ToInt64(_value, CultureInfo.InvariantCulture));
				}
				break;
			case JTokenType.Float:
				if (_value is decimal value)
				{
					writer.WriteValue(value);
				}
				else if (_value is double value2)
				{
					writer.WriteValue(value2);
				}
				else if (_value is float value3)
				{
					writer.WriteValue(value3);
				}
				else
				{
					writer.WriteValue(Convert.ToDouble(_value, CultureInfo.InvariantCulture));
				}
				break;
			case JTokenType.String:
				writer.WriteValue(_value?.ToString());
				break;
			case JTokenType.Boolean:
				writer.WriteValue(Convert.ToBoolean(_value, CultureInfo.InvariantCulture));
				break;
			case JTokenType.Date:
				if (_value is DateTimeOffset value4)
				{
					writer.WriteValue(value4);
				}
				else
				{
					writer.WriteValue(Convert.ToDateTime(_value, CultureInfo.InvariantCulture));
				}
				break;
			case JTokenType.Bytes:
				writer.WriteValue((byte[])_value);
				break;
			case JTokenType.Guid:
				writer.WriteValue((_value != null) ? ((Guid?)_value) : ((Guid?)null));
				break;
			case JTokenType.TimeSpan:
				writer.WriteValue((_value != null) ? ((TimeSpan?)_value) : ((TimeSpan?)null));
				break;
			case JTokenType.Uri:
				writer.WriteValue((Uri)_value);
				break;
			default:
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", _valueType, "Unexpected token type.");
			}
		}

		internal override int GetDeepHashCode()
		{
			int num = ((_value != null) ? _value.GetHashCode() : 0);
			int valueType = (int)_valueType;
			return valueType.GetHashCode() ^ num;
		}

		private static bool ValuesEquals(JValue v1, JValue v2)
		{
			if (v1 != v2)
			{
				if (v1._valueType == v2._valueType)
				{
					return Compare(v1._valueType, v1._value, v2._value) == 0;
				}
				return false;
			}
			return true;
		}

		public bool Equals(JValue? other)
		{
			if (other == null)
			{
				return false;
			}
			return ValuesEquals(this, other);
		}

		public override bool Equals(object obj)
		{
			if (obj is JValue other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			if (_value == null)
			{
				return 0;
			}
			return _value.GetHashCode();
		}

		public override string ToString()
		{
			if (_value == null)
			{
				return string.Empty;
			}
			return _value.ToString();
		}

		public string ToString(string format)
		{
			return ToString(format, CultureInfo.CurrentCulture);
		}

		public string ToString(IFormatProvider formatProvider)
		{
			return ToString(null, formatProvider);
		}

		public string ToString(string? format, IFormatProvider formatProvider)
		{
			if (_value == null)
			{
				return string.Empty;
			}
			if (_value is IFormattable formattable)
			{
				return formattable.ToString(format, formatProvider);
			}
			return _value.ToString();
		}

		protected override DynamicMetaObject GetMetaObject(Expression parameter)
		{
			return new DynamicProxyMetaObject<JValue>(parameter, this, new JValueDynamicProxy());
		}

		int IComparable.CompareTo(object obj)
		{
			if (obj == null)
			{
				return 1;
			}
			object objB;
			JTokenType valueType;
			if (obj is JValue jValue)
			{
				objB = jValue.Value;
				valueType = ((_valueType == JTokenType.String && _valueType != jValue._valueType) ? jValue._valueType : _valueType);
			}
			else
			{
				objB = obj;
				valueType = _valueType;
			}
			return Compare(valueType, _value, objB);
		}

		public int CompareTo(JValue obj)
		{
			if (obj == null)
			{
				return 1;
			}
			return Compare((_valueType == JTokenType.String && _valueType != obj._valueType) ? obj._valueType : _valueType, _value, obj._value);
		}

		TypeCode IConvertible.GetTypeCode()
		{
			if (_value == null)
			{
				return TypeCode.Empty;
			}
			if (_value is IConvertible convertible)
			{
				return convertible.GetTypeCode();
			}
			return TypeCode.Object;
		}

		bool IConvertible.ToBoolean(IFormatProvider provider)
		{
			return (bool)(JToken)this;
		}

		char IConvertible.ToChar(IFormatProvider provider)
		{
			return (char)(JToken)this;
		}

		sbyte IConvertible.ToSByte(IFormatProvider provider)
		{
			return (sbyte)(JToken)this;
		}

		byte IConvertible.ToByte(IFormatProvider provider)
		{
			return (byte)(JToken)this;
		}

		short IConvertible.ToInt16(IFormatProvider provider)
		{
			return (short)(JToken)this;
		}

		ushort IConvertible.ToUInt16(IFormatProvider provider)
		{
			return (ushort)(JToken)this;
		}

		int IConvertible.ToInt32(IFormatProvider provider)
		{
			return (int)(JToken)this;
		}

		uint IConvertible.ToUInt32(IFormatProvider provider)
		{
			return (uint)(JToken)this;
		}

		long IConvertible.ToInt64(IFormatProvider provider)
		{
			return (long)(JToken)this;
		}

		ulong IConvertible.ToUInt64(IFormatProvider provider)
		{
			return (ulong)(JToken)this;
		}

		float IConvertible.ToSingle(IFormatProvider provider)
		{
			return (float)(JToken)this;
		}

		double IConvertible.ToDouble(IFormatProvider provider)
		{
			return (double)(JToken)this;
		}

		decimal IConvertible.ToDecimal(IFormatProvider provider)
		{
			return (decimal)(JToken)this;
		}

		DateTime IConvertible.ToDateTime(IFormatProvider provider)
		{
			return (DateTime)(JToken)this;
		}

		object? IConvertible.ToType(Type conversionType, IFormatProvider provider)
		{
			return ToObject(conversionType);
		}
	}
	internal enum LineInfoHandling
	{
		Ignore,
		Load
	}
	internal enum MergeArrayHandling
	{
		Concat,
		Union,
		Replace,
		Merge
	}
	[Flags]
	internal enum MergeNullValueHandling
	{
		Ignore = 0,
		Merge = 1
	}
}
namespace Microsoft.Identity.Json.Linq.JsonPath
{
	internal class ArrayIndexFilter : PathFilter
	{
		public int? Index { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(JToken root, IEnumerable<JToken> current, JsonSelectSettings? settings)
		{
			foreach (JToken item in current)
			{
				if (Index.HasValue)
				{
					JToken tokenIndex = PathFilter.GetTokenIndex(item, settings, Index.GetValueOrDefault());
					if (tokenIndex != null)
					{
						yield return tokenIndex;
					}
				}
				else if (item is JArray || item is JConstructor)
				{
					foreach (JToken item2 in (IEnumerable<JToken>)item)
					{
						yield return item2;
					}
				}
				else if (settings?.ErrorWhenNoMatch ?? false)
				{
					throw new JsonException("Index * not valid on {0}.".FormatWith(CultureInfo.InvariantCulture, item.GetType().Name));
				}
			}
		}
	}
	internal class ArrayMultipleIndexFilter : PathFilter
	{
		internal List<int> Indexes;

		public ArrayMultipleIndexFilter(List<int> indexes)
		{
			Indexes = indexes;
		}

		public override IEnumerable<JToken> ExecuteFilter(JToken root, IEnumerable<JToken> current, JsonSelectSettings? settings)
		{
			foreach (JToken t in current)
			{
				foreach (int index in Indexes)
				{
					JToken tokenIndex = PathFilter.GetTokenIndex(t, settings, index);
					if (tokenIndex != null)
					{
						yield return tokenIndex;
					}
				}
			}
		}
	}
	internal class ArraySliceFilter : PathFilter
	{
		public int? Start { get; set; }

		public int? End { get; set; }

		public int? Step { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(JToken root, IEnumerable<JToken> current, JsonSelectSettings? settings)
		{
			if (Step == 0)
			{
				throw new JsonException("Step cannot be zero.");
			}
			foreach (JToken item in current)
			{
				if (item is JArray a)
				{
					int stepCount = Step ?? 1;
					int num = Start ?? ((stepCount <= 0) ? (a.Count - 1) : 0);
					int stopIndex = End ?? ((stepCount > 0) ? a.Count : (-1));
					if (Start < 0)
					{
						num = a.Count + num;
					}
					if (End < 0)
					{
						stopIndex = a.Count + stopIndex;
					}
					num = Math.Max(num, (stepCount <= 0) ? int.MinValue : 0);
					num = Math.Min(num, (stepCount > 0) ? a.Count : (a.Count - 1));
					stopIndex = Math.Max(stopIndex, -1);
					stopIndex = Math.Min(stopIndex, a.Count);
					bool positiveStep = stepCount > 0;
					if (IsValid(num, stopIndex, positiveStep))
					{
						for (int i = num; IsValid(i, stopIndex, positiveStep); i += stepCount)
						{
							yield return a[i];
						}
					}
					else if (settings?.ErrorWhenNoMatch ?? false)
					{
						throw new JsonException("Array slice of {0} to {1} returned no results.".FormatWith(CultureInfo.InvariantCulture, Start.HasValue ? Start.GetValueOrDefault().ToString(CultureInfo.InvariantCulture) : "*", End.HasValue ? End.GetValueOrDefault().ToString(CultureInfo.InvariantCulture) : "*"));
					}
				}
				else if (settings?.ErrorWhenNoMatch ?? false)
				{
					throw new JsonException("Array slice is not valid on {0}.".FormatWith(CultureInfo.InvariantCulture, item.GetType().Name));
				}
			}
		}

		private bool IsValid(int index, int stopIndex, bool positiveStep)
		{
			if (positiveStep)
			{
				return index < stopIndex;
			}
			return index > stopIndex;
		}
	}
	internal class FieldFilter : PathFilter
	{
		internal string? Name;

		public FieldFilter(string? name)
		{
			Name = name;
		}

		public override IEnumerable<JToken> ExecuteFilter(JToken root, IEnumerable<JToken> current, JsonSelectSettings? settings)
		{
			foreach (JToken item in current)
			{
				if (item is JObject jObject)
				{
					if (Name != null)
					{
						JToken jToken = jObject[Name];
						if (jToken != null)
						{
							yield return jToken;
						}
						else if (settings?.ErrorWhenNoMatch ?? false)
						{
							throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith(CultureInfo.InvariantCulture, Name));
						}
						continue;
					}
					foreach (KeyValuePair<string, JToken> item2 in jObject)
					{
						yield return item2.Value;
					}
				}
				else if (settings?.ErrorWhenNoMatch ?? false)
				{
					throw new JsonException("Property '{0}' not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, Name ?? "*", item.GetType().Name));
				}
			}
		}
	}
	internal class FieldMultipleFilter : PathFilter
	{
		internal List<string> Names;

		public FieldMultipleFilter(List<string> names)
		{
			Names = names;
		}

		public override IEnumerable<JToken> ExecuteFilter(JToken root, IEnumerable<JToken> current, JsonSelectSettings? settings)
		{
			foreach (JToken item in current)
			{
				if (item is JObject o)
				{
					foreach (string name in Names)
					{
						JToken jToken = o[name];
						if (jToken != null)
						{
							yield return jToken;
						}
						if (settings?.ErrorWhenNoMatch ?? false)
						{
							throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith(CultureInfo.InvariantCulture, name));
						}
					}
				}
				else if (settings?.ErrorWhenNoMatch ?? false)
				{
					throw new JsonException("Properties {0} not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, string.Join(", ", Names.Select((string n) => "'" + n + "'")), item.GetType().Name));
				}
			}
		}
	}
	internal class JPath
	{
		private static readonly char[] FloatCharacters = new char[3] { '.', 'E', 'e' };

		private readonly string _expression;

		private int _currentIndex;

		public List<PathFilter> Filters { get; }

		public JPath(string expression)
		{
			ValidationUtils.ArgumentNotNull(expression, "expression");
			_expression = expression;
			Filters = new List<PathFilter>();
			ParseMain();
		}

		private void ParseMain()
		{
			int currentIndex = _currentIndex;
			EatWhitespace();
			if (_expression.Length == _currentIndex)
			{
				return;
			}
			if (_expression[_currentIndex] == '$')
			{
				if (_expression.Length == 1)
				{
					return;
				}
				char c = _expression[_currentIndex + 1];
				if (c == '.' || c == '[')
				{
					_currentIndex++;
					currentIndex = _currentIndex;
				}
			}
			if (!ParsePath(Filters, currentIndex, query: false))
			{
				int currentIndex2 = _currentIndex;
				EatWhitespace();
				if (_currentIndex < _expression.Length)
				{
					throw new JsonException("Unexpected character while parsing path: " + _expression[currentIndex2]);
				}
			}
		}

		private bool ParsePath(List<PathFilter> filters, int currentPartStartIndex, bool query)
		{
			bool scan = false;
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			while (_currentIndex < _expression.Length && !flag3)
			{
				char c = _expression[_currentIndex];
				switch (c)
				{
				case '(':
				case '[':
					if (_currentIndex > currentPartStartIndex)
					{
						string text = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex);
						if (text == "*")
						{
							text = null;
						}
						filters.Add(CreatePathFilter(text, scan));
						scan = false;
					}
					filters.Add(ParseIndexer(c, scan));
					scan = false;
					_currentIndex++;
					currentPartStartIndex = _currentIndex;
					flag = true;
					flag2 = false;
					break;
				case ')':
				case ']':
					flag3 = true;
					break;
				case ' ':
					if (_currentIndex < _expression.Length)
					{
						flag3 = true;
					}
					break;
				case '.':
					if (_currentIndex > currentPartStartIndex)
					{
						string text2 = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex);
						if (text2 == "*")
						{
							text2 = null;
						}
						filters.Add(CreatePathFilter(text2, scan));
						scan = false;
					}
					if (_currentIndex + 1 < _expression.Length && _expression[_currentIndex + 1] == '.')
					{
						scan = true;
						_currentIndex++;
					}
					_currentIndex++;
					currentPartStartIndex = _currentIndex;
					flag = false;
					flag2 = true;
					break;
				default:
					if (query && (c == '=' || c == '<' || c == '!' || c == '>' || c == '|' || c == '&'))
					{
						flag3 = true;
						break;
					}
					if (flag)
					{
						throw new JsonException("Unexpected character following indexer: " + c);
					}
					_currentIndex++;
					break;
				}
			}
			bool flag4 = _currentIndex == _expression.Length;
			if (_currentIndex > currentPartStartIndex)
			{
				string text3 = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex).TrimEnd(Array.Empty<char>());
				if (text3 == "*")
				{
					text3 = null;
				}
				filters.Add(CreatePathFilter(text3, scan));
			}
			else if (flag2 && (flag4 || query))
			{
				throw new JsonException("Unexpected end while parsing path.");
			}
			return flag4;
		}

		private static PathFilter CreatePathFilter(string? member, bool scan)
		{
			if (!scan)
			{
				return new FieldFilter(member);
			}
			return new ScanFilter(member);
		}

		private PathFilter ParseIndexer(char indexerOpenChar, bool scan)
		{
			_currentIndex++;
			char indexerCloseChar = ((indexerOpenChar == '[') ? ']' : ')');
			EnsureLength("Path ended with open indexer.");
			EatWhitespace();
			if (_expression[_currentIndex] == '\'')
			{
				return ParseQuotedField(indexerCloseChar, scan);
			}
			if (_expression[_currentIndex] == '?')
			{
				return ParseQuery(indexerCloseChar, scan);
			}
			return ParseArrayIndexer(indexerCloseChar);
		}

		private PathFilter ParseArrayIndexer(char indexerCloseChar)
		{
			int currentIndex = _currentIndex;
			int? num = null;
			List<int> list = null;
			int num2 = 0;
			int? start = null;
			int? end = null;
			int? step = null;
			while (_currentIndex < _expression.Length)
			{
				char c = _expression[_currentIndex];
				if (c == ' ')
				{
					num = _currentIndex;
					EatWhitespace();
					continue;
				}
				if (c == indexerCloseChar)
				{
					int num3 = (num ?? _currentIndex) - currentIndex;
					if (list != null)
					{
						if (num3 == 0)
						{
							throw new JsonException("Array index expected.");
						}
						int item = Convert.ToInt32(_expression.Substring(currentIndex, num3), CultureInfo.InvariantCulture);
						list.Add(item);
						return new ArrayMultipleIndexFilter(list);
					}
					if (num2 > 0)
					{
						if (num3 > 0)
						{
							int value = Convert.ToInt32(_expression.Substring(currentIndex, num3), CultureInfo.InvariantCulture);
							if (num2 == 1)
							{
								end = value;
							}
							else
							{
								step = value;
							}
						}
						return new ArraySliceFilter
						{
							Start = start,
							End = end,
							Step = step
						};
					}
					if (num3 == 0)
					{
						throw new JsonException("Array index expected.");
					}
					int value2 = Convert.ToInt32(_expression.Substring(currentIndex, num3), CultureInfo.InvariantCulture);
					return new ArrayIndexFilter
					{
						Index = value2
					};
				}
				switch (c)
				{
				case ',':
				{
					int num5 = (num ?? _currentIndex) - currentIndex;
					if (num5 == 0)
					{
						throw new JsonException("Array index expected.");
					}
					if (list == null)
					{
						list = new List<int>();
					}
					string value4 = _expression.Substring(currentIndex, num5);
					list.Add(Convert.ToInt32(value4, CultureInfo.InvariantCulture));
					_currentIndex++;
					EatWhitespace();
					currentIndex = _currentIndex;
					num = null;
					break;
				}
				case '*':
					_currentIndex++;
					EnsureLength("Path ended with open indexer.");
					EatWhitespace();
					if (_expression[_currentIndex] != indexerCloseChar)
					{
						throw new JsonException("Unexpected character while parsing path indexer: " + c);
					}
					return new ArrayIndexFilter();
				case ':':
				{
					int num4 = (num ?? _currentIndex) - currentIndex;
					if (num4 > 0)
					{
						int value3 = Convert.ToInt32(_expression.Substring(currentIndex, num4), CultureInfo.InvariantCulture);
						switch (num2)
						{
						case 0:
							start = value3;
							break;
						case 1:
							end = value3;
							break;
						default:
							step = value3;
							break;
						}
					}
					num2++;
					_currentIndex++;
					EatWhitespace();
					currentIndex = _currentIndex;
					num = null;
					break;
				}
				default:
					if (!char.IsDigit(c) && c != '-')
					{
						throw new JsonException("Unexpected character while parsing path indexer: " + c);
					}
					if (num.HasValue)
					{
						throw new JsonException("Unexpected character while parsing path indexer: " + c);
					}
					_currentIndex++;
					break;
				}
			}
			throw new JsonException("Path ended with open indexer.");
		}

		private void EatWhitespace()
		{
			while (_currentIndex < _expression.Length && _expression[_currentIndex] == ' ')
			{
				_currentIndex++;
			}
		}

		private PathFilter ParseQuery(char indexerCloseChar, bool scan)
		{
			_currentIndex++;
			EnsureLength("Path ended with open indexer.");
			if (_expression[_currentIndex] != '(')
			{
				throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
			}
			_currentIndex++;
			QueryExpression expression = ParseExpression();
			_currentIndex++;
			EnsureLength("Path ended with open indexer.");
			EatWhitespace();
			if (_expression[_currentIndex] != indexerCloseChar)
			{
				throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
			}
			if (!scan)
			{
				return new QueryFilter(expression);
			}
			return new QueryScanFilter(expression);
		}

		private bool TryParseExpression(out List<PathFilter>? expressionPath)
		{
			if (_expression[_currentIndex] == '$')
			{
				expressionPath = new List<PathFilter> { RootFilter.Instance };
			}
			else
			{
				if (_expression[_currentIndex] != '@')
				{
					expressionPath = null;
					return false;
				}
				expressionPath = new List<PathFilter>();
			}
			_currentIndex++;
			if (ParsePath(expressionPath, _currentIndex, query: true))
			{
				throw new JsonException("Path ended with open query.");
			}
			return true;
		}

		private JsonException CreateUnexpectedCharacterException()
		{
			return new JsonException("Unexpected character while parsing path query: " + _expression[_currentIndex]);
		}

		private object ParseSide()
		{
			EatWhitespace();
			if (TryParseExpression(out List<PathFilter> expressionPath))
			{
				EatWhitespace();
				EnsureLength("Path ended with open query.");
				return expressionPath;
			}
			if (TryParseValue(out object value))
			{
				EatWhitespace();
				EnsureLength("Path ended with open query.");
				return new JValue(value);
			}
			throw CreateUnexpectedCharacterException();
		}

		private QueryExpression ParseExpression()
		{
			QueryExpression queryExpression = null;
			CompositeExpression compositeExpression = null;
			while (_currentIndex < _expression.Length)
			{
				object left = ParseSide();
				object right = null;
				QueryOperator queryOperator;
				if (_expression[_currentIndex] == ')' || _expression[_currentIndex] == '|' || _expression[_currentIndex] == '&')
				{
					queryOperator = QueryOperator.Exists;
				}
				else
				{
					queryOperator = ParseOperator();
					right = ParseSide();
				}
				BooleanQueryExpression booleanQueryExpression = new BooleanQueryExpression(queryOperator, left, right);
				if (_expression[_currentIndex] == ')')
				{
					if (compositeExpression != null)
					{
						compositeExpression.Expressions.Add(booleanQueryExpression);
						return queryExpression;
					}
					return booleanQueryExpression;
				}
				if (_expression[_currentIndex] == '&')
				{
					if (!Match("&&"))
					{
						throw CreateUnexpectedCharacterException();
					}
					if (compositeExpression == null || compositeExpression.Operator != QueryOperator.And)
					{
						CompositeExpression compositeExpression2 = new CompositeExpression(QueryOperator.And);
						compositeExpression?.Expressions.Add(compositeExpression2);
						compositeExpression = compositeExpression2;
						if (queryExpression == null)
						{
							queryExpression = compositeExpression;
						}
					}
					compositeExpression.Expressions.Add(booleanQueryExpression);
				}
				if (_expression[_currentIndex] != '|')
				{
					continue;
				}
				if (!Match("||"))
				{
					throw CreateUnexpectedCharacterException();
				}
				if (compositeExpression == null || compositeExpression.Operator != QueryOperator.Or)
				{
					CompositeExpression compositeExpression3 = new CompositeExpression(QueryOperator.Or);
					compositeExpression?.Expressions.Add(compositeExpression3);
					compositeExpression = compositeExpression3;
					if (queryExpression == null)
					{
						queryExpression = compositeExpression;
					}
				}
				compositeExpression.Expressions.Add(booleanQueryExpression);
			}
			throw new JsonException("Path ended with open query.");
		}

		private bool TryParseValue(out object? value)
		{
			char c = _expression[_currentIndex];
			if (c == '\'')
			{
				value = ReadQuotedString();
				return true;
			}
			if (char.IsDigit(c) || c == '-')
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(c);
				_currentIndex++;
				while (_currentIndex < _expression.Length)
				{
					c = _expression[_currentIndex];
					if (c == ' ' || c == ')')
					{
						string text = stringBuilder.ToString();
						if (text.IndexOfAny(FloatCharacters) != -1)
						{
							double result2;
							bool result = double.TryParse(text, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out result2);
							value = result2;
							return result;
						}
						long result4;
						bool result3 = long.TryParse(text, NumberStyles.Integer, CultureInfo.InvariantCulture, out result4);
						value = result4;
						return result3;
					}
					stringBuilder.Append(c);
					_currentIndex++;
				}
			}
			else
			{
				switch (c)
				{
				case 't':
					if (Match("true"))
					{
						value = true;
						return true;
					}
					break;
				case 'f':
					if (Match("false"))
					{
						value = false;
						return true;
					}
					break;
				case 'n':
					if (Match("null"))
					{
						value = null;
						return true;
					}
					break;
				case '/':
					value = ReadRegexString();
					return true;
				}
			}
			value = null;
			return false;
		}

		private string ReadQuotedString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			_currentIndex++;
			while (_currentIndex < _expression.Length)
			{
				char c = _expression[_currentIndex];
				if (c == '\\' && _currentIndex + 1 < _expression.Length)
				{
					_currentIndex++;
					c = _expression[_currentIndex];
					char value;
					switch (c)
					{
					case 'b':
						value = '\b';
						break;
					case 't':
						value = '\t';
						break;
					case 'n':
						value = '\n';
						break;
					case 'f':
						value = '\f';
						break;
					case 'r':
						value = '\r';
						break;
					case '"':
					case '\'':
					case '/':
					case '\\':
						value = c;
						break;
					default:
						throw new JsonException("Unknown escape character: \\" + c);
					}
					stringBuilder.Append(value);
					_currentIndex++;
				}
				else
				{
					if (c == '\'')
					{
						_currentIndex++;
						return stringBuilder.ToString();
					}
					_currentIndex++;
					stringBuilder.Append(c);
				}
			}
			throw new JsonException("Path ended with an open string.");
		}

		private string ReadRegexString()
		{
			int currentIndex = _currentIndex;
			_currentIndex++;
			while (_currentIndex < _expression.Length)
			{
				char c = _expression[_currentIndex];
				if (c == '\\' && _currentIndex + 1 < _expression.Length)
				{
					_currentIndex += 2;
					continue;
				}
				if (c == '/')
				{
					_currentIndex++;
					while (_currentIndex < _expression.Length)
					{
						c = _expression[_currentIndex];
						if (!char.IsLetter(c))
						{
							break;
						}
						_currentIndex++;
					}
					return _expression.Substring(currentIndex, _currentIndex - currentIndex);
				}
				_currentIndex++;
			}
			throw new JsonException("Path ended with an open regex.");
		}

		private bool Match(string s)
		{
			int num = _currentIndex;
			for (int i = 0; i < s.Length; i++)
			{
				if (num < _expression.Length && _expression[num] == s[i])
				{
					num++;
					continue;
				}
				return false;
			}
			_currentIndex = num;
			return true;
		}

		private QueryOperator ParseOperator()
		{
			if (_currentIndex + 1 >= _expression.Length)
			{
				throw new JsonException("Path ended with open query.");
			}
			if (Match("==="))
			{
				return QueryOperator.StrictEquals;
			}
			if (Match("=="))
			{
				return QueryOperator.Equals;
			}
			if (Match("=~"))
			{
				return QueryOperator.RegexEquals;
			}
			if (Match("!=="))
			{
				return QueryOperator.StrictNotEquals;
			}
			if (Match("!=") || Match("<>"))
			{
				return QueryOperator.NotEquals;
			}
			if (Match("<="))
			{
				return QueryOperator.LessThanOrEquals;
			}
			if (Match("<"))
			{
				return QueryOperator.LessThan;
			}
			if (Match(">="))
			{
				return QueryOperator.GreaterThanOrEquals;
			}
			if (Match(">"))
			{
				return QueryOperator.GreaterThan;
			}
			throw new JsonException("Could not read query operator.");
		}

		private PathFilter ParseQuotedField(char indexerCloseChar, bool scan)
		{
			List<string> list = null;
			while (_currentIndex < _expression.Length)
			{
				string text = ReadQuotedString();
				EatWhitespace();
				EnsureLength("Path ended with open indexer.");
				if (_expression[_currentIndex] == indexerCloseChar)
				{
					if (list != null)
					{
						list.Add(text);
						if (!scan)
						{
							return new FieldMultipleFilter(list);
						}
						return new ScanMultipleFilter(list);
					}
					return CreatePathFilter(text, scan);
				}
				if (_expression[_currentIndex] == ',')
				{
					_currentIndex++;
					EatWhitespace();
					if (list == null)
					{
						list = new List<string>();
					}
					list.Add(text);
					continue;
				}
				throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
			}
			throw new JsonException("Path ended with open indexer.");
		}

		private void EnsureLength(string message)
		{
			if (_currentIndex >= _expression.Length)
			{
				throw new JsonException(message);
			}
		}

		internal IEnumerable<JToken> Evaluate(JToken root, JToken t, JsonSelectSettings? settings)
		{
			return Evaluate(Filters, root, t, settings);
		}

		internal static IEnumerable<JToken> Evaluate(List<PathFilter> filters, JToken root, JToken t, JsonSelectSettings? settings)
		{
			IEnumerable<JToken> enumerable = new JToken[1] { t };
			foreach (PathFilter filter in filters)
			{
				enumerable = filter.ExecuteFilter(root, enumerable, settings);
			}
			return enumerable;
		}
	}
	internal abstract class PathFilter
	{
		public abstract IEnumerable<JToken> ExecuteFilter(JToken root, IEnumerable<JToken> current, JsonSelectSettings? settings);

		protected static JToken? GetTokenIndex(JToken t, JsonSelectSettings? settings, int index)
		{
			if (t is JArray jArray)
			{
				if (jArray.Count <= index)
				{
					if (settings != null && settings.ErrorWhenNoMatch)
					{
						throw new JsonException("Index {0} outside the bounds of JArray.".FormatWith(CultureInfo.InvariantCulture, index));
					}
					return null;
				}
				return jArray[index];
			}
			if (t is JConstructor jConstructor)
			{
				if (jConstructor.Count <= index)
				{
					if (settings != null && settings.ErrorWhenNoMatch)
					{
						throw new JsonException("Index {0} outside the bounds of JConstructor.".FormatWith(CultureInfo.InvariantCulture, index));
					}
					return null;
				}
				return jConstructor[index];
			}
			if (settings != null && settings.ErrorWhenNoMatch)
			{
				throw new JsonException("Index {0} not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, index, t.GetType().Name));
			}
			return null;
		}

		protected static JToken? GetNextScanValue(JToken originalParent, JToken? container, JToken? value)
		{
			if (container != null && container.HasValues)
			{
				value = container.First;
			}
			else
			{
				while (value != null && value != originalParent && value == value.Parent.Last)
				{
					value = value.Parent;
				}
				if (value == null || value == originalParent)
				{
					return null;
				}
				value = value.Next;
			}
			return value;
		}
	}
	internal enum QueryOperator
	{
		None,
		Equals,
		NotEquals,
		Exists,
		LessThan,
		LessThanOrEquals,
		GreaterThan,
		GreaterThanOrEquals,
		And,
		Or,
		RegexEquals,
		StrictEquals,
		StrictNotEquals
	}
	internal abstract class QueryExpression
	{
		internal QueryOperator Operator;

		public QueryExpression(QueryOperator @operator)
		{
			Operator = @operator;
		}

		public bool IsMatch(JToken root, JToken t)
		{
			return IsMatch(root, t, null);
		}

		public abstract bool IsMatch(JToken root, JToken t, JsonSelectSettings? settings);
	}
	internal class CompositeExpression : QueryExpression
	{
		public List<QueryExpression> Expressions { get; set; }

		public CompositeExpression(QueryOperator @operator)
			: base(@operator)
		{
			Expressions = new List<QueryExpression>();
		}

		public override bool IsMatch(JToken root, JToken t, JsonSelectSettings? settings)
		{
			switch (Operator)
			{
			case QueryOperator.And:
				foreach (QueryExpression expression in Expressions)
				{
					if (!expression.IsMatch(root, t, settings))
					{
						return false;
					}
				}
				return true;
			case QueryOperator.Or:
				foreach (QueryExpression expression2 in Expressions)
				{
					if (expression2.IsMatch(root, t, settings))
					{
						return true;
					}
				}
				return false;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}
	internal class BooleanQueryExpression : QueryExpression
	{
		public readonly object Left;

		public readonly object? Right;

		public BooleanQueryExpression(QueryOperator @operator, object left, object? right)
			: base(@operator)
		{
			Left = left;
			Right = right;
		}

		private IEnumerable<JToken> GetResult(JToken root, JToken t, object? o)
		{
			if (o is JToken jToken)
			{
				return new JToken[1] { jToken };
			}
			if (o is List<PathFilter> filters)
			{
				return JPath.Evaluate(filters, root, t, null);
			}
			return CollectionUtils.ArrayEmpty<JToken>();
		}

		public override bool IsMatch(JToken root, JToken t, JsonSelectSettings? settings)
		{
			if (Operator == QueryOperator.Exists)
			{
				return GetResult(root, t, Left).Any();
			}
			using (IEnumerator<JToken> enumerator = GetResult(root, t, Left).GetEnumerator())
			{
				if (enumerator.MoveNext())
				{
					IEnumerable<JToken> result = GetResult(root, t, Right);
					ICollection<JToken> collection = (result as ICollection<JToken>) ?? result.ToList();
					do
					{
						JToken current = enumerator.Current;
						foreach (JToken item in collection)
						{
							if (MatchTokens(current, item, settings))
							{
								return true;
							}
						}
					}
					while (enumerator.MoveNext());
				}
			}
			return false;
		}

		private bool MatchTokens(JToken leftResult, JToken rightResult, JsonSelectSettings? settings)
		{
			if (leftResult is JValue jValue && rightResult is JValue jValue2)
			{
				switch (Operator)
				{
				case QueryOperator.RegexEquals:
					if (RegexEquals(jValue, jValue2, settings))
					{
						return true;
					}
					break;
				case QueryOperator.Equals:
					if (EqualsWithStringCoercion(jValue, jValue2))
					{
						return true;
					}
					break;
				case QueryOperator.StrictEquals:
					if (EqualsWithStrictMatch(jValue, jValue2))
					{
						return true;
					}
					break;
				case QueryOperator.NotEquals:
					if (!EqualsWithStringCoercion(jValue, jValue2))
					{
						return true;
					}
					break;
				case QueryOperator.StrictNotEquals:
					if (!EqualsWithStrictMatch(jValue, jValue2))
					{
						return true;
					}
					break;
				case QueryOperator.GreaterThan:
					if (jValue.CompareTo(jValue2) > 0)
					{
						return true;
					}
					break;
				case QueryOperator.GreaterThanOrEquals:
					if (jValue.CompareTo(jValue2) >= 0)
					{
						return true;
					}
					break;
				case QueryOperator.LessThan:
					if (jValue.CompareTo(jValue2) < 0)
					{
						return true;
					}
					break;
				case QueryOperator.LessThanOrEquals:
					if (jValue.CompareTo(jValue2) <= 0)
					{
						return true;
					}
					break;
				case QueryOperator.Exists:
					return true;
				}
			}
			else
			{
				QueryOperator queryOperator = Operator;
				if ((uint)(queryOperator - 2) <= 1u)
				{
					return true;
				}
			}
			return false;
		}

		private static bool RegexEquals(JValue input, JValue pattern, JsonSelectSettings? settings)
		{
			if (input.Type != JTokenType.String || pattern.Type != JTokenType.String)
			{
				return false;
			}
			string obj = (string)pattern.Value;
			int num = obj.LastIndexOf('/');
			string pattern2 = obj.Substring(1, num - 1);
			string optionsText = obj.Substring(num + 1);
			TimeSpan matchTimeout = settings?.RegexMatchTimeout ?? Regex.InfiniteMatchTimeout;
			return Regex.IsMatch((string)input.Value, pattern2, MiscellaneousUtils.GetRegexOptions(optionsText), matchTimeout);
		}

		internal static bool EqualsWithStringCoercion(JValue value, JValue queryValue)
		{
			if (value.Equals(queryValue))
			{
				return true;
			}
			if ((value.Type == JTokenType.Integer && queryValue.Type == JTokenType.Float) || (value.Type == JTokenType.Float && queryValue.Type == JTokenType.Integer))
			{
				return JValue.Compare(value.Type, value.Value, queryValue.Value) == 0;
			}
			if (queryValue.Type != JTokenType.String)
			{
				return false;
			}
			string b = (string)queryValue.Value;
			string a;
			switch (value.Type)
			{
			case JTokenType.Date:
			{
				using (StringWriter stringWriter = StringUtils.CreateStringWriter(64))
				{
					if (value.Value is DateTimeOffset value2)
					{
						DateTimeUtils.WriteDateTimeOffsetString(stringWriter, value2, DateFormatHandling.IsoDateFormat, null, CultureInfo.InvariantCulture);
					}
					else
					{
						DateTimeUtils.WriteDateTimeString(stringWriter, (DateTime)value.Value, DateFormatHandling.IsoDateFormat, null, CultureInfo.InvariantCulture);
					}
					a = stringWriter.ToString();
				}
				break;
			}
			case JTokenType.Bytes:
				a = Convert.ToBase64String((byte[])value.Value);
				break;
			case JTokenType.Guid:
			case JTokenType.TimeSpan:
				a = value.Value.ToString();
				break;
			case JTokenType.Uri:
				a = ((Uri)value.Value).OriginalString;
				break;
			default:
				return false;
			}
			return string.Equals(a, b, StringComparison.Ordinal);
		}

		internal static bool EqualsWithStrictMatch(JValue value, JValue queryValue)
		{
			if ((value.Type == JTokenType.Integer && queryValue.Type == JTokenType.Float) || (value.Type == JTokenType.Float && queryValue.Type == JTokenType.Integer))
			{
				return JValue.Compare(value.Type, value.Value, queryValue.Value) == 0;
			}
			if (value.Type != queryValue.Type)
			{
				return false;
			}
			return value.Equals(queryValue);
		}
	}
	internal class QueryFilter : PathFilter
	{
		internal QueryExpression Expression;

		public QueryFilter(QueryExpression expression)
		{
			Expression = expression;
		}

		public override IEnumerable<JToken> ExecuteFilter(JToken root, IEnumerable<JToken> current, JsonSelectSettings? settings)
		{
			foreach (JToken item in current)
			{
				foreach (JToken item2 in (IEnumerable<JToken>)item)
				{
					if (Expression.IsMatch(root, item2, settings))
					{
						yield return item2;
					}
				}
			}
		}
	}
	internal class QueryScanFilter : PathFilter
	{
		internal QueryExpression Expression;

		public QueryScanFilter(QueryExpression expression)
		{
			Expression = expression;
		}

		public override IEnumerable<JToken> ExecuteFilter(JToken root, IEnumerable<JToken> current, JsonSelectSettings? settings)
		{
			foreach (JToken item in current)
			{
				if (item is JContainer jContainer)
				{
					foreach (JToken item2 in jContainer.DescendantsAndSelf())
					{
						if (Expression.IsMatch(root, item2, settings))
						{
							yield return item2;
						}
					}
				}
				else if (Expression.IsMatch(root, item, settings))
				{
					yield return item;
				}
			}
		}
	}
	internal class RootFilter : PathFilter
	{
		public static readonly RootFilter Instance = new RootFilter();

		private RootFilter()
		{
		}

		public override IEnumerable<JToken> ExecuteFilter(JToken root, IEnumerable<JToken> current, JsonSelectSettings? settings)
		{
			return new JToken[1] { root };
		}
	}
	internal class ScanFilter : PathFilter
	{
		internal string? Name;

		public ScanFilter(string? name)
		{
			Name = name;
		}

		public override IEnumerable<JToken> ExecuteFilter(JToken root, IEnumerable<JToken> current, JsonSelectSettings? settings)
		{
			foreach (JToken c in current)
			{
				if (Name == null)
				{
					yield return c;
				}
				JToken value = c;
				while (true)
				{
					JContainer container = value as JContainer;
					value = PathFilter.GetNextScanValue(c, container, value);
					if (value == null)
					{
						break;
					}
					if (value is JProperty jProperty)
					{
						if (jProperty.Name == Name)
						{
							yield return jProperty.Value;
						}
					}
					else if (Name == null)
					{
						yield return value;
					}
				}
			}
		}
	}
	internal class ScanMultipleFilter : PathFilter
	{
		private List<string> _names;

		public ScanMultipleFilter(List<string> names)
		{
			_names = names;
		}

		public override IEnumerable<JToken> ExecuteFilter(JToken root, IEnumerable<JToken> current, JsonSelectSettings? settings)
		{
			foreach (JToken c in current)
			{
				JToken value = c;
				while (true)
				{
					JContainer container = value as JContainer;
					value = PathFilter.GetNextScanValue(c, container, value);
					if (value == null)
					{
						break;
					}
					if (!(value is JProperty property))
					{
						continue;
					}
					foreach (string name in _names)
					{
						if (property.Name == name)
						{
							yield return property.Value;
						}
					}
				}
			}
		}
	}
}
namespace Microsoft.Identity.Json.Converters
{
	internal class BinaryConverter : JsonConverter
	{
		private const string BinaryTypeName = "System.Data.Linq.Binary";

		private const string BinaryToArrayName = "ToArray";

		private static ReflectionObject? _reflectionObject;

		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			byte[] byteArray = GetByteArray(value);
			writer.WriteValue(byteArray);
		}

		private byte[] GetByteArray(object value)
		{
			if (value.GetType().FullName == "System.Data.Linq.Binary")
			{
				EnsureReflectionObject(value.GetType());
				return (byte[])_reflectionObject.GetValue(value, "ToArray");
			}
			if (value is SqlBinary sqlBinary)
			{
				return sqlBinary.Value;
			}
			throw new JsonSerializationException("Unexpected value type when writing binary: {0}".FormatWith(CultureInfo.InvariantCulture, value.GetType()));
		}

		private static void EnsureReflectionObject(Type t)
		{
			if (_reflectionObject == null)
			{
				_reflectionObject = ReflectionObject.Create(t, t.GetConstructor(new Type[1] { typeof(byte[]) }), "ToArray");
			}
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				if (!ReflectionUtils.IsNullable(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			byte[] array;
			if (reader.TokenType == JsonToken.StartArray)
			{
				array = ReadByteArray(reader);
			}
			else
			{
				if (reader.TokenType != JsonToken.String)
				{
					throw JsonSerializationException.Create(reader, "Unexpected token parsing binary. Expected String or StartArray, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
				}
				array = Convert.FromBase64String(reader.Value.ToString());
			}
			Type type = (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType);
			if (type.FullName == "System.Data.Linq.Binary")
			{
				EnsureReflectionObject(type);
				return _reflectionObject.Creator(array);
			}
			if (type == typeof(SqlBinary))
			{
				return new SqlBinary(array);
			}
			throw JsonSerializationException.Create(reader, "Unexpected object type when writing binary: {0}".FormatWith(CultureInfo.InvariantCulture, objectType));
		}

		private byte[] ReadByteArray(JsonReader reader)
		{
			List<byte> list = new List<byte>();
			while (reader.Read())
			{
				switch (reader.TokenType)
				{
				case JsonToken.Integer:
					list.Add(Convert.ToByte(reader.Value, CultureInfo.InvariantCulture));
					break;
				case JsonToken.EndArray:
					return list.ToArray();
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when reading bytes: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
				case JsonToken.Comment:
					break;
				}
			}
			throw JsonSerializationException.Create(reader, "Unexpected end when reading bytes.");
		}

		public override bool CanConvert(Type objectType)
		{
			if (objectType.FullName == "System.Data.Linq.Binary")
			{
				return true;
			}
			if (objectType == typeof(SqlBinary) || objectType == typeof(SqlBinary?))
			{
				return true;
			}
			return false;
		}
	}
	[Obsolete("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
	internal class BsonObjectIdConverter : JsonConverter
	{
		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			BsonObjectId bsonObjectId = (BsonObjectId)value;
			if (writer is BsonWriter bsonWriter)
			{
				bsonWriter.WriteObjectId(bsonObjectId.Value);
			}
			else
			{
				writer.WriteValue(bsonObjectId.Value);
			}
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType != JsonToken.Bytes)
			{
				throw new JsonSerializationException("Expected Bytes but got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			return new BsonObjectId((byte[])reader.Value);
		}

		public override bool CanConvert(Type objectType)
		{
			return objectType == typeof(BsonObjectId);
		}
	}
	internal abstract class CustomCreationConverter<T> : JsonConverter
	{
		public override bool CanWrite => false;

		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			throw new NotSupportedException("CustomCreationConverter should only be used while deserializing.");
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			T val = Create(objectType);
			if (val == null)
			{
				throw new JsonSerializationException("No object created.");
			}
			serializer.Populate(reader, val);
			return val;
		}

		public abstract T Create(Type objectType);

		public override bool CanConvert(Type objectType)
		{
			return typeof(T).IsAssignableFrom(objectType);
		}
	}
	internal class DataSetConverter : JsonConverter
	{
		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			DataSet obj = (DataSet)value;
			DefaultContractResolver defaultContractResolver = serializer.ContractResolver as DefaultContractResolver;
			DataTableConverter dataTableConverter = new DataTableConverter();
			writer.WriteStartObject();
			foreach (DataTable table in obj.Tables)
			{
				writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName(table.TableName) : table.TableName);
				dataTableConverter.WriteJson(writer, table, serializer);
			}
			writer.WriteEndObject();
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			DataSet dataSet = ((objectType == typeof(DataSet)) ? new DataSet() : ((DataSet)Activator.CreateInstance(objectType)));
			DataTableConverter dataTableConverter = new DataTableConverter();
			reader.ReadAndAssert();
			while (reader.TokenType == JsonToken.PropertyName)
			{
				DataTable dataTable = dataSet.Tables[(string)reader.Value];
				bool num = dataTable != null;
				dataTable = (DataTable)dataTableConverter.ReadJson(reader, typeof(DataTable), dataTable, serializer);
				if (!num)
				{
					dataSet.Tables.Add(dataTable);
				}
				reader.ReadAndAssert();
			}
			return dataSet;
		}

		public override bool CanConvert(Type valueType)
		{
			return typeof(DataSet).IsAssignableFrom(valueType);
		}
	}
	internal class DataTableConverter : JsonConverter
	{
		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			DataTable obj = (DataTable)value;
			DefaultContractResolver defaultContractResolver = serializer.ContractResolver as DefaultContractResolver;
			writer.WriteStartArray();
			foreach (DataRow row in obj.Rows)
			{
				writer.WriteStartObject();
				foreach (DataColumn column in row.Table.Columns)
				{
					object obj2 = row[column];
					if (serializer.NullValueHandling != NullValueHandling.Ignore || (obj2 != null && obj2 != DBNull.Value))
					{
						writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName(column.ColumnName) : column.ColumnName);
						serializer.Serialize(writer, obj2);
					}
				}
				writer.WriteEndObject();
			}
			writer.WriteEndArray();
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			DataTable dataTable = existingValue as DataTable;
			if (dataTable == null)
			{
				dataTable = ((objectType == typeof(DataTable)) ? new DataTable() : ((DataTable)Activator.CreateInstance(objectType)));
			}
			if (reader.TokenType == JsonToken.PropertyName)
			{
				dataTable.TableName = (string)reader.Value;
				reader.ReadAndAssert();
				if (reader.TokenType == JsonToken.Null)
				{
					return dataTable;
				}
			}
			if (reader.TokenType != JsonToken.StartArray)
			{
				throw JsonSerializationException.Create(reader, "Unexpected JSON token when reading DataTable. Expected StartArray, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			reader.ReadAndAssert();
			while (reader.TokenType != JsonToken.EndArray)
			{
				CreateRow(reader, dataTable, serializer);
				reader.ReadAndAssert();
			}
			return dataTable;
		}

		private static void CreateRow(JsonReader reader, DataTable dt, JsonSerializer serializer)
		{
			DataRow dataRow = dt.NewRow();
			reader.ReadAndAssert();
			while (reader.TokenType == JsonToken.PropertyName)
			{
				string text = (string)reader.Value;
				reader.ReadAndAssert();
				DataColumn dataColumn = dt.Columns[text];
				if (dataColumn == null)
				{
					Type columnDataType = GetColumnDataType(reader);
					dataColumn = new DataColumn(text, columnDataType);
					dt.Columns.Add(dataColumn);
				}
				if (dataColumn.DataType == typeof(DataTable))
				{
					if (reader.TokenType == JsonToken.StartArray)
					{
						reader.ReadAndAssert();
					}
					DataTable dataTable = new DataTable();
					while (reader.TokenType != JsonToken.EndArray)
					{
						CreateRow(reader, dataTable, serializer);
						reader.ReadAndAssert();
					}
					dataRow[text] = dataTable;
				}
				else if (dataColumn.DataType.IsArray && dataColumn.DataType != typeof(byte[]))
				{
					if (reader.TokenType == JsonToken.StartArray)
					{
						reader.ReadAndAssert();
					}
					List<object> list = new List<object>();
					while (reader.TokenType != JsonToken.EndArray)
					{
						list.Add(reader.Value);
						reader.ReadAndAssert();
					}
					Array array = Array.CreateInstance(dataColumn.DataType.GetElementType(), list.Count);
					((ICollection)list).CopyTo(array, 0);
					dataRow[text] = array;
				}
				else
				{
					object value = ((reader.Value != null) ? (serializer.Deserialize(reader, dataColumn.DataType) ?? DBNull.Value) : DBNull.Value);
					dataRow[text] = value;
				}
				reader.ReadAndAssert();
			}
			dataRow.EndEdit();
			dt.Rows.Add(dataRow);
		}

		private static Type GetColumnDataType(JsonReader reader)
		{
			JsonToken tokenType = reader.TokenType;
			switch (tokenType)
			{
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Date:
			case JsonToken.Bytes:
				return reader.ValueType;
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.EndArray:
				return typeof(string);
			case JsonToken.StartArray:
				reader.ReadAndAssert();
				if (reader.TokenType == JsonToken.StartObject)
				{
					return typeof(DataTable);
				}
				return GetColumnDataType(reader).MakeArrayType();
			default:
				throw JsonSerializationException.Create(reader, "Unexpected JSON token when reading DataTable: {0}".FormatWith(CultureInfo.InvariantCulture, tokenType));
			}
		}

		public override bool CanConvert(Type valueType)
		{
			return typeof(DataTable).IsAssignableFrom(valueType);
		}
	}
	internal abstract class DateTimeConverterBase : JsonConverter
	{
		public override bool CanConvert(Type objectType)
		{
			if (objectType == typeof(DateTime) || objectType == typeof(DateTime?))
			{
				return true;
			}
			if (objectType == typeof(DateTimeOffset) || objectType == typeof(DateTimeOffset?))
			{
				return true;
			}
			return false;
		}
	}
	internal class DiscriminatedUnionConverter : JsonConverter
	{
		internal class Union
		{
			public readonly FSharpFunction TagReader;

			public readonly List<UnionCase> Cases;

			public Union(FSharpFunction tagReader, List<UnionCase> cases)
			{
				TagReader = tagReader;
				Cases = cases;
			}
		}

		internal class UnionCase
		{
			public readonly int Tag;

			public readonly string Name;

			public readonly PropertyInfo[] Fields;

			public readonly FSharpFunction FieldReader;

			public readonly FSharpFunction Constructor;

			public UnionCase(int tag, string name, PropertyInfo[] fields, FSharpFunction fieldReader, FSharpFunction constructor)
			{
				Tag = tag;
				Name = name;
				Fields = fields;
				FieldReader = fieldReader;
				Constructor = constructor;
			}
		}

		private const string CasePropertyName = "Case";

		private const string FieldsPropertyName = "Fields";

		private static readonly ThreadSafeStore<Type, Union> UnionCache = new ThreadSafeStore<Type, Union>(CreateUnion);

		private static readonly ThreadSafeStore<Type, Type> UnionTypeLookupCache = new ThreadSafeStore<Type, Type>(CreateUnionTypeLookup);

		private static Type CreateUnionTypeLookup(Type t)
		{
			object arg = ((object[])FSharpUtils.Instance.GetUnionCases(null, t, null)).First();
			return (Type)FSharpUtils.Instance.GetUnionCaseInfoDeclaringType(arg);
		}

		private static Union CreateUnion(Type t)
		{
			Union union = new Union((FSharpFunction)FSharpUtils.Instance.PreComputeUnionTagReader(null, t, null), new List<UnionCase>());
			object[] array = (object[])FSharpUtils.Instance.GetUnionCases(null, t, null);
			foreach (object obj in array)
			{
				UnionCase item = new UnionCase((int)FSharpUtils.Instance.GetUnionCaseInfoTag(obj), (string)FSharpUtils.Instance.GetUnionCaseInfoName(obj), (PropertyInfo[])FSharpUtils.Instance.GetUnionCaseInfoFields(obj), (FSharpFunction)FSharpUtils.Instance.PreComputeUnionReader(null, obj, null), (FSharpFunction)FSharpUtils.Instance.PreComputeUnionConstructor(null, obj, null));
				union.Cases.Add(item);
			}
			return union;
		}

		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			DefaultContractResolver defaultContractResolver = serializer.ContractResolver as DefaultContractResolver;
			Type key = UnionTypeLookupCache.Get(value.GetType());
			Union union = UnionCache.Get(key);
			int tag = (int)union.TagReader.Invoke(value);
			UnionCase unionCase = union.Cases.Single((UnionCase c) => c.Tag == tag);
			writer.WriteStartObject();
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Case") : "Case");
			writer.WriteValue(unionCase.Name);
			if (unionCase.Fields != null && unionCase.Fields.Length != 0)
			{
				object[] obj = (object[])unionCase.FieldReader.Invoke(value);
				writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Fields") : "Fields");
				writer.WriteStartArray();
				object[] array = obj;
				foreach (object value2 in array)
				{
					serializer.Serialize(writer, value2);
				}
				writer.WriteEndArray();
			}
			writer.WriteEndObject();
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			UnionCase unionCase = null;
			string caseName = null;
			JArray jArray = null;
			reader.ReadAndAssert();
			while (reader.TokenType == JsonToken.PropertyName)
			{
				string text = reader.Value.ToString();
				if (string.Equals(text, "Case", StringComparison.OrdinalIgnoreCase))
				{
					reader.ReadAndAssert();
					Union union = UnionCache.Get(objectType);
					caseName = reader.Value.ToString();
					unionCase = union.Cases.SingleOrDefault((UnionCase c) => c.Name == caseName);
					if (unionCase == null)
					{
						throw JsonSerializationException.Create(reader, "No union type found with the name '{0}'.".FormatWith(CultureInfo.InvariantCulture, caseName));
					}
				}
				else
				{
					if (!string.Equals(text, "Fields", StringComparison.OrdinalIgnoreCase))
					{
						throw JsonSerializationException.Create(reader, "Unexpected property '{0}' found when reading union.".FormatWith(CultureInfo.InvariantCulture, text));
					}
					reader.ReadAndAssert();
					if (reader.TokenType != JsonToken.StartArray)
					{
						throw JsonSerializationException.Create(reader, "Union fields must been an array.");
					}
					jArray = (JArray)JToken.ReadFrom(reader);
				}
				reader.ReadAndAssert();
			}
			if (unionCase == null)
			{
				throw JsonSerializationException.Create(reader, "No '{0}' property with union name found.".FormatWith(CultureInfo.InvariantCulture, "Case"));
			}
			object[] array = new object[unionCase.Fields.Length];
			if (unionCase.Fields.Length != 0 && jArray == null)
			{
				throw JsonSerializationException.Create(reader, "No '{0}' property with union fields found.".FormatWith(CultureInfo.InvariantCulture, "Fields"));
			}
			if (jArray != null)
			{
				if (unionCase.Fields.Length != jArray.Count)
				{
					throw JsonSerializationException.Create(reader, "The number of field values does not match the number of properties defined by union '{0}'.".FormatWith(CultureInfo.InvariantCulture, caseName));
				}
				for (int num = 0; num < jArray.Count; num++)
				{
					JToken jToken = jArray[num];
					PropertyInfo propertyInfo = unionCase.Fields[num];
					array[num] = jToken.ToObject(propertyInfo.PropertyType, serializer);
				}
			}
			object[] args = new object[1] { array };
			return unionCase.Constructor.Invoke(args);
		}

		public override bool CanConvert(Type objectType)
		{
			if (typeof(IEnumerable).IsAssignableFrom(objectType))
			{
				return false;
			}
			object[] customAttributes = objectType.GetCustomAttributes(inherit: true);
			bool flag = false;
			object[] array = customAttributes;
			for (int i = 0; i < array.Length; i++)
			{
				Type type = array[i].GetType();
				if (type.FullName == "Microsoft.FSharp.Core.CompilationMappingAttribute")
				{
					FSharpUtils.EnsureInitialized(type.Assembly());
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return false;
			}
			return (bool)FSharpUtils.Instance.IsUnion(null, objectType, null);
		}
	}
	internal class EntityKeyMemberConverter : JsonConverter
	{
		private const string EntityKeyMemberFullTypeName = "System.Data.EntityKeyMember";

		private const string KeyPropertyName = "Key";

		private const string TypePropertyName = "Type";

		private const string ValuePropertyName = "Value";

		private static ReflectionObject? _reflectionObject;

		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			EnsureReflectionObject(value.GetType());
			DefaultContractResolver defaultContractResolver = serializer.ContractResolver as DefaultContractResolver;
			string value2 = (string)_reflectionObject.GetValue(value, "Key");
			object value3 = _reflectionObject.GetValue(value, "Value");
			Type type = value3?.GetType();
			writer.WriteStartObject();
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Key") : "Key");
			writer.WriteValue(value2);
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Type") : "Type");
			writer.WriteValue(type?.FullName);
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Value") : "Value");
			if (type != null)
			{
				if (JsonSerializerInternalWriter.TryConvertToString(value3, type, out string s))
				{
					writer.WriteValue(s);
				}
				else
				{
					writer.WriteValue(value3);
				}
			}
			else
			{
				writer.WriteNull();
			}
			writer.WriteEndObject();
		}

		private static void ReadAndAssertProperty(JsonReader reader, string propertyName)
		{
			reader.ReadAndAssert();
			if (reader.TokenType != JsonToken.PropertyName || !string.Equals(reader.Value?.ToString(), propertyName, StringComparison.OrdinalIgnoreCase))
			{
				throw new JsonSerializationException("Expected JSON property '{0}'.".FormatWith(CultureInfo.InvariantCulture, propertyName));
			}
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			EnsureReflectionObject(objectType);
			object obj = _reflectionObject.Creator();
			ReadAndAssertProperty(reader, "Key");
			reader.ReadAndAssert();
			_reflectionObject.SetValue(obj, "Key", reader.Value?.ToString());
			ReadAndAssertProperty(reader, "Type");
			reader.ReadAndAssert();
			Type type = Type.GetType(reader.Value?.ToString());
			ReadAndAssertProperty(reader, "Value");
			reader.ReadAndAssert();
			_reflectionObject.SetValue(obj, "Value", serializer.Deserialize(reader, type));
			reader.ReadAndAssert();
			return obj;
		}

		private static void EnsureReflectionObject(Type objectType)
		{
			if (_reflectionObject == null)
			{
				_reflectionObject = ReflectionObject.Create(objectType, "Key", "Value");
			}
		}

		public override bool CanConvert(Type objectType)
		{
			return objectType.AssignableToTypeName("System.Data.EntityKeyMember", searchInterfaces: false);
		}
	}
	internal class ExpandoObjectConverter : JsonConverter
	{
		public override bool CanWrite => false;

		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			return ReadValue(reader);
		}

		private object? ReadValue(JsonReader reader)
		{
			if (!reader.MoveToContent())
			{
				throw JsonSerializationException.Create(reader, "Unexpected end when reading ExpandoObject.");
			}
			switch (reader.TokenType)
			{
			case JsonToken.StartObject:
				return ReadObject(reader);
			case JsonToken.StartArray:
				return ReadList(reader);
			default:
				if (JsonTokenUtils.IsPrimitiveToken(reader.TokenType))
				{
					return reader.Value;
				}
				throw JsonSerializationException.Create(reader, "Unexpected token when converting ExpandoObject: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
		}

		private object ReadList(JsonReader reader)
		{
			IList<object> list = new List<object>();
			while (reader.Read())
			{
				switch (reader.TokenType)
				{
				case JsonToken.EndArray:
					return list;
				case JsonToken.Comment:
					continue;
				}
				object item = ReadValue(reader);
				list.Add(item);
			}
			throw JsonSerializationException.Create(reader, "Unexpected end when reading ExpandoObject.");
		}

		private object ReadObject(JsonReader reader)
		{
			IDictionary<string, object> dictionary = new ExpandoObject();
			while (reader.Read())
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string key = reader.Value.ToString();
					if (!reader.Read())
					{
						throw JsonSerializationException.Create(reader, "Unexpected end when reading ExpandoObject.");
					}
					object value = ReadValue(reader);
					dictionary[key] = value;
					break;
				}
				case JsonToken.EndObject:
					return dictionary;
				}
			}
			throw JsonSerializationException.Create(reader, "Unexpected end when reading ExpandoObject.");
		}

		public override bool CanConvert(Type objectType)
		{
			return objectType == typeof(ExpandoObject);
		}
	}
	internal class IsoDateTimeConverter : DateTimeConverterBase
	{
		private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

		private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;

		private string? _dateTimeFormat;

		private CultureInfo? _culture;

		public DateTimeStyles DateTimeStyles
		{
			get
			{
				return _dateTimeStyles;
			}
			set
			{
				_dateTimeStyles = value;
			}
		}

		public string? DateTimeFormat
		{
			get
			{
				return _dateTimeFormat ?? string.Empty;
			}
			set
			{
				_dateTimeFormat = (StringUtils.IsNullOrEmpty(value) ? null : value);
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? CultureInfo.CurrentCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			string value2;
			if (value is DateTime dateTime)
			{
				if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
				{
					dateTime = dateTime.ToUniversalTime();
				}
				value2 = dateTime.ToString(_dateTimeFormat ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK", Culture);
			}
			else
			{
				if (!(value is DateTimeOffset dateTimeOffset))
				{
					throw new JsonSerializationException("Unexpected value when converting date. Expected DateTime or DateTimeOffset, got {0}.".FormatWith(CultureInfo.InvariantCulture, ReflectionUtils.GetObjectType(value)));
				}
				if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
				{
					dateTimeOffset = dateTimeOffset.ToUniversalTime();
				}
				value2 = dateTimeOffset.ToString(_dateTimeFormat ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK", Culture);
			}
			writer.WriteValue(value2);
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			bool flag = ReflectionUtils.IsNullableType(objectType);
			if (reader.TokenType == JsonToken.Null)
			{
				if (!flag)
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			Type type = (flag ? Nullable.GetUnderlyingType(objectType) : objectType);
			if (reader.TokenType == JsonToken.Date)
			{
				if (type == typeof(DateTimeOffset))
				{
					if (!(reader.Value is DateTimeOffset))
					{
						return new DateTimeOffset((DateTime)reader.Value);
					}
					return reader.Value;
				}
				if (reader.Value is DateTimeOffset dateTimeOffset)
				{
					return dateTimeOffset.DateTime;
				}
				return reader.Value;
			}
			if (reader.TokenType != JsonToken.String)
			{
				throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected String, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			string text = reader.Value?.ToString();
			if (StringUtils.IsNullOrEmpty(text) && flag)
			{
				return null;
			}
			if (type == typeof(DateTimeOffset))
			{
				if (!StringUtils.IsNullOrEmpty(_dateTimeFormat))
				{
					return DateTimeOffset.ParseExact(text, _dateTimeFormat, Culture, _dateTimeStyles);
				}
				return DateTimeOffset.Parse(text, Culture, _dateTimeStyles);
			}
			if (!StringUtils.IsNullOrEmpty(_dateTimeFormat))
			{
				return DateTime.ParseExact(text, _dateTimeFormat, Culture, _dateTimeStyles);
			}
			return DateTime.Parse(text, Culture, _dateTimeStyles);
		}
	}
	internal class JavaScriptDateTimeConverter : DateTimeConverterBase
	{
		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			long value2;
			if (value is DateTime dateTime)
			{
				value2 = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTime.ToUniversalTime());
			}
			else
			{
				if (!(value is DateTimeOffset dateTimeOffset))
				{
					throw new JsonSerializationException("Expected date object value.");
				}
				value2 = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTimeOffset.ToUniversalTime().UtcDateTime);
			}
			writer.WriteStartConstructor("Date");
			writer.WriteValue(value2);
			writer.WriteEndConstructor();
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				if (!ReflectionUtils.IsNullable(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			if (reader.TokenType != JsonToken.StartConstructor || !string.Equals(reader.Value?.ToString(), "Date", StringComparison.Ordinal))
			{
				throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing date. Token: {0}, Value: {1}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType, reader.Value));
			}
			if (!JavaScriptUtils.TryGetDateFromConstructorJson(reader, out DateTime dateTime, out string errorMessage))
			{
				throw JsonSerializationException.Create(reader, errorMessage);
			}
			if ((ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType) == typeof(DateTimeOffset))
			{
				return new DateTimeOffset(dateTime);
			}
			return dateTime;
		}
	}
	internal class KeyValuePairConverter : JsonConverter
	{
		private const string KeyName = "Key";

		private const string ValueName = "Value";

		private static readonly ThreadSafeStore<Type, ReflectionObject> ReflectionObjectPerType = new ThreadSafeStore<Type, ReflectionObject>(InitializeReflectionObject);

		private static ReflectionObject InitializeReflectionObject(Type t)
		{
			Type[] genericArguments = t.GetGenericArguments();
			Type type = ((IList<Type>)genericArguments)[0];
			Type type2 = ((IList<Type>)genericArguments)[1];
			return ReflectionObject.Create(t, t.GetConstructor(new Type[2] { type, type2 }), "Key", "Value");
		}

		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			ReflectionObject reflectionObject = ReflectionObjectPerType.Get(value.GetType());
			DefaultContractResolver defaultContractResolver = serializer.ContractResolver as DefaultContractResolver;
			writer.WriteStartObject();
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Key") : "Key");
			serializer.Serialize(writer, reflectionObject.GetValue(value, "Key"), reflectionObject.GetType("Key"));
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Value") : "Value");
			serializer.Serialize(writer, reflectionObject.GetValue(value, "Value"), reflectionObject.GetType("Value"));
			writer.WriteEndObject();
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				if (!ReflectionUtils.IsNullableType(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to KeyValuePair.");
				}
				return null;
			}
			object obj = null;
			object obj2 = null;
			reader.ReadAndAssert();
			Type key = (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType);
			ReflectionObject reflectionObject = ReflectionObjectPerType.Get(key);
			JsonContract jsonContract = serializer.ContractResolver.ResolveContract(reflectionObject.GetType("Key"));
			JsonContract jsonContract2 = serializer.ContractResolver.ResolveContract(reflectionObject.GetType("Value"));
			while (reader.TokenType == JsonToken.PropertyName)
			{
				string a = reader.Value.ToString();
				if (string.Equals(a, "Key", StringComparison.OrdinalIgnoreCase))
				{
					reader.ReadForTypeAndAssert(jsonContract, hasConverter: false);
					obj = serializer.Deserialize(reader, jsonContract.UnderlyingType);
				}
				else if (string.Equals(a, "Value", StringComparison.OrdinalIgnoreCase))
				{
					reader.ReadForTypeAndAssert(jsonContract2, hasConverter: false);
					obj2 = serializer.Deserialize(reader, jsonContract2.UnderlyingType);
				}
				else
				{
					reader.Skip();
				}
				reader.ReadAndAssert();
			}
			return reflectionObject.Creator(obj, obj2);
		}

		public override bool CanConvert(Type objectType)
		{
			Type type = (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType);
			if (type.IsValueType() && type.IsGenericType())
			{
				return type.GetGenericTypeDefinition() == typeof(KeyValuePair<, >);
			}
			return false;
		}
	}
	internal class RegexConverter : JsonConverter
	{
		private const string PatternName = "Pattern";

		private const string OptionsName = "Options";

		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			Regex regex = (Regex)value;
			if (writer is BsonWriter writer2)
			{
				WriteBson(writer2, regex);
			}
			else
			{
				WriteJson(writer, regex, serializer);
			}
		}

		private bool HasFlag(RegexOptions options, RegexOptions flag)
		{
			return (options & flag) == flag;
		}

		private void WriteBson(BsonWriter writer, Regex regex)
		{
			string text = null;
			if (HasFlag(regex.Options, RegexOptions.IgnoreCase))
			{
				text += "i";
			}
			if (HasFlag(regex.Options, RegexOptions.Multiline))
			{
				text += "m";
			}
			if (HasFlag(regex.Options, RegexOptions.Singleline))
			{
				text += "s";
			}
			text += "u";
			if (HasFlag(regex.Options, RegexOptions.ExplicitCapture))
			{
				text += "x";
			}
			writer.WriteRegex(regex.ToString(), text);
		}

		private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer)
		{
			DefaultContractResolver defaultContractResolver = serializer.ContractResolver as DefaultContractResolver;
			writer.WriteStartObject();
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Pattern") : "Pattern");
			writer.WriteValue(regex.ToString());
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Options") : "Options");
			serializer.Serialize(writer, regex.Options);
			writer.WriteEndObject();
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			return reader.TokenType switch
			{
				JsonToken.StartObject => ReadRegexObject(reader, serializer), 
				JsonToken.String => ReadRegexString(reader), 
				JsonToken.Null => null, 
				_ => throw JsonSerializationException.Create(reader, "Unexpected token when reading Regex."), 
			};
		}

		private object ReadRegexString(JsonReader reader)
		{
			string text = (string)reader.Value;
			if (text.Length > 0 && text[0] == '/')
			{
				int num = text.LastIndexOf('/');
				if (num > 0)
				{
					string pattern = text.Substring(1, num - 1);
					RegexOptions regexOptions = MiscellaneousUtils.GetRegexOptions(text.Substring(num + 1));
					return new Regex(pattern, regexOptions);
				}
			}
			throw JsonSerializationException.Create(reader, "Regex pattern must be enclosed by slashes.");
		}

		private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer)
		{
			string text = null;
			RegexOptions? regexOptions = null;
			while (reader.Read())
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string a = reader.Value.ToString();
					if (!reader.Read())
					{
						throw JsonSerializationException.Create(reader, "Unexpected end when reading Regex.");
					}
					if (string.Equals(a, "Pattern", StringComparison.OrdinalIgnoreCase))
					{
						text = (string)reader.Value;
					}
					else if (string.Equals(a, "Options", StringComparison.OrdinalIgnoreCase))
					{
						regexOptions = serializer.Deserialize<RegexOptions>(reader);
					}
					else
					{
						reader.Skip();
					}
					break;
				}
				case JsonToken.EndObject:
					if (text == null)
					{
						throw JsonSerializationException.Create(reader, "Error deserializing Regex. No pattern found.");
					}
					return new Regex(text, regexOptions.GetValueOrDefault());
				}
			}
			throw JsonSerializationException.Create(reader, "Unexpected end when reading Regex.");
		}

		public override bool CanConvert(Type objectType)
		{
			if (objectType.Name == "Regex")
			{
				return IsRegex(objectType);
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private bool IsRegex(Type objectType)
		{
			return objectType == typeof(Regex);
		}
	}
	internal class StringEnumConverter : JsonConverter
	{
		[Obsolete("StringEnumConverter.CamelCaseText is obsolete. Set StringEnumConverter.NamingStrategy with CamelCaseNamingStrategy instead.")]
		public bool CamelCaseText
		{
			get
			{
				return NamingStrategy is CamelCaseNamingStrategy;
			}
			set
			{
				if (value)
				{
					if (!(NamingStrategy is CamelCaseNamingStrategy))
					{
						NamingStrategy = new CamelCaseNamingStrategy();
					}
				}
				else if (NamingStrategy is CamelCaseNamingStrategy)
				{
					NamingStrategy = null;
				}
			}
		}

		public NamingStrategy? NamingStrategy { get; set; }

		public bool AllowIntegerValues { get; set; } = true;

		public StringEnumConverter()
		{
		}

		[Obsolete("StringEnumConverter(bool) is obsolete. Create a converter with StringEnumConverter(NamingStrategy, bool) instead.")]
		public StringEnumConverter(bool camelCaseText)
		{
			if (camelCaseText)
			{
				NamingStrategy = new CamelCaseNamingStrategy();
			}
		}

		public StringEnumConverter(NamingStrategy namingStrategy, bool allowIntegerValues = true)
		{
			NamingStrategy = namingStrategy;
			AllowIntegerValues = allowIntegerValues;
		}

		public StringEnumConverter(Type namingStrategyType)
		{
			ValidationUtils.ArgumentNotNull(namingStrategyType, "namingStrategyType");
			NamingStrategy = JsonTypeReflector.CreateNamingStrategyInstance(namingStrategyType, null);
		}

		public StringEnumConverter(Type namingStrategyType, object[] namingStrategyParameters)
		{
			ValidationUtils.ArgumentNotNull(namingStrategyType, "namingStrategyType");
			NamingStrategy = JsonTypeReflector.CreateNamingStrategyInstance(namingStrategyType, namingStrategyParameters);
		}

		public StringEnumConverter(Type namingStrategyType, object[] namingStrategyParameters, bool allowIntegerValues)
		{
			ValidationUtils.ArgumentNotNull(namingStrategyType, "namingStrategyType");
			NamingStrategy = JsonTypeReflector.CreateNamingStrategyInstance(namingStrategyType, namingStrategyParameters);
			AllowIntegerValues = allowIntegerValues;
		}

		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			Enum obj = (Enum)value;
			if (!EnumUtils.TryToString(obj.GetType(), value, NamingStrategy, out string name))
			{
				if (!AllowIntegerValues)
				{
					throw JsonSerializationException.Create(null, writer.ContainerPath, "Integer value {0} is not allowed.".FormatWith(CultureInfo.InvariantCulture, obj.ToString("D")), null);
				}
				writer.WriteValue(value);
			}
			else
			{
				writer.WriteValue(name);
			}
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				if (!ReflectionUtils.IsNullableType(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			bool flag = ReflectionUtils.IsNullableType(objectType);
			Type type = (flag ? Nullable.GetUnderlyingType(objectType) : objectType);
			try
			{
				if (reader.TokenType == JsonToken.String)
				{
					string value = reader.Value?.ToString();
					if (StringUtils.IsNullOrEmpty(value) && flag)
					{
						return null;
					}
					return EnumUtils.ParseEnum(type, NamingStrategy, value, !AllowIntegerValues);
				}
				if (reader.TokenType == JsonToken.Integer)
				{
					if (!AllowIntegerValues)
					{
						throw JsonSerializationException.Create(reader, "Integer value {0} is not allowed.".FormatWith(CultureInfo.InvariantCulture, reader.Value));
					}
					return ConvertUtils.ConvertOrCast(reader.Value, CultureInfo.InvariantCulture, type);
				}
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(reader, "Error converting value {0} to type '{1}'.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(reader.Value), objectType), ex);
			}
			throw JsonSerializationException.Create(reader, "Unexpected token {0} when parsing enum.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}

		public override bool CanConvert(Type objectType)
		{
			return (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType).IsEnum();
		}
	}
	internal class UnixDateTimeConverter : DateTimeConverterBase
	{
		internal static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			long num;
			if (value is DateTime dateTime)
			{
				num = (long)(dateTime.ToUniversalTime() - UnixEpoch).TotalSeconds;
			}
			else
			{
				if (!(value is DateTimeOffset dateTimeOffset))
				{
					throw new JsonSerializationException("Expected date object value.");
				}
				num = (long)(dateTimeOffset.ToUniversalTime() - UnixEpoch).TotalSeconds;
			}
			if (num < 0)
			{
				throw new JsonSerializationException("Cannot convert date value that is before Unix epoch of 00:00:00 UTC on 1 January 1970.");
			}
			writer.WriteValue(num);
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			bool flag = ReflectionUtils.IsNullable(objectType);
			if (reader.TokenType == JsonToken.Null)
			{
				if (!flag)
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			long result;
			if (reader.TokenType == JsonToken.Integer)
			{
				result = (long)reader.Value;
			}
			else
			{
				if (reader.TokenType != JsonToken.String)
				{
					throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected Integer or String, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
				}
				if (!long.TryParse((string)reader.Value, out result))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert invalid value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
			}
			if (result >= 0)
			{
				DateTime unixEpoch = UnixEpoch;
				DateTime dateTime = unixEpoch.AddSeconds(result);
				if ((flag ? Nullable.GetUnderlyingType(objectType) : objectType) == typeof(DateTimeOffset))
				{
					return new DateTimeOffset(dateTime, TimeSpan.Zero);
				}
				return dateTime;
			}
			throw JsonSerializationException.Create(reader, "Cannot convert value that is before Unix epoch of 00:00:00 UTC on 1 January 1970 to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
		}
	}
	internal class VersionConverter : JsonConverter
	{
		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			if (value is Version)
			{
				writer.WriteValue(value.ToString());
				return;
			}
			throw new JsonSerializationException("Expected Version object value");
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			if (reader.TokenType == JsonToken.String)
			{
				try
				{
					return new Version((string)reader.Value);
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error parsing version string: {0}".FormatWith(CultureInfo.InvariantCulture, reader.Value), ex);
				}
			}
			throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing version. Token: {0}, Value: {1}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType, reader.Value));
		}

		public override bool CanConvert(Type objectType)
		{
			return objectType == typeof(Version);
		}
	}
	internal class XmlDocumentWrapper : XmlNodeWrapper, IXmlDocument, IXmlNode
	{
		private readonly XmlDocument _document;

		public IXmlElement? DocumentElement
		{
			get
			{
				if (_document.DocumentElement == null)
				{
					return null;
				}
				return new XmlElementWrapper(_document.DocumentElement);
			}
		}

		public XmlDocumentWrapper(XmlDocument document)
			: base(document)
		{
			_document = document;
		}

		public IXmlNode CreateComment(string? data)
		{
			return new XmlNodeWrapper(_document.CreateComment(data));
		}

		public IXmlNode CreateTextNode(string? text)
		{
			return new XmlNodeWrapper(_document.CreateTextNode(text));
		}

		public IXmlNode CreateCDataSection(string? data)
		{
			return new XmlNodeWrapper(_document.CreateCDataSection(data));
		}

		public IXmlNode CreateWhitespace(string? text)
		{
			return new XmlNodeWrapper(_document.CreateWhitespace(text));
		}

		public IXmlNode CreateSignificantWhitespace(string? text)
		{
			return new XmlNodeWrapper(_document.CreateSignificantWhitespace(text));
		}

		public IXmlNode CreateXmlDeclaration(string? version, string? encoding, string? standalone)
		{
			return new XmlDeclarationWrapper(_document.CreateXmlDeclaration(version, encoding, standalone));
		}

		public IXmlNode CreateXmlDocumentType(string? name, string? publicId, string? systemId, string? internalSubset)
		{
			return new XmlDocumentTypeWrapper(_document.CreateDocumentType(name, publicId, systemId, null));
		}

		public IXmlNode CreateProcessingInstruction(string target, string? data)
		{
			return new XmlNodeWrapper(_document.CreateProcessingInstruction(target, data));
		}

		public IXmlElement CreateElement(string elementName)
		{
			return new XmlElementWrapper(_document.CreateElement(elementName));
		}

		public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
		{
			return new XmlElementWrapper(_document.CreateElement(qualifiedName, namespaceUri));
		}

		public IXmlNode CreateAttribute(string name, string? value)
		{
			return new XmlNodeWrapper(_document.CreateAttribute(name))
			{
				Value = value
			};
		}

		public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string? value)
		{
			return new XmlNodeWrapper(_document.CreateAttribute(qualifiedName, namespaceUri))
			{
				Value = value
			};
		}
	}
	internal class XmlElementWrapper : XmlNodeWrapper, IXmlElement, IXmlNode
	{
		private readonly XmlElement _element;

		public bool IsEmpty => _element.IsEmpty;

		public XmlElementWrapper(XmlElement element)
			: base(element)
		{
			_element = element;
		}

		public void SetAttributeNode(IXmlNode attribute)
		{
			XmlNodeWrapper xmlNodeWrapper = (XmlNodeWrapper)attribute;
			_element.SetAttributeNode((XmlAttribute)xmlNodeWrapper.WrappedNode);
		}

		public string GetPrefixOfNamespace(string namespaceUri)
		{
			return _element.GetPrefixOfNamespace(namespaceUri);
		}
	}
	internal class XmlDeclarationWrapper : XmlNodeWrapper, IXmlDeclaration, IXmlNode
	{
		private readonly XmlDeclaration _declaration;

		public string Version => _declaration.Version;

		public string Encoding
		{
			get
			{
				return _declaration.Encoding;
			}
			set
			{
				_declaration.Encoding = value;
			}
		}

		public string Standalone
		{
			get
			{
				return _declaration.Standalone;
			}
			set
			{
				_declaration.Standalone = value;
			}
		}

		public XmlDeclarationWrapper(XmlDeclaration declaration)
			: base(declaration)
		{
			_declaration = declaration;
		}
	}
	internal class XmlDocumentTypeWrapper : XmlNodeWrapper, IXmlDocumentType, IXmlNode
	{
		private readonly XmlDocumentType _documentType;

		public string Name => _documentType.Name;

		public string System => _documentType.SystemId;

		public string Public => _documentType.PublicId;

		public string InternalSubset => _documentType.InternalSubset;

		public override string? LocalName => "DOCTYPE";

		public XmlDocumentTypeWrapper(XmlDocumentType documentType)
			: base(documentType)
		{
			_documentType = documentType;
		}
	}
	internal class XmlNodeWrapper : IXmlNode
	{
		private readonly XmlNode _node;

		private List<IXmlNode>? _childNodes;

		private List<IXmlNode>? _attributes;

		public object? WrappedNode => _node;

		public XmlNodeType NodeType => _node.NodeType;

		public virtual string? LocalName => _node.LocalName;

		public List<IXmlNode> ChildNodes
		{
			get
			{
				if (_childNodes == null)
				{
					if (!_node.HasChildNodes)
					{
						_childNodes = XmlNodeConverter.EmptyChildNodes;
					}
					else
					{
						_childNodes = new List<IXmlNode>(_node.ChildNodes.Count);
						foreach (XmlNode childNode in _node.ChildNodes)
						{
							_childNodes.Add(WrapNode(childNode));
						}
					}
				}
				return _childNodes;
			}
		}

		protected virtual bool HasChildNodes => _node.HasChildNodes;

		public List<IXmlNode> Attributes
		{
			get
			{
				if (_attributes == null)
				{
					if (!HasAttributes)
					{
						_attributes = XmlNodeConverter.EmptyChildNodes;
					}
					else
					{
						_attributes = new List<IXmlNode>(_node.Attributes.Count);
						foreach (XmlAttribute attribute in _node.Attributes)
						{
							_attributes.Add(WrapNode(attribute));
						}
					}
				}
				return _attributes;
			}
		}

		private bool HasAttributes
		{
			get
			{
				if (_node is XmlElement xmlElement)
				{
					return xmlElement.HasAttributes;
				}
				XmlAttributeCollection attributes = _node.Attributes;
				if (attributes == null)
				{
					return false;
				}
				return attributes.Count > 0;
			}
		}

		public IXmlNode? ParentNode
		{
			get
			{
				XmlNode xmlNode = ((_node is XmlAttribute xmlAttribute) ? xmlAttribute.OwnerElement : _node.ParentNode);
				if (xmlNode == null)
				{
					return null;
				}
				return WrapNode(xmlNode);
			}
		}

		public string? Value
		{
			get
			{
				return _node.Value;
			}
			set
			{
				_node.Value = value;
			}
		}

		public string? NamespaceUri => _node.NamespaceURI;

		public XmlNodeWrapper(XmlNode node)
		{
			_node = node;
		}

		internal static IXmlNode WrapNode(XmlNode node)
		{
			return node.NodeType switch
			{
				XmlNodeType.Element => new XmlElementWrapper((XmlElement)node), 
				XmlNodeType.XmlDeclaration => new XmlDeclarationWrapper((XmlDeclaration)node), 
				XmlNodeType.DocumentType => new XmlDocumentTypeWrapper((XmlDocumentType)node), 
				_ => new XmlNodeWrapper(node), 
			};
		}

		public IXmlNode AppendChild(IXmlNode newChild)
		{
			XmlNodeWrapper xmlNodeWrapper = (XmlNodeWrapper)newChild;
			_node.AppendChild(xmlNodeWrapper._node);
			_childNodes = null;
			_attributes = null;
			return newChild;
		}
	}
	internal interface IXmlDocument : IXmlNode
	{
		IXmlElement? DocumentElement { get; }

		IXmlNode CreateComment(string? text);

		IXmlNode CreateTextNode(string? text);

		IXmlNode CreateCDataSection(string? data);

		IXmlNode CreateWhitespace(string? text);

		IXmlNode CreateSignificantWhitespace(string? text);

		IXmlNode CreateXmlDeclaration(string? version, string? encoding, string? standalone);

		IXmlNode CreateXmlDocumentType(string? name, string? publicId, string? systemId, string? internalSubset);

		IXmlNode CreateProcessingInstruction(string target, string? data);

		IXmlElement CreateElement(string elementName);

		IXmlElement CreateElement(string qualifiedName, string namespaceUri);

		IXmlNode CreateAttribute(string name, string? value);

		IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string? value);
	}
	internal interface IXmlDeclaration : IXmlNode
	{
		string Version { get; }

		string Encoding { get; set; }

		string Standalone { get; set; }
	}
	internal interface IXmlDocumentType : IXmlNode
	{
		string Name { get; }

		string System { get; }

		string Public { get; }

		string InternalSubset { get; }
	}
	internal interface IXmlElement : IXmlNode
	{
		bool IsEmpty { get; }

		void SetAttributeNode(IXmlNode attribute);

		string GetPrefixOfNamespace(string namespaceUri);
	}
	internal interface IXmlNode
	{
		XmlNodeType NodeType { get; }

		string? LocalName { get; }

		List<IXmlNode> ChildNodes { get; }

		List<IXmlNode> Attributes { get; }

		IXmlNode? ParentNode { get; }

		string? Value { get; set; }

		string? NamespaceUri { get; }

		object? WrappedNode { get; }

		IXmlNode AppendChild(IXmlNode newChild);
	}
	internal class XDeclarationWrapper : XObjectWrapper, IXmlDeclaration, IXmlNode
	{
		internal XDeclaration Declaration { get; }

		public override XmlNodeType NodeType => XmlNodeType.XmlDeclaration;

		public string Version => Declaration.Version;

		public string Encoding
		{
			get
			{
				return Declaration.Encoding;
			}
			set
			{
				Declaration.Encoding = value;
			}
		}

		public string Standalone
		{
			get
			{
				return Declaration.Standalone;
			}
			set
			{
				Declaration.Standalone = value;
			}
		}

		public XDeclarationWrapper(XDeclaration declaration)
			: base(null)
		{
			Declaration = declaration;
		}
	}
	internal class XDocumentTypeWrapper : XObjectWrapper, IXmlDocumentType, IXmlNode
	{
		private readonly XDocumentType _documentType;

		public string Name => _documentType.Name;

		public string System => _documentType.SystemId;

		public string Public => _documentType.PublicId;

		public string InternalSubset => _documentType.InternalSubset;

		public override string? LocalName => "DOCTYPE";

		public XDocumentTypeWrapper(XDocumentType documentType)
			: base(documentType)
		{
			_documentType = documentType;
		}
	}
	internal class XDocumentWrapper : XContainerWrapper, IXmlDocument, IXmlNode
	{
		private XDocument Document => (XDocument)base.WrappedNode;

		public override List<IXmlNode> ChildNodes
		{
			get
			{
				List<IXmlNode> childNodes = base.ChildNodes;
				if (Document.Declaration != null && (childNodes.Count == 0 || childNodes[0].NodeType != XmlNodeType.XmlDeclaration))
				{
					childNodes.Insert(0, new XDeclarationWrapper(Document.Declaration));
				}
				return childNodes;
			}
		}

		protected override bool HasChildNodes
		{
			get
			{
				if (base.HasChildNodes)
				{
					return true;
				}
				return Document.Declaration != null;
			}
		}

		public IXmlElement? DocumentElement
		{
			get
			{
				if (Document.Root == null)
				{
					return null;
				}
				return new XElementWrapper(Document.Root);
			}
		}

		public XDocumentWrapper(XDocument document)
			: base(document)
		{
		}

		public IXmlNode CreateComment(string? text)
		{
			return new XObjectWrapper(new XComment(text));
		}

		public IXmlNode CreateTextNode(string? text)
		{
			return new XObjectWrapper(new XText(text));
		}

		public IXmlNode CreateCDataSection(string? data)
		{
			return new XObjectWrapper(new XCData(data));
		}

		public IXmlNode CreateWhitespace(string? text)
		{
			return new XObjectWrapper(new XText(text));
		}

		public IXmlNode CreateSignificantWhitespace(string? text)
		{
			return new XObjectWrapper(new XText(text));
		}

		public IXmlNode CreateXmlDeclaration(string? version, string? encoding, string? standalone)
		{
			return new XDeclarationWrapper(new XDeclaration(version, encoding, standalone));
		}

		public IXmlNode CreateXmlDocumentType(string? name, string? publicId, string? systemId, string? internalSubset)
		{
			return new XDocumentTypeWrapper(new XDocumentType(name, publicId, systemId, internalSubset));
		}

		public IXmlNode CreateProcessingInstruction(string target, string? data)
		{
			return new XProcessingInstructionWrapper(new XProcessingInstruction(target, data));
		}

		public IXmlElement CreateElement(string elementName)
		{
			return new XElementWrapper(new XElement(elementName));
		}

		public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
		{
			return new XElementWrapper(new XElement(XName.Get(MiscellaneousUtils.GetLocalName(qualifiedName), namespaceUri)));
		}

		public IXmlNode CreateAttribute(string name, string? value)
		{
			return new XAttributeWrapper(new XAttribute(name, value));
		}

		public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string? value)
		{
			return new XAttributeWrapper(new XAttribute(XName.Get(MiscellaneousUtils.GetLocalName(qualifiedName), namespaceUri), value));
		}

		public override IXmlNode AppendChild(IXmlNode newChild)
		{
			if (newChild is XDeclarationWrapper xDeclarationWrapper)
			{
				Document.Declaration = xDeclarationWrapper.Declaration;
				return xDeclarationWrapper;
			}
			return base.AppendChild(newChild);
		}
	}
	internal class XTextWrapper : XObjectWrapper
	{
		private XText Text => (XText)base.WrappedNode;

		public override string? Value
		{
			get
			{
				return Text.Value;
			}
			set
			{
				Text.Value = value;
			}
		}

		public override IXmlNode? ParentNode
		{
			get
			{
				if (Text.Parent == null)
				{
					return null;
				}
				return XContainerWrapper.WrapNode(Text.Parent);
			}
		}

		public XTextWrapper(XText text)
			: base(text)
		{
		}
	}
	internal class XCommentWrapper : XObjectWrapper
	{
		private XComment Text => (XComment)base.WrappedNode;

		public override string? Value
		{
			get
			{
				return Text.Value;
			}
			set
			{
				Text.Value = value;
			}
		}

		public override IXmlNode? ParentNode
		{
			get
			{
				if (Text.Parent == null)
				{
					return null;
				}
				return XContainerWrapper.WrapNode(Text.Parent);
			}
		}

		public XCommentWrapper(XComment text)
			: base(text)
		{
		}
	}
	internal class XProcessingInstructionWrapper : XObjectWrapper
	{
		private XProcessingInstruction ProcessingInstruction => (XProcessingInstruction)base.WrappedNode;

		public override string? LocalName => ProcessingInstruction.Target;

		public override string? Value
		{
			get
			{
				return ProcessingInstruction.Data;
			}
			set
			{
				ProcessingInstruction.Data = value;
			}
		}

		public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction)
			: base(processingInstruction)
		{
		}
	}
	internal class XContainerWrapper : XObjectWrapper
	{
		private List<IXmlNode>? _childNodes;

		private XContainer Container => (XContainer)base.WrappedNode;

		public override List<IXmlNode> ChildNodes
		{
			get
			{
				if (_childNodes == null)
				{
					if (!HasChildNodes)
					{
						_childNodes = XmlNodeConverter.EmptyChildNodes;
					}
					else
					{
						_childNodes = new List<IXmlNode>();
						foreach (XNode item in Container.Nodes())
						{
							_childNodes.Add(WrapNode(item));
						}
					}
				}
				return _childNodes;
			}
		}

		protected virtual bool HasChildNodes => Container.LastNode != null;

		public override IXmlNode? ParentNode
		{
			get
			{
				if (Container.Parent == null)
				{
					return null;
				}
				return WrapNode(Container.Parent);
			}
		}

		public XContainerWrapper(XContainer container)
			: base(container)
		{
		}

		internal static IXmlNode WrapNode(XObject node)
		{
			if (node is XDocument document)
			{
				return new XDocumentWrapper(document);
			}
			if (node is XElement element)
			{
				return new XElementWrapper(element);
			}
			if (node is XContainer container)
			{
				return new XContainerWrapper(container);
			}
			if (node is XProcessingInstruction processingInstruction)
			{
				return new XProcessingInstructionWrapper(processingInstruction);
			}
			if (node is XText text)
			{
				return new XTextWrapper(text);
			}
			if (node is XComment text2)
			{
				return new XCommentWrapper(text2);
			}
			if (node is XAttribute attribute)
			{
				return new XAttributeWrapper(attribute);
			}
			if (node is XDocumentType documentType)
			{
				return new XDocumentTypeWrapper(documentType);
			}
			return new XObjectWrapper(node);
		}

		public override IXmlNode AppendChild(IXmlNode newChild)
		{
			Container.Add(newChild.WrappedNode);
			_childNodes = null;
			return newChild;
		}
	}
	internal class XObjectWrapper : IXmlNode
	{
		private readonly XObject? _xmlObject;

		public object? WrappedNode => _xmlObject;

		public virtual XmlNodeType NodeType => _xmlObject?.NodeType ?? XmlNodeType.None;

		public virtual string? LocalName => null;

		public virtual List<IXmlNode> ChildNodes => XmlNodeConverter.EmptyChildNodes;

		public virtual List<IXmlNode> Attributes => XmlNodeConverter.EmptyChildNodes;

		public virtual IXmlNode? ParentNode => null;

		public virtual string? Value
		{
			get
			{
				return null;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public virtual string? NamespaceUri => null;

		public XObjectWrapper(XObject? xmlObject)
		{
			_xmlObject = xmlObject;
		}

		public virtual IXmlNode AppendChild(IXmlNode newChild)
		{
			throw new InvalidOperationException();
		}
	}
	internal class XAttributeWrapper : XObjectWrapper
	{
		private XAttribute Attribute => (XAttribute)base.WrappedNode;

		public override string? Value
		{
			get
			{
				return Attribute.Value;
			}
			set
			{
				Attribute.Value = value;
			}
		}

		public override string? LocalName => Attribute.Name.LocalName;

		public override string? NamespaceUri => Attribute.Name.NamespaceName;

		public override IXmlNode? ParentNode
		{
			get
			{
				if (Attribute.Parent == null)
				{
					return null;
				}
				return XContainerWrapper.WrapNode(Attribute.Parent);
			}
		}

		public XAttributeWrapper(XAttribute attribute)
			: base(attribute)
		{
		}
	}
	internal class XElementWrapper : XContainerWrapper, IXmlElement, IXmlNode
	{
		private List<IXmlNode>? _attributes;

		private XElement Element => (XElement)base.WrappedNode;

		public override List<IXmlNode> Attributes
		{
			get
			{
				if (_attributes == null)
				{
					if (!Element.HasAttributes && !HasImplicitNamespaceAttribute(NamespaceUri))
					{
						_attributes = XmlNodeConverter.EmptyChildNodes;
					}
					else
					{
						_attributes = new List<IXmlNode>();
						foreach (XAttribute item in Element.Attributes())
						{
							_attributes.Add(new XAttributeWrapper(item));
						}
						string namespaceUri = NamespaceUri;
						if (HasImplicitNamespaceAttribute(namespaceUri))
						{
							_attributes.Insert(0, new XAttributeWrapper(new XAttribute("xmlns", namespaceUri)));
						}
					}
				}
				return _attributes;
			}
		}

		public override string? Value
		{
			get
			{
				return Element.Value;
			}
			set
			{
				Element.Value = value;
			}
		}

		public override string? LocalName => Element.Name.LocalName;

		public override string? NamespaceUri => Element.Name.NamespaceName;

		public bool IsEmpty => Element.IsEmpty;

		public XElementWrapper(XElement element)
			: base(element)
		{
		}

		public void SetAttributeNode(IXmlNode attribute)
		{
			XObjectWrapper xObjectWrapper = (XObjectWrapper)attribute;
			Element.Add(xObjectWrapper.WrappedNode);
			_attributes = null;
		}

		private bool HasImplicitNamespaceAttribute(string namespaceUri)
		{
			if (!StringUtils.IsNullOrEmpty(namespaceUri) && namespaceUri != ParentNode?.NamespaceUri && StringUtils.IsNullOrEmpty(GetPrefixOfNamespace(namespaceUri)))
			{
				bool flag = false;
				if (Element.HasAttributes)
				{
					foreach (XAttribute item in Element.Attributes())
					{
						if (item.Name.LocalName == "xmlns" && StringUtils.IsNullOrEmpty(item.Name.NamespaceName) && item.Value == namespaceUri)
						{
							flag = true;
						}
					}
				}
				if (!flag)
				{
					return true;
				}
			}
			return false;
		}

		public override IXmlNode AppendChild(IXmlNode newChild)
		{
			IXmlNode result = base.AppendChild(newChild);
			_attributes = null;
			return result;
		}

		public string GetPrefixOfNamespace(string namespaceUri)
		{
			return Element.GetPrefixOfNamespace(namespaceUri);
		}
	}
	internal class XmlNodeConverter : JsonConverter
	{
		internal static readonly List<IXmlNode> EmptyChildNodes = new List<IXmlNode>();

		private const string TextName = "#text";

		private const string CommentName = "#comment";

		private const string CDataName = "#cdata-section";

		private const string WhitespaceName = "#whitespace";

		private const string SignificantWhitespaceName = "#significant-whitespace";

		private const string DeclarationName = "?xml";

		private const string JsonNamespaceUri = "http://james.newtonking.com/projects/json";

		public string? DeserializeRootElementName { get; set; }

		public bool WriteArrayAttribute { get; set; }

		public bool OmitRootObject { get; set; }

		public bool EncodeSpecialCharacters { get; set; }

		public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			IXmlNode node = WrapXml(value);
			XmlNamespaceManager manager = new XmlNamespaceManager(new NameTable());
			PushParentNamespaces(node, manager);
			if (!OmitRootObject)
			{
				writer.WriteStartObject();
			}
			SerializeNode(writer, node, manager, !OmitRootObject);
			if (!OmitRootObject)
			{
				writer.WriteEndObject();
			}
		}

		private IXmlNode WrapXml(object value)
		{
			if (value is XObject node)
			{
				return XContainerWrapper.WrapNode(node);
			}
			if (value is XmlNode node2)
			{
				return XmlNodeWrapper.WrapNode(node2);
			}
			throw new ArgumentException("Value must be an XML object.", "value");
		}

		private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager)
		{
			List<IXmlNode> list = null;
			IXmlNode xmlNode = node;
			while ((xmlNode = xmlNode.ParentNode) != null)
			{
				if (xmlNode.NodeType == XmlNodeType.Element)
				{
					if (list == null)
					{
						list = new List<IXmlNode>();
					}
					list.Add(xmlNode);
				}
			}
			if (list == null)
			{
				return;
			}
			list.Reverse();
			foreach (IXmlNode item in list)
			{
				manager.PushScope();
				foreach (IXmlNode attribute in item.Attributes)
				{
					if (attribute.NamespaceUri == "http://www.w3.org/2000/xmlns/" && attribute.LocalName != "xmlns")
					{
						manager.AddNamespace(attribute.LocalName, attribute.Value);
					}
				}
			}
		}

		private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager)
		{
			string text = ((node.NamespaceUri == null || (node.LocalName == "xmlns" && node.NamespaceUri == "http://www.w3.org/2000/xmlns/")) ? null : manager.LookupPrefix(node.NamespaceUri));
			if (!StringUtils.IsNullOrEmpty(text))
			{
				return text + ":" + XmlConvert.DecodeName(node.LocalName);
			}
			return XmlConvert.DecodeName(node.LocalName);
		}

		private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager)
		{
			switch (node.NodeType)
			{
			case XmlNodeType.Attribute:
				if (node.NamespaceUri == "http://james.newtonking.com/projects/json")
				{
					return "$" + node.LocalName;
				}
				return "@" + ResolveFullName(node, manager);
			case XmlNodeType.CDATA:
				return "#cdata-section";
			case XmlNodeType.Comment:
				return "#comment";
			case XmlNodeType.Element:
				if (node.NamespaceUri == "http://james.newtonking.com/projects/json")
				{
					return "$" + node.LocalName;
				}
				return ResolveFullName(node, manager);
			case XmlNodeType.ProcessingInstruction:
				return "?" + ResolveFullName(node, manager);
			case XmlNodeType.DocumentType:
				return "!" + ResolveFullName(node, manager);
			case XmlNodeType.XmlDeclaration:
				return "?xml";
			case XmlNodeType.SignificantWhitespace:
				return "#significant-whitespace";
			case XmlNodeType.Text:
				return "#text";
			case XmlNodeType.Whitespace:
				return "#whitespace";
			default:
				throw new JsonSerializationException("Unexpected XmlNodeType when getting node name: " + node.NodeType);
			}
		}

		private bool IsArray(IXmlNode node)
		{
			foreach (IXmlNode attribute in node.Attributes)
			{
				if (attribute.LocalName == "Array" && attribute.NamespaceUri == "http://james.newtonking.com/projects/json")
				{
					return XmlConvert.ToBoolean(attribute.Value);
				}
			}
			return false;
		}

		private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
		{
			switch (node.ChildNodes.Count)
			{
			case 1:
			{
				string propertyName = GetPropertyName(node.ChildNodes[0], manager);
				WriteGroupedNodes(writer, manager, writePropertyName, node.ChildNodes, propertyName);
				return;
			}
			case 0:
				return;
			}
			Dictionary<string, object> dictionary = null;
			string text = null;
			for (int i = 0; i < node.ChildNodes.Count; i++)
			{
				IXmlNode xmlNode = node.ChildNodes[i];
				string propertyName2 = GetPropertyName(xmlNode, manager);
				object value;
				if (dictionary == null)
				{
					if (text == null)
					{
						text = propertyName2;
						continue;
					}
					if (propertyName2 == text)
					{
						continue;
					}
					dictionary = new Dictionary<string, object>();
					if (i > 1)
					{
						List<IXmlNode> list = new List<IXmlNode>(i);
						for (int j = 0; j < i; j++)
						{
							list.Add(node.ChildNodes[j]);
						}
						dictionary.Add(text, list);
					}
					else
					{
						dictionary.Add(text, node.ChildNodes[0]);
					}
					dictionary.Add(propertyName2, xmlNode);
				}
				else if (!dictionary.TryGetValue(propertyName2, out value))
				{
					dictionary.Add(propertyName2, xmlNode);
				}
				else
				{
					List<IXmlNode> list2 = value as List<IXmlNode>;
					if (list2 == null)
					{
						list2 = (List<IXmlNode>)(dictionary[propertyName2] = new List<IXmlNode> { (IXmlNode)value });
					}
					list2.Add(xmlNode);
				}
			}
			if (dictionary == null)
			{
				WriteGroupedNodes(writer, manager, writePropertyName, node.ChildNodes, text);
				return;
			}
			foreach (KeyValuePair<string, object> item in dictionary)
			{
				if (item.Value is List<IXmlNode> groupedNodes)
				{
					WriteGroupedNodes(writer, manager, writePropertyName, groupedNodes, item.Key);
				}
				else
				{
					WriteGroupedNodes(writer, manager, writePropertyName, (IXmlNode)item.Value, item.Key);
				}
			}
		}

		private void WriteGroupedNodes(JsonWriter writer, XmlNamespaceManager manager, bool writePropertyName, List<IXmlNode> groupedNodes, string elementNames)
		{
			if (groupedNodes.Count == 1 && !IsArray(groupedNodes[0]))
			{
				SerializeNode(writer, groupedNodes[0], manager, writePropertyName);
				return;
			}
			if (writePropertyName)
			{
				writer.WritePropertyName(elementNames);
			}
			writer.WriteStartArray();
			for (int i = 0; i < groupedNodes.Count; i++)
			{
				SerializeNode(writer, groupedNodes[i], manager, writePropertyName: false);
			}
			writer.WriteEndArray();
		}

		private void WriteGroupedNodes(JsonWriter writer, XmlNamespaceManager manager, bool writePropertyName, IXmlNode node, string elementNames)
		{
			if (!IsArray(node))
			{
				SerializeNode(writer, node, manager, writePropertyName);
				return;
			}
			if (writePropertyName)
			{
				writer.WritePropertyName(elementNames);
			}
			writer.WriteStartArray();
			SerializeNode(writer, node, manager, writePropertyName: false);
			writer.WriteEndArray();
		}

		private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
		{
			switch (node.NodeType)
			{
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
				SerializeGroupedNodes(writer, node, manager, writePropertyName);
				break;
			case XmlNodeType.Element:
				if (IsArray(node) && AllSameName(node) && node.ChildNodes.Count > 0)
				{
					SerializeGroupedNodes(writer, node, manager, writePropertyName: false);
					break;
				}
				manager.PushScope();
				foreach (IXmlNode attribute in node.Attributes)
				{
					if (attribute.NamespaceUri == "http://www.w3.org/2000/xmlns/")
					{
						string prefix = ((attribute.LocalName != "xmlns") ? XmlConvert.DecodeName(attribute.LocalName) : string.Empty);
						string value = attribute.Value;
						if (value == null)
						{
							throw new JsonSerializationException("Namespace attribute must have a value.");
						}
						manager.AddNamespace(prefix, value);
					}
				}
				if (writePropertyName)
				{
					writer.WritePropertyName(GetPropertyName(node, manager));
				}
				if (!ValueAttributes(node.Attributes) && node.ChildNodes.Count == 1 && node.ChildNodes[0].NodeType == XmlNodeType.Text)
				{
					writer.WriteValue(node.ChildNodes[0].Value);
				}
				else if (node.ChildNodes.Count == 0 && node.Attributes.Count == 0)
				{
					if (((IXmlElement)node).IsEmpty)
					{
						writer.WriteNull();
					}
					else
					{
						writer.WriteValue(string.Empty);
					}
				}
				else
				{
					writer.WriteStartObject();
					for (int i = 0; i < node.Attributes.Count; i++)
					{
						SerializeNode(writer, node.Attributes[i], manager, writePropertyName: true);
					}
					SerializeGroupedNodes(writer, node, manager, writePropertyName: true);
					writer.WriteEndObject();
				}
				manager.PopScope();
				break;
			case XmlNodeType.Comment:
				if (writePropertyName)
				{
					writer.WriteComment(node.Value);
				}
				break;
			case XmlNodeType.Attribute:
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				if ((!(node.NamespaceUri == "http://www.w3.org/2000/xmlns/") || !(node.Value == "http://james.newtonking.com/projects/json")) && (!(node.NamespaceUri == "http://james.newtonking.com/projects/json") || !(node.LocalName == "Array")))
				{
					if (writePropertyName)
					{
						writer.WritePropertyName(GetPropertyName(node, manager));
					}
					writer.WriteValue(node.Value);
				}
				break;
			case XmlNodeType.XmlDeclaration:
			{
				IXmlDeclaration xmlDeclaration = (IXmlDeclaration)node;
				writer.WritePropertyName(GetPropertyName(node, manager));
				writer.WriteStartObject();
				if (!StringUtils.IsNullOrEmpty(xmlDeclaration.Version))
				{
					writer.WritePropertyName("@version");
					writer.WriteValue(xmlDeclaration.Version);
				}
				if (!StringUtils.IsNullOrEmpty(xmlDeclaration.Encoding))
				{
					writer.WritePropertyName("@encoding");
					writer.WriteValue(xmlDeclaration.Encoding);
				}
				if (!StringUtils.IsNullOrEmpty(xmlDeclaration.Standalone))
				{
					writer.WritePropertyName("@standalone");
					writer.WriteValue(xmlDeclaration.Standalone);
				}
				writer.WriteEndObject();
				break;
			}
			case XmlNodeType.DocumentType:
			{
				IXmlDocumentType xmlDocumentType = (IXmlDocumentType)node;
				writer.WritePropertyName(GetPropertyName(node, manager));
				writer.WriteStartObject();
				if (!StringUtils.IsNullOrEmpty(xmlDocumentType.Name))
				{
					writer.WritePropertyName("@name");
					writer.WriteValue(xmlDocumentType.Name);
				}
				if (!StringUtils.IsNullOrEmpty(xmlDocumentType.Public))
				{
					writer.WritePropertyName("@public");
					writer.WriteValue(xmlDocumentType.Public);
				}
				if (!StringUtils.IsNullOrEmpty(xmlDocumentType.System))
				{
					writer.WritePropertyName("@system");
					writer.WriteValue(xmlDocumentType.System);
				}
				if (!StringUtils.IsNullOrEmpty(xmlDocumentType.InternalSubset))
				{
					writer.WritePropertyName("@internalSubset");
					writer.WriteValue(xmlDocumentType.InternalSubset);
				}
				writer.WriteEndObject();
				break;
			}
			default:
				throw new JsonSerializationException("Unexpected XmlNodeType when serializing nodes: " + node.NodeType);
			}
		}

		private static bool AllSameName(IXmlNode node)
		{
			foreach (IXmlNode childNode in node.ChildNodes)
			{
				if (childNode.LocalName != node.LocalName)
				{
					return false;
				}
			}
			return true;
		}

		public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
		{
			switch (reader.TokenType)
			{
			case JsonToken.Null:
				return null;
			default:
				throw JsonSerializationException.Create(reader, "XmlNodeConverter can only convert JSON that begins with an object.");
			case JsonToken.StartObject:
			{
				XmlNamespaceManager manager = new XmlNamespaceManager(new NameTable());
				IXmlDocument xmlDocument = null;
				IXmlNode xmlNode = null;
				if (typeof(XObject).IsAssignableFrom(objectType))
				{
					if (objectType != typeof(XContainer) && objectType != typeof(XDocument) && objectType != typeof(XElement) && objectType != typeof(XNode) && objectType != typeof(XObject))
					{
						throw JsonSerializationException.Create(reader, "XmlNodeConverter only supports deserializing XDocument, XElement, XContainer, XNode or XObject.");
					}
					xmlDocument = new XDocumentWrapper(new XDocument());
					xmlNode = xmlDocument;
				}
				if (typeof(XmlNode).IsAssignableFrom(objectType))
				{
					if (objectType != typeof(XmlDocument) && objectType != typeof(XmlElement) && objectType != typeof(XmlNode))
					{
						throw JsonSerializationException.Create(reader, "XmlNodeConverter only supports deserializing XmlDocument, XmlElement or XmlNode.");
					}
					xmlDocument = new XmlDocumentWrapper(new XmlDocument
					{
						XmlResolver = null
					});
					xmlNode = xmlDocument;
				}
				if (xmlDocument == null || xmlNode == null)
				{
					throw JsonSerializationException.Create(reader, "Unexpected type when converting XML: " + objectType);
				}
				if (!StringUtils.IsNullOrEmpty(DeserializeRootElementName))
				{
					ReadElement(reader, xmlDocument, xmlNode, DeserializeRootElementName, manager);
				}
				else
				{
					reader.ReadAndAssert();
					DeserializeNode(reader, xmlDocument, manager, xmlNode);
				}
				if (objectType == typeof(XElement))
				{
					XElement obj = (XElement)xmlDocument.DocumentElement.WrappedNode;
					obj.Remove();
					return obj;
				}
				if (objectType == typeof(XmlElement))
				{
					return xmlDocument.DocumentElement.WrappedNode;
				}
				return xmlDocument.WrappedNode;
			}
			}
		}

		private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode)
		{
			if (!EncodeSpecialCharacters)
			{
				switch (propertyName)
				{
				case "#text":
					currentNode.AppendChild(document.CreateTextNode(ConvertTokenToXmlValue(reader)));
					return;
				case "#cdata-section":
					currentNode.AppendChild(document.CreateCDataSection(ConvertTokenToXmlValue(reader)));
					return;
				case "#whitespace":
					currentNode.AppendChild(document.CreateWhitespace(ConvertTokenToXmlValue(reader)));
					return;
				case "#significant-whitespace":
					currentNode.AppendChild(document.CreateSignificantWhitespace(ConvertTokenToXmlValue(reader)));
					return;
				}
				if (!StringUtils.IsNullOrEmpty(propertyName) && propertyName[0] == '?')
				{
					CreateInstruction(reader, document, currentNode, propertyName);
					return;
				}
				if (string.Equals(propertyName, "!DOCTYPE", StringComparison.OrdinalIgnoreCase))
				{
					CreateDocumentType(reader, document, currentNode);
					return;
				}
			}
			if (reader.TokenType == JsonToken.StartArray)
			{
				ReadArrayElements(reader, document, propertyName, currentNode, manager);
			}
			else
			{
				ReadElement(reader, document, currentNode, propertyName, manager);
			}
		}

		private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager)
		{
			if (StringUtils.IsNullOrEmpty(propertyName))
			{
				throw JsonSerializationException.Create(reader, "XmlNodeConverter cannot convert JSON with an empty property name to XML.");
			}
			Dictionary<string, string> attributeNameValues = null;
			string elementPrefix = null;
			if (!EncodeSpecialCharacters)
			{
				attributeNameValues = (ShouldReadInto(reader) ? ReadAttributeElements(reader, manager) : null);
				elementPrefix = MiscellaneousUtils.GetPrefix(propertyName);
				if (StringUtils.StartsWith(propertyName, '@'))
				{
					string text = propertyName.Substring(1);
					string prefix = MiscellaneousUtils.GetPrefix(text);
					AddAttribute(reader, document, currentNode, propertyName, text, manager, prefix);
					return;
				}
				if (StringUtils.StartsWith(propertyName, '$'))
				{
					switch (propertyName)
					{
					case "$values":
						propertyName = propertyName.Substring(1);
						elementPrefix = manager.LookupPrefix("http://james.newtonking.com/projects/json");
						CreateElement(reader, document, currentNode, propertyName, manager, elementPrefix, attributeNameValues);
						return;
					case "$id":
					case "$ref":
					case "$type":
					case "$value":
					{
						string attributeName = propertyName.Substring(1);
						string attributePrefix = manager.LookupPrefix("http://james.newtonking.com/projects/json");
						AddAttribute(reader, document, currentNode, propertyName, attributeName, manager, attributePrefix);
						return;
					}
					}
				}
			}
			else if (ShouldReadInto(reader))
			{
				reader.ReadAndAssert();
			}
			CreateElement(reader, document, currentNode, propertyName, manager, elementPrefix, attributeNameValues);
		}

		private void CreateElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string elementName, XmlNamespaceManager manager, string? elementPrefix, Dictionary<string, string?>? attributeNameValues)
		{
			IXmlElement xmlElement = CreateElement(elementName, document, elementPrefix, manager);
			currentNode.AppendChild(xmlElement);
			if (attributeNameValues != null)
			{
				foreach (KeyValuePair<string, string> attributeNameValue in attributeNameValues)
				{
					string text = XmlConvert.EncodeName(attributeNameValue.Key);
					string prefix = MiscellaneousUtils.GetPrefix(attributeNameValue.Key);
					IXmlNode attributeNode = ((!StringUtils.IsNullOrEmpty(prefix)) ? document.CreateAttribute(text, manager.LookupNamespace(prefix) ?? string.Empty, attributeNameValue.Value) : document.CreateAttribute(text, attributeNameValue.Value));
					xmlElement.SetAttributeNode(attributeNode);
				}
			}
			switch (reader.TokenType)
			{
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Date:
			case JsonToken.Bytes:
			{
				string text2 = ConvertTokenToXmlValue(reader);
				if (text2 != null)
				{
					xmlElement.AppendChild(document.CreateTextNode(text2));
				}
				break;
			}
			case JsonToken.EndObject:
				manager.RemoveNamespace(string.Empty, manager.DefaultNamespace);
				break;
			default:
				manager.PushScope();
				DeserializeNode(reader, document, manager, xmlElement);
				manager.PopScope();
				manager.RemoveNamespace(string.Empty, manager.DefaultNamespace);
				break;
			case JsonToken.Null:
				break;
			}
		}

		private static void AddAttribute(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, string attributeName, XmlNamespaceManager manager, string? attributePrefix)
		{
			if (currentNode.NodeType == XmlNodeType.Document)
			{
				throw JsonSerializationException.Create(reader, "JSON root object has property '{0}' that will be converted to an attribute. A root object cannot have any attribute properties. Consider specifying a DeserializeRootElementName.".FormatWith(CultureInfo.InvariantCulture, propertyName));
			}
			string text = XmlConvert.EncodeName(attributeName);
			string value = ConvertTokenToXmlValue(reader);
			IXmlNode attributeNode = ((!StringUtils.IsNullOrEmpty(attributePrefix)) ? document.CreateAttribute(text, manager.LookupNamespace(attributePrefix), value) : document.CreateAttribute(text, value));
			((IXmlElement)currentNode).SetAttributeNode(attributeNode);
		}

		private static string? ConvertTokenToXmlValue(JsonReader reader)
		{
			switch (reader.TokenType)
			{
			case JsonToken.String:
				return reader.Value?.ToString();
			case JsonToken.Integer:
				if (reader.Value is BigInteger bigInteger)
				{
					return bigInteger.ToString(CultureInfo.InvariantCulture);
				}
				return XmlConvert.ToString(Convert.ToInt64(reader.Value, CultureInfo.InvariantCulture));
			case JsonToken.Float:
				if (reader.Value is decimal num)
				{
					return XmlConvert.ToString(num);
				}
				if (reader.Value is float num2)
				{
					return XmlConvert.ToString(num2);
				}
				return XmlConvert.ToString(Convert.ToDouble(reader.Value, CultureInfo.InvariantCulture));
			case JsonToken.Boolean:
				return XmlConvert.ToString(Convert.ToBoolean(reader.Value, CultureInfo.InvariantCulture));
			case JsonToken.Date:
			{
				if (reader.Value is DateTimeOffset dateTimeOffset)
				{
					return XmlConvert.ToString(dateTimeOffset);
				}
				DateTime dateTime = Convert.ToDateTime(reader.Value, CultureInfo.InvariantCulture);
				return XmlConvert.ToString(dateTime, DateTimeUtils.ToSerializationMode(dateTime.Kind));
			}
			case JsonToken.Bytes:
				return Convert.ToBase64String((byte[])reader.Value);
			case JsonToken.Null:
				return null;
			default:
				throw JsonSerializationException.Create(reader, "Cannot get an XML string value from token type '{0}'.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
		}

		private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager)
		{
			string prefix = MiscellaneousUtils.GetPrefix(propertyName);
			IXmlElement xmlElement = CreateElement(propertyName, document, prefix, manager);
			currentNode.AppendChild(xmlElement);
			int num = 0;
			while (reader.Read() && reader.TokenType != JsonToken.EndArray)
			{
				DeserializeValue(reader, document, manager, propertyName, xmlElement);
				num++;
			}
			if (WriteArrayAttribute)
			{
				AddJsonArrayAttribute(xmlElement, document);
			}
			if (num != 1 || !WriteArrayAttribute)
			{
				return;
			}
			foreach (IXmlNode childNode in xmlElement.ChildNodes)
			{
				if (childNode is IXmlElement xmlElement2 && xmlElement2.LocalName == propertyName)
				{
					AddJsonArrayAttribute(xmlElement2, document);
					break;
				}
			}
		}

		private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document)
		{
			element.SetAttributeNode(document.CreateAttribute("json:Array", "http://james.newtonking.com/projects/json", "true"));
			if (element is XElementWrapper && element.GetPrefixOfNamespace("http://james.newtonking.com/projects/json") == null)
			{
				element.SetAttributeNode(document.CreateAttribute("xmlns:json", "http://www.w3.org/2000/xmlns/", "http://james.newtonking.com/projects/json"));
			}
		}

		private bool ShouldReadInto(JsonReader reader)
		{
			switch (reader.TokenType)
			{
			case JsonToken.StartConstructor:
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Date:
			case JsonToken.Bytes:
				return false;
			default:
				return true;
			}
		}

		private Dictionary<string, string?>? ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager)
		{
			Dictionary<string, string> dictionary = null;
			bool flag = false;
			while (!flag && reader.Read())
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					if (!StringUtils.IsNullOrEmpty(text))
					{
						switch (text[0])
						{
						case '@':
						{
							if (dictionary == null)
							{
								dictionary = new Dictionary<string, string>();
							}
							text = text.Substring(1);
							reader.ReadAndAssert();
							string value = ConvertTokenToXmlValue(reader);
							dictionary.Add(text, value);
							if (IsNamespaceAttribute(text, out string prefix))
							{
								manager.AddNamespace(prefix, value);
							}
							break;
						}
						case '$':
							switch (text)
							{
							case "$values":
							case "$id":
							case "$ref":
							case "$type":
							case "$value":
							{
								string text2 = manager.LookupPrefix("http://james.newtonking.com/projects/json");
								if (text2 == null)
								{
									if (dictionary == null)
									{
										dictionary = new Dictionary<string, string>();
									}
									int? num = null;
									int? num2;
									while (true)
									{
										num2 = num;
										if (manager.LookupNamespace("json" + num2) == null)
										{
											break;
										}
										num = num.GetValueOrDefault() + 1;
									}
									num2 = num;
									text2 = "json" + num2;
									dictionary.Add("xmlns:" + text2, "http://james.newtonking.com/projects/json");
									manager.AddNamespace(text2, "http://james.newtonking.com/projects/json");
								}
								if (text == "$values")
								{
									flag = true;
									break;
								}
								text = text.Substring(1);
								reader.ReadAndAssert();
								if (!JsonTokenUtils.IsPrimitiveToken(reader.TokenType))
								{
									throw JsonSerializationException.Create(reader, "Unexpected JsonToken: " + reader.TokenType);
								}
								if (dictionary == null)
								{
									dictionary = new Dictionary<string, string>();
								}
								string value = reader.Value?.ToString();
								dictionary.Add(text2 + ":" + text, value);
								break;
							}
							default:
								flag = true;
								break;
							}
							break;
						default:
							flag = true;
							break;
						}
					}
					else
					{
						flag = true;
					}
					break;
				}
				case JsonToken.Comment:
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected JsonToken: " + reader.TokenType);
				}
			}
			return dictionary;
		}

		private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName)
		{
			if (propertyName == "?xml")
			{
				string version = null;
				string encoding = null;
				string standalone = null;
				while (reader.Read() && reader.TokenType != JsonToken.EndObject)
				{
					switch (reader.Value?.ToString())
					{
					case "@version":
						reader.ReadAndAssert();
						version = ConvertTokenToXmlValue(reader);
						break;
					case "@encoding":
						reader.ReadAndAssert();
						encoding = ConvertTokenToXmlValue(reader);
						break;
					case "@standalone":
						reader.ReadAndAssert();
						standalone = ConvertTokenToXmlValue(reader);
						break;
					default:
						throw JsonSerializationException.Create(reader, "Unexpected property name encountered while deserializing XmlDeclaration: " + reader.Value);
					}
				}
				IXmlNode newChild = document.CreateXmlDeclaration(version, encoding, standalone);
				currentNode.AppendChild(newChild);
			}
			else
			{
				IXmlNode newChild2 = document.CreateProcessingInstruction(propertyName.Substring(1), ConvertTokenToXmlValue(reader));
				currentNode.AppendChild(newChild2);
			}
		}

		private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode)
		{
			string name = null;
			string publicId = null;
			string systemId = null;
			string internalSubset = null;
			while (reader.Read() && reader.TokenType != JsonToken.EndObject)
			{
				switch (reader.Value?.ToString())
				{
				case "@name":
					reader.ReadAndAssert();
					name = ConvertTokenToXmlValue(reader);
					break;
				case "@public":
					reader.ReadAndAssert();
					publicId = ConvertTokenToXmlValue(reader);
					break;
				case "@system":
					reader.ReadAndAssert();
					systemId = ConvertTokenToXmlValue(reader);
					break;
				case "@internalSubset":
					reader.ReadAndAssert();
					internalSubset = ConvertTokenToXmlValue(reader);
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected property name encountered while deserializing XmlDeclaration: " + reader.Value);
				}
			}
			IXmlNode newChild = document.CreateXmlDocumentType(name, publicId, systemId, internalSubset);
			currentNode.AppendChild(newChild);
		}

		private IXmlElement CreateElement(string elementName, IXmlDocument document, string? elementPrefix, XmlNamespaceManager manager)
		{
			string text = (EncodeSpecialCharacters ? XmlConvert.EncodeLocalName(elementName) : XmlConvert.EncodeName(elementName));
			string text2 = (StringUtils.IsNullOrEmpty(elementPrefix) ? manager.DefaultNamespace : manager.LookupNamespace(elementPrefix));
			if (StringUtils.IsNullOrEmpty(text2))
			{
				return document.CreateElement(text);
			}
			return document.CreateElement(text, text2);
		}

		private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode)
		{
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					if (currentNode.NodeType == XmlNodeType.Document && document.DocumentElement != null)
					{
						throw JsonSerializationException.Create(reader, "JSON root object has multiple properties. The root object must have a single property in order to create a valid XML document. Consider specifying a DeserializeRootElementName.");
					}
					string text = reader.Value.ToString();
					reader.ReadAndAssert();
					if (reader.TokenType == JsonToken.StartArray)
					{
						int num = 0;
						while (reader.Read() && reader.TokenType != JsonToken.EndArray)
						{
							DeserializeValue(reader, document, manager, text, currentNode);
							num++;
						}
						if (num != 1 || !WriteArrayAttribute)
						{
							break;
						}
						MiscellaneousUtils.GetQualifiedNameParts(text, out string prefix, out string localName);
						string text2 = (StringUtils.IsNullOrEmpty(prefix) ? manager.DefaultNamespace : manager.LookupNamespace(prefix));
						foreach (IXmlNode childNode in currentNode.ChildNodes)
						{
							if (childNode is IXmlElement xmlElement && xmlElement.LocalName == localName && xmlElement.NamespaceUri == text2)
							{
								AddJsonArrayAttribute(xmlElement, document);
								break;
							}
						}
					}
					else
					{
						DeserializeValue(reader, document, manager, text, currentNode);
					}
					break;
				}
				case JsonToken.StartConstructor:
				{
					string propertyName = reader.Value.ToString();
					while (reader.Read() && reader.TokenType != JsonToken.EndConstructor)
					{
						DeserializeValue(reader, document, manager, propertyName, currentNode);
					}
					break;
				}
				case JsonToken.Comment:
					currentNode.AppendChild(document.CreateComment((string)reader.Value));
					break;
				case JsonToken.EndObject:
				case JsonToken.EndArray:
					return;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected JsonToken when deserializing node: " + reader.TokenType);
				}
			}
			while (reader.Read());
		}

		private bool IsNamespaceAttribute(string attributeName, [NotNullWhen(true)] out string? prefix)
		{
			if (attributeName.StartsWith("xmlns", StringComparison.Ordinal))
			{
				if (attributeName.Length == 5)
				{
					prefix = string.Empty;
					return true;
				}
				if (attributeName[5] == ':')
				{
					prefix = attributeName.Substring(6, attributeName.Length - 6);
					return true;
				}
			}
			prefix = null;
			return false;
		}

		private bool ValueAttributes(List<IXmlNode> c)
		{
			foreach (IXmlNode item in c)
			{
				if (!(item.NamespaceUri == "http://james.newtonking.com/projects/json") && (!(item.NamespaceUri == "http://www.w3.org/2000/xmlns/") || !(item.Value == "http://james.newtonking.com/projects/json")))
				{
					return true;
				}
			}
			return false;
		}

		public override bool CanConvert(Type valueType)
		{
			if (valueType.AssignableToTypeName("System.Xml.Linq.XObject", searchInterfaces: false))
			{
				return IsXObject(valueType);
			}
			if (valueType.AssignableToTypeName("System.Xml.XmlNode", searchInterfaces: false))
			{
				return IsXmlNode(valueType);
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private bool IsXObject(Type valueType)
		{
			return typeof(XObject).IsAssignableFrom(valueType);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private bool IsXmlNode(Type valueType)
		{
			return typeof(XmlNode).IsAssignableFrom(valueType);
		}
	}
}
namespace Microsoft.Identity.Json.Bson
{
	internal enum BsonBinaryType : byte
	{
		Binary = 0,
		Function = 1,
		[Obsolete("This type has been deprecated in the BSON specification. Use Binary instead.")]
		BinaryOld = 2,
		[Obsolete("This type has been deprecated in the BSON specification. Use Uuid instead.")]
		UuidOld = 3,
		Uuid = 4,
		Md5 = 5,
		UserDefined = 128
	}
	internal class BsonBinaryWriter
	{
		private static readonly Encoding Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

		private readonly BinaryWriter _writer;

		private byte[] _largeByteBuffer;

		public DateTimeKind DateTimeKindHandling { get; set; }

		public BsonBinaryWriter(BinaryWriter writer)
		{
			DateTimeKindHandling = DateTimeKind.Utc;
			_writer = writer;
		}

		public void Flush()
		{
			_writer.Flush();
		}

		public void Close()
		{
			_writer.Close();
		}

		public void WriteToken(BsonToken t)
		{
			CalculateSize(t);
			WriteTokenInternal(t);
		}

		private void WriteTokenInternal(BsonToken t)
		{
			switch (t.Type)
			{
			case BsonType.Object:
			{
				BsonObject bsonObject = (BsonObject)t;
				_writer.Write(bsonObject.CalculatedSize);
				foreach (BsonProperty item in bsonObject)
				{
					_writer.Write((sbyte)item.Value.Type);
					WriteString((string)item.Name.Value, item.Name.ByteCount, null);
					WriteTokenInternal(item.Value);
				}
				_writer.Write((byte)0);
				break;
			}
			case BsonType.Array:
			{
				BsonArray bsonArray = (BsonArray)t;
				_writer.Write(bsonArray.CalculatedSize);
				ulong num2 = 0uL;
				foreach (BsonToken item2 in bsonArray)
				{
					_writer.Write((sbyte)item2.Type);
					WriteString(num2.ToString(CultureInfo.InvariantCulture), MathUtils.IntLength(num2), null);
					WriteTokenInternal(item2);
					num2++;
				}
				_writer.Write((byte)0);
				break;
			}
			case BsonType.Integer:
			{
				BsonValue bsonValue3 = (BsonValue)t;
				_writer.Write(Convert.ToInt32(bsonValue3.Value, CultureInfo.InvariantCulture));
				break;
			}
			case BsonType.Long:
			{
				BsonValue bsonValue4 = (BsonValue)t;
				_writer.Write(Convert.ToInt64(bsonValue4.Value, CultureInfo.InvariantCulture));
				break;
			}
			case BsonType.Number:
			{
				BsonValue bsonValue2 = (BsonValue)t;
				_writer.Write(Convert.ToDouble(bsonValue2.Value, CultureInfo.InvariantCulture));
				break;
			}
			case BsonType.String:
			{
				BsonString bsonString = (BsonString)t;
				WriteString((string)bsonString.Value, bsonString.ByteCount, bsonString.CalculatedSize - 4);
				break;
			}
			case BsonType.Boolean:
				_writer.Write(t == BsonBoolean.True);
				break;
			case BsonType.Date:
			{
				BsonValue bsonValue = (BsonValue)t;
				long num = 0L;
				if (bsonValue.Value is DateTime dateTime)
				{
					if (DateTimeKindHandling == DateTimeKind.Utc)
					{
						dateTime = dateTime.ToUniversalTime();
					}
					else if (DateTimeKindHandling == DateTimeKind.Local)
					{
						dateTime = dateTime.ToLocalTime();
					}
					num = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTime, convertToUtc: false);
				}
				else
				{
					DateTimeOffset dateTimeOffset = (DateTimeOffset)bsonValue.Value;
					num = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTimeOffset.UtcDateTime, dateTimeOffset.Offset);
				}
				_writer.Write(num);
				break;
			}
			case BsonType.Binary:
			{
				BsonBinary bsonBinary = (BsonBinary)t;
				byte[] array = (byte[])bsonBinary.Value;
				_writer.Write(array.Length);
				_writer.Write((byte)bsonBinary.BinaryType);
				_writer.Write(array);
				break;
			}
			case BsonType.Oid:
			{
				byte[] buffer = (byte[])((BsonValue)t).Value;
				_writer.Write(buffer);
				break;
			}
			case BsonType.Regex:
			{
				BsonRegex bsonRegex = (BsonRegex)t;
				WriteString((string)bsonRegex.Pattern.Value, bsonRegex.Pattern.ByteCount, null);
				WriteString((string)bsonRegex.Options.Value, bsonRegex.Options.ByteCount, null);
				break;
			}
			default:
				throw new ArgumentOutOfRangeException("t", "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture, t.Type));
			case BsonType.Undefined:
			case BsonType.Null:
				break;
			}
		}

		private void WriteString(string s, int byteCount, int? calculatedlengthPrefix)
		{
			if (calculatedlengthPrefix.HasValue)
			{
				_writer.Write(calculatedlengthPrefix.GetValueOrDefault());
			}
			WriteUtf8Bytes(s, byteCount);
			_writer.Write((byte)0);
		}

		public void WriteUtf8Bytes(string s, int byteCount)
		{
			if (s == null)
			{
				return;
			}
			if (byteCount <= 256)
			{
				if (_largeByteBuffer == null)
				{
					_largeByteBuffer = new byte[256];
				}
				Encoding.GetBytes(s, 0, s.Length, _largeByteBuffer, 0);
				_writer.Write(_largeByteBuffer, 0, byteCount);
			}
			else
			{
				byte[] bytes = Encoding.GetBytes(s);
				_writer.Write(bytes);
			}
		}

		private int CalculateSize(int stringByteCount)
		{
			return stringByteCount + 1;
		}

		private int CalculateSizeWithLength(int stringByteCount, bool includeSize)
		{
			return ((!includeSize) ? 1 : 5) + stringByteCount;
		}

		private int CalculateSize(BsonToken t)
		{
			switch (t.Type)
			{
			case BsonType.Object:
			{
				BsonObject bsonObject = (BsonObject)t;
				int num4 = 4;
				foreach (BsonProperty item in bsonObject)
				{
					int num5 = 1;
					num5 += CalculateSize(item.Name);
					num5 += CalculateSize(item.Value);
					num4 += num5;
				}
				return bsonObject.CalculatedSize = num4 + 1;
			}
			case BsonType.Array:
			{
				BsonArray bsonArray = (BsonArray)t;
				int num2 = 4;
				ulong num3 = 0uL;
				foreach (BsonToken item2 in bsonArray)
				{
					num2++;
					num2 += CalculateSize(MathUtils.IntLength(num3));
					num2 += CalculateSize(item2);
					num3++;
				}
				num2++;
				bsonArray.CalculatedSize = num2;
				return bsonArray.CalculatedSize;
			}
			case BsonType.Integer:
				return 4;
			case BsonType.Long:
				return 8;
			case BsonType.Number:
				return 8;
			case BsonType.String:
			{
				BsonString bsonString = (BsonString)t;
				string text = (string)bsonString.Value;
				bsonString.ByteCount = ((text != null) ? Encoding.GetByteCount(text) : 0);
				bsonString.CalculatedSize = CalculateSizeWithLength(bsonString.ByteCount, bsonString.IncludeLength);
				return bsonString.CalculatedSize;
			}
			case BsonType.Boolean:
				return 1;
			case BsonType.Undefined:
			case BsonType.Null:
				return 0;
			case BsonType.Date:
				return 8;
			case BsonType.Binary:
			{
				BsonBinary obj = (BsonBinary)t;
				byte[] array = (byte[])obj.Value;
				obj.CalculatedSize = 5 + array.Length;
				return obj.CalculatedSize;
			}
			case BsonType.Oid:
				return 12;
			case BsonType.Regex:
			{
				BsonRegex bsonRegex = (BsonRegex)t;
				int num = 0;
				num += CalculateSize(bsonRegex.Pattern);
				num += CalculateSize(bsonRegex.Options);
				bsonRegex.CalculatedSize = num;
				return bsonRegex.CalculatedSize;
			}
			default:
				throw new ArgumentOutOfRangeException("t", "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture, t.Type));
			}
		}
	}
	[Obsolete("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
	internal class BsonObjectId
	{
		public byte[] Value { get; }

		public BsonObjectId(byte[] value)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			if (value.Length != 12)
			{
				throw new ArgumentException("An ObjectId must be 12 bytes", "value");
			}
			Value = value;
		}
	}
	[Obsolete("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
	internal class BsonReader : JsonReader
	{
		private enum BsonReaderState
		{
			Normal,
			ReferenceStart,
			ReferenceRef,
			ReferenceId,
			CodeWScopeStart,
			CodeWScopeCode,
			CodeWScopeScope,
			CodeWScopeScopeObject,
			CodeWScopeScopeEnd
		}

		private class ContainerContext
		{
			public readonly BsonType Type;

			public int Length;

			public int Position;

			public ContainerContext(BsonType type)
			{
				Type = type;
			}
		}

		private const int MaxCharBytesSize = 128;

		private static readonly byte[] SeqRange1 = new byte[2] { 0, 127 };

		private static readonly byte[] SeqRange2 = new byte[2] { 194, 223 };

		private static readonly byte[] SeqRange3 = new byte[2] { 224, 239 };

		private static readonly byte[] SeqRange4 = new byte[2] { 240, 244 };

		private readonly BinaryReader _reader;

		private readonly List<ContainerContext> _stack;

		private byte[] _byteBuffer;

		private char[] _charBuffer;

		private BsonType _currentElementType;

		private BsonReaderState _bsonReaderState;

		private ContainerContext _currentContext;

		private bool _readRootValueAsArray;

		private bool _jsonNet35BinaryCompatibility;

		private DateTimeKind _dateTimeKindHandling;

		[Obsolete("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]
		public bool JsonNet35BinaryCompatibility
		{
			get
			{
				return _jsonNet35BinaryCompatibility;
			}
			set
			{
				_jsonNet35BinaryCompatibility = value;
			}
		}

		public bool ReadRootValueAsArray
		{
			get
			{
				return _readRootValueAsArray;
			}
			set
			{
				_readRootValueAsArray = value;
			}
		}

		public DateTimeKind DateTimeKindHandling
		{
			get
			{
				return _dateTimeKindHandling;
			}
			set
			{
				_dateTimeKindHandling = value;
			}
		}

		public BsonReader(Stream stream)
			: this(stream, readRootValueAsArray: false, DateTimeKind.Local)
		{
		}

		public BsonReader(BinaryReader reader)
			: this(reader, readRootValueAsArray: false, DateTimeKind.Local)
		{
		}

		public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
		{
			ValidationUtils.ArgumentNotNull(stream, "stream");
			_reader = new BinaryReader(stream);
			_stack = new List<ContainerContext>();
			_readRootValueAsArray = readRootValueAsArray;
			_dateTimeKindHandling = dateTimeKindHandling;
		}

		public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			_reader = reader;
			_stack = new List<ContainerContext>();
			_readRootValueAsArray = readRootValueAsArray;
			_dateTimeKindHandling = dateTimeKindHandling;
		}

		private string ReadElement()
		{
			_currentElementType = ReadType();
			return ReadString();
		}

		public override bool Read()
		{
			try
			{
				bool flag;
				switch (_bsonReaderState)
				{
				case BsonReaderState.Normal:
					flag = ReadNormal();
					break;
				case BsonReaderState.ReferenceStart:
				case BsonReaderState.ReferenceRef:
				case BsonReaderState.ReferenceId:
					flag = ReadReference();
					break;
				case BsonReaderState.CodeWScopeStart:
				case BsonReaderState.CodeWScopeCode:
				case BsonReaderState.CodeWScopeScope:
				case BsonReaderState.CodeWScopeScopeObject:
				case BsonReaderState.CodeWScopeScopeEnd:
					flag = ReadCodeWScope();
					break;
				default:
					throw JsonReaderException.Create(this, "Unexpected state: {0}".FormatWith(CultureInfo.InvariantCulture, _bsonReaderState));
				}
				if (!flag)
				{
					SetToken(JsonToken.None);
					return false;
				}
				return true;
			}
			catch (EndOfStreamException)
			{
				SetToken(JsonToken.None);
				return false;
			}
		}

		public override void Close()
		{
			base.Close();
			if (base.CloseInput)
			{
				_reader?.Close();
			}
		}

		private bool ReadCodeWScope()
		{
			switch (_bsonReaderState)
			{
			case BsonReaderState.CodeWScopeStart:
				SetToken(JsonToken.PropertyName, "$code");
				_bsonReaderState = BsonReaderState.CodeWScopeCode;
				return true;
			case BsonReaderState.CodeWScopeCode:
				ReadInt32();
				SetToken(JsonToken.String, ReadLengthString());
				_bsonReaderState = BsonReaderState.CodeWScopeScope;
				return true;
			case BsonReaderState.CodeWScopeScope:
			{
				if (base.CurrentState == State.PostValue)
				{
					SetToken(JsonToken.PropertyName, "$scope");
					return true;
				}
				SetToken(JsonToken.StartObject);
				_bsonReaderState = BsonReaderState.CodeWScopeScopeObject;
				ContainerContext containerContext = new ContainerContext(BsonType.Object);
				PushContext(containerContext);
				containerContext.Length = ReadInt32();
				return true;
			}
			case BsonReaderState.CodeWScopeScopeObject:
			{
				bool num = ReadNormal();
				if (num && TokenType == JsonToken.EndObject)
				{
					_bsonReaderState = BsonReaderState.CodeWScopeScopeEnd;
				}
				return num;
			}
			case BsonReaderState.CodeWScopeScopeEnd:
				SetToken(JsonToken.EndObject);
				_bsonReaderState = BsonReaderState.Normal;
				return true;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		private bool ReadReference()
		{
			switch (base.CurrentState)
			{
			case State.ObjectStart:
				SetToken(JsonToken.PropertyName, "$ref");
				_bsonReaderState = BsonReaderState.ReferenceRef;
				return true;
			case State.Property:
				if (_bsonReaderState == BsonReaderState.ReferenceRef)
				{
					SetToken(JsonToken.String, ReadLengthString());
					return true;
				}
				if (_bsonReaderState == BsonReaderState.ReferenceId)
				{
					SetToken(JsonToken.Bytes, ReadBytes(12));
					return true;
				}
				throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + _bsonReaderState);
			case State.PostValue:
				if (_bsonReaderState == BsonReaderState.ReferenceRef)
				{
					SetToken(JsonToken.PropertyName, "$id");
					_bsonReaderState = BsonReaderState.ReferenceId;
					return true;
				}
				if (_bsonReaderState == BsonReaderState.ReferenceId)
				{
					SetToken(JsonToken.EndObject);
					_bsonReaderState = BsonReaderState.Normal;
					return true;
				}
				throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + _bsonReaderState);
			default:
				throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + base.CurrentState);
			}
		}

		private bool ReadNormal()
		{
			switch (base.CurrentState)
			{
			case State.Start:
			{
				JsonToken token2 = ((!_readRootValueAsArray) ? JsonToken.StartObject : JsonToken.StartArray);
				int type = ((!_readRootValueAsArray) ? 3 : 4);
				SetToken(token2);
				ContainerContext containerContext = new ContainerContext((BsonType)type);
				PushContext(containerContext);
				containerContext.Length = ReadInt32();
				return true;
			}
			case State.Complete:
			case State.Closed:
				return false;
			case State.Property:
				ReadType(_currentElementType);
				return true;
			case State.ObjectStart:
			case State.ArrayStart:
			case State.PostValue:
			{
				ContainerContext currentContext = _currentContext;
				if (currentContext == null)
				{
					if (!base.SupportMultipleContent)
					{
						return false;
					}
					goto case State.Start;
				}
				int num = currentContext.Length - 1;
				if (currentContext.Position < num)
				{
					if (currentContext.Type == BsonType.Array)
					{
						ReadElement();
						ReadType(_currentElementType);
						return true;
					}
					SetToken(JsonToken.PropertyName, ReadElement());
					return true;
				}
				if (currentContext.Position == num)
				{
					if (ReadByte() != 0)
					{
						throw JsonReaderException.Create(this, "Unexpected end of object byte value.");
					}
					PopContext();
					if (_currentContext != null)
					{
						MovePosition(currentContext.Length);
					}
					JsonToken token = ((currentContext.Type == BsonType.Object) ? JsonToken.EndObject : JsonToken.EndArray);
					SetToken(token);
					return true;
				}
				throw JsonReaderException.Create(this, "Read past end of current container context.");
			}
			default:
				throw new ArgumentOutOfRangeException();
			case State.ConstructorStart:
			case State.Constructor:
			case State.Error:
			case State.Finished:
				return false;
			}
		}

		private void PopContext()
		{
			_stack.RemoveAt(_stack.Count - 1);
			if (_stack.Count == 0)
			{
				_currentContext = null;
			}
			else
			{
				_currentContext = _stack[_stack.Count - 1];
			}
		}

		private void PushContext(ContainerContext newContext)
		{
			_stack.Add(newContext);
			_currentContext = newContext;
		}

		private byte ReadByte()
		{
			MovePosition(1);
			return _reader.ReadByte();
		}

		private void ReadType(BsonType type)
		{
			switch (type)
			{
			case BsonType.Number:
			{
				double num = ReadDouble();
				if (_floatParseHandling == FloatParseHandling.Decimal)
				{
					SetToken(JsonToken.Float, Convert.ToDecimal(num, CultureInfo.InvariantCulture));
				}
				else
				{
					SetToken(JsonToken.Float, num);
				}
				break;
			}
			case BsonType.String:
			case BsonType.Symbol:
				SetToken(JsonToken.String, ReadLengthString());
				break;
			case BsonType.Object:
			{
				SetToken(JsonToken.StartObject);
				ContainerContext containerContext2 = new ContainerContext(BsonType.Object);
				PushContext(containerContext2);
				containerContext2.Length = ReadInt32();
				break;
			}
			case BsonType.Array:
			{
				SetToken(JsonToken.StartArray);
				ContainerContext containerContext = new ContainerContext(BsonType.Array);
				PushContext(containerContext);
				containerContext.Length = ReadInt32();
				break;
			}
			case BsonType.Binary:
			{
				BsonBinaryType binaryType;
				byte[] array = ReadBinary(out binaryType);
				object value3 = ((binaryType != BsonBinaryType.Uuid) ? array : ((object)new Guid(array)));
				SetToken(JsonToken.Bytes, value3);
				break;
			}
			case BsonType.Undefined:
				SetToken(JsonToken.Undefined);
				break;
			case BsonType.Oid:
			{
				byte[] value2 = ReadBytes(12);
				SetToken(JsonToken.Bytes, value2);
				break;
			}
			case BsonType.Boolean:
			{
				bool flag = Convert.ToBoolean(ReadByte());
				SetToken(JsonToken.Boolean, flag);
				break;
			}
			case BsonType.Date:
			{
				DateTime dateTime = DateTimeUtils.ConvertJavaScriptTicksToDateTime(ReadInt64());
				SetToken(JsonToken.Date, DateTimeKindHandling switch
				{
					DateTimeKind.Unspecified => DateTime.SpecifyKind(dateTime, DateTimeKind.Unspecified), 
					DateTimeKind.Local => dateTime.ToLocalTime(), 
					_ => dateTime, 
				});
				break;
			}
			case BsonType.Null:
				SetToken(JsonToken.Null);
				break;
			case BsonType.Regex:
			{
				string text = ReadString();
				string text2 = ReadString();
				string value = "/" + text + "/" + text2;
				SetToken(JsonToken.String, value);
				break;
			}
			case BsonType.Reference:
				SetToken(JsonToken.StartObject);
				_bsonReaderState = BsonReaderState.ReferenceStart;
				break;
			case BsonType.Code:
				SetToken(JsonToken.String, ReadLengthString());
				break;
			case BsonType.CodeWScope:
				SetToken(JsonToken.StartObject);
				_bsonReaderState = BsonReaderState.CodeWScopeStart;
				break;
			case BsonType.Integer:
				SetToken(JsonToken.Integer, (long)ReadInt32());
				break;
			case BsonType.TimeStamp:
			case BsonType.Long:
				SetToken(JsonToken.Integer, ReadInt64());
				break;
			default:
				throw new ArgumentOutOfRangeException("type", "Unexpected BsonType value: " + type);
			}
		}

		private byte[] ReadBinary(out BsonBinaryType binaryType)
		{
			int count = ReadInt32();
			binaryType = (BsonBinaryType)ReadByte();
			if (binaryType == BsonBinaryType.BinaryOld && !_jsonNet35BinaryCompatibility)
			{
				count = ReadInt32();
			}
			return ReadBytes(count);
		}

		private string ReadString()
		{
			EnsureBuffers();
			StringBuilder stringBuilder = null;
			int num = 0;
			int num2 = 0;
			while (true)
			{
				int num3 = num2;
				byte b;
				while (num3 < 128 && (b = _reader.ReadByte()) > 0)
				{
					_byteBuffer[num3++] = b;
				}
				int num4 = num3 - num2;
				num += num4;
				if (num3 < 128 && stringBuilder == null)
				{
					int chars = Encoding.UTF8.GetChars(_byteBuffer, 0, num4, _charBuffer, 0);
					MovePosition(num + 1);
					return new string(_charBuffer, 0, chars);
				}
				int lastFullCharStop = GetLastFullCharStop(num3 - 1);
				int chars2 = Encoding.UTF8.GetChars(_byteBuffer, 0, lastFullCharStop + 1, _charBuffer, 0);
				if (stringBuilder == null)
				{
					stringBuilder = new StringBuilder(256);
				}
				stringBuilder.Append(_charBuffer, 0, chars2);
				if (lastFullCharStop < num4 - 1)
				{
					num2 = num4 - lastFullCharStop - 1;
					Array.Copy(_byteBuffer, lastFullCharStop + 1, _byteBuffer, 0, num2);
					continue;
				}
				if (num3 < 128)
				{
					break;
				}
				num2 = 0;
			}
			MovePosition(num + 1);
			return stringBuilder.ToString();
		}

		private string ReadLengthString()
		{
			int num = ReadInt32();
			MovePosition(num);
			string result = GetString(num - 1);
			_reader.ReadByte();
			return result;
		}

		private string GetString(int length)
		{
			if (length == 0)
			{
				return string.Empty;
			}
			EnsureBuffers();
			StringBuilder stringBuilder = null;
			int num = 0;
			int num2 = 0;
			do
			{
				int count = ((length - num > 128 - num2) ? (128 - num2) : (length - num));
				int num3 = _reader.Read(_byteBuffer, num2, count);
				if (num3 == 0)
				{
					throw new EndOfStreamException("Unable to read beyond the end of the stream.");
				}
				num += num3;
				num3 += num2;
				if (num3 == length)
				{
					int chars = Encoding.UTF8.GetChars(_byteBuffer, 0, num3, _charBuffer, 0);
					return new string(_charBuffer, 0, chars);
				}
				int lastFullCharStop = GetLastFullCharStop(num3 - 1);
				if (stringBuilder == null)
				{
					stringBuilder = new StringBuilder(length);
				}
				int chars2 = Encoding.UTF8.GetChars(_byteBuffer, 0, lastFullCharStop + 1, _charBuffer, 0);
				stringBuilder.Append(_charBuffer, 0, chars2);
				if (lastFullCharStop < num3 - 1)
				{
					num2 = num3 - lastFullCharStop - 1;
					Array.Copy(_byteBuffer, lastFullCharStop + 1, _byteBuffer, 0, num2);
				}
				else
				{
					num2 = 0;
				}
			}
			while (num < length);
			return stringBuilder.ToString();
		}

		private int GetLastFullCharStop(int start)
		{
			int num = start;
			int num2 = 0;
			for (; num >= 0; num--)
			{
				num2 = BytesInSequence(_byteBuffer[num]);
				switch (num2)
				{
				case 0:
					continue;
				default:
					num--;
					break;
				case 1:
					break;
				}
				break;
			}
			if (num2 == start - num)
			{
				return start;
			}
			return num;
		}

		private int BytesInSequence(byte b)
		{
			if (b <= SeqRange1[1])
			{
				return 1;
			}
			if (b >= SeqRange2[0] && b <= SeqRange2[1])
			{
				return 2;
			}
			if (b >= SeqRange3[0] && b <= SeqRange3[1])
			{
				return 3;
			}
			if (b >= SeqRange4[0] && b <= SeqRange4[1])
			{
				return 4;
			}
			return 0;
		}

		private void EnsureBuffers()
		{
			if (_byteBuffer == null)
			{
				_byteBuffer = new byte[128];
			}
			if (_charBuffer == null)
			{
				int maxCharCount = Encoding.UTF8.GetMaxCharCount(128);
				_charBuffer = new char[maxCharCount];
			}
		}

		private double ReadDouble()
		{
			MovePosition(8);
			return _reader.ReadDouble();
		}

		private int ReadInt32()
		{
			MovePosition(4);
			return _reader.ReadInt32();
		}

		private long ReadInt64()
		{
			MovePosition(8);
			return _reader.ReadInt64();
		}

		private BsonType ReadType()
		{
			MovePosition(1);
			return (BsonType)_reader.ReadSByte();
		}

		private void MovePosition(int count)
		{
			_currentContext.Position += count;
		}

		private byte[] ReadBytes(int count)
		{
			MovePosition(count);
			return _reader.ReadBytes(count);
		}
	}
	internal abstract class BsonToken
	{
		public abstract BsonType Type { get; }

		public BsonToken Parent { get; set; }

		public int CalculatedSize { get; set; }
	}
	internal class BsonObject : BsonToken, IEnumerable<BsonProperty>, IEnumerable
	{
		private readonly List<BsonProperty> _children = new List<BsonProperty>();

		public override BsonType Type => BsonType.Object;

		public void Add(string name, BsonToken token)
		{
			_children.Add(new BsonProperty
			{
				Name = new BsonString(name, includeLength: false),
				Value = token
			});
			token.Parent = this;
		}

		public IEnumerator<BsonProperty> GetEnumerator()
		{
			return _children.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal class BsonArray : BsonToken, IEnumerable<BsonToken>, IEnumerable
	{
		private readonly List<BsonToken> _children = new List<BsonToken>();

		public override BsonType Type => BsonType.Array;

		public void Add(BsonToken token)
		{
			_children.Add(token);
			token.Parent = this;
		}

		public IEnumerator<BsonToken> GetEnumerator()
		{
			return _children.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal class BsonEmpty : BsonToken
	{
		public static readonly BsonToken Null = new BsonEmpty(BsonType.Null);

		public static readonly BsonToken Undefined = new BsonEmpty(BsonType.Undefined);

		public override BsonType Type { get; }

		private BsonEmpty(BsonType type)
		{
			Type = type;
		}
	}
	internal class BsonValue : BsonToken
	{
		private readonly object _value;

		private readonly BsonType _type;

		public object Value => _value;

		public override BsonType Type => _type;

		public BsonValue(object value, BsonType type)
		{
			_value = value;
			_type = type;
		}
	}
	internal class BsonBoolean : BsonValue
	{
		public static readonly BsonBoolean False = new BsonBoolean(value: false);

		public static readonly BsonBoolean True = new BsonBoolean(value: true);

		private BsonBoolean(bool value)
			: base(value, BsonType.Boolean)
		{
		}
	}
	internal class BsonString : BsonValue
	{
		public int ByteCount { get; set; }

		public bool IncludeLength { get; }

		public BsonString(object value, bool includeLength)
			: base(value, BsonType.String)
		{
			IncludeLength = includeLength;
		}
	}
	internal class BsonBinary : BsonValue
	{
		public BsonBinaryType BinaryType { get; set; }

		public BsonBinary(byte[] value, BsonBinaryType binaryType)
			: base(value, BsonType.Binary)
		{
			BinaryType = binaryType;
		}
	}
	internal class BsonRegex : BsonToken
	{
		public BsonString Pattern { get; set; }

		public BsonString Options { get; set; }

		public override BsonType Type => BsonType.Regex;

		public BsonRegex(string pattern, string options)
		{
			Pattern = new BsonString(pattern, includeLength: false);
			Options = new BsonString(options, includeLength: false);
		}
	}
	internal class BsonProperty
	{
		public BsonString Name { get; set; }

		public BsonToken Value { get; set; }
	}
	internal enum BsonType : sbyte
	{
		Number = 1,
		String = 2,
		Object = 3,
		Array = 4,
		Binary = 5,
		Undefined = 6,
		Oid = 7,
		Boolean = 8,
		Date = 9,
		Null = 10,
		Regex = 11,
		Reference = 12,
		Code = 13,
		Symbol = 14,
		CodeWScope = 15,
		Integer = 16,
		TimeStamp = 17,
		Long = 18,
		MinKey = -1,
		MaxKey = sbyte.MaxValue
	}
	[Obsolete("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
	internal class BsonWriter : JsonWriter
	{
		private readonly BsonBinaryWriter _writer;

		private BsonToken _root;

		private BsonToken _parent;

		private string _propertyName;

		public DateTimeKind DateTimeKindHandling
		{
			get
			{
				return _writer.DateTimeKindHandling;
			}
			set
			{
				_writer.DateTimeKindHandling = value;
			}
		}

		public BsonWriter(Stream stream)
		{
			ValidationUtils.ArgumentNotNull(stream, "stream");
			_writer = new BsonBinaryWriter(new BinaryWriter(stream));
		}

		public BsonWriter(BinaryWriter writer)
		{
			ValidationUtils.ArgumentNotNull(writer, "writer");
			_writer = new BsonBinaryWriter(writer);
		}

		public override void Flush()
		{
			_writer.Flush();
		}

		protected override void WriteEnd(JsonToken token)
		{
			base.WriteEnd(token);
			RemoveParent();
			if (base.Top == 0)
			{
				_writer.WriteToken(_root);
			}
		}

		public override void WriteComment(string text)
		{
			throw JsonWriterException.Create(this, "Cannot write JSON comment as BSON.", null);
		}

		public override void WriteStartConstructor(string name)
		{
			throw JsonWriterException.Create(this, "Cannot write JSON constructor as BSON.", null);
		}

		public override void WriteRaw(string json)
		{
			throw JsonWriterException.Create(this, "Cannot write raw JSON as BSON.", null);
		}

		public override void WriteRawValue(string json)
		{
			throw JsonWriterException.Create(this, "Cannot write raw JSON as BSON.", null);
		}

		public override void WriteStartArray()
		{
			base.WriteStartArray();
			AddParent(new BsonArray());
		}

		public override void WriteStartObject()
		{
			base.WriteStartObject();
			AddParent(new BsonObject());
		}

		public override void WritePropertyName(string name)
		{
			base.WritePropertyName(name);
			_propertyName = name;
		}

		public override void Close()
		{
			base.Close();
			if (base.CloseOutput)
			{
				_writer?.Close();
			}
		}

		private void AddParent(BsonToken container)
		{
			AddToken(container);
			_parent = container;
		}

		private void RemoveParent()
		{
			_parent = _parent.Parent;
		}

		private void AddValue(object value, BsonType type)
		{
			AddToken(new BsonValue(value, type));
		}

		internal void AddToken(BsonToken token)
		{
			if (_parent != null)
			{
				if (_parent is BsonObject bsonObject)
				{
					bsonObject.Add(_propertyName, token);
					_propertyName = null;
				}
				else
				{
					((BsonArray)_parent).Add(token);
				}
				return;
			}
			if (token.Type != BsonType.Object && token.Type != BsonType.Array)
			{
				throw JsonWriterException.Create(this, "Error writing {0} value. BSON must start with an Object or Array.".FormatWith(CultureInfo.InvariantCulture, token.Type), null);
			}
			_parent = token;
			_root = token;
		}

		public override void WriteValue(object value)
		{
			if (value is BigInteger bigInteger)
			{
				SetWriteState(JsonToken.Integer, null);
				AddToken(new BsonBinary(bigInteger.ToByteArray(), BsonBinaryType.Binary));
			}
			else
			{
				base.WriteValue(value);
			}
		}

		public override void WriteNull()
		{
			base.WriteNull();
			AddToken(BsonEmpty.Null);
		}

		public override void WriteUndefined()
		{
			base.WriteUndefined();
			AddToken(BsonEmpty.Undefined);
		}

		public override void WriteValue(string value)
		{
			base.WriteValue(value);
			AddToken((value == null) ? BsonEmpty.Null : new BsonString(value, includeLength: true));
		}

		public override void WriteValue(int value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(uint value)
		{
			if (value > int.MaxValue)
			{
				throw JsonWriterException.Create(this, "Value is too large to fit in a signed 32 bit integer. BSON does not support unsigned values.", null);
			}
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		public override void WriteValue(long value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Long);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ulong value)
		{
			if (value > long.MaxValue)
			{
				throw JsonWriterException.Create(this, "Value is too large to fit in a signed 64 bit integer. BSON does not support unsigned values.", null);
			}
			base.WriteValue(value);
			AddValue(value, BsonType.Long);
		}

		public override void WriteValue(float value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Number);
		}

		public override void WriteValue(double value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Number);
		}

		public override void WriteValue(bool value)
		{
			base.WriteValue(value);
			AddToken(value ? BsonBoolean.True : BsonBoolean.False);
		}

		public override void WriteValue(short value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ushort value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		public override void WriteValue(char value)
		{
			base.WriteValue(value);
			string text = null;
			text = value.ToString(CultureInfo.InvariantCulture);
			AddToken(new BsonString(text, includeLength: true));
		}

		public override void WriteValue(byte value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(sbyte value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		public override void WriteValue(decimal value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Number);
		}

		public override void WriteValue(DateTime value)
		{
			base.WriteValue(value);
			value = DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
			AddValue(value, BsonType.Date);
		}

		public override void WriteValue(DateTimeOffset value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Date);
		}

		public override void WriteValue(byte[] value)
		{
			if (value == null)
			{
				WriteNull();
				return;
			}
			base.WriteValue(value);
			AddToken(new BsonBinary(value, BsonBinaryType.Binary));
		}

		public override void WriteValue(Guid value)
		{
			base.WriteValue(value);
			AddToken(new BsonBinary(value.ToByteArray(), BsonBinaryType.Uuid));
		}

		public override void WriteValue(TimeSpan value)
		{
			base.WriteValue(value);
			AddToken(new BsonString(value.ToString(), includeLength: true));
		}

		public override void WriteValue(Uri value)
		{
			if (value == null)
			{
				WriteNull();
				return;
			}
			base.WriteValue(value);
			AddToken(new BsonString(value.ToString(), includeLength: true));
		}

		public void WriteObjectId(byte[] value)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			if (value.Length != 12)
			{
				throw JsonWriterException.Create(this, "An object id must be 12 bytes", null);
			}
			SetWriteState(JsonToken.Undefined, null);
			AddValue(value, BsonType.Oid);
		}

		public void WriteRegex(string pattern, string options)
		{
			ValidationUtils.ArgumentNotNull(pattern, "pattern");
			SetWriteState(JsonToken.Undefined, null);
			AddToken(new BsonRegex(pattern, options));
		}
	}
}
namespace Microsoft.Identity.Client
{
	internal sealed class Account : IAccount
	{
		public string Username { get; }

		public string Environment { get; }

		public AccountId HomeAccountId { get; }

		public IEnumerable<TenantProfile> TenantProfiles { get; }

		internal IDictionary<string, string> WamAccountIds { get; }

		public Account(string homeAccountId, string username, string environment, IDictionary<string, string> wamAccountIds = null, IEnumerable<TenantProfile> tenantProfiles = null)
		{
			Username = username;
			Environment = environment;
			HomeAccountId = AccountId.ParseFromString(homeAccountId);
			WamAccountIds = wamAccountIds;
			TenantProfiles = tenantProfiles;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.CurrentCulture, "Account username: {0} environment {1} home account id: {2}", Username, Environment, HomeAccountId);
		}
	}
	public static class AccountExtensions
	{
		public static IEnumerable<TenantProfile> GetTenantProfiles(this IAccount account)
		{
			return (account as Account)?.TenantProfiles;
		}
	}
	public class AccountId
	{
		public string Identifier { get; }

		public string ObjectId { get; }

		public string TenantId { get; }

		public AccountId(string identifier, string objectId, string tenantId)
		{
			Identifier = identifier ?? throw new ArgumentNullException("identifier");
			ObjectId = objectId;
			TenantId = tenantId;
		}

		public AccountId(string adfsIdentifier)
			: this(adfsIdentifier, adfsIdentifier, null)
		{
		}

		internal static AccountId ParseFromString(string str)
		{
			if (string.IsNullOrEmpty(str))
			{
				return null;
			}
			int num = str.LastIndexOf('.');
			if (num == -1)
			{
				return new AccountId(str);
			}
			return new AccountId(str, str.Substring(0, num), str.Substring(num + 1));
		}

		public override bool Equals(object obj)
		{
			if (!(obj is AccountId accountId))
			{
				return false;
			}
			return string.Equals(Identifier, accountId.Identifier, StringComparison.OrdinalIgnoreCase);
		}

		public override int GetHashCode()
		{
			return Identifier.GetHashCode();
		}

		public override string ToString()
		{
			return "AccountId: " + Identifier;
		}

		[Conditional("DEBUG")]
		private void ValidateId()
		{
			if (!string.Equals((TenantId == null) ? ObjectId : (ObjectId + "." + TenantId), Identifier, StringComparison.Ordinal))
			{
				throw new InvalidOperationException("Internal Error (debug only) - Expecting Identifier = ObjectId.TenantId but have " + ToString());
			}
		}
	}
	public abstract class AbstractAcquireTokenParameterBuilder<T> : BaseAbstractAcquireTokenParameterBuilder<T> where T : BaseAbstractAcquireTokenParameterBuilder<T>
	{
		protected AbstractAcquireTokenParameterBuilder()
		{
		}

		internal AbstractAcquireTokenParameterBuilder(IServiceBundle serviceBundle)
			: base(serviceBundle)
		{
		}

		protected T WithScopes(IEnumerable<string> scopes)
		{
			base.CommonParameters.Scopes = scopes;
			return this as T;
		}

		public T WithExtraQueryParameters(Dictionary<string, string> extraQueryParameters)
		{
			base.CommonParameters.ExtraQueryParameters = extraQueryParameters ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			return this as T;
		}

		public T WithClaims(string claims)
		{
			base.CommonParameters.Claims = claims;
			return this as T;
		}

		public T WithExtraQueryParameters(string extraQueryParameters)
		{
			if (!string.IsNullOrWhiteSpace(extraQueryParameters))
			{
				return WithExtraQueryParameters(CoreHelpers.ParseKeyValueList(extraQueryParameters, '&', urlDecode: true, null));
			}
			return this as T;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
		public T WithAuthority(string authorityUri, bool validateAuthority = true)
		{
			if (string.IsNullOrWhiteSpace(authorityUri))
			{
				throw new ArgumentNullException("authorityUri");
			}
			base.CommonParameters.AuthorityOverride = AuthorityInfo.FromAuthorityUri(authorityUri, validateAuthority);
			return this as T;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
		public T WithAuthority(string cloudInstanceUri, Guid tenantId, bool validateAuthority = true)
		{
			if (string.IsNullOrWhiteSpace(cloudInstanceUri))
			{
				throw new ArgumentNullException("cloudInstanceUri");
			}
			base.CommonParameters.AuthorityOverride = AuthorityInfo.FromAadAuthority(cloudInstanceUri, tenantId, validateAuthority);
			return this as T;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
		public T WithAuthority(string cloudInstanceUri, string tenant, bool validateAuthority = true)
		{
			if (string.IsNullOrWhiteSpace(cloudInstanceUri))
			{
				throw new ArgumentNullException("cloudInstanceUri");
			}
			base.CommonParameters.AuthorityOverride = AuthorityInfo.FromAadAuthority(cloudInstanceUri, tenant, validateAuthority);
			return this as T;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
		public T WithAuthority(AzureCloudInstance azureCloudInstance, Guid tenantId, bool validateAuthority = true)
		{
			base.CommonParameters.AuthorityOverride = AuthorityInfo.FromAadAuthority(azureCloudInstance, tenantId, validateAuthority);
			return this as T;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
		public T WithAuthority(AzureCloudInstance azureCloudInstance, string tenant, bool validateAuthority = true)
		{
			base.CommonParameters.AuthorityOverride = AuthorityInfo.FromAadAuthority(azureCloudInstance, tenant, validateAuthority);
			return this as T;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
		public T WithAuthority(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, bool validateAuthority = true)
		{
			base.CommonParameters.AuthorityOverride = AuthorityInfo.FromAadAuthority(azureCloudInstance, authorityAudience, validateAuthority);
			return this as T;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
		public T WithAuthority(AadAuthorityAudience authorityAudience, bool validateAuthority = true)
		{
			base.CommonParameters.AuthorityOverride = AuthorityInfo.FromAadAuthority(authorityAudience, validateAuthority);
			return this as T;
		}

		public T WithTenantId(string tenantId)
		{
			if (string.IsNullOrEmpty(tenantId))
			{
				throw new ArgumentNullException("tenantId");
			}
			Authority authority = AuthorityInfo.AuthorityInfoHelper.CreateAuthorityWithTenant(base.ServiceBundle.Config.Authority, tenantId, forceSpecifiedTenant: true);
			base.CommonParameters.AuthorityOverride = authority.AuthorityInfo;
			return this as T;
		}

		public T WithTenantIdFromAuthority(Uri authorityUri)
		{
			if (authorityUri == null)
			{
				throw new ArgumentNullException("authorityUri");
			}
			Authority authority = Authority.CreateAuthority(AuthorityInfo.FromAuthorityUri(authorityUri.ToString(), validateAuthority: false));
			return WithTenantId(authority.TenantId);
		}

		public T WithAdfsAuthority(string authorityUri, bool validateAuthority = true)
		{
			if (string.IsNullOrWhiteSpace(authorityUri))
			{
				throw new ArgumentNullException("authorityUri");
			}
			base.CommonParameters.AuthorityOverride = new AuthorityInfo(AuthorityType.Adfs, authorityUri, validateAuthority);
			return this as T;
		}

		public T WithB2CAuthority(string authorityUri)
		{
			if (string.IsNullOrWhiteSpace(authorityUri))
			{
				throw new ArgumentNullException("authorityUri");
			}
			base.CommonParameters.AuthorityOverride = new AuthorityInfo(AuthorityType.B2C, authorityUri, validateAuthority: false);
			return this as T;
		}

		internal T WithAuthenticationScheme(IAuthenticationScheme scheme)
		{
			base.CommonParameters.AuthenticationScheme = scheme ?? throw new ArgumentNullException("scheme");
			return this as T;
		}
	}
	public abstract class AbstractClientAppBaseAcquireTokenParameterBuilder<T> : AbstractAcquireTokenParameterBuilder<T> where T : AbstractAcquireTokenParameterBuilder<T>
	{
		internal IClientApplicationBaseExecutor ClientApplicationBaseExecutor { get; }

		internal AbstractClientAppBaseAcquireTokenParameterBuilder(IClientApplicationBaseExecutor clientApplicationBaseExecutor)
			: base(clientApplicationBaseExecutor.ServiceBundle)
		{
			ClientApplicationBaseExecutor = clientApplicationBaseExecutor;
		}

		internal abstract Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);

		public override Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			ValidateAndCalculateApiId();
			return ExecuteInternalAsync(cancellationToken);
		}
	}
	public abstract class AbstractConfidentialClientAcquireTokenParameterBuilder<T> : AbstractAcquireTokenParameterBuilder<T> where T : AbstractAcquireTokenParameterBuilder<T>
	{
		internal IConfidentialClientApplicationExecutor ConfidentialClientApplicationExecutor { get; }

		internal AbstractConfidentialClientAcquireTokenParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor)
			: base(confidentialClientApplicationExecutor.ServiceBundle)
		{
			ApplicationBase.GuardMobileFrameworks();
			ConfidentialClientApplicationExecutor = confidentialClientApplicationExecutor;
		}

		internal abstract Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);

		public override Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			ApplicationBase.GuardMobileFrameworks();
			ValidateAndCalculateApiId();
			return ExecuteInternalAsync(cancellationToken);
		}

		protected override void Validate()
		{
			if (base.ServiceBundle?.Config.ClientCredential == null && base.CommonParameters.OnBeforeTokenRequestHandler == null && base.ServiceBundle?.Config.AppTokenProvider == null)
			{
				throw new MsalClientException("Client_Credentials_Required_In_Confidential_Client_Application", "One client credential type required either: ClientSecret, Certificate, ClientAssertion or AppTokenProvider must be defined when creating a Confidential Client. Only specify one. See https://aka.ms/msal-net-client-credentials. ");
			}
			base.Validate();
		}

		public T WithProofOfPossession(PoPAuthenticationConfiguration popAuthenticationConfiguration)
		{
			ValidateUseOfExperimentalFeature("WithProofOfPossession");
			base.CommonParameters.PopAuthenticationConfiguration = popAuthenticationConfiguration ?? throw new ArgumentNullException("popAuthenticationConfiguration");
			base.CommonParameters.AuthenticationScheme = new PopAuthenticationScheme(base.CommonParameters.PopAuthenticationConfiguration, base.ServiceBundle);
			return this as T;
		}
	}
	public abstract class AbstractManagedIdentityAcquireTokenParameterBuilder<T> : BaseAbstractAcquireTokenParameterBuilder<T> where T : BaseAbstractAcquireTokenParameterBuilder<T>
	{
		internal IManagedIdentityApplicationExecutor ManagedIdentityApplicationExecutor { get; }

		protected AbstractManagedIdentityAcquireTokenParameterBuilder()
		{
		}

		internal AbstractManagedIdentityAcquireTokenParameterBuilder(IManagedIdentityApplicationExecutor managedIdentityApplicationExecutor)
			: base(managedIdentityApplicationExecutor.ServiceBundle)
		{
			ApplicationBase.GuardMobileFrameworks();
			ManagedIdentityApplicationExecutor = managedIdentityApplicationExecutor;
		}

		internal abstract Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);

		public override Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			ApplicationBase.GuardMobileFrameworks();
			ValidateAndCalculateApiId();
			return ExecuteInternalAsync(cancellationToken);
		}
	}
	public abstract class AbstractPublicClientAcquireTokenParameterBuilder<T> : AbstractAcquireTokenParameterBuilder<T> where T : AbstractAcquireTokenParameterBuilder<T>
	{
		internal IPublicClientApplicationExecutor PublicClientApplicationExecutor { get; }

		internal AbstractPublicClientAcquireTokenParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor)
			: base(publicClientApplicationExecutor.ServiceBundle)
		{
			PublicClientApplicationExecutor = publicClientApplicationExecutor;
		}

		internal abstract Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);

		public override Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			ValidateAndCalculateApiId();
			return ExecuteInternalAsync(cancellationToken);
		}
	}
	public sealed class AcquireTokenByAuthorizationCodeParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder<AcquireTokenByAuthorizationCodeParameterBuilder>
	{
		private AcquireTokenByAuthorizationCodeParameters Parameters { get; } = new AcquireTokenByAuthorizationCodeParameters();

		internal AcquireTokenByAuthorizationCodeParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor)
			: base(confidentialClientApplicationExecutor)
		{
			ApplicationBase.GuardMobileFrameworks();
		}

		internal static AcquireTokenByAuthorizationCodeParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable<string> scopes, string authorizationCode)
		{
			ApplicationBase.GuardMobileFrameworks();
			return new AcquireTokenByAuthorizationCodeParameterBuilder(confidentialClientApplicationExecutor).WithScopes(scopes).WithAuthorizationCode(authorizationCode);
		}

		private AcquireTokenByAuthorizationCodeParameterBuilder WithAuthorizationCode(string authorizationCode)
		{
			Parameters.AuthorizationCode = authorizationCode;
			return this;
		}

		internal override ApiEvent.ApiIds CalculateApiEventId()
		{
			return ApiEvent.ApiIds.AcquireTokenByAuthorizationCode;
		}

		protected override void Validate()
		{
			base.Validate();
			if (string.IsNullOrWhiteSpace(Parameters.AuthorizationCode))
			{
				throw new ArgumentException("AuthorizationCode can not be null or whitespace", "AuthorizationCode");
			}
			if (!Parameters.SendX5C.HasValue)
			{
				Parameters.SendX5C = base.ServiceBundle.Config.SendX5C;
			}
		}

		internal override Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken)
		{
			return base.ConfidentialClientApplicationExecutor.ExecuteAsync(base.CommonParameters, Parameters, cancellationToken);
		}

		public AcquireTokenByAuthorizationCodeParameterBuilder WithSendX5C(bool withSendX5C)
		{
			Parameters.SendX5C = withSendX5C;
			return this;
		}

		public AcquireTokenByAuthorizationCodeParameterBuilder WithPkceCodeVerifier(string pkceCodeVerifier)
		{
			Parameters.PkceCodeVerifier = pkceCodeVerifier;
			return this;
		}

		public AcquireTokenByAuthorizationCodeParameterBuilder WithCcsRoutingHint(string userObjectIdentifier, string tenantIdentifier)
		{
			if (string.IsNullOrEmpty(userObjectIdentifier) || string.IsNullOrEmpty(tenantIdentifier))
			{
				return this;
			}
			Dictionary<string, string> extraHttpHeaders = new Dictionary<string, string> { 
			{
				"x-anchormailbox",
				CoreHelpers.GetCcsClientInfoHint(userObjectIdentifier, tenantIdentifier)
			} };
			this.WithExtraHttpHeaders(extraHttpHeaders);
			return this;
		}

		public AcquireTokenByAuthorizationCodeParameterBuilder WithCcsRoutingHint(string userName)
		{
			if (string.IsNullOrEmpty(userName))
			{
				return this;
			}
			Dictionary<string, string> extraHttpHeaders = new Dictionary<string, string> { 
			{
				"x-anchormailbox",
				CoreHelpers.GetCcsUpnHint(userName)
			} };
			this.WithExtraHttpHeaders(extraHttpHeaders);
			return this;
		}

		public AcquireTokenByAuthorizationCodeParameterBuilder WithSpaAuthorizationCode(bool requestSpaAuthorizationCode = true)
		{
			Parameters.SpaCode = requestSpaAuthorizationCode;
			return this;
		}
	}
	public sealed class AcquireTokenByIntegratedWindowsAuthParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder<AcquireTokenByIntegratedWindowsAuthParameterBuilder>
	{
		private AcquireTokenByIntegratedWindowsAuthParameters Parameters { get; } = new AcquireTokenByIntegratedWindowsAuthParameters();

		internal AcquireTokenByIntegratedWindowsAuthParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor)
			: base(publicClientApplicationExecutor)
		{
		}

		internal static AcquireTokenByIntegratedWindowsAuthParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable<string> scopes)
		{
			return new AcquireTokenByIntegratedWindowsAuthParameterBuilder(publicClientApplicationExecutor).WithScopes(scopes);
		}

		public AcquireTokenByIntegratedWindowsAuthParameterBuilder WithUsername(string username)
		{
			Parameters.Username = username;
			return this;
		}

		public AcquireTokenByIntegratedWindowsAuthParameterBuilder WithFederationMetadata(string federationMetadata)
		{
			Parameters.FederationMetadata = federationMetadata;
			return this;
		}

		internal override Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken)
		{
			return base.PublicClientApplicationExecutor.ExecuteAsync(base.CommonParameters, Parameters, cancellationToken);
		}

		internal override ApiEvent.ApiIds CalculateApiEventId()
		{
			return ApiEvent.ApiIds.AcquireTokenByIntegratedWindowsAuth;
		}
	}
	public sealed class AcquireTokenByRefreshTokenParameterBuilder : AbstractClientAppBaseAcquireTokenParameterBuilder<AcquireTokenByRefreshTokenParameterBuilder>
	{
		private AcquireTokenByRefreshTokenParameters Parameters { get; } = new AcquireTokenByRefreshTokenParameters();

		internal AcquireTokenByRefreshTokenParameterBuilder(IClientApplicationBaseExecutor clientApplicationBaseExecutor)
			: base(clientApplicationBaseExecutor)
		{
		}

		internal static AcquireTokenByRefreshTokenParameterBuilder Create(IClientApplicationBaseExecutor clientApplicationBaseExecutor, IEnumerable<string> scopes, string refreshToken)
		{
			return new AcquireTokenByRefreshTokenParameterBuilder(clientApplicationBaseExecutor).WithScopes(scopes).WithRefreshToken(refreshToken);
		}

		internal AcquireTokenByRefreshTokenParameterBuilder WithRefreshToken(string refreshToken)
		{
			Parameters.RefreshToken = refreshToken;
			return this;
		}

		internal override Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken)
		{
			return base.ClientApplicationBaseExecutor.ExecuteAsync(base.CommonParameters, Parameters, cancellationToken);
		}

		protected override void Validate()
		{
			base.Validate();
			if (!Parameters.SendX5C.HasValue)
			{
				Parameters.SendX5C = base.ServiceBundle.Config.SendX5C;
			}
		}

		internal override ApiEvent.ApiIds CalculateApiEventId()
		{
			return ApiEvent.ApiIds.AcquireTokenByRefreshToken;
		}

		public AcquireTokenByRefreshTokenParameterBuilder WithSendX5C(bool withSendX5C)
		{
			Parameters.SendX5C = withSendX5C;
			return this;
		}
	}
	public sealed class AcquireTokenByUsernamePasswordParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder<AcquireTokenByUsernamePasswordParameterBuilder>
	{
		private AcquireTokenByUsernamePasswordParameters Parameters { get; } = new AcquireTokenByUsernamePasswordParameters();

		internal AcquireTokenByUsernamePasswordParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor)
			: base(publicClientApplicationExecutor)
		{
		}

		internal static AcquireTokenByUsernamePasswordParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable<string> scopes, string username, string password)
		{
			return new AcquireTokenByUsernamePasswordParameterBuilder(publicClientApplicationExecutor).WithScopes(scopes).WithUsername(username).WithPassword(password);
		}

		public AcquireTokenByUsernamePasswordParameterBuilder WithFederationMetadata(string federationMetadata)
		{
			Parameters.FederationMetadata = federationMetadata;
			return this;
		}

		public AcquireTokenByUsernamePasswordParameterBuilder WithProofOfPossession(string nonce, HttpMethod httpMethod, Uri requestUri)
		{
			ApplicationBase.GuardMobileFrameworks();
			if (!base.ServiceBundle.Config.IsBrokerEnabled)
			{
				throw new MsalClientException("broker_required_for_pop", "The request has Proof-of-Possession configured but does not have broker enabled. Broker is required to use Proof-of-Possession on public clients. Use IPublicClientApplication.IsProofOfPossessionSupportedByClient to ensure Proof-of-Possession can be performed before using WithProofOfPossession.");
			}
			if (!base.ServiceBundle.PlatformProxy.CreateBroker(base.ServiceBundle.Config, null).IsPopSupported)
			{
				throw new MsalClientException("broker_does_not_support_pop", "The broker does not support Proof-of-Possession on the current platform.");
			}
			if (string.IsNullOrEmpty(nonce))
			{
				throw new ArgumentNullException("nonce");
			}
			PoPAuthenticationConfiguration poPAuthenticationConfiguration = new PoPAuthenticationConfiguration(requestUri);
			poPAuthenticationConfiguration.Nonce = nonce;
			poPAuthenticationConfiguration.HttpMethod = httpMethod;
			base.CommonParameters.PopAuthenticationConfiguration = poPAuthenticationConfiguration;
			base.CommonParameters.AuthenticationScheme = new PopBrokerAuthenticationScheme();
			return this;
		}

		private AcquireTokenByUsernamePasswordParameterBuilder WithUsername(string username)
		{
			Parameters.Username = username;
			return this;
		}

		private AcquireTokenByUsernamePasswordParameterBuilder WithPassword(string password)
		{
			Parameters.Password = password;
			return this;
		}

		internal override Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken)
		{
			return base.PublicClientApplicationExecutor.ExecuteAsync(base.CommonParameters, Parameters, cancellationToken);
		}

		internal override ApiEvent.ApiIds CalculateApiEventId()
		{
			return ApiEvent.ApiIds.AcquireTokenByUsernamePassword;
		}
	}
	public sealed class AcquireTokenForClientParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder<AcquireTokenForClientParameterBuilder>
	{
		private AcquireTokenForClientParameters Parameters { get; } = new AcquireTokenForClientParameters();

		internal AcquireTokenForClientParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor)
			: base(confidentialClientApplicationExecutor)
		{
		}

		internal static AcquireTokenForClientParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable<string> scopes)
		{
			return new AcquireTokenForClientParameterBuilder(confidentialClientApplicationExecutor).WithScopes(scopes);
		}

		public AcquireTokenForClientParameterBuilder WithForceRefresh(bool forceRefresh)
		{
			Parameters.ForceRefresh = forceRefresh;
			return this;
		}

		public AcquireTokenForClientParameterBuilder WithSendX5C(bool withSendX5C)
		{
			Parameters.SendX5C = withSendX5C;
			return this;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use WithAzureRegion on the ConfidentialClientApplicationBuilder object", true)]
		public AcquireTokenForClientParameterBuilder WithAzureRegion(bool useAzureRegion)
		{
			throw new NotImplementedException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use WithAzureRegion on the ConfidentialClientApplicationBuilder object", true)]
		public AcquireTokenForClientParameterBuilder WithPreferredAzureRegion(bool useAzureRegion = true, string regionUsedIfAutoDetectFails = "", bool fallbackToGlobal = true)
		{
			throw new NotImplementedException();
		}

		internal override Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken)
		{
			return base.ConfidentialClientApplicationExecutor.ExecuteAsync(base.CommonParameters, Parameters, cancellationToken);
		}

		protected override void Validate()
		{
			base.Validate();
			if (!Parameters.SendX5C.HasValue)
			{
				Parameters.SendX5C = base.ServiceBundle.Config.SendX5C;
			}
		}

		internal override ApiEvent.ApiIds CalculateApiEventId()
		{
			return ApiEvent.ApiIds.AcquireTokenForClient;
		}
	}
	public sealed class AcquireTokenForManagedIdentityParameterBuilder : AbstractManagedIdentityAcquireTokenParameterBuilder<AcquireTokenForManagedIdentityParameterBuilder>
	{
		private AcquireTokenForManagedIdentityParameters Parameters { get; } = new AcquireTokenForManagedIdentityParameters();

		internal AcquireTokenForManagedIdentityParameterBuilder(IManagedIdentityApplicationExecutor managedIdentityApplicationExecutor)
			: base(managedIdentityApplicationExecutor)
		{
		}

		internal static AcquireTokenForManagedIdentityParameterBuilder Create(IManagedIdentityApplicationExecutor managedIdentityApplicationExecutor, string resource)
		{
			return new AcquireTokenForManagedIdentityParameterBuilder(managedIdentityApplicationExecutor).WithResource(resource);
		}

		private AcquireTokenForManagedIdentityParameterBuilder WithResource(string resource)
		{
			Parameters.Resource = ScopeHelper.RemoveDefaultSuffixIfPresent(resource);
			base.CommonParameters.Scopes = new string[1] { Parameters.Resource };
			return this;
		}

		public AcquireTokenForManagedIdentityParameterBuilder WithForceRefresh(bool forceRefresh)
		{
			Parameters.ForceRefresh = forceRefresh;
			return this;
		}

		internal override Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken)
		{
			return base.ManagedIdentityApplicationExecutor.ExecuteAsync(base.CommonParameters, Parameters, cancellationToken);
		}

		internal override ApiEvent.ApiIds CalculateApiEventId()
		{
			if (base.ServiceBundle.Config.ManagedIdentityId.IdType == ManagedIdentityIdType.SystemAssigned)
			{
				return ApiEvent.ApiIds.AcquireTokenForSystemAssignedManagedIdentity;
			}
			return ApiEvent.ApiIds.AcquireTokenForUserAssignedManagedIdentity;
		}
	}
	public sealed class AcquireTokenInteractiveParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder<AcquireTokenInteractiveParameterBuilder>
	{
		private AcquireTokenInteractiveParameters Parameters { get; } = new AcquireTokenInteractiveParameters();

		internal AcquireTokenInteractiveParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor)
			: base(publicClientApplicationExecutor)
		{
		}

		internal void SetCustomWebUi(ICustomWebUi customWebUi)
		{
			Parameters.CustomWebUi = customWebUi;
		}

		internal static AcquireTokenInteractiveParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable<string> scopes)
		{
			return new AcquireTokenInteractiveParameterBuilder(publicClientApplicationExecutor).WithCurrentSynchronizationContext().WithScopes(scopes);
		}

		internal AcquireTokenInteractiveParameterBuilder WithCurrentSynchronizationContext()
		{
			Parameters.UiParent.SynchronizationContext = SynchronizationContext.Current;
			return this;
		}

		internal AcquireTokenInteractiveParameterBuilder WithParentActivityOrWindowFunc(Func<object> parentActivityOrWindowFunc)
		{
			if (parentActivityOrWindowFunc != null)
			{
				WithParentActivityOrWindow(parentActivityOrWindowFunc());
			}
			return this;
		}

		public AcquireTokenInteractiveParameterBuilder WithUseEmbeddedWebView(bool useEmbeddedWebView)
		{
			Parameters.UseEmbeddedWebView = (useEmbeddedWebView ? WebViewPreference.Embedded : WebViewPreference.System);
			return this;
		}

		public AcquireTokenInteractiveParameterBuilder WithSystemWebViewOptions(SystemWebViewOptions options)
		{
			SystemWebViewOptions.ValidatePlatformAvailability();
			Parameters.UiParent.SystemWebViewOptions = options;
			return this;
		}

		public AcquireTokenInteractiveParameterBuilder WithEmbeddedWebViewOptions(EmbeddedWebViewOptions options)
		{
			EmbeddedWebViewOptions.ValidatePlatformAvailability();
			Parameters.UiParent.EmbeddedWebviewOptions = options;
			return this;
		}

		public AcquireTokenInteractiveParameterBuilder WithLoginHint(string loginHint)
		{
			Parameters.LoginHint = loginHint;
			return this;
		}

		public AcquireTokenInteractiveParameterBuilder WithAccount(IAccount account)
		{
			Parameters.Account = account;
			return this;
		}

		public AcquireTokenInteractiveParameterBuilder WithExtraScopesToConsent(IEnumerable<string> extraScopesToConsent)
		{
			Parameters.ExtraScopesToConsent = extraScopesToConsent;
			return this;
		}

		public AcquireTokenInteractiveParameterBuilder WithPrompt(Prompt prompt)
		{
			Parameters.Prompt = prompt;
			return this;
		}

		public AcquireTokenInteractiveParameterBuilder WithParentActivityOrWindow(object parent)
		{
			return WithParentObject(parent);
		}

		private AcquireTokenInteractiveParameterBuilder WithParentObject(object parent)
		{
			if (parent is IntPtr intPtr)
			{
				Parameters.UiParent.OwnerWindow = intPtr;
			}
			return this;
		}

		[CLSCompliant(false)]
		public AcquireTokenInteractiveParameterBuilder WithParentActivityOrWindow(IntPtr window)
		{
			return WithParentObject(window);
		}

		public AcquireTokenInteractiveParameterBuilder WithProofOfPossession(string nonce, HttpMethod httpMethod, Uri requestUri)
		{
			ApplicationBase.GuardMobileFrameworks();
			if (!base.ServiceBundle.Config.IsBrokerEnabled)
			{
				throw new MsalClientException("broker_required_for_pop", "The request has Proof-of-Possession configured but does not have broker enabled. Broker is required to use Proof-of-Possession on public clients. Use IPublicClientApplication.IsProofOfPossessionSupportedByClient to ensure Proof-of-Possession can be performed before using WithProofOfPossession.");
			}
			if (!base.ServiceBundle.PlatformProxy.CreateBroker(base.ServiceBundle.Config, null).IsPopSupported)
			{
				throw new MsalClientException("broker_does_not_support_pop", "The broker does not support Proof-of-Possession on the current platform.");
			}
			PoPAuthenticationConfiguration poPAuthenticationConfiguration = new PoPAuthenticationConfiguration(requestUri);
			if (string.IsNullOrEmpty(nonce))
			{
				throw new ArgumentNullException("nonce");
			}
			poPAuthenticationConfiguration.Nonce = nonce;
			poPAuthenticationConfiguration.HttpMethod = httpMethod;
			base.CommonParameters.PopAuthenticationConfiguration = poPAuthenticationConfiguration;
			base.CommonParameters.AuthenticationScheme = new PopBrokerAuthenticationScheme();
			return this;
		}

		protected override void Validate()
		{
			base.Validate();
			if (Parameters.UiParent.SystemWebViewOptions != null && Parameters.UseEmbeddedWebView == WebViewPreference.Embedded)
			{
				throw new MsalClientException("embedded_webview_not_compatible_default_browser", "You configured MSAL interactive authentication to use an embedded WebView and you also configured system WebView options. These are mutually exclusive. See https://aka.ms/msal-net-os-browser. ");
			}
			if (Parameters.UiParent.SystemWebViewOptions != null && Parameters.UseEmbeddedWebView == WebViewPreference.NotSpecified)
			{
				WithUseEmbeddedWebView(useEmbeddedWebView: false);
			}
			Parameters.LoginHint = ((!string.IsNullOrWhiteSpace(Parameters.LoginHint)) ? Parameters.LoginHint : Parameters.Account?.Username);
		}

		internal override Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken)
		{
			return base.PublicClientApplicationExecutor.ExecuteAsync(base.CommonParameters, Parameters, cancellationToken);
		}

		internal override ApiEvent.ApiIds CalculateApiEventId()
		{
			return ApiEvent.ApiIds.AcquireTokenInteractive;
		}
	}
	public sealed class AcquireTokenOnBehalfOfParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder<AcquireTokenOnBehalfOfParameterBuilder>
	{
		internal AcquireTokenOnBehalfOfParameters Parameters { get; } = new AcquireTokenOnBehalfOfParameters();

		internal AcquireTokenOnBehalfOfParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor)
			: base(confidentialClientApplicationExecutor)
		{
		}

		internal static AcquireTokenOnBehalfOfParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable<string> scopes, UserAssertion userAssertion)
		{
			return new AcquireTokenOnBehalfOfParameterBuilder(confidentialClientApplicationExecutor).WithScopes(scopes).WithUserAssertion(userAssertion);
		}

		internal static AcquireTokenOnBehalfOfParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable<string> scopes, UserAssertion userAssertion, string cacheKey)
		{
			return new AcquireTokenOnBehalfOfParameterBuilder(confidentialClientApplicationExecutor).WithScopes(scopes).WithUserAssertion(userAssertion).WithCacheKey(cacheKey);
		}

		internal static AcquireTokenOnBehalfOfParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable<string> scopes, string cacheKey)
		{
			return new AcquireTokenOnBehalfOfParameterBuilder(confidentialClientApplicationExecutor).WithScopes(scopes).WithCacheKey(cacheKey);
		}

		private AcquireTokenOnBehalfOfParameterBuilder WithUserAssertion(UserAssertion userAssertion)
		{
			Parameters.UserAssertion = userAssertion;
			return this;
		}

		private AcquireTokenOnBehalfOfParameterBuilder WithCacheKey(string cacheKey)
		{
			Parameters.LongRunningOboCacheKey = cacheKey ?? throw new ArgumentNullException("cacheKey");
			return this;
		}

		public AcquireTokenOnBehalfOfParameterBuilder WithSendX5C(bool withSendX5C)
		{
			Parameters.SendX5C = withSendX5C;
			return this;
		}

		public AcquireTokenOnBehalfOfParameterBuilder WithForceRefresh(bool forceRefresh)
		{
			Parameters.ForceRefresh = forceRefresh;
			return this;
		}

		public AcquireTokenOnBehalfOfParameterBuilder WithCcsRoutingHint(string userObjectIdentifier, string tenantIdentifier)
		{
			if (string.IsNullOrEmpty(userObjectIdentifier) || string.IsNullOrEmpty(tenantIdentifier))
			{
				return this;
			}
			Dictionary<string, string> extraHttpHeaders = new Dictionary<string, string> { 
			{
				"x-anchormailbox",
				CoreHelpers.GetCcsClientInfoHint(userObjectIdentifier, tenantIdentifier)
			} };
			this.WithExtraHttpHeaders(extraHttpHeaders);
			return this;
		}

		public AcquireTokenOnBehalfOfParameterBuilder WithCcsRoutingHint(string userName)
		{
			if (string.IsNullOrEmpty(userName))
			{
				return this;
			}
			Dictionary<string, string> extraHttpHeaders = new Dictionary<string, string> { 
			{
				"x-anchormailbox",
				CoreHelpers.GetCcsUpnHint(userName)
			} };
			this.WithExtraHttpHeaders(extraHttpHeaders);
			return this;
		}

		internal override Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken)
		{
			return base.ConfidentialClientApplicationExecutor.ExecuteAsync(base.CommonParameters, Parameters, cancellationToken);
		}

		protected override void Validate()
		{
			base.Validate();
			if (!Parameters.SendX5C.HasValue)
			{
				Parameters.SendX5C = base.ServiceBundle.Config?.SendX5C ?? false;
			}
		}

		internal override ApiEvent.ApiIds CalculateApiEventId()
		{
			if (string.IsNullOrEmpty(Parameters.LongRunningOboCacheKey))
			{
				return ApiEvent.ApiIds.AcquireTokenOnBehalfOf;
			}
			if (Parameters.UserAssertion != null)
			{
				return ApiEvent.ApiIds.InitiateLongRunningObo;
			}
			return ApiEvent.ApiIds.AcquireTokenInLongRunningObo;
		}
	}
	public sealed class AcquireTokenSilentParameterBuilder : AbstractClientAppBaseAcquireTokenParameterBuilder<AcquireTokenSilentParameterBuilder>
	{
		private AcquireTokenSilentParameters Parameters { get; } = new AcquireTokenSilentParameters();

		internal AcquireTokenSilentParameterBuilder(IClientApplicationBaseExecutor clientApplicationBaseExecutor)
			: base(clientApplicationBaseExecutor)
		{
		}

		internal static AcquireTokenSilentParameterBuilder Create(IClientApplicationBaseExecutor clientApplicationBaseExecutor, IEnumerable<string> scopes, IAccount account)
		{
			return new AcquireTokenSilentParameterBuilder(clientApplicationBaseExecutor).WithScopes(scopes).WithAccount(account);
		}

		internal static AcquireTokenSilentParameterBuilder Create(IClientApplicationBaseExecutor clientApplicationBaseExecutor, IEnumerable<string> scopes, string loginHint)
		{
			return new AcquireTokenSilentParameterBuilder(clientApplicationBaseExecutor).WithScopes(scopes).WithLoginHint(loginHint);
		}

		private AcquireTokenSilentParameterBuilder WithAccount(IAccount account)
		{
			Parameters.Account = account;
			return this;
		}

		private AcquireTokenSilentParameterBuilder WithLoginHint(string loginHint)
		{
			Parameters.LoginHint = loginHint;
			return this;
		}

		public AcquireTokenSilentParameterBuilder WithForceRefresh(bool forceRefresh)
		{
			Parameters.ForceRefresh = forceRefresh;
			return this;
		}

		internal override Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken)
		{
			return base.ClientApplicationBaseExecutor.ExecuteAsync(base.CommonParameters, Parameters, cancellationToken);
		}

		protected override void Validate()
		{
			base.Validate();
			if (!Parameters.SendX5C.HasValue)
			{
				Parameters.SendX5C = base.ServiceBundle.Config.SendX5C;
			}
			if (base.ServiceBundle.Config.Authority.AuthorityInfo.AuthorityType == AuthorityType.B2C && (base.CommonParameters.Scopes == null || base.CommonParameters.Scopes.All(string.IsNullOrWhiteSpace)))
			{
				throw new MsalUiRequiredException("scopes_required_client_credentials", "At least one scope needs to be requested for this authentication flow. ", null, UiRequiredExceptionClassification.AcquireTokenSilentFailed);
			}
		}

		internal override ApiEvent.ApiIds CalculateApiEventId()
		{
			return ApiEvent.ApiIds.AcquireTokenSilent;
		}

		public AcquireTokenSilentParameterBuilder WithSendX5C(bool withSendX5C)
		{
			Parameters.SendX5C = withSendX5C;
			return this;
		}

		public AcquireTokenSilentParameterBuilder WithProofOfPossession(PoPAuthenticationConfiguration popAuthenticationConfiguration)
		{
			ApplicationBase.GuardMobileFrameworks();
			ValidateUseOfExperimentalFeature("WithProofOfPossession");
			base.CommonParameters.PopAuthenticationConfiguration = popAuthenticationConfiguration ?? throw new ArgumentNullException("popAuthenticationConfiguration");
			base.CommonParameters.AuthenticationScheme = new PopAuthenticationScheme(base.CommonParameters.PopAuthenticationConfiguration, base.ServiceBundle);
			return this;
		}

		public AcquireTokenSilentParameterBuilder WithProofOfPossession(string nonce, HttpMethod httpMethod, Uri requestUri)
		{
			if (base.ServiceBundle.Config.IsConfidentialClient)
			{
				ValidateUseOfExperimentalFeature("WithProofOfPossession");
			}
			if (!base.ServiceBundle.Config.IsConfidentialClient && !base.ServiceBundle.Config.IsBrokerEnabled)
			{
				throw new MsalClientException("broker_required_for_pop", "The request has Proof-of-Possession configured but does not have broker enabled. Broker is required to use Proof-of-Possession on public clients. Use IPublicClientApplication.IsProofOfPossessionSupportedByClient to ensure Proof-of-Possession can be performed before using WithProofOfPossession.");
			}
			ApplicationBase.GuardMobileFrameworks();
			IBroker broker = base.ServiceBundle.PlatformProxy.CreateBroker(base.ServiceBundle.Config, null);
			if (base.ServiceBundle.Config.IsBrokerEnabled)
			{
				if (string.IsNullOrEmpty(nonce))
				{
					throw new ArgumentNullException("nonce");
				}
				if (!broker.IsPopSupported)
				{
					throw new MsalClientException("broker_does_not_support_pop", "The broker does not support Proof-of-Possession on the current platform.");
				}
			}
			PoPAuthenticationConfiguration poPAuthenticationConfiguration = new PoPAuthenticationConfiguration(requestUri ?? throw new ArgumentNullException("requestUri"));
			poPAuthenticationConfiguration.HttpMethod = httpMethod ?? throw new ArgumentNullException("httpMethod");
			poPAuthenticationConfiguration.Nonce = nonce;
			IAuthenticationScheme authenticationScheme;
			if (base.ServiceBundle.Config.IsBrokerEnabled)
			{
				poPAuthenticationConfiguration.SignHttpRequest = false;
				authenticationScheme = new PopBrokerAuthenticationScheme();
			}
			else
			{
				authenticationScheme = new PopAuthenticationScheme(poPAuthenticationConfiguration, base.ServiceBundle);
			}
			base.CommonParameters.PopAuthenticationConfiguration = poPAuthenticationConfiguration;
			base.CommonParameters.AuthenticationScheme = authenticationScheme;
			return this;
		}
	}
	public sealed class AcquireTokenWithDeviceCodeParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder<AcquireTokenWithDeviceCodeParameterBuilder>
	{
		private AcquireTokenWithDeviceCodeParameters Parameters { get; } = new AcquireTokenWithDeviceCodeParameters();

		internal AcquireTokenWithDeviceCodeParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor)
			: base(publicClientApplicationExecutor)
		{
		}

		internal static AcquireTokenWithDeviceCodeParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable<string> scopes, Func<DeviceCodeResult, Task> deviceCodeResultCallback)
		{
			return new AcquireTokenWithDeviceCodeParameterBuilder(publicClientApplicationExecutor).WithScopes(scopes).WithDeviceCodeResultCallback(deviceCodeResultCallback);
		}

		public AcquireTokenWithDeviceCodeParameterBuilder WithDeviceCodeResultCallback(Func<DeviceCodeResult, Task> deviceCodeResultCallback)
		{
			Parameters.DeviceCodeResultCallback = deviceCodeResultCallback;
			return this;
		}

		internal override Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken)
		{
			return base.PublicClientApplicationExecutor.ExecuteAsync(base.CommonParameters, Parameters, cancellationToken);
		}

		internal override ApiEvent.ApiIds CalculateApiEventId()
		{
			return ApiEvent.ApiIds.AcquireTokenByDeviceCode;
		}

		protected override void Validate()
		{
			base.Validate();
			if (Parameters.DeviceCodeResultCallback == null)
			{
				throw new ArgumentNullException("DeviceCodeResultCallback", "A deviceCodeResultCallback must be provided for Device Code authentication to work properly");
			}
		}
	}
	public abstract class BaseAbstractAcquireTokenParameterBuilder<T> where T : BaseAbstractAcquireTokenParameterBuilder<T>
	{
		internal IServiceBundle ServiceBundle { get; }

		internal AcquireTokenCommonParameters CommonParameters { get; } = new AcquireTokenCommonParameters();

		protected BaseAbstractAcquireTokenParameterBuilder()
		{
		}

		internal BaseAbstractAcquireTokenParameterBuilder(IServiceBundle serviceBundle)
		{
			ServiceBundle = serviceBundle;
		}

		public abstract Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);

		internal abstract ApiEvent.ApiIds CalculateApiEventId();

		public Task<AuthenticationResult> ExecuteAsync()
		{
			return ExecuteAsync(CancellationToken.None);
		}

		public T WithCorrelationId(Guid correlationId)
		{
			CommonParameters.UserProvidedCorrelationId = correlationId;
			CommonParameters.UseCorrelationIdFromUser = true;
			return (T)this;
		}

		protected virtual void Validate()
		{
		}

		internal void ValidateAndCalculateApiId()
		{
			Validate();
			CommonParameters.ApiId = CalculateApiEventId();
			CommonParameters.CorrelationId = (CommonParameters.UseCorrelationIdFromUser ? CommonParameters.UserProvidedCorrelationId : Guid.NewGuid());
		}

		internal void ValidateUseOfExperimentalFeature([CallerMemberName] string memberName = "")
		{
			if (!ServiceBundle.Config.ExperimentalFeaturesEnabled)
			{
				throw new MsalClientException("experimental_feature", MsalErrorMessage.ExperimentalFeature(memberName));
			}
		}
	}
	public class BrokerOptions
	{
		[Flags]
		public enum OperatingSystems
		{
			None = 0,
			Windows = 1
		}

		public OperatingSystems EnabledOn { get; }

		public string Title { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool MsaPassthrough { get; set; }

		public bool ListOperatingSystemAccounts { get; set; }

		public BrokerOptions(OperatingSystems enabledOn)
		{
			EnabledOn = enabledOn;
		}

		internal static BrokerOptions CreateFromWindowsOptions(WindowsBrokerOptions winOptions)
		{
			return new BrokerOptions(OperatingSystems.Windows)
			{
				Title = winOptions.HeaderText,
				MsaPassthrough = winOptions.MsaPassthrough,
				ListOperatingSystemAccounts = winOptions.ListWindowsWorkAndSchoolAccounts
			};
		}

		internal bool IsBrokerEnabledOnCurrentOs()
		{
			if (EnabledOn.HasFlag(OperatingSystems.Windows) && DesktopOsHelper.IsWindows())
			{
				return true;
			}
			return false;
		}
	}
	public class EmbeddedWebViewOptions
	{
		public string Title { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("In case when WebView2 is not available, MSAL.NET will fallback to legacy WebView.", true)]
		public string WebView2BrowserExecutableFolder { get; set; }

		public EmbeddedWebViewOptions()
		{
			ValidatePlatformAvailability();
		}

		internal static EmbeddedWebViewOptions GetDefaultOptions()
		{
			return new EmbeddedWebViewOptions();
		}

		internal void LogParameters(ILoggerAdapter logger)
		{
			logger.Info("WebView2Options configured");
			logger.Info(() => "Title: " + Title);
		}

		internal static void ValidatePlatformAvailability()
		{
		}
	}
	public sealed class GetAuthorizationRequestUrlParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder<GetAuthorizationRequestUrlParameterBuilder>
	{
		private GetAuthorizationRequestUrlParameters Parameters { get; } = new GetAuthorizationRequestUrlParameters();

		internal GetAuthorizationRequestUrlParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationexecutor)
			: base(confidentialClientApplicationexecutor)
		{
		}

		internal static GetAuthorizationRequestUrlParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable<string> scopes)
		{
			return new GetAuthorizationRequestUrlParameterBuilder(confidentialClientApplicationExecutor).WithScopes(scopes);
		}

		public GetAuthorizationRequestUrlParameterBuilder WithRedirectUri(string redirectUri)
		{
			Parameters.RedirectUri = redirectUri;
			return this;
		}

		public GetAuthorizationRequestUrlParameterBuilder WithLoginHint(string loginHint)
		{
			Parameters.LoginHint = loginHint;
			return this;
		}

		public GetAuthorizationRequestUrlParameterBuilder WithAccount(IAccount account)
		{
			Parameters.Account = account;
			return this;
		}

		public GetAuthorizationRequestUrlParameterBuilder WithExtraScopesToConsent(IEnumerable<string> extraScopesToConsent)
		{
			Parameters.ExtraScopesToConsent = extraScopesToConsent;
			return this;
		}

		public GetAuthorizationRequestUrlParameterBuilder WithPkce(out string codeVerifier)
		{
			Parameters.CodeVerifier = (codeVerifier = base.ServiceBundle.PlatformProxy.CryptographyManager.GenerateCodeVerifier());
			return this;
		}

		public GetAuthorizationRequestUrlParameterBuilder WithCcsRoutingHint(string userObjectIdentifier, string tenantIdentifier)
		{
			if (string.IsNullOrEmpty(userObjectIdentifier) || string.IsNullOrEmpty(tenantIdentifier))
			{
				return this;
			}
			Parameters.CcsRoutingHint = new KeyValuePair<string, string>(userObjectIdentifier, tenantIdentifier);
			return this;
		}

		public GetAuthorizationRequestUrlParameterBuilder WithPrompt(Prompt prompt)
		{
			Parameters.Prompt = prompt;
			return this;
		}

		internal override Task<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken)
		{
			throw new InvalidOperationException("This is a developer BUG.  This should never get executed.");
		}

		public new Task<Uri> ExecuteAsync(CancellationToken cancellationToken)
		{
			ValidateAndCalculateApiId();
			return base.ConfidentialClientApplicationExecutor.ExecuteAsync(base.CommonParameters, Parameters, cancellationToken);
		}

		public new Task<Uri> ExecuteAsync()
		{
			return ExecuteAsync(CancellationToken.None);
		}

		internal override ApiEvent.ApiIds CalculateApiEventId()
		{
			return ApiEvent.ApiIds.GetAuthorizationRequestUrl;
		}
	}
	public class SystemWebViewOptions
	{
		public string HtmlMessageSuccess { get; set; }

		public string HtmlMessageError { get; set; }

		public Uri BrowserRedirectSuccess { get; set; }

		public Uri BrowserRedirectError { get; set; }

		public bool iOSHidePrivacyPrompt { get; set; }

		public Func<Uri, Task> OpenBrowserAsync { get; set; }

		public SystemWebViewOptions()
		{
			ValidatePlatformAvailability();
		}

		internal void LogParameters(ILoggerAdapter logger)
		{
			logger.Info($"DefaultBrowserOptions configured. HidePrivacyPrompt {iOSHidePrivacyPrompt}");
			if (logger.IsLoggingEnabled(LogLevel.Verbose))
			{
				logger.VerbosePii(() => "HtmlMessageSuccess " + HtmlMessageSuccess, () => "HtmlMessageSuccess? " + !string.IsNullOrEmpty(HtmlMessageSuccess));
				logger.VerbosePii(() => "HtmlMessageError " + HtmlMessageError, () => "HtmlMessageError? " + !string.IsNullOrEmpty(HtmlMessageError));
				logger.VerbosePii(() => "BrowserRedirectSuccess " + BrowserRedirectSuccess, () => "BrowserRedirectSuccess? " + (BrowserRedirectSuccess != null));
				logger.VerbosePii(() => "BrowserRedirectError " + BrowserRedirectError, () => "BrowserRedirectError? " + (BrowserRedirectError != null));
			}
		}

		internal static void ValidatePlatformAvailability()
		{
		}

		public static async Task OpenWithEdgeBrowserAsync(Uri uri)
		{
			if (uri == null)
			{
				throw new ArgumentNullException("uri");
			}
			string absoluteUri = uri.AbsoluteUri;
			if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
			{
				absoluteUri = absoluteUri.Replace("&", "^&");
				Process.Start(new ProcessStartInfo("cmd", "/c start microsoft-edge:" + absoluteUri)
				{
					CreateNoWindow = true
				});
			}
			else
			{
				await PlatformProxyFactory.CreatePlatformProxy(new NullLogger()).StartDefaultOsBrowserAsync(absoluteUri, isBrokerConfigured: true).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		public static async Task OpenWithChromeEdgeBrowserAsync(Uri uri)
		{
			if (uri == null)
			{
				throw new ArgumentNullException("uri");
			}
			string absoluteUri = uri.AbsoluteUri;
			if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
			{
				absoluteUri = absoluteUri.Replace("&", "^&");
				Process.Start(new ProcessStartInfo("cmd", "/c start msedge " + absoluteUri)
				{
					CreateNoWindow = true
				});
				return;
			}
			if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
			{
				await PlatformProxyFactory.CreatePlatformProxy(new NullLogger()).StartDefaultOsBrowserAsync(absoluteUri, isBrokerConfigured: true).ConfigureAwait(continueOnCapturedContext: false);
				return;
			}
			if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
			{
				Process.Start("msedge", absoluteUri);
				return;
			}
			throw new PlatformNotSupportedException(RuntimeInformation.OSDescription);
		}
	}
	public class WindowsBrokerOptions
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool MsaPassthrough { get; set; }

		public bool ListWindowsWorkAndSchoolAccounts { get; set; }

		public string HeaderText { get; set; }

		public WindowsBrokerOptions()
		{
			ValidatePlatformAvailability();
		}

		internal static WindowsBrokerOptions CreateDefault()
		{
			return new WindowsBrokerOptions();
		}

		internal static void ValidatePlatformAvailability()
		{
		}
	}
	public enum AadAuthorityAudience
	{
		None,
		AzureAdMyOrg,
		AzureAdAndPersonalMicrosoftAccount,
		AzureAdMultipleOrgs,
		PersonalMicrosoftAccount
	}
	public abstract class AbstractApplicationBuilder<T> : BaseAbstractApplicationBuilder<T> where T : BaseAbstractApplicationBuilder<T>
	{
		internal AbstractApplicationBuilder(ApplicationConfiguration configuration)
			: base(configuration)
		{
		}

		[Obsolete("This method name has a typo, please use WithInstanceDiscoveryMetadata instead", false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public T WithInstanceDicoveryMetadata(string instanceDiscoveryJson)
		{
			if (string.IsNullOrEmpty(instanceDiscoveryJson))
			{
				throw new ArgumentNullException(instanceDiscoveryJson);
			}
			try
			{
				InstanceDiscoveryResponse customInstanceDiscoveryMetadata = JsonHelper.DeserializeFromJson<InstanceDiscoveryResponse>(instanceDiscoveryJson);
				base.Config.CustomInstanceDiscoveryMetadata = customInstanceDiscoveryMetadata;
				return this as T;
			}
			catch (JsonException innerException)
			{
				throw new MsalClientException("invalid-custom-instance-metadata", "The json containing instance metadata could not be parsed. See https://aka.ms/msal-net-custom-instance-metadata for details. ", innerException);
			}
		}

		public T WithInstanceDiscoveryMetadata(string instanceDiscoveryJson)
		{
			if (string.IsNullOrEmpty(instanceDiscoveryJson))
			{
				throw new ArgumentNullException(instanceDiscoveryJson);
			}
			try
			{
				InstanceDiscoveryResponse customInstanceDiscoveryMetadata = JsonHelper.DeserializeFromJson<InstanceDiscoveryResponse>(instanceDiscoveryJson);
				base.Config.CustomInstanceDiscoveryMetadata = customInstanceDiscoveryMetadata;
				return this as T;
			}
			catch (JsonException innerException)
			{
				throw new MsalClientException("invalid-custom-instance-metadata", "The json containing instance metadata could not be parsed. See https://aka.ms/msal-net-custom-instance-metadata for details. ", innerException);
			}
		}

		[Obsolete("This method name has a typo, please use WithInstanceDiscoveryMetadata instead", false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public T WithInstanceDicoveryMetadata(Uri instanceDiscoveryUri)
		{
			base.Config.CustomInstanceDiscoveryMetadataUri = instanceDiscoveryUri ?? throw new ArgumentNullException("instanceDiscoveryUri");
			return this as T;
		}

		public T WithInstanceDiscoveryMetadata(Uri instanceDiscoveryUri)
		{
			base.Config.CustomInstanceDiscoveryMetadataUri = instanceDiscoveryUri ?? throw new ArgumentNullException("instanceDiscoveryUri");
			return this as T;
		}

		internal T WithPlatformProxy(IPlatformProxy platformProxy)
		{
			base.Config.PlatformProxy = platformProxy;
			return this as T;
		}

		public T WithCacheOptions(CacheOptions options)
		{
			base.Config.AccessorOptions = options;
			return this as T;
		}

		internal T WithUserTokenCacheInternalForTest(ITokenCacheInternal tokenCacheInternal)
		{
			base.Config.UserTokenCacheInternalForTest = tokenCacheInternal;
			return this as T;
		}

		public T WithLegacyCacheCompatibility(bool enableLegacyCacheCompatibility = true)
		{
			base.Config.LegacyCacheCompatibilityEnabled = enableLegacyCacheCompatibility;
			return this as T;
		}

		[Obsolete("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		internal T WithTelemetry(TelemetryCallback telemetryCallback)
		{
			return this as T;
		}

		public T WithClientId(string clientId)
		{
			base.Config.ClientId = clientId;
			return this as T;
		}

		public T WithRedirectUri(string redirectUri)
		{
			base.Config.RedirectUri = GetValueIfNotEmpty(base.Config.RedirectUri, redirectUri);
			return this as T;
		}

		public T WithTenantId(string tenantId)
		{
			base.Config.TenantId = GetValueIfNotEmpty(base.Config.TenantId, tenantId);
			return this as T;
		}

		public T WithClientName(string clientName)
		{
			base.Config.ClientName = GetValueIfNotEmpty(base.Config.ClientName, clientName);
			return this as T;
		}

		public T WithClientVersion(string clientVersion)
		{
			base.Config.ClientVersion = GetValueIfNotEmpty(base.Config.ClientVersion, clientVersion);
			return this as T;
		}

		protected T WithOptions(ApplicationOptions applicationOptions)
		{
			WithClientId(applicationOptions.ClientId);
			WithRedirectUri(applicationOptions.RedirectUri);
			WithTenantId(applicationOptions.TenantId);
			WithClientName(applicationOptions.ClientName);
			WithClientVersion(applicationOptions.ClientVersion);
			WithClientCapabilities(applicationOptions.ClientCapabilities);
			WithLegacyCacheCompatibility(applicationOptions.LegacyCacheCompatibilityEnabled);
			WithLogging(null, applicationOptions.LogLevel, applicationOptions.EnablePiiLogging, applicationOptions.IsDefaultPlatformLoggingEnabled);
			base.Config.Instance = applicationOptions.Instance;
			base.Config.AadAuthorityAudience = applicationOptions.AadAuthorityAudience;
			base.Config.AzureCloudInstance = applicationOptions.AzureCloudInstance;
			return this as T;
		}

		public T WithExtraQueryParameters(IDictionary<string, string> extraQueryParameters)
		{
			base.Config.ExtraQueryParameters = extraQueryParameters ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			return this as T;
		}

		public T WithExtraQueryParameters(string extraQueryParameters)
		{
			if (!string.IsNullOrWhiteSpace(extraQueryParameters))
			{
				return WithExtraQueryParameters(CoreHelpers.ParseKeyValueList(extraQueryParameters, '&', urlDecode: true, null));
			}
			return this as T;
		}

		public T WithClientCapabilities(IEnumerable<string> clientCapabilities)
		{
			if (clientCapabilities != null && clientCapabilities.Any())
			{
				base.Config.ClientCapabilities = clientCapabilities;
			}
			return this as T;
		}

		public T WithInstanceDiscovery(bool enableInstanceDiscovery)
		{
			base.Config.IsInstanceDiscoveryEnabled = enableInstanceDiscovery;
			return this as T;
		}

		[Obsolete("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public T WithTelemetry(ITelemetryConfig telemetryConfig)
		{
			return this as T;
		}

		internal virtual void Validate()
		{
			if (string.IsNullOrWhiteSpace(base.Config.ClientId))
			{
				throw new MsalClientException("no_client_id", "No ClientId was specified. ");
			}
			if (base.Config.CustomInstanceDiscoveryMetadata != null && base.Config.CustomInstanceDiscoveryMetadataUri != null)
			{
				throw new MsalClientException("custom_metadata_instance_or_uri", "You have configured your own instance metadata using both an Uri and a string. Only one is supported. See https://aka.ms/msal-net-custom-instance-metadata for more details. ");
			}
			if (base.Config.Authority.AuthorityInfo.ValidateAuthority && (base.Config.CustomInstanceDiscoveryMetadata != null || base.Config.CustomInstanceDiscoveryMetadataUri != null))
			{
				throw new MsalClientException("validate_authority_or_custom_instance_metadata", "You have configured custom instance metadata, but the validateAuthority flag is set to true. These are mutually exclusive. Set the validateAuthority flag to false. See https://aka.ms/msal-net-custom-instance-metadata for more details. ");
			}
		}

		internal override ApplicationConfiguration BuildConfiguration()
		{
			ResolveAuthority();
			Validate();
			return base.Config;
		}

		public T WithAuthority(Uri authorityUri, bool validateAuthority = true)
		{
			if (authorityUri == null)
			{
				throw new ArgumentNullException("authorityUri");
			}
			return WithAuthority(authorityUri.ToString(), validateAuthority);
		}

		public T WithAuthority(string authorityUri, bool validateAuthority = true)
		{
			if (string.IsNullOrWhiteSpace(authorityUri))
			{
				throw new ArgumentNullException(authorityUri);
			}
			base.Config.Authority = Authority.CreateAuthority(authorityUri, validateAuthority);
			return this as T;
		}

		public T WithAuthority(string cloudInstanceUri, Guid tenantId, bool validateAuthority = true)
		{
			WithAuthority(cloudInstanceUri, tenantId.ToString("D", CultureInfo.InvariantCulture), validateAuthority);
			return this as T;
		}

		public T WithAuthority(string cloudInstanceUri, string tenant, bool validateAuthority = true)
		{
			if (string.IsNullOrWhiteSpace(cloudInstanceUri))
			{
				throw new ArgumentNullException("cloudInstanceUri");
			}
			if (string.IsNullOrWhiteSpace(tenant))
			{
				throw new ArgumentNullException("tenant");
			}
			AuthorityInfo authorityInfo = AuthorityInfo.FromAadAuthority(cloudInstanceUri, tenant, validateAuthority);
			base.Config.Authority = new AadAuthority(authorityInfo);
			return this as T;
		}

		public T WithAuthority(AzureCloudInstance azureCloudInstance, Guid tenantId, bool validateAuthority = true)
		{
			WithAuthority(azureCloudInstance, tenantId.ToString("D", CultureInfo.InvariantCulture), validateAuthority);
			return this as T;
		}

		public T WithAuthority(AzureCloudInstance azureCloudInstance, string tenant, bool validateAuthority = true)
		{
			if (string.IsNullOrWhiteSpace(tenant))
			{
				throw new ArgumentNullException("tenant");
			}
			base.Config.AzureCloudInstance = azureCloudInstance;
			base.Config.TenantId = tenant;
			base.Config.ValidateAuthority = validateAuthority;
			return this as T;
		}

		public T WithAuthority(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, bool validateAuthority = true)
		{
			base.Config.AzureCloudInstance = azureCloudInstance;
			base.Config.AadAuthorityAudience = authorityAudience;
			base.Config.ValidateAuthority = validateAuthority;
			return this as T;
		}

		public T WithAuthority(AadAuthorityAudience authorityAudience, bool validateAuthority = true)
		{
			base.Config.AadAuthorityAudience = authorityAudience;
			base.Config.ValidateAuthority = validateAuthority;
			return this as T;
		}

		public T WithAdfsAuthority(string authorityUri, bool validateAuthority = true)
		{
			AuthorityInfo authorityInfo = AuthorityInfo.FromAdfsAuthority(authorityUri, validateAuthority);
			base.Config.Authority = Authority.CreateAuthority(authorityInfo);
			return this as T;
		}

		public T WithB2CAuthority(string authorityUri)
		{
			AuthorityInfo authorityInfo = AuthorityInfo.FromB2CAuthority(authorityUri);
			base.Config.Authority = Authority.CreateAuthority(authorityInfo);
			return this as T;
		}

		private static string GetValueIfNotEmpty(string original, string value)
		{
			if (!string.IsNullOrWhiteSpace(value))
			{
				return value;
			}
			return original;
		}
	}
	internal sealed class ApplicationConfiguration : IAppConfig
	{
		public const string DefaultClientName = "UnknownClient";

		public const string DefaultClientVersion = "0.0.0.0";

		private string _clientName = "UnknownClient";

		private string _clientVersion = "0.0.0.0";

		public Func<AppTokenProviderParameters, Task<AppTokenProviderResult>> AppTokenProvider;

		public string ClientName
		{
			get
			{
				return _clientName;
			}
			internal set
			{
				_clientName = (string.IsNullOrWhiteSpace(value) ? "UnknownClient" : value);
			}
		}

		public string ClientVersion
		{
			get
			{
				return _clientVersion;
			}
			internal set
			{
				_clientVersion = (string.IsNullOrWhiteSpace(value) ? "0.0.0.0" : value);
			}
		}

		public ITelemetryClient[] TelemetryClients { get; internal set; } = Array.Empty<ITelemetryClient>();

		public Func<object> ParentActivityOrWindowFunc { get; internal set; }

		public string IosKeychainSecurityGroup { get; internal set; }

		public bool IsBrokerEnabled { get; internal set; }

		public bool IsWebviewSsoPolicyEnabled { get; internal set; }

		public BrokerOptions BrokerOptions { get; set; }

		public Func<CoreUIParent, ApplicationConfiguration, ILoggerAdapter, IBroker> BrokerCreatorFunc { get; set; }

		public Func<IWebUIFactory> WebUiFactoryCreator { get; set; }

		public string KerberosServicePrincipalName { get; set; } = string.Empty;

		public KerberosTicketContainer TicketContainer { get; set; }

		[Obsolete("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public ITelemetryConfig TelemetryConfig { get; internal set; }

		public IHttpManager HttpManager { get; internal set; }

		public IPlatformProxy PlatformProxy { get; internal set; }

		public CacheOptions AccessorOptions { get; set; }

		public Authority Authority { get; internal set; }

		public string ClientId { get; internal set; }

		public string RedirectUri { get; internal set; }

		public bool EnablePiiLogging { get; internal set; }

		public LogLevel LogLevel { get; internal set; } = LogLevel.Info;

		public bool IsDefaultPlatformLoggingEnabled { get; internal set; }

		public IMsalHttpClientFactory HttpClientFactory { get; internal set; }

		public bool IsExtendedTokenLifetimeEnabled { get; set; }

		public LogCallback LoggingCallback { get; internal set; }

		public IIdentityLogger IdentityLogger { get; internal set; }

		public string Component { get; internal set; }

		public IDictionary<string, string> ExtraQueryParameters { get; internal set; } = new Dictionary<string, string>();

		public bool UseRecommendedDefaultRedirectUri { get; internal set; }

		public bool ExperimentalFeaturesEnabled { get; set; }

		public IEnumerable<string> ClientCapabilities { get; set; }

		public bool SendX5C { get; internal set; }

		public bool LegacyCacheCompatibilityEnabled { get; internal set; } = true;

		public bool CacheSynchronizationEnabled { get; internal set; } = true;

		public bool MultiCloudSupportEnabled { get; set; }

		public bool RetryOnServerErrors { get; set; } = true;

		public ManagedIdentityId ManagedIdentityId { get; internal set; }

		public bool IsManagedIdentity { get; }

		public bool IsConfidentialClient { get; }

		public bool IsPublicClient
		{
			get
			{
				if (!IsConfidentialClient)
				{
					return !IsManagedIdentity;
				}
				return false;
			}
		}

		public IClientCredential ClientCredential { get; internal set; }

		public string ClientSecret
		{
			get
			{
				if (ClientCredential is SecretStringClientCredential secretStringClientCredential)
				{
					return secretStringClientCredential.Secret;
				}
				return null;
			}
		}

		public X509Certificate2 ClientCredentialCertificate
		{
			get
			{
				if (ClientCredential is CertificateAndClaimsClientCredential certificateAndClaimsClientCredential)
				{
					return certificateAndClaimsClientCredential.Certificate;
				}
				return null;
			}
		}

		public string AzureRegion { get; set; }

		public string TenantId { get; internal set; }

		public InstanceDiscoveryResponse CustomInstanceDiscoveryMetadata { get; set; }

		public Uri CustomInstanceDiscoveryMetadataUri { get; set; }

		public AadAuthorityAudience AadAuthorityAudience { get; set; }

		public AzureCloudInstance AzureCloudInstance { get; set; }

		public string Instance { get; set; }

		public bool ValidateAuthority { get; set; }

		public ILegacyCachePersistence UserTokenLegacyCachePersistenceForTest { get; set; }

		public ITokenCacheInternal UserTokenCacheInternalForTest { get; set; }

		public ITokenCacheInternal AppTokenCacheInternalForTest { get; set; }

		public IDeviceAuthManager DeviceAuthManagerForTest { get; set; }

		public bool IsInstanceDiscoveryEnabled { get; internal set; } = true;

		public ApplicationConfiguration(MsalClientType applicationType)
		{
			switch (applicationType)
			{
			case MsalClientType.ConfidentialClient:
				IsConfidentialClient = true;
				break;
			case MsalClientType.ManagedIdentityClient:
				IsManagedIdentity = true;
				break;
			}
		}
	}
	public abstract class ApplicationOptions : BaseApplicationOptions
	{
		public string ClientId { get; set; }

		public string TenantId { get; set; }

		public AadAuthorityAudience AadAuthorityAudience { get; set; }

		public string Instance { get; set; }

		public AzureCloudInstance AzureCloudInstance { get; set; }

		public string RedirectUri { get; set; }

		public string ClientName { get; set; }

		public string ClientVersion { get; set; }

		public IEnumerable<string> ClientCapabilities { get; set; }

		public bool LegacyCacheCompatibilityEnabled { get; set; } = true;

		public string KerberosServicePrincipalName { get; set; } = string.Empty;

		public KerberosTicketContainer TicketContainer { get; set; }
	}
	public class AssertionRequestOptions
	{
		public CancellationToken CancellationToken { get; set; }

		public string ClientID { get; set; }

		public string TokenEndpoint { get; set; }
	}
	internal class AuthorityInfo
	{
		internal class AuthorityInfoHelper
		{
			public static IAuthorityValidator CreateAuthorityValidator(AuthorityInfo authorityInfo, RequestContext requestContext)
			{
				switch (authorityInfo.AuthorityType)
				{
				case AuthorityType.Adfs:
					return new AdfsAuthorityValidator(requestContext);
				case AuthorityType.Aad:
					return new AadAuthorityValidator(requestContext);
				case AuthorityType.B2C:
				case AuthorityType.Dsts:
				case AuthorityType.Generic:
				case AuthorityType.Ciam:
					return new NullAuthorityValidator();
				default:
					throw new InvalidOperationException("Invalid AuthorityType");
				}
			}

			public static async Task<Authority> CreateAuthorityForRequestAsync(RequestContext requestContext, AuthorityInfo requestAuthorityInfo, IAccount account = null)
			{
				Authority configAuthority = requestContext.ServiceBundle.Config.Authority;
				AuthorityInfo configAuthorityInfo = configAuthority.AuthorityInfo;
				if (configAuthorityInfo == null)
				{
					throw new ArgumentNullException("AuthorityInfo");
				}
				ValidateTypeMismatch(configAuthorityInfo, requestAuthorityInfo);
				await ValidateSameHostAsync(requestAuthorityInfo, requestContext).ConfigureAwait(continueOnCapturedContext: false);
				AuthorityInfo authorityInfo = requestAuthorityInfo ?? configAuthorityInfo;
				switch (configAuthorityInfo.AuthorityType)
				{
				case AuthorityType.Adfs:
					return new AdfsAuthority(authorityInfo);
				case AuthorityType.Dsts:
					return new DstsAuthority(authorityInfo);
				case AuthorityType.B2C:
					return new B2CAuthority(authorityInfo);
				case AuthorityType.Ciam:
					return new CiamAuthority(authorityInfo);
				case AuthorityType.Generic:
					return new GenericAuthority(authorityInfo);
				case AuthorityType.Aad:
				{
					bool flag = requestContext.ServiceBundle.Config.MultiCloudSupportEnabled && account != null && !PublicClientApplication.IsOperatingSystemAccount(account);
					if (requestAuthorityInfo == null)
					{
						return flag ? CreateAuthorityWithTenant(CreateAuthorityWithEnvironment(configAuthorityInfo, account.Environment), account?.HomeAccountId?.TenantId, forceSpecifiedTenant: false) : CreateAuthorityWithTenant(configAuthority, account?.HomeAccountId?.TenantId, forceSpecifiedTenant: false);
					}
					if (configAuthorityInfo.IsDefaultAuthority && requestAuthorityInfo.AuthorityType != AuthorityType.Aad)
					{
						return requestAuthorityInfo.CreateAuthority();
					}
					AadAuthority aadAuthority = (flag ? new AadAuthority(CreateAuthorityWithEnvironment(requestAuthorityInfo, account?.Environment).AuthorityInfo) : new AadAuthority(requestAuthorityInfo));
					if (!aadAuthority.IsCommonOrganizationsOrConsumersTenant() || aadAuthority.IsOrganizationsTenantWithMsaPassthroughEnabled(requestContext.ServiceBundle.Config.IsBrokerEnabled && requestContext.ServiceBundle.Config.BrokerOptions != null && requestContext.ServiceBundle.Config.BrokerOptions.MsaPassthrough, account?.HomeAccountId?.TenantId))
					{
						return aadAuthority;
					}
					return flag ? CreateAuthorityWithTenant(CreateAuthorityWithEnvironment(configAuthorityInfo, account.Environment), account?.HomeAccountId?.TenantId, forceSpecifiedTenant: false) : CreateAuthorityWithTenant(configAuthority, account?.HomeAccountId?.TenantId, forceSpecifiedTenant: false);
				}
				default:
					throw new MsalClientException("invalid_authority_type", "Unsupported authority type");
				}
			}

			internal static Authority CreateAuthorityWithTenant(Authority authority, string tenantId, bool forceSpecifiedTenant)
			{
				return Authority.CreateAuthority(authority.GetTenantedAuthority(tenantId, forceSpecifiedTenant), authority.AuthorityInfo.ValidateAuthority);
			}

			internal static Authority CreateAuthorityWithEnvironment(AuthorityInfo authorityInfo, string environment)
			{
				return Authority.CreateAuthority(new UriBuilder(authorityInfo.CanonicalAuthority)
				{
					Host = environment
				}.Uri.AbsoluteUri, authorityInfo.ValidateAuthority);
			}

			private static void ValidateTypeMismatch(AuthorityInfo configAuthorityInfo, AuthorityInfo requestAuthorityInfo)
			{
				if (!configAuthorityInfo.IsDefaultAuthority && requestAuthorityInfo != null && configAuthorityInfo.AuthorityType != requestAuthorityInfo.AuthorityType)
				{
					throw new MsalClientException("authority_type_mismatch", MsalErrorMessage.AuthorityTypeMismatch(configAuthorityInfo.AuthorityType, requestAuthorityInfo.AuthorityType));
				}
			}

			private static async Task ValidateSameHostAsync(AuthorityInfo requestAuthorityInfo, RequestContext requestContext)
			{
				AuthorityInfo configAuthorityInfo = requestContext.ServiceBundle.Config.Authority.AuthorityInfo;
				if (requestContext.ServiceBundle.Config.MultiCloudSupportEnabled || requestAuthorityInfo == null || string.Equals(requestAuthorityInfo.Host, configAuthorityInfo.Host, StringComparison.OrdinalIgnoreCase))
				{
					return;
				}
				if (requestAuthorityInfo.AuthorityType == AuthorityType.B2C)
				{
					throw new MsalClientException("B2C_authority_host_mismatch", "The B2C authority host that was used when creating the client application is not the same authority host used in the AcquireToken call. See https://aka.ms/msal-net-b2c for details. ");
				}
				if (requestAuthorityInfo.AuthorityType == AuthorityType.Ciam || requestAuthorityInfo.AuthorityType == AuthorityType.Generic)
				{
					return;
				}
				if (!string.IsNullOrEmpty(requestContext.ServiceBundle.Config.AzureRegion))
				{
					throw new MsalClientException("authority_override_regional", "You configured WithAuthority at the request level, and also WithAzureRegion. This is not supported when the environment changes from application to request. Use WithTenantId at the request level instead.");
				}
				if (await IsAuthorityAliasedAsync(requestContext, requestAuthorityInfo).ConfigureAwait(continueOnCapturedContext: false))
				{
					return;
				}
				if (configAuthorityInfo.IsDefaultAuthority)
				{
					throw new MsalClientException("authority_host_mismatch", "You did not define an authority at the application level, so it defaults to the https://login.microsoftonline.com/common. \n\rHowever, the request is for a different cloud " + requestAuthorityInfo.Host + ". This is not supported - the app and the request must target the same cloud. \n\r\n\r Add .WithAuthority(\"https://" + requestAuthorityInfo.Host + "/common\") in the app builder. \n\rSee https://aka.ms/msal-net-authority-override for details");
				}
				throw new MsalClientException("authority_host_mismatch", "\n\r The application is configured for cloud " + configAuthorityInfo.Host + " and the request for a different cloud - " + requestAuthorityInfo.Host + ". This is not supported - the app and the request must target the same cloud. \n\rSee https://aka.ms/msal-net-authority-override for details");
			}

			private static async Task<bool> IsAuthorityAliasedAsync(RequestContext requestContext, AuthorityInfo requestAuthorityInfo)
			{
				return (await requestContext.ServiceBundle.InstanceDiscoveryManager.GetMetadataEntryAsync(requestContext.ServiceBundle.Config.Authority.AuthorityInfo, requestContext).ConfigureAwait(continueOnCapturedContext: false)).Aliases.Any((string alias) => alias.Equals(requestAuthorityInfo.Host));
			}
		}

		public string Host => CanonicalAuthority.Host;

		public Uri CanonicalAuthority { get; }

		internal AuthorityType AuthorityType { get; }

		public string UserRealmUriPrefix { get; }

		public bool ValidateAuthority { get; }

		internal bool IsInstanceDiscoverySupported => AuthorityType == AuthorityType.Aad;

		internal bool IsWsTrustFlowSupported
		{
			get
			{
				if (AuthorityType != AuthorityType.Aad)
				{
					return AuthorityType == AuthorityType.Dsts;
				}
				return true;
			}
		}

		internal bool CanBeTenanted
		{
			get
			{
				if (AuthorityType != AuthorityType.Aad && AuthorityType != AuthorityType.Dsts && AuthorityType != AuthorityType.B2C)
				{
					return AuthorityType == AuthorityType.Ciam;
				}
				return true;
			}
		}

		internal bool IsClientInfoSupported
		{
			get
			{
				if (AuthorityType != AuthorityType.Aad && AuthorityType != AuthorityType.Dsts && AuthorityType != AuthorityType.B2C)
				{
					return AuthorityType == AuthorityType.Ciam;
				}
				return true;
			}
		}

		internal bool IsSha2CredentialSupported
		{
			get
			{
				if (AuthorityType != AuthorityType.Dsts && AuthorityType != AuthorityType.Generic)
				{
					return AuthorityType != AuthorityType.Adfs;
				}
				return false;
			}
		}

		internal bool IsDefaultAuthority => string.Equals(CanonicalAuthority.ToString(), "https://login.microsoftonline.com/common/", StringComparison.OrdinalIgnoreCase);

		public AuthorityInfo(AuthorityType authorityType, string authority, bool validateAuthority)
			: this(authorityType, ValidateAndCreateAuthorityUri(authority, authorityType), validateAuthority)
		{
		}

		public AuthorityInfo(AuthorityType authorityType, Uri authorityUri, bool validateAuthority)
		{
			AuthorityType = authorityType;
			ValidateAuthority = validateAuthority;
			switch (AuthorityType)
			{
			case AuthorityType.Generic:
				CanonicalAuthority = authorityUri;
				break;
			case AuthorityType.B2C:
			{
				string[] pathSegments = GetPathSegments(authorityUri.AbsolutePath);
				if (pathSegments.Length < 3)
				{
					throw new ArgumentException("The B2C authority URI should have at least 3 segments in the path (i.e. https://<host>/tfp/<tenant>/<policy>/...). ");
				}
				CanonicalAuthority = new Uri("https://" + authorityUri.Authority + "/" + pathSegments[0] + "/" + pathSegments[1] + "/" + pathSegments[2] + "/");
				break;
			}
			case AuthorityType.Dsts:
			{
				string[] pathSegments = GetPathSegments(authorityUri.AbsolutePath);
				if (pathSegments.Length < 2)
				{
					throw new ArgumentException("The DSTS authority URI should have at least 2 segments in the path (i.e. https://<host>/dstsv2/<tenant>/...). ");
				}
				CanonicalAuthority = new Uri("https://" + authorityUri.Authority + "/" + pathSegments[0] + "/" + pathSegments[1] + "/");
				UserRealmUriPrefix = UriBuilderExtensions.GetHttpsUriWithOptionalPort("https://" + authorityUri.Authority + "/" + pathSegments[0] + "/common/userrealm/", authorityUri.Port);
				break;
			}
			default:
				CanonicalAuthority = new Uri(UriBuilderExtensions.GetHttpsUriWithOptionalPort("https://" + authorityUri.Authority + "/" + GetFirstPathSegment(authorityUri) + "/", authorityUri.Port));
				UserRealmUriPrefix = UriBuilderExtensions.GetHttpsUriWithOptionalPort("https://" + Host + "/common/userrealm/", authorityUri.Port);
				break;
			}
		}

		public AuthorityInfo(AuthorityInfo other)
			: this(other.CanonicalAuthority, other.AuthorityType, other.UserRealmUriPrefix, other.ValidateAuthority)
		{
		}

		private AuthorityInfo(Uri canonicalAuthority, AuthorityType authorityType, string userRealmUriPrefix, bool validateAuthority)
		{
			CanonicalAuthority = canonicalAuthority;
			AuthorityType = authorityType;
			UserRealmUriPrefix = userRealmUriPrefix;
			ValidateAuthority = validateAuthority;
		}

		internal static AuthorityInfo FromAuthorityUri(string authorityUri, bool validateAuthority)
		{
			Uri authorityUri2 = ValidateAndCreateAuthorityUri(CanonicalizeAuthorityUri(authorityUri));
			authorityUri2 = TransformIfCiamAuthority(authorityUri2);
			AuthorityType authorityType = GetAuthorityType(authorityUri2);
			if (authorityType == AuthorityType.B2C || authorityType == AuthorityType.Generic)
			{
				validateAuthority = false;
			}
			return new AuthorityInfo(authorityType, authorityUri2, validateAuthority);
		}

		private static Uri TransformIfCiamAuthority(Uri authorityUri)
		{
			if (IsCiamAuthority(authorityUri))
			{
				return CiamAuthority.TransformAuthority(authorityUri);
			}
			return authorityUri;
		}

		internal static AuthorityInfo FromAadAuthority(string cloudInstanceUri, Guid tenantId, bool validateAuthority)
		{
			return FromAuthorityUri(cloudInstanceUri.Trim().TrimEnd(new char[1] { '/' }) + "/" + tenantId.ToString("D"), validateAuthority);
		}

		internal static AuthorityInfo FromAadAuthority(string cloudInstanceUri, string tenant, bool validateAuthority)
		{
			if (Guid.TryParse(tenant, out var result))
			{
				return FromAadAuthority(cloudInstanceUri, result, validateAuthority);
			}
			return FromAuthorityUri(cloudInstanceUri.Trim().TrimEnd(new char[1] { '/' }) + "/" + tenant, validateAuthority);
		}

		internal static AuthorityInfo FromAadAuthority(AzureCloudInstance azureCloudInstance, Guid tenantId, bool validateAuthority)
		{
			string authorityUri = GetAuthorityUri(azureCloudInstance, AadAuthorityAudience.AzureAdMyOrg, tenantId.ToString("D"));
			return new AuthorityInfo(AuthorityType.Aad, authorityUri, validateAuthority);
		}

		internal static AuthorityInfo FromAadAuthority(AzureCloudInstance azureCloudInstance, string tenant, bool validateAuthority)
		{
			if (Guid.TryParse(tenant, out var result))
			{
				return FromAadAuthority(azureCloudInstance, result, validateAuthority);
			}
			string authorityUri = GetAuthorityUri(azureCloudInstance, AadAuthorityAudience.AzureAdMyOrg, tenant);
			return new AuthorityInfo(AuthorityType.Aad, authorityUri, validateAuthority);
		}

		internal static AuthorityInfo FromAadAuthority(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, bool validateAuthority)
		{
			string authorityUri = GetAuthorityUri(azureCloudInstance, authorityAudience);
			return new AuthorityInfo(AuthorityType.Aad, authorityUri, validateAuthority);
		}

		internal static AuthorityInfo FromAadAuthority(AadAuthorityAudience authorityAudience, bool validateAuthority)
		{
			string authorityUri = GetAuthorityUri(AzureCloudInstance.AzurePublic, authorityAudience);
			return new AuthorityInfo(AuthorityType.Aad, authorityUri, validateAuthority);
		}

		internal static AuthorityInfo FromAdfsAuthority(string authorityUri, bool validateAuthority)
		{
			return new AuthorityInfo(AuthorityType.Adfs, authorityUri, validateAuthority);
		}

		internal static AuthorityInfo FromB2CAuthority(string authorityUri)
		{
			return new AuthorityInfo(AuthorityType.B2C, authorityUri, validateAuthority: false);
		}

		internal static AuthorityInfo FromGenericAuthority(string authorityUri)
		{
			return new AuthorityInfo(AuthorityType.Generic, authorityUri, validateAuthority: false);
		}

		internal static string GetCloudUrl(AzureCloudInstance azureCloudInstance)
		{
			return azureCloudInstance switch
			{
				AzureCloudInstance.AzurePublic => "https://login.microsoftonline.com", 
				AzureCloudInstance.AzureChina => "https://login.chinacloudapi.cn", 
				AzureCloudInstance.AzureGermany => "https://login.microsoftonline.de", 
				AzureCloudInstance.AzureUsGovernment => "https://login.microsoftonline.us", 
				_ => throw new ArgumentException("azureCloudInstance"), 
			};
		}

		internal static string GetAadAuthorityAudienceValue(AadAuthorityAudience authorityAudience, string tenantId)
		{
			switch (authorityAudience)
			{
			case AadAuthorityAudience.AzureAdAndPersonalMicrosoftAccount:
				return "common";
			case AadAuthorityAudience.AzureAdMultipleOrgs:
				return "organizations";
			case AadAuthorityAudience.PersonalMicrosoftAccount:
				return "consumers";
			case AadAuthorityAudience.AzureAdMyOrg:
				if (string.IsNullOrWhiteSpace(tenantId))
				{
					throw new InvalidOperationException("When specifying AadAuthorityAudience.AzureAdMyOrg, you must also specify a tenant domain or tenant GUID. ");
				}
				return tenantId;
			default:
				throw new ArgumentException("authorityAudience");
			}
		}

		internal static string CanonicalizeAuthorityUri(string uri)
		{
			if (!string.IsNullOrWhiteSpace(uri) && !uri.EndsWith("/", StringComparison.OrdinalIgnoreCase))
			{
				uri += "/";
			}
			return uri?.ToLowerInvariant() ?? string.Empty;
		}

		internal Authority CreateAuthority()
		{
			return AuthorityType switch
			{
				AuthorityType.Adfs => new AdfsAuthority(this), 
				AuthorityType.B2C => new B2CAuthority(this), 
				AuthorityType.Aad => new AadAuthority(this), 
				AuthorityType.Dsts => new DstsAuthority(this), 
				AuthorityType.Ciam => new CiamAuthority(this), 
				AuthorityType.Generic => new GenericAuthority(this), 
				_ => throw new MsalClientException("invalid_authority_type", $"Unsupported authority type {AuthorityType}"), 
			};
		}

		private static Uri ValidateAndCreateAuthorityUri(string authority, AuthorityType? authorityType = null)
		{
			if (string.IsNullOrWhiteSpace(authority))
			{
				throw new ArgumentNullException("authority");
			}
			if (!Uri.IsWellFormedUriString(authority, UriKind.Absolute))
			{
				throw new ArgumentException("The authority (including the tenant ID) must be in a well-formed URI format. ", "authority");
			}
			Uri uri = new Uri(authority);
			if (uri.Scheme != "https")
			{
				throw new ArgumentException("The authority must use HTTPS scheme. ", "authority");
			}
			if (!authorityType.HasValue || authorityType != AuthorityType.Generic)
			{
				string text = uri.AbsolutePath.Substring(1);
				if (string.IsNullOrWhiteSpace(text) && !IsCiamAuthority(uri))
				{
					throw new ArgumentException("The authority URI should have at least one segment in the path (i.e. https://<host>/<path>/...). ", "authority");
				}
				string[] array = text.Split(new char[1] { '/' });
				if (array == null || array.Length == 0)
				{
					throw new ArgumentException("The authority URI should have at least one segment in the path (i.e. https://<host>/<path>/...). ");
				}
			}
			return uri;
		}

		private static string GetAuthorityUri(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, string tenantId = null)
		{
			string cloudUrl = GetCloudUrl(azureCloudInstance);
			string aadAuthorityAudienceValue = GetAadAuthorityAudienceValue(authorityAudience, tenantId);
			return cloudUrl + "/" + aadAuthorityAudienceValue;
		}

		internal static string GetFirstPathSegment(Uri authority)
		{
			if (authority.Segments.Length >= 2)
			{
				return authority.Segments[1].TrimEnd(new char[1] { '/' });
			}
			throw new InvalidOperationException("Authority should be in the form <host>/<audience>, for example https://login.microsoftonline.com/common. ");
		}

		internal static string GetSecondPathSegment(Uri authority)
		{
			if (authority.Segments.Length >= 3)
			{
				return authority.Segments[2].TrimEnd(new char[1] { '/' });
			}
			throw new InvalidOperationException("Authority should be in the form <host>/<audience>/<tenantID>, for example https://login.microsoftonline.com/dsts/<tenantid>. ");
		}

		private static AuthorityType GetAuthorityType(Uri authorityUri)
		{
			if (IsCiamAuthority(authorityUri))
			{
				return AuthorityType.Ciam;
			}
			string firstPathSegment = GetFirstPathSegment(authorityUri);
			if (string.Equals(firstPathSegment, "adfs", StringComparison.OrdinalIgnoreCase))
			{
				return AuthorityType.Adfs;
			}
			if (string.Equals(firstPathSegment, "dstsv2", StringComparison.OrdinalIgnoreCase))
			{
				return AuthorityType.Dsts;
			}
			if (string.Equals(firstPathSegment, "tfp", StringComparison.OrdinalIgnoreCase))
			{
				return AuthorityType.B2C;
			}
			return AuthorityType.Aad;
		}

		private static bool IsCiamAuthority(Uri authorityUri)
		{
			return authorityUri.Host.EndsWith(".ciamlogin.com");
		}

		private static string[] GetPathSegments(string absolutePath)
		{
			return absolutePath.Substring(1).Split(new char[1] { '/' }, StringSplitOptions.RemoveEmptyEntries);
		}
	}
	internal enum AuthorityType
	{
		Aad,
		Adfs,
		B2C,
		Dsts,
		Generic,
		Ciam
	}
	public enum AzureCloudInstance
	{
		None,
		AzurePublic,
		AzureChina,
		AzureGermany,
		AzureUsGovernment
	}
	public abstract class BaseAbstractApplicationBuilder<T> where T : BaseAbstractApplicationBuilder<T>
	{
		internal ApplicationConfiguration Config { get; }

		internal BaseAbstractApplicationBuilder(ApplicationConfiguration configuration)
		{
			Config = configuration;
		}

		public T WithHttpClientFactory(IMsalHttpClientFactory httpClientFactory)
		{
			Config.HttpClientFactory = httpClientFactory;
			return (T)this;
		}

		public T WithHttpClientFactory(IMsalHttpClientFactory httpClientFactory, bool retryOnceOn5xx)
		{
			Config.HttpClientFactory = httpClientFactory;
			Config.RetryOnServerErrors = retryOnceOn5xx;
			return (T)this;
		}

		internal T WithHttpManager(IHttpManager httpManager)
		{
			Config.HttpManager = httpManager;
			return (T)this;
		}

		public T WithLogging(LogCallback loggingCallback, LogLevel? logLevel = null, bool? enablePiiLogging = null, bool? enableDefaultPlatformLogging = null)
		{
			if (Config.LoggingCallback != null)
			{
				throw new InvalidOperationException("LoggingCallback has already been set. ");
			}
			Config.LoggingCallback = loggingCallback;
			Config.LogLevel = logLevel ?? Config.LogLevel;
			Config.EnablePiiLogging = enablePiiLogging ?? Config.EnablePiiLogging;
			Config.IsDefaultPlatformLoggingEnabled = enableDefaultPlatformLogging ?? Config.IsDefaultPlatformLoggingEnabled;
			return (T)this;
		}

		public T WithLogging(IIdentityLogger identityLogger, bool enablePiiLogging = false)
		{
			Config.IdentityLogger = identityLogger;
			Config.EnablePiiLogging = enablePiiLogging;
			return (T)this;
		}

		public T WithDebugLoggingCallback(LogLevel logLevel = LogLevel.Info, bool enablePiiLogging = false, bool withDefaultPlatformLoggingEnabled = false)
		{
			WithLogging(delegate
			{
			}, logLevel, enablePiiLogging, withDefaultPlatformLoggingEnabled);
			return (T)this;
		}

		protected T WithOptions(BaseApplicationOptions applicationOptions)
		{
			WithLogging(null, applicationOptions.LogLevel, applicationOptions.EnablePiiLogging, applicationOptions.IsDefaultPlatformLoggingEnabled);
			return (T)this;
		}

		public T WithExperimentalFeatures(bool enableExperimentalFeatures = true)
		{
			Config.ExperimentalFeaturesEnabled = enableExperimentalFeatures;
			return (T)this;
		}

		internal virtual ApplicationConfiguration BuildConfiguration()
		{
			ResolveAuthority();
			return Config;
		}

		internal void ResolveAuthority()
		{
			if (Config.Authority?.AuthorityInfo != null)
			{
				if (!string.IsNullOrEmpty(Config.TenantId))
				{
					string tenantedAuthority = Config.Authority.GetTenantedAuthority(Config.TenantId, forceSpecifiedTenant: true);
					Config.Authority = Authority.CreateAuthority(tenantedAuthority, Config.Authority.AuthorityInfo.ValidateAuthority);
				}
			}
			else
			{
				string authorityInstance = GetAuthorityInstance();
				string authorityAudience = GetAuthorityAudience();
				AuthorityInfo authorityInfo = new AuthorityInfo(AuthorityType.Aad, new Uri(authorityInstance + "/" + authorityAudience).ToString(), Config.ValidateAuthority);
				Config.Authority = new AadAuthority(authorityInfo);
			}
		}

		private string GetAuthorityAudience()
		{
			if (!string.IsNullOrWhiteSpace(Config.TenantId) && Config.AadAuthorityAudience != AadAuthorityAudience.None && Config.AadAuthorityAudience != AadAuthorityAudience.AzureAdMyOrg)
			{
				throw new InvalidOperationException("TenantId and AadAuthorityAudience are both set, but they're mutually exclusive. ");
			}
			if (Config.AadAuthorityAudience != AadAuthorityAudience.None)
			{
				return AuthorityInfo.GetAadAuthorityAudienceValue(Config.AadAuthorityAudience, Config.TenantId);
			}
			if (!string.IsNullOrWhiteSpace(Config.TenantId))
			{
				return Config.TenantId;
			}
			return AuthorityInfo.GetAadAuthorityAudienceValue(AadAuthorityAudience.AzureAdAndPersonalMicrosoftAccount, string.Empty);
		}

		private string GetAuthorityInstance()
		{
			if (!string.IsNullOrWhiteSpace(Config.Instance) && Config.AzureCloudInstance != AzureCloudInstance.None)
			{
				throw new InvalidOperationException("Instance and AzureCloudInstance are both set but they're mutually exclusive. ");
			}
			if (!string.IsNullOrWhiteSpace(Config.Instance))
			{
				Config.Instance = Config.Instance.TrimEnd(' ', '/');
				return Config.Instance;
			}
			if (Config.AzureCloudInstance != AzureCloudInstance.None)
			{
				return AuthorityInfo.GetCloudUrl(Config.AzureCloudInstance);
			}
			return AuthorityInfo.GetCloudUrl(AzureCloudInstance.AzurePublic);
		}

		internal void ValidateUseOfExperimentalFeature([CallerMemberName] string memberName = "")
		{
			if (!Config.ExperimentalFeaturesEnabled)
			{
				throw new MsalClientException("experimental_feature", MsalErrorMessage.ExperimentalFeature(memberName));
			}
		}
	}
	public abstract class BaseApplicationOptions
	{
		public LogLevel LogLevel { get; set; }

		public bool EnablePiiLogging { get; set; }

		public bool IsDefaultPlatformLoggingEnabled { get; set; }
	}
	public class CacheOptions
	{
		public static CacheOptions EnableSharedCacheOptions => new CacheOptions(useSharedCache: true);

		public bool UseSharedCache { get; set; }

		public CacheOptions()
		{
		}

		public CacheOptions(bool useSharedCache)
		{
			UseSharedCache = useSharedCache;
		}
	}
	public class ConfidentialClientApplicationBuilder : AbstractApplicationBuilder<ConfidentialClientApplicationBuilder>
	{
		internal ConfidentialClientApplicationBuilder(ApplicationConfiguration configuration)
			: base(configuration)
		{
			ApplicationBase.GuardMobileFrameworks();
		}

		public static ConfidentialClientApplicationBuilder CreateWithApplicationOptions(ConfidentialClientApplicationOptions options)
		{
			ApplicationBase.GuardMobileFrameworks();
			ConfidentialClientApplicationBuilder confidentialClientApplicationBuilder = new ConfidentialClientApplicationBuilder(new ApplicationConfiguration(MsalClientType.ConfidentialClient)).WithOptions(options);
			if (!string.IsNullOrWhiteSpace(options.ClientSecret))
			{
				confidentialClientApplicationBuilder = confidentialClientApplicationBuilder.WithClientSecret(options.ClientSecret);
			}
			if (!string.IsNullOrWhiteSpace(options.AzureRegion))
			{
				confidentialClientApplicationBuilder = confidentialClientApplicationBuilder.WithAzureRegion(options.AzureRegion);
			}
			return confidentialClientApplicationBuilder.WithCacheSynchronization(options.EnableCacheSynchronization);
		}

		public static ConfidentialClientApplicationBuilder Create(string clientId)
		{
			ApplicationBase.GuardMobileFrameworks();
			return new ConfidentialClientApplicationBuilder(new ApplicationConfiguration(MsalClientType.ConfidentialClient)).WithClientId(clientId);
		}

		public ConfidentialClientApplicationBuilder WithCertificate(X509Certificate2 certificate)
		{
			return WithCertificate(certificate, sendX5C: false);
		}

		public ConfidentialClientApplicationBuilder WithCertificate(X509Certificate2 certificate, bool sendX5C)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			if (!certificate.HasPrivateKey)
			{
				throw new MsalClientException("cert_without_private_key", MsalErrorMessage.CertMustHavePrivateKey("certificate"));
			}
			base.Config.ClientCredential = new CertificateClientCredential(certificate);
			base.Config.SendX5C = sendX5C;
			return this;
		}

		public ConfidentialClientApplicationBuilder WithClientClaims(X509Certificate2 certificate, IDictionary<string, string> claimsToSign, bool mergeWithDefaultClaims)
		{
			return WithClientClaims(certificate, claimsToSign, mergeWithDefaultClaims, sendX5C: false);
		}

		public ConfidentialClientApplicationBuilder WithClientClaims(X509Certificate2 certificate, IDictionary<string, string> claimsToSign, bool mergeWithDefaultClaims = true, bool sendX5C = false)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			if (claimsToSign == null || !claimsToSign.Any())
			{
				throw new ArgumentNullException("claimsToSign");
			}
			base.Config.ClientCredential = new CertificateAndClaimsClientCredential(certificate, claimsToSign, mergeWithDefaultClaims);
			base.Config.SendX5C = sendX5C;
			return this;
		}

		public ConfidentialClientApplicationBuilder WithClientSecret(string clientSecret)
		{
			if (string.IsNullOrWhiteSpace(clientSecret))
			{
				throw new ArgumentNullException("clientSecret");
			}
			base.Config.ClientCredential = new SecretStringClientCredential(clientSecret);
			return this;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This method is not recommended. Use overload with Func<AssertionRequestOptions, Task<string>> instead, and return a non-expired assertion, which can be a Federated Credential. See https://aka.ms/msal-net-client-assertion", false)]
		public ConfidentialClientApplicationBuilder WithClientAssertion(string signedClientAssertion)
		{
			if (string.IsNullOrWhiteSpace(signedClientAssertion))
			{
				throw new ArgumentNullException("signedClientAssertion");
			}
			base.Config.ClientCredential = new SignedAssertionClientCredential(signedClientAssertion);
			return this;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public ConfidentialClientApplicationBuilder WithClientAssertion(Func<string> clientAssertionDelegate)
		{
			if (clientAssertionDelegate == null)
			{
				throw new ArgumentNullException("clientAssertionDelegate");
			}
			Func<CancellationToken, Task<string>> signedAssertionDelegate = (CancellationToken _) => Task.FromResult(clientAssertionDelegate());
			base.Config.ClientCredential = new SignedAssertionDelegateClientCredential(signedAssertionDelegate);
			return this;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public ConfidentialClientApplicationBuilder WithClientAssertion(Func<CancellationToken, Task<string>> clientAssertionAsyncDelegate)
		{
			if (clientAssertionAsyncDelegate == null)
			{
				throw new ArgumentNullException("clientAssertionAsyncDelegate");
			}
			base.Config.ClientCredential = new SignedAssertionDelegateClientCredential(clientAssertionAsyncDelegate);
			return this;
		}

		public ConfidentialClientApplicationBuilder WithClientAssertion(Func<AssertionRequestOptions, Task<string>> clientAssertionAsyncDelegate)
		{
			if (clientAssertionAsyncDelegate == null)
			{
				throw new ArgumentNullException("clientAssertionAsyncDelegate");
			}
			base.Config.ClientCredential = new SignedAssertionDelegateClientCredential(clientAssertionAsyncDelegate);
			return this;
		}

		public ConfidentialClientApplicationBuilder WithAzureRegion(string azureRegion = "TryAutoDetect")
		{
			if (string.IsNullOrEmpty(azureRegion))
			{
				throw new ArgumentNullException("azureRegion");
			}
			base.Config.AzureRegion = azureRegion;
			return this;
		}

		public ConfidentialClientApplicationBuilder WithCacheSynchronization(bool enableCacheSynchronization)
		{
			base.Config.CacheSynchronizationEnabled = enableCacheSynchronization;
			return this;
		}

		[Obsolete("This method has been renamed to WithOidcAuthority.", false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public ConfidentialClientApplicationBuilder WithGenericAuthority(string authorityUri)
		{
			return WithOidcAuthority(authorityUri);
		}

		public ConfidentialClientApplicationBuilder WithOidcAuthority(string authorityUri)
		{
			AuthorityInfo authorityInfo = AuthorityInfo.FromGenericAuthority(authorityUri);
			base.Config.Authority = Authority.CreateAuthority(authorityInfo);
			return this;
		}

		public ConfidentialClientApplicationBuilder WithTelemetryClient(params ITelemetryClient[] telemetryClients)
		{
			if (telemetryClients == null)
			{
				throw new ArgumentNullException("telemetryClients");
			}
			if (telemetryClients.Length != 0)
			{
				for (int i = 0; i < telemetryClients.Length; i++)
				{
					(telemetryClients[i] ?? throw new ArgumentNullException("telemetryClient")).Initialize();
				}
				base.Config.TelemetryClients = telemetryClients;
			}
			TelemetryClientLogMsalVersion();
			return this;
		}

		private void TelemetryClientLogMsalVersion()
		{
			if (base.Config.TelemetryClients.HasEnabledClients("config_update"))
			{
				MsalTelemetryEventDetails msalTelemetryEventDetails = new MsalTelemetryEventDetails("config_update");
				msalTelemetryEventDetails.SetProperty("MsalVersion", MsalIdHelper.GetMsalVersion());
				base.Config.TelemetryClients.TrackEvent(msalTelemetryEventDetails);
			}
		}

		internal ConfidentialClientApplicationBuilder WithAppTokenCacheInternalForTest(ITokenCacheInternal tokenCacheInternal)
		{
			base.Config.AppTokenCacheInternalForTest = tokenCacheInternal;
			return this;
		}

		internal override void Validate()
		{
			base.Validate();
			if (string.IsNullOrWhiteSpace(base.Config.RedirectUri))
			{
				base.Config.RedirectUri = "https://replyUrlNotSet";
			}
			if (!Uri.TryCreate(base.Config.RedirectUri, UriKind.Absolute, out var _))
			{
				throw new InvalidOperationException(MsalErrorMessage.InvalidRedirectUriReceived(base.Config.RedirectUri));
			}
			if (!string.IsNullOrEmpty(base.Config.AzureRegion) && (base.Config.CustomInstanceDiscoveryMetadata != null || base.Config.CustomInstanceDiscoveryMetadataUri != null))
			{
				throw new MsalClientException("region_discovery_with_custom_instance_metadata", "Configure either region discovery or custom instance metadata. Custom instance discovery metadata overrides region discovery. ");
			}
		}

		public IConfidentialClientApplication Build()
		{
			return BuildConcrete();
		}

		internal ConfidentialClientApplication BuildConcrete()
		{
			return new ConfidentialClientApplication(BuildConfiguration());
		}
	}
	public class ConfidentialClientApplicationOptions : ApplicationOptions
	{
		public string ClientSecret { get; set; }

		public string AzureRegion { get; set; }

		public bool EnableCacheSynchronization { get; set; } = true;
	}
	public interface IAppConfig
	{
		string ClientId { get; }

		bool EnablePiiLogging { get; }

		IMsalHttpClientFactory HttpClientFactory { get; }

		LogLevel LogLevel { get; }

		bool IsDefaultPlatformLoggingEnabled { get; }

		string RedirectUri { get; }

		string TenantId { get; }

		LogCallback LoggingCallback { get; }

		IDictionary<string, string> ExtraQueryParameters { get; }

		bool IsBrokerEnabled { get; }

		string ClientName { get; }

		string ClientVersion { get; }

		[Obsolete("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		ITelemetryConfig TelemetryConfig { get; }

		bool ExperimentalFeaturesEnabled { get; }

		IEnumerable<string> ClientCapabilities { get; }

		bool LegacyCacheCompatibilityEnabled { get; }

		string ClientSecret { get; }

		X509Certificate2 ClientCredentialCertificate { get; }

		Func<object> ParentActivityOrWindowFunc { get; }
	}
	public interface IMsalHttpClientFactory
	{
		HttpClient GetHttpClient();
	}
	[Obsolete("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public enum TelemetryAudienceType
	{
		PreProduction,
		Production
	}
	[Obsolete("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface ITelemetryConfig
	{
		TelemetryAudienceType AudienceType { get; }

		string SessionId { get; }

		Action<ITelemetryEventPayload> DispatchAction { get; }
	}
	[Obsolete("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface ITelemetryEventPayload
	{
		string Name { get; }

		IReadOnlyDictionary<string, bool> BoolValues { get; }

		IReadOnlyDictionary<string, long> Int64Values { get; }

		IReadOnlyDictionary<string, int> IntValues { get; }

		IReadOnlyDictionary<string, string> StringValues { get; }

		string ToJsonString();
	}
	public sealed class ManagedIdentityApplicationBuilder : BaseAbstractApplicationBuilder<ManagedIdentityApplicationBuilder>
	{
		internal ManagedIdentityApplicationBuilder(ApplicationConfiguration configuration)
			: base(configuration)
		{
			ApplicationBase.GuardMobileFrameworks();
		}

		public static ManagedIdentityApplicationBuilder Create(ManagedIdentityId managedIdentityId)
		{
			ApplicationBase.GuardMobileFrameworks();
			return new ManagedIdentityApplicationBuilder(BuildConfiguration(managedIdentityId));
		}

		private static ApplicationConfiguration BuildConfiguration(ManagedIdentityId managedIdentityId)
		{
			if (managedIdentityId == null)
			{
				throw new ArgumentNullException("managedIdentityId");
			}
			return new ApplicationConfiguration(MsalClientType.ManagedIdentityClient)
			{
				ManagedIdentityId = managedIdentityId,
				CacheSynchronizationEnabled = false,
				AccessorOptions = CacheOptions.EnableSharedCacheOptions
			};
		}

		public ManagedIdentityApplicationBuilder WithTelemetryClient(params ITelemetryClient[] telemetryClients)
		{
			ValidateUseOfExperimentalFeature("ITelemetryClient");
			if (telemetryClients == null)
			{
				throw new ArgumentNullException("telemetryClients");
			}
			if (telemetryClients.Length != 0)
			{
				for (int i = 0; i < telemetryClients.Length; i++)
				{
					(telemetryClients[i] ?? throw new ArgumentNullException("telemetryClient")).Initialize();
				}
				base.Config.TelemetryClients = telemetryClients;
			}
			TelemetryClientLogMsalVersion();
			return this;
		}

		private void TelemetryClientLogMsalVersion()
		{
			if (base.Config.TelemetryClients.HasEnabledClients("config_update"))
			{
				MsalTelemetryEventDetails msalTelemetryEventDetails = new MsalTelemetryEventDetails("config_update");
				msalTelemetryEventDetails.SetProperty("MsalVersion", MsalIdHelper.GetMsalVersion());
				base.Config.TelemetryClients.TrackEvent(msalTelemetryEventDetails);
			}
		}

		internal ManagedIdentityApplicationBuilder WithAppTokenCacheInternalForTest(ITokenCacheInternal tokenCacheInternal)
		{
			base.Config.AppTokenCacheInternalForTest = tokenCacheInternal;
			return this;
		}

		public IManagedIdentityApplication Build()
		{
			return BuildConcrete();
		}

		internal ManagedIdentityApplication BuildConcrete()
		{
			DefaultConfiguration();
			return new ManagedIdentityApplication(BuildConfiguration());
		}

		private void DefaultConfiguration()
		{
			ComputeClientIdForCaching();
			base.Config.TenantId = "managed_identity";
			base.Config.RedirectUri = "https://replyUrlNotSet";
			base.Config.IsInstanceDiscoveryEnabled = false;
		}

		private void ComputeClientIdForCaching()
		{
			if (base.Config.ManagedIdentityId.IdType == ManagedIdentityIdType.SystemAssigned)
			{
				base.Config.ClientId = "system_assigned_managed_identity";
			}
			else
			{
				base.Config.ClientId = base.Config.ManagedIdentityId.UserAssignedId;
			}
		}
	}
	public sealed class PublicClientApplicationBuilder : AbstractApplicationBuilder<PublicClientApplicationBuilder>
	{
		internal PublicClientApplicationBuilder(ApplicationConfiguration configuration)
			: base(configuration)
		{
		}

		public static PublicClientApplicationBuilder CreateWithApplicationOptions(PublicClientApplicationOptions options)
		{
			return new PublicClientApplicationBuilder(new ApplicationConfiguration(MsalClientType.PublicClient)).WithOptions(options).WithKerberosTicketClaim(options.KerberosServicePrincipalName, options.TicketContainer);
		}

		public static PublicClientApplicationBuilder Create(string clientId)
		{
			return new PublicClientApplicationBuilder(new ApplicationConfiguration(MsalClientType.PublicClient)).WithClientId(clientId);
		}

		internal PublicClientApplicationBuilder WithUserTokenLegacyCachePersistenceForTest(ILegacyCachePersistence legacyCachePersistence)
		{
			base.Config.UserTokenLegacyCachePersistenceForTest = legacyCachePersistence;
			return this;
		}

		public PublicClientApplicationBuilder WithDefaultRedirectUri()
		{
			base.Config.UseRecommendedDefaultRedirectUri = true;
			return this;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public PublicClientApplicationBuilder WithMultiCloudSupport(bool enableMultiCloudSupport)
		{
			base.Config.MultiCloudSupportEnabled = enableMultiCloudSupport;
			return this;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public PublicClientApplicationBuilder WithIosKeychainSecurityGroup(string keychainSecurityGroup)
		{
			return this;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("The desktop broker is not directly available in the MSAL package. Install the NuGet package Microsoft.Identity.Client.Broker and call the extension method .WithBroker(BrokerOptions). For details, see https://aka.ms/msal-net-wam", true)]
		public PublicClientApplicationBuilder WithBroker(bool enableBroker = true)
		{
			throw new PlatformNotSupportedException("The desktop broker is not directly available in the Microsoft.Identity.Client package. \n\rTo use it, install the NuGet package named Microsoft.Identity.Client.Broker and call the extension method .WithBroker(BrokerOptions) from namespace Microsoft.Identity.Client.Broker\n\rFor details see https://aka.ms/msal-net-wam ");
		}

		[Obsolete("This API has been replaced with WithBroker(BrokerOptions), which can be found in Microsoft.Identity.Client.Broker package. See https://aka.ms/msal-net-wam for details.", false)]
		public PublicClientApplicationBuilder WithWindowsBrokerOptions(WindowsBrokerOptions options)
		{
			WindowsBrokerOptions.ValidatePlatformAvailability();
			BrokerOptions brokerOptions = BrokerOptions.CreateFromWindowsOptions(options);
			base.Config.BrokerOptions = brokerOptions;
			return this;
		}

		public PublicClientApplicationBuilder WithParentActivityOrWindow(Func<object> parentActivityOrWindowFunc)
		{
			return WithParentFunc(parentActivityOrWindowFunc);
		}

		private PublicClientApplicationBuilder WithParentFunc(Func<object> parentFunc)
		{
			base.Config.ParentActivityOrWindowFunc = parentFunc;
			return this;
		}

		public PublicClientApplicationBuilder WithOidcAuthority(string authorityUri)
		{
			ValidateUseOfExperimentalFeature("WithOidcAuthority");
			AuthorityInfo authorityInfo = AuthorityInfo.FromGenericAuthority(authorityUri);
			base.Config.Authority = Authority.CreateAuthority(authorityInfo);
			return this;
		}

		[CLSCompliant(false)]
		public PublicClientApplicationBuilder WithParentActivityOrWindow(Func<IntPtr> windowFunc)
		{
			if (windowFunc == null)
			{
				throw new ArgumentNullException("windowFunc");
			}
			return WithParentFunc(() => windowFunc());
		}

		public PublicClientApplicationBuilder WithKerberosTicketClaim(string servicePrincipalName, KerberosTicketContainer ticketContainer)
		{
			base.Config.KerberosServicePrincipalName = servicePrincipalName;
			base.Config.TicketContainer = ticketContainer;
			return this;
		}

		public bool IsBrokerAvailable()
		{
			return PlatformProxyFactory.CreatePlatformProxy(null).CreateBroker(base.Config, null).IsBrokerInstalledAndInvokable((base.Config.Authority?.AuthorityInfo?.AuthorityType).GetValueOrDefault());
		}

		public IPublicClientApplication Build()
		{
			return BuildConcrete();
		}

		internal PublicClientApplication BuildConcrete()
		{
			return new PublicClientApplication(BuildConfiguration());
		}

		internal override void Validate()
		{
			base.Validate();
			if (string.IsNullOrWhiteSpace(base.Config.RedirectUri))
			{
				base.Config.RedirectUri = PlatformProxyFactory.CreatePlatformProxy(null).GetDefaultRedirectUri(base.Config.ClientId, base.Config.UseRecommendedDefaultRedirectUri);
			}
			if (!Uri.TryCreate(base.Config.RedirectUri, UriKind.Absolute, out var _))
			{
				throw new InvalidOperationException(MsalErrorMessage.InvalidRedirectUriReceived(base.Config.RedirectUri));
			}
		}
	}
	public class PublicClientApplicationOptions : ApplicationOptions
	{
	}
	[Obsolete("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public class TraceTelemetryConfig : ITelemetryConfig
	{
		public TelemetryAudienceType AudienceType => TelemetryAudienceType.PreProduction;

		public string SessionId { get; }

		public Action<ITelemetryEventPayload> DispatchAction => delegate(ITelemetryEventPayload payload)
		{
			JObject jObject = new JObject();
			foreach (KeyValuePair<string, bool> boolValue in payload.BoolValues)
			{
				jObject[boolValue.Key] = boolValue.Value;
			}
			foreach (KeyValuePair<string, int> intValue in payload.IntValues)
			{
				jObject[intValue.Key] = intValue.Value;
			}
			foreach (KeyValuePair<string, long> int64Value in payload.Int64Values)
			{
				jObject[int64Value.Key] = int64Value.Value;
			}
			foreach (KeyValuePair<string, string> stringValue in payload.StringValues)
			{
				jObject[stringValue.Key] = stringValue.Value;
			}
			Trace.TraceInformation(JsonHelper.JsonObjectToString(jObject));
			Trace.Flush();
		};

		public IEnumerable<string> AllowedScopes => CollectionHelpers.GetEmptyReadOnlyList<string>();

		public TraceTelemetryConfig()
		{
			SessionId = Guid.NewGuid().ToString();
		}
	}
	public abstract class ApplicationBase : IApplicationBase
	{
		internal const string DefaultAuthority = "https://login.microsoftonline.com/common/";

		internal IServiceBundle ServiceBundle { get; }

		internal ApplicationBase(ApplicationConfiguration config)
		{
			ServiceBundle = Microsoft.Identity.Client.Internal.ServiceBundle.Create(config);
		}

		internal virtual async Task<AuthenticationRequestParameters> CreateRequestParametersAsync(AcquireTokenCommonParameters commonParameters, RequestContext requestContext, ITokenCacheInternal cache)
		{
			Authority initialAuthority = await Authority.CreateAuthorityForRequestAsync(requestContext, commonParameters.AuthorityOverride).ConfigureAwait(continueOnCapturedContext: false);
			return new AuthenticationRequestParameters(ServiceBundle, cache, commonParameters, requestContext, initialAuthority);
		}

		internal static void GuardMobileFrameworks()
		{
		}
	}
	public class AuthenticationHeaderParser
	{
		private static readonly Lazy<IMsalHttpClientFactory> _httpClientFactory = new Lazy<IMsalHttpClientFactory>(() => PlatformProxyFactory.CreatePlatformProxy(null).CreateDefaultHttpClientFactory());

		public IReadOnlyList<WwwAuthenticateParameters> WwwAuthenticateParameters { get; private set; }

		public AuthenticationInfoParameters AuthenticationInfoParameters { get; private set; }

		public string PopNonce { get; private set; }

		public static Task<AuthenticationHeaderParser> ParseAuthenticationHeadersAsync(string resourceUri, CancellationToken cancellationToken = default(CancellationToken))
		{
			return ParseAuthenticationHeadersAsync(resourceUri, GetHttpClient(), cancellationToken);
		}

		public static async Task<AuthenticationHeaderParser> ParseAuthenticationHeadersAsync(string resourceUri, HttpClient httpClient, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (httpClient == null)
			{
				throw new ArgumentNullException("httpClient");
			}
			if (string.IsNullOrWhiteSpace(resourceUri))
			{
				throw new ArgumentNullException("resourceUri");
			}
			return ParseAuthenticationHeaders((await httpClient.GetAsync(resourceUri, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Headers);
		}

		public static AuthenticationHeaderParser ParseAuthenticationHeaders(HttpResponseHeaders httpResponseHeaders)
		{
			AuthenticationHeaderParser authenticationHeaderParser = new AuthenticationHeaderParser();
			AuthenticationInfoParameters authenticationInfoParameters = new AuthenticationInfoParameters();
			string text = null;
			if (httpResponseHeaders.WwwAuthenticate.Count != 0)
			{
				IReadOnlyList<WwwAuthenticateParameters> readOnlyList = Microsoft.Identity.Client.WwwAuthenticateParameters.CreateFromAuthenticationHeaders(httpResponseHeaders);
				text = readOnlyList.SingleOrDefault((WwwAuthenticateParameters parameter) => string.Equals(parameter.AuthenticationScheme, "PoP", StringComparison.Ordinal))?.Nonce;
				authenticationHeaderParser.WwwAuthenticateParameters = readOnlyList;
			}
			else
			{
				authenticationHeaderParser.WwwAuthenticateParameters = new List<WwwAuthenticateParameters>();
				authenticationInfoParameters = (authenticationHeaderParser.AuthenticationInfoParameters = AuthenticationInfoParameters.CreateFromResponseHeaders(httpResponseHeaders));
			}
			authenticationHeaderParser.PopNonce = text ?? authenticationInfoParameters.NextNonce;
			return authenticationHeaderParser;
		}

		internal static HttpClient GetHttpClient()
		{
			return _httpClientFactory.Value.GetHttpClient();
		}

		internal static KeyValuePair<string, string> CreateKeyValuePair(string paramValue, string authScheme)
		{
			string[] array = (from s in CoreHelpers.SplitWithQuotes(paramValue, '=')
				select s.Trim().Trim(new char[1] { '"' })).ToArray();
			if (array.Length < 2)
			{
				return new KeyValuePair<string, string>(authScheme, paramValue);
			}
			return new KeyValuePair<string, string>(array[0], array[1]);
		}
	}
	public class AuthenticationInfoParameters
	{
		private const string AuthenticationInfoKey = "Authentication-Info";

		public string NextNonce { get; private set; }

		public string this[string key] => RawParameters[key];

		internal IDictionary<string, string> RawParameters { get; private set; }

		public static AuthenticationInfoParameters CreateFromResponseHeaders(HttpResponseHeaders httpResponseHeaders)
		{
			AuthenticationInfoParameters authenticationInfoParameters = new AuthenticationInfoParameters();
			try
			{
				IEnumerable<string> value = httpResponseHeaders.SingleOrDefault((KeyValuePair<string, IEnumerable<string>> header) => header.Key == "Authentication-Info").Value;
				if (value != null)
				{
					string text = value.FirstOrDefault();
					string[] array = text.Split(new char[1] { ' ' }, 2);
					IDictionary<string, string> dictionary;
					if (array.Length != 2)
					{
						dictionary = new Dictionary<string, string>();
						dictionary.Add(new KeyValuePair<string, string>("Authentication-Info", text));
					}
					else
					{
						dictionary = (from v in CoreHelpers.SplitWithQuotes(array[1], ',')
							select AuthenticationHeaderParser.CreateKeyValuePair(v.Trim(), "Authentication-Info")).ToDictionary((KeyValuePair<string, string> pair) => pair.Key, (KeyValuePair<string, string> pair) => pair.Value, StringComparer.OrdinalIgnoreCase);
						if (dictionary.TryGetValue("nextnonce", out var value2))
						{
							authenticationInfoParameters.NextNonce = value2;
						}
					}
					authenticationInfoParameters.RawParameters = dictionary;
				}
				return authenticationInfoParameters;
			}
			catch (Exception ex) when (!(ex is MsalClientException))
			{
				throw new MsalClientException("unable_to_parse_authentication_header", string.Format("{0}Response Headers: {1} See inner exception for details.", "MSAL is unable to parse the authentication header returned from the resource endpoint. This can be a result of a malformed header returned in either the WWW-Authenticate or the Authentication-Info collections acquired from the provided endpoint.", httpResponseHeaders), ex);
			}
		}
	}
	public class AuthenticationResult
	{
		private readonly IAuthenticationScheme _authenticationScheme;

		public string AccessToken { get; }

		[Obsolete("This feature has been deprecated", false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool IsExtendedLifeTimeToken { get; }

		public string UniqueId { get; }

		public DateTimeOffset ExpiresOn { get; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This feature has been deprecated", false)]
		public DateTimeOffset ExtendedExpiresOn { get; }

		public string TenantId { get; }

		public IAccount Account { get; }

		public string IdToken { get; }

		public IEnumerable<string> Scopes { get; }

		public Guid CorrelationId { get; }

		public string TokenType { get; }

		public string SpaAuthCode { get; }

		public IReadOnlyDictionary<string, string> AdditionalResponseParameters { get; }

		public ClaimsPrincipal ClaimsPrincipal { get; }

		internal ApiEvent ApiEvent { get; }

		public AuthenticationResultMetadata AuthenticationResultMetadata { get; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		[Obsolete("Use Account instead (See https://aka.ms/msal-net-2-released)", true)]
		public IUser User
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public AuthenticationResult(string accessToken, bool isExtendedLifeTimeToken, string uniqueId, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, string tenantId, IAccount account, string idToken, IEnumerable<string> scopes, Guid correlationId, string tokenType = "Bearer", AuthenticationResultMetadata authenticationResultMetadata = null, ClaimsPrincipal claimsPrincipal = null, string spaAuthCode = null, IReadOnlyDictionary<string, string> additionalResponseParameters = null)
		{
			AccessToken = accessToken;
			IsExtendedLifeTimeToken = isExtendedLifeTimeToken;
			ExtendedExpiresOn = extendedExpiresOn;
			UniqueId = uniqueId;
			ExpiresOn = expiresOn;
			TenantId = tenantId;
			Account = account;
			IdToken = idToken;
			Scopes = scopes;
			CorrelationId = correlationId;
			TokenType = tokenType;
			AuthenticationResultMetadata = authenticationResultMetadata;
			ClaimsPrincipal = claimsPrincipal;
			SpaAuthCode = spaAuthCode;
			AdditionalResponseParameters = additionalResponseParameters;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public AuthenticationResult(string accessToken, bool isExtendedLifeTimeToken, string uniqueId, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, string tenantId, IAccount account, string idToken, IEnumerable<string> scopes, Guid correlationId, AuthenticationResultMetadata authenticationResultMetadata, string tokenType = "Bearer")
			: this(accessToken, isExtendedLifeTimeToken, uniqueId, expiresOn, extendedExpiresOn, tenantId, account, idToken, scopes, correlationId, tokenType, authenticationResultMetadata)
		{
		}

		internal AuthenticationResult(MsalAccessTokenCacheItem msalAccessTokenCacheItem, MsalIdTokenCacheItem msalIdTokenCacheItem, IAuthenticationScheme authenticationScheme, Guid correlationID, TokenSource tokenSource, ApiEvent apiEvent, Account account, string spaAuthCode, IReadOnlyDictionary<string, string> additionalResponseParameters)
		{
			_authenticationScheme = authenticationScheme ?? throw new ArgumentNullException("authenticationScheme");
			string text = msalAccessTokenCacheItem?.HomeAccountId ?? msalIdTokenCacheItem?.HomeAccountId;
			string environment = msalAccessTokenCacheItem?.Environment ?? msalIdTokenCacheItem?.Environment;
			ClaimsPrincipal = msalIdTokenCacheItem?.IdToken.ClaimsPrincipal;
			if (account != null)
			{
				Account = account;
			}
			else if (text != null)
			{
				Account = new Account(text, msalIdTokenCacheItem?.GetUsername(), environment);
			}
			UniqueId = msalIdTokenCacheItem?.IdToken?.GetUniqueId();
			TenantId = msalIdTokenCacheItem?.IdToken?.TenantId;
			IdToken = msalIdTokenCacheItem?.Secret;
			SpaAuthCode = spaAuthCode;
			CorrelationId = correlationID;
			ApiEvent = apiEvent;
			AuthenticationResultMetadata = new AuthenticationResultMetadata(tokenSource);
			AdditionalResponseParameters = additionalResponseParameters;
			if (msalAccessTokenCacheItem != null)
			{
				AccessToken = authenticationScheme.FormatAccessToken(msalAccessTokenCacheItem);
				ExpiresOn = msalAccessTokenCacheItem.ExpiresOn;
				Scopes = msalAccessTokenCacheItem.ScopeSet;
				ExtendedExpiresOn = msalAccessTokenCacheItem.ExtendedExpiresOn;
				IsExtendedLifeTimeToken = msalAccessTokenCacheItem.IsExtendedLifeTimeToken;
				TokenType = msalAccessTokenCacheItem.TokenType;
				if (msalAccessTokenCacheItem.RefreshOn.HasValue)
				{
					AuthenticationResultMetadata.RefreshOn = msalAccessTokenCacheItem.RefreshOn;
				}
			}
		}

		internal AuthenticationResult()
		{
		}

		public string CreateAuthorizationHeader()
		{
			return (_authenticationScheme?.AuthorizationHeaderPrefix ?? TokenType) + " " + AccessToken;
		}
	}
	public class AuthenticationResultMetadata
	{
		public TokenSource TokenSource { get; }

		public string TokenEndpoint { get; set; }

		public long DurationTotalInMs { get; set; }

		public long DurationInCacheInMs { get; set; }

		public long DurationInHttpInMs { get; set; }

		public DateTimeOffset? RefreshOn { get; set; }

		public CacheRefreshReason CacheRefreshReason { get; set; }

		public CacheLevel CacheLevel { get; set; }

		public RegionDetails RegionDetails { get; set; }

		public string Telemetry { get; set; }

		public AuthenticationResultMetadata(TokenSource tokenSource)
		{
			TokenSource = tokenSource;
		}
	}
	public enum CacheRefreshReason
	{
		NotApplicable,
		ForceRefreshOrClaims,
		NoCachedAccessToken,
		Expired,
		ProactivelyRefreshed
	}
	public abstract class ClientApplicationBase : ApplicationBase, IClientApplicationBase, IApplicationBase
	{
		public IAppConfig AppConfig => base.ServiceBundle.Config;

		public ITokenCache UserTokenCache => UserTokenCacheInternal;

		internal ITokenCacheInternal UserTokenCacheInternal { get; }

		public string Authority => base.ServiceBundle.Config.Authority.AuthorityInfo.CanonicalAuthority?.ToString();

		internal AuthorityInfo AuthorityInfo => base.ServiceBundle.Config.Authority.AuthorityInfo;

		[EditorBrowsable(EditorBrowsableState.Never)]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		[Obsolete("Use GetAccountsAsync instead (See https://aka.ms/msal-net-2-released)", true)]
		public IEnumerable<IUser> Users
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use WithComponent on AbstractApplicationBuilder<T> to configure this instead.See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public string Component { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use ExtraQueryParameters on each call instead.See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public string SliceParameters { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Can be set on AbstractApplicationBuilder<T>.WithAuthority as needed.See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public bool ValidateAuthority { get; set; }

		[Obsolete("Should be set using AbstractApplicationBuilder<T>.WithRedirectUri and can be viewed with ClientApplicationBase.AppConfig.RedirectUri.See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string RedirectUri { get; set; }

		[Obsolete("Use AppConfig.ClientId instead.See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string ClientId => AppConfig.ClientId;

		internal ClientApplicationBase(ApplicationConfiguration config)
			: base(config)
		{
			UserTokenCacheInternal = config.UserTokenCacheInternalForTest ?? new TokenCache(base.ServiceBundle, isApplicationTokenCache: false, config.UserTokenLegacyCachePersistenceForTest);
		}

		public Task<IEnumerable<IAccount>> GetAccountsAsync()
		{
			return GetAccountsAsync(default(CancellationToken));
		}

		public Task<IEnumerable<IAccount>> GetAccountsAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetAccountsInternalAsync(ApiEvent.ApiIds.GetAccounts, null, cancellationToken);
		}

		public Task<IEnumerable<IAccount>> GetAccountsAsync(string userFlow)
		{
			return GetAccountsAsync(userFlow, default(CancellationToken));
		}

		public async Task<IEnumerable<IAccount>> GetAccountsAsync(string userFlow, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (string.IsNullOrWhiteSpace(userFlow))
			{
				throw new ArgumentException("userFlow should not be null or whitespace", "userFlow");
			}
			return (await GetAccountsInternalAsync(ApiEvent.ApiIds.GetAccountsByUserFlow, null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Where((IAccount acc) => acc.HomeAccountId.ObjectId.EndsWith(userFlow, StringComparison.OrdinalIgnoreCase));
		}

		public async Task<IAccount> GetAccountAsync(string accountId, CancellationToken cancellationToken = default(CancellationToken))
		{
			return (await GetAccountsInternalAsync(ApiEvent.ApiIds.GetAccountById, accountId, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).SingleOrDefault();
		}

		public async Task<IAccount> GetAccountAsync(string accountId)
		{
			if (!string.IsNullOrWhiteSpace(accountId))
			{
				return await GetAccountAsync(accountId, default(CancellationToken)).ConfigureAwait(continueOnCapturedContext: false);
			}
			return null;
		}

		public Task RemoveAsync(IAccount account)
		{
			return RemoveAsync(account, default(CancellationToken));
		}

		public async Task RemoveAsync(IAccount account, CancellationToken cancellationToken = default(CancellationToken))
		{
			Guid correlationId = Guid.NewGuid();
			RequestContext requestContext = CreateRequestContext(correlationId, cancellationToken);
			requestContext.ApiEvent = new ApiEvent(correlationId);
			requestContext.ApiEvent.ApiId = ApiEvent.ApiIds.RemoveAccount;
			Authority authority = await Microsoft.Identity.Client.Instance.Authority.CreateAuthorityForRequestAsync(requestContext, null).ConfigureAwait(continueOnCapturedContext: false);
			AuthenticationRequestParameters requestParameters = new AuthenticationRequestParameters(base.ServiceBundle, UserTokenCacheInternal, new AcquireTokenCommonParameters
			{
				ApiId = requestContext.ApiEvent.ApiId
			}, requestContext, authority);
			if (account != null && UserTokenCacheInternal != null)
			{
				await UserTokenCacheInternal.RemoveAccountAsync(account, requestParameters).ConfigureAwait(continueOnCapturedContext: false);
			}
			if (AppConfig.IsBrokerEnabled && base.ServiceBundle.PlatformProxy.CanBrokerSupportSilentAuth())
			{
				cancellationToken.ThrowIfCancellationRequested();
				IBroker broker = base.ServiceBundle.PlatformProxy.CreateBroker(base.ServiceBundle.Config, null);
				if (broker.IsBrokerInstalledAndInvokable(authority.AuthorityInfo.AuthorityType))
				{
					await broker.RemoveAccountAsync(base.ServiceBundle.Config, account).ConfigureAwait(continueOnCapturedContext: false);
				}
			}
		}

		private async Task<IEnumerable<IAccount>> GetAccountsInternalAsync(ApiEvent.ApiIds apiId, string homeAccountIdFilter, CancellationToken cancellationToken)
		{
			Guid correlationId = Guid.NewGuid();
			RequestContext requestContext = CreateRequestContext(correlationId, cancellationToken);
			requestContext.ApiEvent = new ApiEvent(correlationId);
			requestContext.ApiEvent.ApiId = apiId;
			Authority initialAuthority = await Microsoft.Identity.Client.Instance.Authority.CreateAuthorityForRequestAsync(requestContext, null).ConfigureAwait(continueOnCapturedContext: false);
			AuthenticationRequestParameters requestParams = new AuthenticationRequestParameters(base.ServiceBundle, UserTokenCacheInternal, new AcquireTokenCommonParameters
			{
				ApiId = apiId
			}, requestContext, initialAuthority, homeAccountIdFilter);
			CacheSessionManager cacheSessionManager = new CacheSessionManager(UserTokenCacheInternal, requestParams);
			IEnumerable<IAccount> accountsFromCache = await cacheSessionManager.GetAccountsAsync().ConfigureAwait(continueOnCapturedContext: false);
			IEnumerable<IAccount> accountsFromBroker = await GetAccountsFromBrokerAsync(homeAccountIdFilter, cacheSessionManager, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (accountsFromCache == null)
			{
				accountsFromCache = Enumerable.Empty<IAccount>();
			}
			if (accountsFromBroker == null)
			{
				accountsFromBroker = Enumerable.Empty<IAccount>();
			}
			base.ServiceBundle.ApplicationLogger.Info(() => $"Found {accountsFromCache.Count()} cache accounts and {accountsFromBroker.Count()} broker accounts");
			IEnumerable<IAccount> cacheAndBrokerAccounts = MergeAccounts(accountsFromCache, accountsFromBroker);
			base.ServiceBundle.ApplicationLogger.Info(() => $"Returning {cacheAndBrokerAccounts.Count()} accounts");
			return cacheAndBrokerAccounts;
		}

		private async Task<IEnumerable<IAccount>> GetAccountsFromBrokerAsync(string homeAccountIdFilter, ICacheSessionManager cacheSessionManager, CancellationToken cancellationToken)
		{
			if (AppConfig.IsBrokerEnabled && base.ServiceBundle.PlatformProxy.CanBrokerSupportSilentAuth())
			{
				IBroker broker = base.ServiceBundle.PlatformProxy.CreateBroker(base.ServiceBundle.Config, null);
				if (broker.IsBrokerInstalledAndInvokable(base.ServiceBundle.Config.Authority.AuthorityInfo.AuthorityType))
				{
					IEnumerable<IAccount> enumerable = (await broker.GetAccountsAsync(AppConfig.ClientId, AppConfig.RedirectUri, AuthorityInfo, cacheSessionManager, base.ServiceBundle.InstanceDiscoveryManager).ConfigureAwait(continueOnCapturedContext: false)) ?? Enumerable.Empty<IAccount>();
					if (!string.IsNullOrEmpty(homeAccountIdFilter))
					{
						enumerable = enumerable.Where((IAccount acc) => homeAccountIdFilter.Equals(acc.HomeAccountId.Identifier, StringComparison.OrdinalIgnoreCase));
					}
					return await FilterBrokerAccountsByEnvAsync(enumerable, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
			}
			return Enumerable.Empty<IAccount>();
		}

		private async Task<IEnumerable<IAccount>> FilterBrokerAccountsByEnvAsync(IEnumerable<IAccount> brokerAccounts, CancellationToken cancellationToken)
		{
			base.ServiceBundle.ApplicationLogger.Verbose(() => "Filtering broker accounts by environment. Before filtering: " + brokerAccounts.Count());
			ISet<string> existingEnvironmentsInCache = new HashSet<string>(brokerAccounts.Select((IAccount aci) => aci.Environment), StringComparer.OrdinalIgnoreCase);
			InstanceDiscoveryMetadataEntry instanceMetadata = await base.ServiceBundle.InstanceDiscoveryManager.GetMetadataEntryTryAvoidNetworkAsync(AuthorityInfo, existingEnvironmentsInCache, CreateRequestContext(Guid.NewGuid(), cancellationToken)).ConfigureAwait(continueOnCapturedContext: false);
			brokerAccounts = brokerAccounts.Where((IAccount acc) => instanceMetadata.Aliases.ContainsOrdinalIgnoreCase(acc.Environment));
			base.ServiceBundle.ApplicationLogger.Verbose(() => "After filtering: " + brokerAccounts.Count());
			return brokerAccounts;
		}

		private IEnumerable<IAccount> MergeAccounts(IEnumerable<IAccount> cacheAccounts, IEnumerable<IAccount> brokerAccounts)
		{
			List<IAccount> list = new List<IAccount>(cacheAccounts);
			foreach (IAccount account in brokerAccounts)
			{
				if (!list.Any((IAccount x) => x.HomeAccountId.Equals(account.HomeAccountId)))
				{
					list.Add(account);
					continue;
				}
				base.ServiceBundle.ApplicationLogger.InfoPii(() => "Account merge eliminated broker account with ID: " + account.HomeAccountId, () => "Account merge eliminated an account");
			}
			return list;
		}

		internal RequestContext CreateRequestContext(Guid correlationId, CancellationToken cancellationToken)
		{
			return new RequestContext(base.ServiceBundle, correlationId, cancellationToken);
		}

		public AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable<string> scopes, IAccount account)
		{
			return AcquireTokenSilentParameterBuilder.Create(ClientExecutorFactory.CreateClientApplicationBaseExecutor(this), scopes, account);
		}

		public AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable<string> scopes, string loginHint)
		{
			if (string.IsNullOrWhiteSpace(loginHint))
			{
				throw new ArgumentNullException("loginHint");
			}
			return AcquireTokenSilentParameterBuilder.Create(ClientExecutorFactory.CreateClientApplicationBaseExecutor(this), scopes, loginHint);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use GetAccountAsync instead and pass IAccount.HomeAccountId.Identifier (See https://aka.ms/msal-net-2-released)", true)]
		public IUser GetUser(string identifier)
		{
			throw new NotImplementedException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use RemoveAccountAsync instead (See https://aka.ms/msal-net-2-released)", true)]
		public void Remove(IUser user)
		{
			throw new NotImplementedException();
		}

		[Obsolete("Use AcquireTokenSilent instead.See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public Task<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable<string> scopes, IAccount account, string authority, bool forceRefresh)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[Obsolete("Use AcquireTokenSilent instead.See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public Task<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable<string> scopes, IAccount account)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}
	}
	public sealed class ConfidentialClientApplication : ClientApplicationBase, IConfidentialClientApplication, IClientApplicationBase, IApplicationBase, IConfidentialClientApplicationWithCertificate, IByRefreshToken, ILongRunningWebApi
	{
		public const string AttemptRegionDiscovery = "TryAutoDetect";

		public ITokenCache AppTokenCache => AppTokenCacheInternal;

		public X509Certificate2 Certificate { get; }

		internal ITokenCacheInternal AppTokenCacheInternal { get; }

		internal ConfidentialClientApplication(ApplicationConfiguration configuration)
			: base(configuration)
		{
			ApplicationBase.GuardMobileFrameworks();
			AppTokenCacheInternal = configuration.AppTokenCacheInternalForTest ?? new TokenCache(base.ServiceBundle, isApplicationTokenCache: true);
			Certificate = configuration.ClientCredentialCertificate;
			base.ServiceBundle.ApplicationLogger.Verbose(() => $"ConfidentialClientApplication {configuration.GetHashCode()} created");
		}

		public AcquireTokenByAuthorizationCodeParameterBuilder AcquireTokenByAuthorizationCode(IEnumerable<string> scopes, string authorizationCode)
		{
			return AcquireTokenByAuthorizationCodeParameterBuilder.Create(ClientExecutorFactory.CreateConfidentialClientExecutor(this), scopes, authorizationCode);
		}

		public AcquireTokenForClientParameterBuilder AcquireTokenForClient(IEnumerable<string> scopes)
		{
			return AcquireTokenForClientParameterBuilder.Create(ClientExecutorFactory.CreateConfidentialClientExecutor(this), scopes);
		}

		public AcquireTokenOnBehalfOfParameterBuilder AcquireTokenOnBehalfOf(IEnumerable<string> scopes, UserAssertion userAssertion)
		{
			if (userAssertion == null)
			{
				base.ServiceBundle.ApplicationLogger.Error("User assertion for OBO request should not be null");
				throw new MsalClientException("user_assertion_null");
			}
			return AcquireTokenOnBehalfOfParameterBuilder.Create(ClientExecutorFactory.CreateConfidentialClientExecutor(this), scopes, userAssertion);
		}

		public AcquireTokenOnBehalfOfParameterBuilder InitiateLongRunningProcessInWebApi(IEnumerable<string> scopes, string userToken, ref string longRunningProcessSessionKey)
		{
			if (string.IsNullOrEmpty(userToken))
			{
				throw new ArgumentNullException("userToken");
			}
			UserAssertion userAssertion = new UserAssertion(userToken);
			if (string.IsNullOrEmpty(longRunningProcessSessionKey))
			{
				longRunningProcessSessionKey = userAssertion.AssertionHash;
			}
			return AcquireTokenOnBehalfOfParameterBuilder.Create(ClientExecutorFactory.CreateConfidentialClientExecutor(this), scopes, userAssertion, longRunningProcessSessionKey);
		}

		public AcquireTokenOnBehalfOfParameterBuilder AcquireTokenInLongRunningProcess(IEnumerable<string> scopes, string longRunningProcessSessionKey)
		{
			if (string.IsNullOrEmpty(longRunningProcessSessionKey))
			{
				throw new ArgumentNullException("longRunningProcessSessionKey");
			}
			return AcquireTokenOnBehalfOfParameterBuilder.Create(ClientExecutorFactory.CreateConfidentialClientExecutor(this), scopes, longRunningProcessSessionKey);
		}

		public async Task<bool> StopLongRunningProcessInWebApiAsync(string longRunningProcessSessionKey, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (string.IsNullOrEmpty(longRunningProcessSessionKey))
			{
				throw new ArgumentNullException("longRunningProcessSessionKey");
			}
			Guid correlationId = Guid.NewGuid();
			RequestContext requestContext = CreateRequestContext(correlationId, cancellationToken);
			requestContext.ApiEvent = new ApiEvent(correlationId);
			requestContext.ApiEvent.ApiId = ApiEvent.ApiIds.RemoveOboTokens;
			Authority initialAuthority = await Microsoft.Identity.Client.Instance.Authority.CreateAuthorityForRequestAsync(requestContext, null).ConfigureAwait(continueOnCapturedContext: false);
			AuthenticationRequestParameters requestParameters = new AuthenticationRequestParameters(base.ServiceBundle, base.UserTokenCacheInternal, new AcquireTokenCommonParameters
			{
				ApiId = requestContext.ApiEvent.ApiId
			}, requestContext, initialAuthority);
			if (base.UserTokenCacheInternal != null)
			{
				return await base.UserTokenCacheInternal.StopLongRunningOboProcessAsync(longRunningProcessSessionKey, requestParameters).ConfigureAwait(continueOnCapturedContext: false);
			}
			return false;
		}

		public GetAuthorizationRequestUrlParameterBuilder GetAuthorizationRequestUrl(IEnumerable<string> scopes)
		{
			return GetAuthorizationRequestUrlParameterBuilder.Create(ClientExecutorFactory.CreateConfidentialClientExecutor(this), scopes);
		}

		AcquireTokenByRefreshTokenParameterBuilder IByRefreshToken.AcquireTokenByRefreshToken(IEnumerable<string> scopes, string refreshToken)
		{
			return AcquireTokenByRefreshTokenParameterBuilder.Create(ClientExecutorFactory.CreateClientApplicationBaseExecutor(this), scopes, refreshToken);
		}

		internal override async Task<AuthenticationRequestParameters> CreateRequestParametersAsync(AcquireTokenCommonParameters commonParameters, RequestContext requestContext, ITokenCacheInternal cache)
		{
			return await base.CreateRequestParametersAsync(commonParameters, requestContext, cache).ConfigureAwait(continueOnCapturedContext: false);
		}

		[Obsolete("Use ConfidentialClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public ConfidentialClientApplication(string clientId, string redirectUri, ClientCredential clientCredential, TokenCache userTokenCache, TokenCache appTokenCache)
			: this(ConfidentialClientApplicationBuilder.Create(clientId).BuildConfiguration())
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use ConfidentialClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public ConfidentialClientApplication(string clientId, string authority, string redirectUri, ClientCredential clientCredential, TokenCache userTokenCache, TokenCache appTokenCache)
			: this(ConfidentialClientApplicationBuilder.Create(clientId).BuildConfiguration())
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenOnBehalfOfAsync(IEnumerable<string> scopes, UserAssertion userAssertion)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenOnBehalfOfAsync(IEnumerable<string> scopes, UserAssertion userAssertion, string authority)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable<string> scopes, UserAssertion userAssertion)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable<string> scopes, UserAssertion userAssertion, string authority)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenByAuthorizationCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenByAuthorizationCodeAsync(string authorizationCode, IEnumerable<string> scopes)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenForClientAsync(IEnumerable<string> scopes)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenForClientAsync(IEnumerable<string> scopes, bool forceRefresh)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(IEnumerable<string> scopes)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(IEnumerable<string> scopes, bool forceRefresh)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenByRefreshToken instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> IByRefreshToken.AcquireTokenByRefreshTokenAsync(IEnumerable<string> scopes, string refreshToken)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<Uri> GetAuthorizationRequestUrlAsync(IEnumerable<string> scopes, string loginHint, string extraQueryParameters)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<Uri> GetAuthorizationRequestUrlAsync(IEnumerable<string> scopes, string redirectUri, string loginHint, string extraQueryParameters, IEnumerable<string> extraScopesToConsent, string authority)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}
	}
	public class DeviceCodeResult
	{
		public string UserCode { get; }

		public string DeviceCode { get; }

		public string VerificationUrl { get; }

		public DateTimeOffset ExpiresOn { get; }

		public long Interval { get; }

		public string Message { get; }

		public string ClientId { get; }

		public IReadOnlyCollection<string> Scopes { get; }

		internal DeviceCodeResult(string userCode, string deviceCode, string verificationUrl, DateTimeOffset expiresOn, long interval, string message, string clientId, ISet<string> scopes)
		{
			UserCode = userCode;
			DeviceCode = deviceCode;
			VerificationUrl = verificationUrl;
			ExpiresOn = expiresOn;
			Interval = interval;
			Message = message;
			ClientId = clientId;
			Scopes = new ReadOnlyCollection<string>(scopes.AsEnumerable().ToList());
		}
	}
	public static class PublicClientApplicationExtensions
	{
		public static bool IsProofOfPossessionSupportedByClient(this IPublicClientApplication app)
		{
			if (app is PublicClientApplication publicClientApplication)
			{
				return publicClientApplication.IsProofOfPossessionSupportedByClient();
			}
			return false;
		}
	}
	public interface IAccount
	{
		string Username { get; }

		string Environment { get; }

		AccountId HomeAccountId { get; }
	}
	public interface IApplicationBase
	{
	}
	public interface IByRefreshToken
	{
		AcquireTokenByRefreshTokenParameterBuilder AcquireTokenByRefreshToken(IEnumerable<string> scopes, string refreshToken);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenByRefreshToken instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenByRefreshTokenAsync(IEnumerable<string> scopes, string refreshToken);
	}
	public interface IClientApplicationBase : IApplicationBase
	{
		IAppConfig AppConfig { get; }

		ITokenCache UserTokenCache { get; }

		string Authority { get; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		[Obsolete("Use GetAccountsAsync instead (See https://aka.ms/msal-net-2-released)", true)]
		IEnumerable<IUser> Users { get; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use WithComponent on AbstractApplicationBuilder<T> to configure this instead.  See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", true)]
		string Component { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use ExtraQueryParameters on each call instead.  See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", true)]
		string SliceParameters { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Can be set on AbstractApplicationBuilder<T>.WithAuthority as needed.  See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", true)]
		bool ValidateAuthority { get; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Should be set using AbstractApplicationBuilder<T>.WithRedirectUri and can be viewed with ClientApplicationBase.AppConfig.RedirectUri. See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", true)]
		string RedirectUri { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AppConfig.ClientId instead.See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		string ClientId { get; }

		Task<IEnumerable<IAccount>> GetAccountsAsync();

		Task<IAccount> GetAccountAsync(string identifier);

		Task<IEnumerable<IAccount>> GetAccountsAsync(string userFlow);

		AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable<string> scopes, IAccount account);

		AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable<string> scopes, string loginHint);

		Task RemoveAsync(IAccount account);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use GetAccountAsync instead and pass IAccount.HomeAccountId.Identifier (See https://aka.ms/msal-net-2-released)", true)]
		IUser GetUser(string identifier);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use RemoveAccountAsync instead (See https://aka.ms/msal-net-2-released)", true)]
		void Remove(IUser user);

		[Obsolete("Use AcquireTokenSilent instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable<string> scopes, IAccount account);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenSilent instead.See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable<string> scopes, IAccount account, string authority, bool forceRefresh);
	}
	public interface IConfidentialClientApplication : IClientApplicationBase, IApplicationBase
	{
		ITokenCache AppTokenCache { get; }

		AcquireTokenByAuthorizationCodeParameterBuilder AcquireTokenByAuthorizationCode(IEnumerable<string> scopes, string authorizationCode);

		AcquireTokenForClientParameterBuilder AcquireTokenForClient(IEnumerable<string> scopes);

		AcquireTokenOnBehalfOfParameterBuilder AcquireTokenOnBehalfOf(IEnumerable<string> scopes, UserAssertion userAssertion);

		GetAuthorizationRequestUrlParameterBuilder GetAuthorizationRequestUrl(IEnumerable<string> scopes);

		[Obsolete("In confidential client apps use AcquireTokenSilent(scopes, account) instead.")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		new AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable<string> scopes, string loginHint);

		[Obsolete("Use GetAccountAsync(identifier) in web apps and web APIs, and use a token cache serializer for better security and performance. See https://aka.ms/msal-net-cca-token-cache-serialization.")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		new Task<IEnumerable<IAccount>> GetAccountsAsync();

		[Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenOnBehalfOfAsync(IEnumerable<string> scopes, UserAssertion userAssertion);

		[Obsolete("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenOnBehalfOfAsync(IEnumerable<string> scopes, UserAssertion userAssertion, string authority);

		[Obsolete("Use AcquireTokenByAuthorizationCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenByAuthorizationCodeAsync(string authorizationCode, IEnumerable<string> scopes);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenForClientAsync(IEnumerable<string> scopes);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenForClientAsync(IEnumerable<string> scopes, bool forceRefresh);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<Uri> GetAuthorizationRequestUrlAsync(IEnumerable<string> scopes, string loginHint, string extraQueryParameters);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<Uri> GetAuthorizationRequestUrlAsync(IEnumerable<string> scopes, string redirectUri, string loginHint, string extraQueryParameters, IEnumerable<string> extraScopesToConsent, string authority);
	}
	public interface ILongRunningWebApi
	{
		AcquireTokenOnBehalfOfParameterBuilder InitiateLongRunningProcessInWebApi(IEnumerable<string> scopes, string userToken, ref string longRunningProcessSessionKey);

		AcquireTokenOnBehalfOfParameterBuilder AcquireTokenInLongRunningProcess(IEnumerable<string> scopes, string longRunningProcessSessionKey);
	}
	public interface IManagedIdentityApplication : IApplicationBase
	{
		AcquireTokenForManagedIdentityParameterBuilder AcquireTokenForManagedIdentity(string resource);
	}
	public class IntuneAppProtectionPolicyRequiredException : MsalServiceException
	{
		public string Upn { get; set; }

		public string AccountUserId { get; set; }

		public string TenantId { get; set; }

		public string AuthorityUrl { get; set; }

		public IntuneAppProtectionPolicyRequiredException(string errorCode, string errorMessage)
			: base(errorCode, errorMessage, null)
		{
		}
	}
	public interface IPublicClientApplication : IClientApplicationBase, IApplicationBase
	{
		bool IsSystemWebViewAvailable { get; }

		AcquireTokenInteractiveParameterBuilder AcquireTokenInteractive(IEnumerable<string> scopes);

		AcquireTokenWithDeviceCodeParameterBuilder AcquireTokenWithDeviceCode(IEnumerable<string> scopes, Func<DeviceCodeResult, Task> deviceCodeResultCallback);

		AcquireTokenByIntegratedWindowsAuthParameterBuilder AcquireTokenByIntegratedWindowsAuth(IEnumerable<string> scopes);

		[Obsolete("Using SecureString is not recommended. Use AcquireTokenByUsernamePassword(IEnumerable<string> scopes, string username, string password) instead.", false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable<string> scopes, string username, SecureString password);

		AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable<string> scopes, string username, string password);

		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable<string> extraScopesToConsent, string authority);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable<string> extraScopesToConsent, string authority);

		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, UIParent parent);

		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint, UIParent parent);

		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account, UIParent parent);

		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, UIParent parent);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, UIParent parent);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable<string> extraScopesToConsent, string authority, UIParent parent);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable<string> extraScopesToConsent, string authority, UIParent parent);

		[Obsolete("Use AcquireTokenByUsernamePassword instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenByUsernamePasswordAsync(IEnumerable<string> scopes, string username, SecureString securePassword);

		[Obsolete("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable<string> scopes, Func<DeviceCodeResult, Task> deviceCodeResultCallback);

		[Obsolete("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		Task<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable<string> scopes, string extraQueryParameters, Func<DeviceCodeResult, Task> deviceCodeResultCallback);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable<string> scopes, Func<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable<string> scopes, string extraQueryParameters, Func<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable<string> scopes);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable<string> scopes, string username);
	}
	public delegate void TokenCacheCallback(TokenCacheNotificationArgs args);
	public interface ITokenCache
	{
		void SetBeforeAccess(TokenCacheCallback beforeAccess);

		void SetAfterAccess(TokenCacheCallback afterAccess);

		void SetBeforeWrite(TokenCacheCallback beforeWrite);

		void SetBeforeAccessAsync(Func<TokenCacheNotificationArgs, Task> beforeAccess);

		void SetAfterAccessAsync(Func<TokenCacheNotificationArgs, Task> afterAccess);

		void SetBeforeWriteAsync(Func<TokenCacheNotificationArgs, Task> beforeWrite);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use ITokenCacheSerializer.SerializeMsalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		byte[] SerializeMsalV3();

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use ITokenCacheSerializer.DeserializeMsalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		void DeserializeMsalV3(byte[] msalV3State, bool shouldClearExistingCache = false);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use ITokenCacheSerializer.SerializeMsalV2 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		byte[] SerializeMsalV2();

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use ITokenCacheSerializer.DeserializeMsalV2 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		void DeserializeMsalV2(byte[] msalV2State);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use ITokenCacheSerializer.SerializeAdalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		byte[] SerializeAdalV3();

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use ITokenCacheSerializer.DeserializeAdalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		void DeserializeAdalV3(byte[] adalV3State);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		byte[] Serialize();

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		void Deserialize(byte[] msalV2State);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		CacheData SerializeUnifiedAndAdalCache();

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		void DeserializeUnifiedAndAdalCache(CacheData cacheData);
	}
	internal interface ITokenCacheInternal : ITokenCache, ITokenCacheSerializer
	{
		OptionalSemaphoreSlim Semaphore { get; }

		ILegacyCachePersistence LegacyPersistence { get; }

		ITokenCacheAccessor Accessor { get; }

		bool IsApplicationCache { get; }

		Task RemoveAccountAsync(IAccount account, AuthenticationRequestParameters requestParameters);

		Task<bool> StopLongRunningOboProcessAsync(string longRunningOboCacheKey, AuthenticationRequestParameters requestParameters);

		Task<IEnumerable<IAccount>> GetAccountsAsync(AuthenticationRequestParameters requestParameters);

		Task<Tuple<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> SaveTokenResponseAsync(AuthenticationRequestParameters requestParams, MsalTokenResponse response);

		Task<MsalAccessTokenCacheItem> FindAccessTokenAsync(AuthenticationRequestParameters requestParams);

		MsalIdTokenCacheItem GetIdTokenCacheItem(MsalAccessTokenCacheItem msalAccessTokenCacheItem);

		Task<MsalRefreshTokenCacheItem> FindRefreshTokenAsync(AuthenticationRequestParameters requestParams, string familyId = null);

		Task<Account> GetAccountAssociatedWithAccessTokenAsync(AuthenticationRequestParameters requestParameters, MsalAccessTokenCacheItem msalAccessTokenCacheItem);

		Task<bool?> IsFociMemberAsync(AuthenticationRequestParameters requestParams, string familyId);

		void SetIosKeychainSecurityGroup(string securityGroup);

		Task OnAfterAccessAsync(TokenCacheNotificationArgs args);

		Task OnBeforeAccessAsync(TokenCacheNotificationArgs args);

		Task OnBeforeWriteAsync(TokenCacheNotificationArgs args);

		bool HasTokensNoLocks();

		bool IsAppSubscribedToSerializationEvents();
	}
	public interface ITokenCacheSerializer
	{
		byte[] SerializeMsalV3();

		void DeserializeMsalV3(byte[] msalV3State, bool shouldClearExistingCache = false);

		byte[] SerializeAdalV3();

		void DeserializeAdalV3(byte[] adalV3State);

		[Obsolete("Support for the MSAL v2 token cache format will be dropped in the next major version", false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		byte[] SerializeMsalV2();

		[Obsolete("Support for the MSAL v2 token cache format will be dropped in the next major version", false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		void DeserializeMsalV2(byte[] msalV2State);
	}
	public delegate void LogCallback(LogLevel level, string message, bool containsPii);
	public enum LogLevel
	{
		Always = -1,
		Error,
		Warning,
		Info,
		Verbose
	}
	internal static class LogMessages
	{
		public const string BeginningAcquireByRefreshToken = "Begin acquire token by refresh token...";

		public const string NoScopesProvidedForRefreshTokenRequest = "No scopes provided for acquire token by refresh token request. Using default scope instead.";

		public const string CustomWebUiAcquiringAuthorizationCode = "Using CustomWebUi to acquire the authorization code";

		public const string CustomWebUiRedirectUriMatched = "Redirect Uri was matched.  Returning success from CustomWebUiHandler.";

		public const string CustomWebUiOperationCancelled = "CustomWebUi AcquireAuthorizationCode was canceled";

		public const string CustomWebUiCallingAcquireAuthorizationCodeNoPii = "Calling CustomWebUi.AcquireAuthorizationCode";

		public const string ClientAssertionDoesNotExistOrNearExpiry = "Client Assertion does not exist or near expiry. ";

		public const string ReusingTheUnexpiredClientAssertion = "Reusing the unexpired Client Assertion...";

		public const string ResolvingAuthorityEndpointsTrue = "Resolving authority endpoints... Already resolved? - TRUE";

		public const string ResolvingAuthorityEndpointsFalse = "Resolving authority endpoints... Already resolved? - FALSE";

		public const string CheckMsalTokenResponseReturnedFromBroker = "Checking MsalTokenResponse returned from broker. ";

		public const string UnknownErrorReturnedInBrokerResponse = "Unknown error returned in broker response. ";

		public const string BrokerInvocationRequired = "Based on auth code received from STS, broker invocation is required. ";

		public const string AddBrokerInstallUrlToPayload = "Broker is required for authentication and broker is not installed on the device. Adding BrokerInstallUrl to broker payload. ";

		public const string BrokerInvocationNotRequired = "Based on auth code received from STS, broker invocation is not required. ";

		public const string CanInvokeBrokerAcquireTokenWithBroker = "Can invoke broker. Will attempt to acquire token with broker. ";

		public const string AuthenticationWithBrokerDidNotSucceed = "Broker authentication did not succeed, or the broker install failed. See https://aka.ms/msal-net-brokers for more information. ";

		public const string UserCancelledAuthentication = "Authorization result status returned user cancelled authentication. ";

		public const string AuthorizationResultWasNotSuccessful = "Authorization result was not successful. See error message for more details. ";

		public const string WsTrustRequestFailed = "Ws-Trust request failed. See error message for more details.";

		public static string ErrorReturnedInBrokerResponse(string error)
		{
			return "Error " + error + " returned in broker response. ";
		}

		public static string UsingXScopesForRefreshTokenRequest(int numScopes)
		{
			return string.Format(CultureInfo.InvariantCulture, "Using {0} scopes for acquire token by refresh token request", numScopes);
		}

		public static string CustomWebUiCallingAcquireAuthorizationCodePii(Uri authorizationUri, Uri redirectUri)
		{
			return string.Format(CultureInfo.InvariantCulture, "calling CustomWebUi.AcquireAuthorizationCode authUri({0}) redirectUri({1})", authorizationUri, redirectUri);
		}
	}
	public sealed class ManagedIdentityApplication : ApplicationBase, IManagedIdentityApplication, IApplicationBase
	{
		internal ITokenCacheInternal AppTokenCacheInternal { get; }

		internal ManagedIdentityApplication(ApplicationConfiguration configuration)
			: base(configuration)
		{
			ApplicationBase.GuardMobileFrameworks();
			AppTokenCacheInternal = configuration.AppTokenCacheInternalForTest ?? new TokenCache(base.ServiceBundle, isApplicationTokenCache: true);
			base.ServiceBundle.ApplicationLogger.Verbose(() => $"ManagedIdentityApplication {configuration.GetHashCode()} created");
		}

		public AcquireTokenForManagedIdentityParameterBuilder AcquireTokenForManagedIdentity(string resource)
		{
			if (string.IsNullOrEmpty(resource))
			{
				throw new ArgumentNullException("resource");
			}
			return AcquireTokenForManagedIdentityParameterBuilder.Create(ClientExecutorFactory.CreateManagedIdentityExecutor(this), resource);
		}

		public static ManagedIdentitySource GetManagedIdentitySource()
		{
			return ManagedIdentityClient.s_managedIdentitySourceDetected.Value;
		}
	}
	public class Metrics
	{
		private static long _totalAccessTokensFromIdP;

		private static long _totalAccessTokensFromCache;

		private static long _totalAccessTokensFromBroker;

		private static long _totalDurationInMs;

		public static long TotalAccessTokensFromIdP
		{
			get
			{
				return _totalAccessTokensFromIdP;
			}
			internal set
			{
				_totalAccessTokensFromIdP = value;
			}
		}

		public static long TotalAccessTokensFromCache
		{
			get
			{
				return _totalAccessTokensFromCache;
			}
			internal set
			{
				_totalAccessTokensFromCache = value;
			}
		}

		public static long TotalAccessTokensFromBroker
		{
			get
			{
				return _totalAccessTokensFromBroker;
			}
			internal set
			{
				_totalAccessTokensFromBroker = value;
			}
		}

		public static long TotalDurationInMs
		{
			get
			{
				return _totalDurationInMs;
			}
			internal set
			{
				_totalDurationInMs = value;
			}
		}

		private Metrics()
		{
		}

		internal static void IncrementTotalAccessTokensFromIdP()
		{
			Interlocked.Increment(ref _totalAccessTokensFromIdP);
		}

		internal static void IncrementTotalAccessTokensFromCache()
		{
			Interlocked.Increment(ref _totalAccessTokensFromCache);
		}

		internal static void IncrementTotalAccessTokensFromBroker()
		{
			Interlocked.Increment(ref _totalAccessTokensFromBroker);
		}

		internal static void IncrementTotalDurationInMs(long requestDurationInMs)
		{
			Interlocked.Add(ref _totalDurationInMs, requestDurationInMs);
		}
	}
	internal static class MigrationHelper
	{
		public static NotImplementedException CreateMsalNet3BreakingChangesException()
		{
			return new NotImplementedException("See https://aka.ms/msal-net-3-breaking-changes");
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("Use IAccount instead (See https://aka.ms/msal-net-2-released)", true)]
	public interface IUser
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		[Obsolete("Use IAccount.Username instead (See https://aka.ms/msal-net-2-released)", true)]
		string DisplayableId { get; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		[Obsolete("Use IAccount.Username instead (See https://aka.ms/msal-net-2-released)", true)]
		string Name { get; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		[Obsolete("Use IAccount.Environment instead to get the Identity Provider host (See https://aka.ms/msal-net-2-released)", true)]
		string IdentityProvider { get; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		[Obsolete("Use IAccount.HomeAccountId.Identifier instead to get the user identifier (See https://aka.ms/msal-net-2-released)", true)]
		string Identifier { get; }
	}
	public sealed class TokenCacheNotificationArgs
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		[Obsolete("Use Account instead (See https://aka.ms/msal-net-2-released)", true)]
		public IUser User
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public ITokenCacheSerializer TokenCache { get; }

		public string ClientId { get; }

		public IAccount Account { get; }

		public bool HasStateChanged { get; internal set; }

		public bool IsApplicationCache { get; }

		public string SuggestedCacheKey { get; }

		public bool HasTokens { get; }

		public CancellationToken CancellationToken { get; }

		public Guid CorrelationId { get; }

		public IEnumerable<string> RequestScopes { get; }

		public string RequestTenantId { get; }

		public DateTimeOffset? SuggestedCacheExpiry { get; }

		public IIdentityLogger IdentityLogger { get; }

		public bool PiiLoggingEnabled { get; }

		public TelemetryData TelemetryData { get; }

		public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, DateTimeOffset? suggestedCacheExpiry, CancellationToken cancellationToken)
			: this(tokenCache, clientId, account, hasStateChanged, isApplicationCache, suggestedCacheKey, hasTokens, suggestedCacheExpiry, cancellationToken, default(Guid), null, null, null, piiLoggingEnabled: false)
		{
		}

		public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, DateTimeOffset? suggestedCacheExpiry, CancellationToken cancellationToken, Guid correlationId)
			: this(tokenCache, clientId, account, hasStateChanged, isApplicationCache, suggestedCacheKey, hasTokens, suggestedCacheExpiry, cancellationToken, correlationId, null, null, null, piiLoggingEnabled: false)
		{
		}

		public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, DateTimeOffset? suggestedCacheExpiry, CancellationToken cancellationToken, Guid correlationId, IEnumerable<string> requestScopes, string requestTenantId)
		{
			TokenCache = tokenCache;
			ClientId = clientId;
			Account = account;
			HasStateChanged = hasStateChanged;
			IsApplicationCache = isApplicationCache;
			SuggestedCacheKey = suggestedCacheKey;
			HasTokens = hasTokens;
			CancellationToken = cancellationToken;
			CorrelationId = correlationId;
			RequestScopes = requestScopes;
			RequestTenantId = requestTenantId;
			SuggestedCacheExpiry = suggestedCacheExpiry;
		}

		public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, DateTimeOffset? suggestedCacheExpiry, CancellationToken cancellationToken, Guid correlationId, IEnumerable<string> requestScopes, string requestTenantId, IIdentityLogger identityLogger, bool piiLoggingEnabled, TelemetryData telemetryData = null)
		{
			TokenCache = tokenCache;
			ClientId = clientId;
			Account = account;
			HasStateChanged = hasStateChanged;
			IsApplicationCache = isApplicationCache;
			SuggestedCacheKey = suggestedCacheKey;
			HasTokens = hasTokens;
			CancellationToken = cancellationToken;
			CorrelationId = correlationId;
			RequestScopes = requestScopes;
			RequestTenantId = requestTenantId;
			SuggestedCacheExpiry = suggestedCacheExpiry;
			IdentityLogger = identityLogger;
			PiiLoggingEnabled = piiLoggingEnabled;
			TelemetryData = telemetryData ?? new TelemetryData();
		}
	}
	public sealed class PublicClientApplication : ClientApplicationBase, IPublicClientApplication, IClientApplicationBase, IApplicationBase, IByRefreshToken
	{
		private const string CurrentOSAccountDescriptor = "current_os_account";

		private static readonly IAccount s_currentOsAccount = new Account("current_os_account", null, null);

		public static IAccount OperatingSystemAccount => s_currentOsAccount;

		public bool IsSystemWebViewAvailable => base.ServiceBundle.PlatformProxy.GetWebUiFactory(base.ServiceBundle.Config).IsSystemWebViewAvailable;

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use PublicClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public PublicClientApplication(string clientId)
			: this(clientId, "https://login.microsoftonline.com/common/")
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use PublicClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public PublicClientApplication(string clientId, string authority)
			: base(PublicClientApplicationBuilder.Create(clientId).WithRedirectUri(PlatformProxyFactory.CreatePlatformProxy(null).GetDefaultRedirectUri(clientId)).WithAuthority(new Uri(authority))
				.BuildConfiguration())
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable<string> extraScopesToConsent, string authority)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable<string> extraScopesToConsent, string authority)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, UIParent parent)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint, UIParent parent)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account, UIParent parent)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, UIParent parent)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, UIParent parent)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ")]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable<string> extraScopesToConsent, string authority, UIParent parent)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenAsync(IEnumerable<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable<string> extraScopesToConsent, string authority, UIParent parent)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[Obsolete("Use AcquireTokenByUsernamePassword instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public Task<AuthenticationResult> AcquireTokenByUsernamePasswordAsync(IEnumerable<string> scopes, string username, SecureString securePassword)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable<string> scopes, Func<DeviceCodeResult, Task> deviceCodeResultCallback)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable<string> scopes, string extraQueryParameters, Func<DeviceCodeResult, Task> deviceCodeResultCallback)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable<string> scopes, Func<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable<string> scopes, string extraQueryParameters, Func<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenByRefreshToken instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> IByRefreshToken.AcquireTokenByRefreshTokenAsync(IEnumerable<string> scopes, string refreshToken)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable<string> scopes)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public Task<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable<string> scopes, string username)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use PublicClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		public PublicClientApplication(string clientId, string authority, TokenCache userTokenCache)
			: this(PublicClientApplicationBuilder.Create(clientId).WithAuthority(new Uri(authority)).BuildConfiguration())
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		internal PublicClientApplication(ApplicationConfiguration configuration)
			: base(configuration)
		{
		}

		internal static bool IsOperatingSystemAccount(IAccount account)
		{
			return string.Equals(account?.HomeAccountId?.Identifier, "current_os_account", StringComparison.Ordinal);
		}

		public bool IsEmbeddedWebViewAvailable()
		{
			return base.ServiceBundle.PlatformProxy.GetWebUiFactory(base.ServiceBundle.Config).IsEmbeddedWebViewAvailable;
		}

		public bool IsUserInteractive()
		{
			return base.ServiceBundle.PlatformProxy.GetWebUiFactory(base.ServiceBundle.Config).IsUserInteractive;
		}

		public bool IsBrokerAvailable()
		{
			return base.ServiceBundle.PlatformProxy.CreateBroker(base.ServiceBundle.Config, null).IsBrokerInstalledAndInvokable((base.ServiceBundle.Config.Authority?.AuthorityInfo?.AuthorityType).GetValueOrDefault());
		}

		[CLSCompliant(false)]
		public AcquireTokenInteractiveParameterBuilder AcquireTokenInteractive(IEnumerable<string> scopes)
		{
			return AcquireTokenInteractiveParameterBuilder.Create(ClientExecutorFactory.CreatePublicClientExecutor(this), scopes).WithParentActivityOrWindowFunc(base.ServiceBundle.Config.ParentActivityOrWindowFunc);
		}

		public AcquireTokenWithDeviceCodeParameterBuilder AcquireTokenWithDeviceCode(IEnumerable<string> scopes, Func<DeviceCodeResult, Task> deviceCodeResultCallback)
		{
			return AcquireTokenWithDeviceCodeParameterBuilder.Create(ClientExecutorFactory.CreatePublicClientExecutor(this), scopes, deviceCodeResultCallback);
		}

		AcquireTokenByRefreshTokenParameterBuilder IByRefreshToken.AcquireTokenByRefreshToken(IEnumerable<string> scopes, string refreshToken)
		{
			return AcquireTokenByRefreshTokenParameterBuilder.Create(ClientExecutorFactory.CreateClientApplicationBaseExecutor(this), scopes, refreshToken);
		}

		public AcquireTokenByIntegratedWindowsAuthParameterBuilder AcquireTokenByIntegratedWindowsAuth(IEnumerable<string> scopes)
		{
			return AcquireTokenByIntegratedWindowsAuthParameterBuilder.Create(ClientExecutorFactory.CreatePublicClientExecutor(this), scopes);
		}

		[Obsolete("Using SecureString is not recommended. Use AcquireTokenByUsernamePassword(IEnumerable<string> scopes, string username, string password) instead.", false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable<string> scopes, string username, SecureString password)
		{
			return AcquireTokenByUsernamePasswordParameterBuilder.Create(ClientExecutorFactory.CreatePublicClientExecutor(this), scopes, username, new string(password.PasswordToCharArray()));
		}

		public AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable<string> scopes, string username, string password)
		{
			return AcquireTokenByUsernamePasswordParameterBuilder.Create(ClientExecutorFactory.CreatePublicClientExecutor(this), scopes, username, password);
		}

		public bool IsProofOfPossessionSupportedByClient()
		{
			if (base.ServiceBundle.Config.IsBrokerEnabled)
			{
				IBroker broker = base.ServiceBundle.PlatformProxy.CreateBroker(base.ServiceBundle.Config, null);
				if (broker.IsBrokerInstalledAndInvokable(base.ServiceBundle.Config.Authority.AuthorityInfo.AuthorityType))
				{
					return broker.IsPopSupported;
				}
			}
			return false;
		}
	}
	public interface IConfidentialClientApplicationWithCertificate
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenForClientWithCertificateAsync(IEnumerable<string> scopes);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenForClientWithCertificateAsync(IEnumerable<string> scopes, bool forceRefresh);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable<string> scopes, UserAssertion userAssertion);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		Task<AuthenticationResult> AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable<string> scopes, UserAssertion userAssertion, string authority);
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("UIBehavior struct is now obsolete.  Please use Prompt struct instead.See https://aka.ms/msal-net-3-breaking-changes. ", true)]
	public struct UIBehavior
	{
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
	public sealed class Logger
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
		public static LogCallback LogCallback
		{
			set
			{
				throw new NotImplementedException("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ");
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
		public static LogLevel Level
		{
			get
			{
				throw new NotImplementedException("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ");
			}
			set
			{
				throw new NotImplementedException("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ");
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
		public static bool PiiLoggingEnabled { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
		public static bool DefaultLoggingEnabled { get; set; }
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
	public class Telemetry : ITelemetryReceiver
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
		public delegate void Receiver(List<Dictionary<string, string>> events);

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
		public bool TelemetryOnFailureOnly
		{
			get
			{
				throw new NotImplementedException("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ");
			}
			set
			{
				throw new NotImplementedException("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ");
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
		public static Telemetry GetInstance()
		{
			throw new NotImplementedException("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ");
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
		public void RegisterReceiver(Receiver r)
		{
			throw new NotImplementedException("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ");
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
		public bool HasRegisteredReceiver()
		{
			throw new NotImplementedException("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ");
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", true)]
		void ITelemetryReceiver.HandleTelemetryEvents(List<Dictionary<string, string>> events)
		{
			throw new NotImplementedException("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ");
		}
	}
	[Obsolete("Use ConfidentialClientApplicationBuilder.WithCertificate instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class ClientAssertionCertificate
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static int MinKeySizeInBits => 2048;

		[EditorBrowsable(EditorBrowsableState.Never)]
		public X509Certificate2 Certificate
		{
			get
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		internal string Thumbprint
		{
			get
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public ClientAssertionCertificate(X509Certificate2 certificate)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		internal byte[] Sign(ICryptographyManager cryptographyManager, string message)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}
	}
	[Obsolete("Use ConfidentialClientApplicationBuilder.WithCertificate or WithClientSecret instead. See https://aka.ms/msal-net-3-breaking-changes. ", true)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class ClientCredential
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		internal ClientAssertionCertificate Certificate
		{
			get
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		internal string Assertion
		{
			get
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
			set
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		internal long ValidTo
		{
			get
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
			set
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		internal bool ContainsX5C
		{
			get
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
			set
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		internal string Audience
		{
			get
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
			set
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		internal string Secret
		{
			get
			{
				throw MigrationHelper.CreateMsalNet3BreakingChangesException();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public ClientCredential(ClientAssertionCertificate certificate)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public ClientCredential(string secret)
		{
			throw MigrationHelper.CreateMsalNet3BreakingChangesException();
		}
	}
	[Obsolete("In MSAL.NET 3.x, you should directly pass the Activity (on Xamarin.Android), or Window (on .NET Framework and UWP) using AcquireTokenInteractiveParameterBuilder.WithParentActivityOrWindowSee https://aka.ms/msal-net-3-breaking-changes. ", true)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class UIParent
	{
		[Obsolete("See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public UIParent()
		{
			throw new NotImplementedException("See https://aka.ms/msal-net-3-breaking-changes. ");
		}

		[Obsolete("See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public UIParent(object parent, bool useEmbeddedWebView)
		{
			throw new NotImplementedException("See https://aka.ms/msal-net-3-breaking-changes. ");
		}

		[Obsolete("See https://aka.ms/msal-net-3-breaking-changes. ", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static bool IsSystemWebviewAvailable()
		{
			throw new NotImplementedException("See https://aka.ms/msal-net-3-breaking-changes. ");
		}
	}
	public sealed class TokenCache : ITokenCacheInternal, ITokenCache, ITokenCacheSerializer
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use Microsoft.Identity.Client.TokenCacheCallback instead. See https://aka.ms/msal-net-3x-cache-breaking-change", true)]
		public delegate void TokenCacheNotification(TokenCacheNotificationArgs args);

		internal const int ExpirationTooLongInDays = 3650;

		private readonly IFeatureFlags _featureFlags;

		private volatile bool _hasStateChanged;

		private readonly OptionalSemaphoreSlim _semaphoreSlim;

		private IDictionary<string, JToken> _unknownNodes;

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Please use the equivalent flag TokenCacheNotificationArgs.HasStateChanged, which indicates if the operation triggering the notification is modifying the cache or not. Setting the flag is not required.")]
		public bool HasStateChanged
		{
			get
			{
				return _hasStateChanged;
			}
			set
			{
				_hasStateChanged = value;
			}
		}

		internal ITokenCacheAccessor Accessor { get; set; }

		internal IServiceBundle ServiceBundle { get; }

		internal ILegacyCachePersistence LegacyCachePersistence { get; }

		internal string ClientId => ServiceBundle.Config.ClientId;

		ITokenCacheAccessor ITokenCacheInternal.Accessor => Accessor;

		ILegacyCachePersistence ITokenCacheInternal.LegacyPersistence => LegacyCachePersistence;

		internal bool IsAppTokenCache { get; }

		bool ITokenCacheInternal.IsApplicationCache => IsAppTokenCache;

		OptionalSemaphoreSlim ITokenCacheInternal.Semaphore => _semaphoreSlim;

		internal TokenCacheCallback BeforeAccess { get; set; }

		internal TokenCacheCallback BeforeWrite { get; set; }

		internal TokenCacheCallback AfterAccess { get; set; }

		internal Func<TokenCacheNotificationArgs, Task> AsyncBeforeAccess { get; set; }

		internal Func<TokenCacheNotificationArgs, Task> AsyncAfterAccess { get; set; }

		internal Func<TokenCacheNotificationArgs, Task> AsyncBeforeWrite { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", false)]
		public CacheData SerializeUnifiedAndAdalCache()
		{
			Validate();
			ServiceBundle.ApplicationLogger.Info(() => "[ADAL Caching] Legacy SerializeUnifiedAndAdalCache being called. " + _semaphoreSlim.GetCurrentCountLogMessage() + ".");
			_semaphoreSlim.Wait();
			ServiceBundle.ApplicationLogger.Info("[ADAL Caching] Acquired semaphore");
			try
			{
				byte[] unifiedState = Serialize();
				byte[] adalV3State = LegacyCachePersistence.LoadCache();
				return new CacheData
				{
					AdalV3State = adalV3State,
					UnifiedState = unifiedState
				};
			}
			finally
			{
				_semaphoreSlim.Release();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", false)]
		public void DeserializeUnifiedAndAdalCache(CacheData cacheData)
		{
			Validate();
			ServiceBundle.ApplicationLogger.Info("[ADAL Caching] Legacy SerializeUnifiedAndAdalCache being called. Acquiring semaphore " + _semaphoreSlim.GetCurrentCountLogMessage());
			_semaphoreSlim.Wait();
			ServiceBundle.ApplicationLogger.Info("[ADAL Caching] Acquired semaphore");
			try
			{
				Deserialize(cacheData.UnifiedState);
				LegacyCachePersistence.WriteCache(cacheData.AdalV3State);
			}
			finally
			{
				_semaphoreSlim.Release();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", false)]
		public byte[] Serialize()
		{
			throw new NotImplementedException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", false)]
		public void Deserialize(byte[] msalV2State)
		{
			throw new NotImplementedException();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		public byte[] SerializeAdalV3()
		{
			throw new NotImplementedException("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change");
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		public void DeserializeAdalV3(byte[] adalV3State)
		{
			throw new NotImplementedException("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change");
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		public byte[] SerializeMsalV2()
		{
			throw new NotImplementedException("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change");
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		public void DeserializeMsalV2(byte[] msalV2State)
		{
			throw new NotImplementedException("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change");
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		public byte[] SerializeMsalV3()
		{
			throw new NotImplementedException("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change");
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", false)]
		public void DeserializeMsalV3(byte[] msalV3State, bool shouldClearExistingCache)
		{
			throw new NotImplementedException("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change");
		}

		[Obsolete("The recommended way to get a cache is by using IClientApplicationBase.UserTokenCache or IClientApplicationBase.AppTokenCache")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public TokenCache()
			: this(null, isApplicationTokenCache: false)
		{
		}

		internal TokenCache(IServiceBundle serviceBundle, bool isApplicationTokenCache, ILegacyCachePersistence legacyCachePersistenceForTest = null)
		{
			if (serviceBundle == null)
			{
				throw new ArgumentNullException("serviceBundle");
			}
			_semaphoreSlim = new OptionalSemaphoreSlim(serviceBundle.Config.CacheSynchronizationEnabled);
			IPlatformProxy platformProxy = serviceBundle?.PlatformProxy ?? PlatformProxyFactory.CreatePlatformProxy(null);
			Accessor = platformProxy.CreateTokenCacheAccessor(serviceBundle.Config.AccessorOptions, isApplicationTokenCache);
			_featureFlags = platformProxy.GetFeatureFlags();
			LegacyCachePersistence = legacyCachePersistenceForTest ?? platformProxy.CreateLegacyCachePersistence();
			IsAppTokenCache = isApplicationTokenCache;
			ServiceBundle = serviceBundle;
		}

		public void SetIosKeychainSecurityGroup(string securityGroup)
		{
		}

		private void UpdateAppMetadata(string clientId, string environment, string familyId)
		{
			if (_featureFlags.IsFociEnabled)
			{
				MsalAppMetadataCacheItem item = new MsalAppMetadataCacheItem(clientId, environment, familyId);
				Accessor.SaveAppMetadata(item);
			}
		}

		private void DeleteAccessTokensWithIntersectingScopes(AuthenticationRequestParameters requestParams, IEnumerable<string> environmentAliases, string tenantId, HashSet<string> scopeSet, string homeAccountId, string tokenType)
		{
			if (requestParams.RequestContext.Logger.IsLoggingEnabled(LogLevel.Info))
			{
				requestParams.RequestContext.Logger.Info(() => "Looking for scopes for the authority in the cache which intersect with " + requestParams.Scope.AsSingleString());
			}
			List<MsalAccessTokenCacheItem> accessTokensToDelete = new List<MsalAccessTokenCacheItem>();
			string internalPartitionKeyFromResponse = CacheKeyFactory.GetInternalPartitionKeyFromResponse(requestParams, homeAccountId);
			foreach (MsalAccessTokenCacheItem allAccessToken in Accessor.GetAllAccessTokens(internalPartitionKeyFromResponse))
			{
				if (allAccessToken.ClientId.Equals(ClientId, StringComparison.OrdinalIgnoreCase) && environmentAliases.Contains(allAccessToken.Environment) && string.Equals(allAccessToken.TokenType ?? "", tokenType ?? "", StringComparison.OrdinalIgnoreCase) && string.Equals(allAccessToken.TenantId, tenantId, StringComparison.OrdinalIgnoreCase) && allAccessToken.ScopeSet.Overlaps(scopeSet))
				{
					requestParams.RequestContext.Logger.Verbose(() => $"Intersecting scopes found: {scopeSet}");
					accessTokensToDelete.Add(allAccessToken);
				}
			}
			requestParams.RequestContext.Logger.Info(() => "Intersecting scope entries count - " + accessTokensToDelete.Count);
			if (!requestParams.IsClientCredentialRequest && requestParams.ApiId != ApiEvent.ApiIds.AcquireTokenForSystemAssignedManagedIdentity && requestParams.ApiId != ApiEvent.ApiIds.AcquireTokenForUserAssignedManagedIdentity)
			{
				accessTokensToDelete.RemoveAll((MsalAccessTokenCacheItem item) => !item.HomeAccountId.Equals(homeAccountId, StringComparison.OrdinalIgnoreCase));
				requestParams.RequestContext.Logger.Info(() => "Matching entries after filtering by user - " + accessTokensToDelete.Count);
			}
			foreach (MsalAccessTokenCacheItem item in accessTokensToDelete)
			{
				Accessor.DeleteAccessToken(item);
			}
		}

		private static string GetAccessTokenExpireLogMessageContent(MsalAccessTokenCacheItem msalAccessTokenCacheItem)
		{
			return string.Format(CultureInfo.InvariantCulture, "[Current time ({0}) - Expiration Time ({1}) - Extended Expiration Time ({2})]", DateTime.UtcNow, msalAccessTokenCacheItem.ExpiresOn, msalAccessTokenCacheItem.ExtendedExpiresOn);
		}

		private bool RtMatchesAccount(MsalRefreshTokenCacheItem rtItem, MsalAccountCacheItem account)
		{
			bool num = rtItem.HomeAccountId.Equals(account.HomeAccountId, StringComparison.OrdinalIgnoreCase);
			bool flag = rtItem.IsFRT || rtItem.ClientId.Equals(ClientId, StringComparison.OrdinalIgnoreCase);
			return num && flag;
		}

		private static bool FrtExists(IEnumerable<MsalRefreshTokenCacheItem> refreshTokens)
		{
			return refreshTokens.Any((MsalRefreshTokenCacheItem rt) => rt.IsFRT);
		}

		async Task<Tuple<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> ITokenCacheInternal.SaveTokenResponseAsync(AuthenticationRequestParameters requestParams, MsalTokenResponse response)
		{
			ILoggerAdapter logger = requestParams.RequestContext.Logger;
			response.Log(logger, LogLevel.Verbose);
			MsalAccessTokenCacheItem msalAccessTokenCacheItem = null;
			MsalRefreshTokenCacheItem msalRefreshTokenCacheItem = null;
			MsalIdTokenCacheItem msalIdTokenCacheItem = null;
			MsalAccountCacheItem msalAccountCacheItem = null;
			IdToken idToken = IdToken.Parse(response.IdToken);
			if (idToken == null)
			{
				logger.Info("[SaveTokenResponseAsync] ID Token not present in response. ");
			}
			string tenantId = TokenResponseHelper.GetTenantId(idToken, requestParams);
			string username = TokenResponseHelper.GetUsernameFromIdToken(idToken);
			string homeAccountId = TokenResponseHelper.GetHomeAccountId(requestParams, response, idToken);
			string suggestedWebCacheKey = CacheKeyFactory.GetExternalCacheKeyFromResponse(requestParams, homeAccountId);
			if (requestParams.AppConfig.MultiCloudSupportEnabled && !string.IsNullOrEmpty(response.AuthorityUrl))
			{
				Uri uri = new Uri(response.AuthorityUrl);
				requestParams.AuthorityManager = new AuthorityManager(requestParams.RequestContext, Authority.CreateAuthorityWithEnvironment(requestParams.Authority.AuthorityInfo, uri.Host));
			}
			InstanceDiscoveryMetadataEntry instanceDiscoveryMetadata = await requestParams.AuthorityManager.GetInstanceDiscoveryEntryAsync().ConfigureAwait(continueOnCapturedContext: false);
			if (!string.IsNullOrEmpty(response.AccessToken))
			{
				msalAccessTokenCacheItem = new MsalAccessTokenCacheItem(instanceDiscoveryMetadata.PreferredCache, requestParams.AppConfig.ClientId, response, tenantId, homeAccountId, requestParams.AuthenticationScheme.KeyId, CacheKeyFactory.GetOboKey(requestParams.LongRunningOboCacheKey, requestParams.UserAssertion));
			}
			if (!string.IsNullOrEmpty(response.RefreshToken))
			{
				msalRefreshTokenCacheItem = new MsalRefreshTokenCacheItem(instanceDiscoveryMetadata.PreferredCache, requestParams.AppConfig.ClientId, response, homeAccountId)
				{
					OboCacheKey = CacheKeyFactory.GetOboKey(requestParams.LongRunningOboCacheKey, requestParams.UserAssertion)
				};
				if (!_featureFlags.IsFociEnabled)
				{
					msalRefreshTokenCacheItem.FamilyId = null;
				}
			}
			Account account = null;
			if (idToken != null)
			{
				msalIdTokenCacheItem = new MsalIdTokenCacheItem(instanceDiscoveryMetadata.PreferredCache, requestParams.AppConfig.ClientId, response, tenantId, homeAccountId);
				Dictionary<string, string> wamAccountIds = TokenResponseHelper.GetWamAccountIds(requestParams, response);
				msalAccountCacheItem = new MsalAccountCacheItem(instanceDiscoveryMetadata.PreferredCache, response.ClientInfo, homeAccountId, idToken, username, tenantId, wamAccountIds);
				IDictionary<string, TenantProfile> dictionary = null;
				if (msalIdTokenCacheItem.TenantId != null)
				{
					dictionary = await GetTenantProfilesAsync(requestParams, homeAccountId).ConfigureAwait(continueOnCapturedContext: false);
					if (dictionary != null)
					{
						TenantProfile value = new TenantProfile(msalIdTokenCacheItem);
						dictionary[msalIdTokenCacheItem.TenantId] = value;
					}
				}
				account = new Account(homeAccountId, username, instanceDiscoveryMetadata.PreferredNetwork, wamAccountIds, dictionary?.Values);
			}
			logger.Verbose(() => "[SaveTokenResponseAsync] Entering token cache semaphore. Count " + _semaphoreSlim.GetCurrentCountLogMessage() + ".");
			await _semaphoreSlim.WaitAsync(requestParams.RequestContext.UserCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			logger.Verbose(() => "[SaveTokenResponseAsync] Entered token cache semaphore. ");
			ITokenCacheInternal tokenCacheInternal = this;
			try
			{
				HasStateChanged = true;
				object obj = null;
				try
				{
					if (tokenCacheInternal.IsAppSubscribedToSerializationEvents())
					{
						TokenCacheNotificationArgs args = new TokenCacheNotificationArgs(this, ClientId, account, hasStateChanged: true, tokenCacheInternal.IsApplicationCache, suggestedWebCacheKey, tokenCacheInternal.HasTokensNoLocks(), null, requestParams.RequestContext.UserCancellationToken, requestParams.RequestContext.CorrelationId, requestParams.Scope, requestParams.AuthorityManager.OriginalAuthority.TenantId, requestParams.RequestContext.Logger.IdentityLogger, requestParams.RequestContext.Logger.PiiLoggingEnabled);
						MeasureDurationResult measureDurationResult = await StopwatchService.MeasureCodeBlockAsync(async delegate
						{
							await tokenCacheInternal.OnBeforeAccessAsync(args).ConfigureAwait(continueOnCapturedContext: false);
							await tokenCacheInternal.OnBeforeWriteAsync(args).ConfigureAwait(continueOnCapturedContext: false);
						}).ConfigureAwait(continueOnCapturedContext: false);
						requestParams.RequestContext.ApiEvent.DurationInCacheInMs += measureDurationResult.Milliseconds;
					}
					if (ShouldCacheAccessToken(msalAccessTokenCacheItem, response.TokenSource))
					{
						logger.Info("[SaveTokenResponseAsync] Saving AT in cache and removing overlapping ATs...");
						DeleteAccessTokensWithIntersectingScopes(requestParams, instanceDiscoveryMetadata.Aliases, tenantId, msalAccessTokenCacheItem.ScopeSet, msalAccessTokenCacheItem.HomeAccountId, msalAccessTokenCacheItem.TokenType);
						Accessor.SaveAccessToken(msalAccessTokenCacheItem);
					}
					if (idToken != null)
					{
						logger.Info("[SaveTokenResponseAsync] Saving Id Token and Account in cache ...");
						Accessor.SaveIdToken(msalIdTokenCacheItem);
						MergeWamAccountIds(msalAccountCacheItem);
						Accessor.SaveAccount(msalAccountCacheItem);
					}
					if (msalRefreshTokenCacheItem != null)
					{
						logger.Info("[SaveTokenResponseAsync] Saving RT in cache...");
						Accessor.SaveRefreshToken(msalRefreshTokenCacheItem);
					}
					UpdateAppMetadata(requestParams.AppConfig.ClientId, instanceDiscoveryMetadata.PreferredCache, response.FamilyId);
					SaveToLegacyAdalCache(requestParams, response, msalRefreshTokenCacheItem, msalIdTokenCacheItem, tenantId, instanceDiscoveryMetadata);
				}
				catch (object obj2)
				{
					obj = obj2;
				}
				if (tokenCacheInternal.IsAppSubscribedToSerializationEvents())
				{
					DateTimeOffset? suggestedCacheExpiry = CalculateSuggestedCacheExpiry(Accessor, logger);
					TokenCacheNotificationArgs args2 = new TokenCacheNotificationArgs(this, ClientId, account, hasStateChanged: true, tokenCacheInternal.IsApplicationCache, suggestedWebCacheKey, tokenCacheInternal.HasTokensNoLocks(), suggestedCacheExpiry, requestParams.RequestContext.UserCancellationToken, requestParams.RequestContext.CorrelationId, requestParams.Scope, requestParams.AuthorityManager.OriginalAuthority.TenantId, requestParams.RequestContext.Logger.IdentityLogger, requestParams.RequestContext.Logger.PiiLoggingEnabled);
					MeasureDurationResult measureDurationResult2 = await tokenCacheInternal.OnAfterAccessAsync(args2).MeasureAsync().ConfigureAwait(continueOnCapturedContext: false);
					requestParams.RequestContext.ApiEvent.DurationInCacheInMs += measureDurationResult2.Milliseconds;
					LogCacheContents(requestParams);
				}
				HasStateChanged = false;
				object obj3 = obj;
				if (obj3 != null)
				{
					ExceptionDispatchInfo.Capture((obj3 as Exception) ?? throw obj3).Throw();
				}
				return Tuple.Create(msalAccessTokenCacheItem, msalIdTokenCacheItem, account);
			}
			finally
			{
				_semaphoreSlim.Release();
				logger.Verbose(() => "[SaveTokenResponseAsync] Released token cache semaphore. ");
			}
		}

		private static bool ShouldCacheAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem, TokenSource tokenSource)
		{
			if (msalAccessTokenCacheItem != null)
			{
				return tokenSource != TokenSource.Broker;
			}
			return false;
		}

		private void LogCacheContents(AuthenticationRequestParameters requestParameters)
		{
			if (!requestParameters.RequestContext.Logger.IsLoggingEnabled(LogLevel.Verbose))
			{
				return;
			}
			List<MsalAccessTokenCacheItem> allAccessTokens = Accessor.GetAllAccessTokens();
			List<MsalRefreshTokenCacheItem> allRefreshTokens = Accessor.GetAllRefreshTokens();
			List<MsalAccessTokenCacheItem> list = allAccessTokens.Take(10).ToList();
			List<MsalRefreshTokenCacheItem> list2 = allRefreshTokens.Take(10).ToList();
			StringBuilder tokenCacheKeyLog = new StringBuilder();
			tokenCacheKeyLog.AppendLine($"Total number of access tokens in the cache: {allAccessTokens.Count}");
			tokenCacheKeyLog.AppendLine($"Total number of refresh tokens in the cache: {allRefreshTokens.Count}");
			tokenCacheKeyLog.AppendLine($"First {list.Count} access token cache keys:");
			foreach (MsalAccessTokenCacheItem item in list)
			{
				tokenCacheKeyLog.AppendLine("AT Cache Key: " + item.ToLogString(requestParameters.RequestContext.Logger.PiiLoggingEnabled));
			}
			tokenCacheKeyLog.AppendLine($"First {list2.Count} refresh token cache keys:");
			foreach (MsalRefreshTokenCacheItem item2 in list2)
			{
				tokenCacheKeyLog.AppendLine("RT Cache Key: " + item2.ToLogString(requestParameters.RequestContext.Logger.PiiLoggingEnabled));
			}
			requestParameters.RequestContext.Logger.Verbose(() => tokenCacheKeyLog.ToString());
		}

		private bool IsLegacyAdalCacheEnabled(AuthenticationRequestParameters requestParams)
		{
			if (requestParams.IsClientCredentialRequest)
			{
				return false;
			}
			if (ServiceBundle.PlatformProxy.LegacyCacheRequiresSerialization && !((ITokenCacheInternal)this).IsAppSubscribedToSerializationEvents())
			{
				return false;
			}
			if (!ServiceBundle.Config.LegacyCacheCompatibilityEnabled)
			{
				return false;
			}
			if (requestParams.AuthorityInfo.AuthorityType != AuthorityType.Aad)
			{
				return false;
			}
			requestParams.RequestContext.Logger.Info("IsLegacyAdalCacheEnabled: yes");
			return true;
		}

		private void SaveToLegacyAdalCache(AuthenticationRequestParameters requestParams, MsalTokenResponse response, MsalRefreshTokenCacheItem msalRefreshTokenCacheItem, MsalIdTokenCacheItem msalIdTokenCacheItem, string tenantId, InstanceDiscoveryMetadataEntry instanceDiscoveryMetadata)
		{
			if (msalRefreshTokenCacheItem != null && msalRefreshTokenCacheItem.RawClientInfo != null && msalIdTokenCacheItem != null && msalIdTokenCacheItem.IdToken?.GetUniqueId() != null && IsLegacyAdalCacheEnabled(requestParams))
			{
				Authority authority = Authority.CreateAuthorityWithEnvironment(Authority.CreateAuthorityWithTenant(requestParams.AuthorityInfo, tenantId).AuthorityInfo, instanceDiscoveryMetadata.PreferredCache);
				CacheFallbackOperations.WriteAdalRefreshToken(requestParams.RequestContext.Logger, LegacyCachePersistence, msalRefreshTokenCacheItem, msalIdTokenCacheItem, authority.AuthorityInfo.CanonicalAuthority.ToString(), msalIdTokenCacheItem.IdToken.GetUniqueId(), response.Scope);
			}
			else
			{
				requestParams.RequestContext.Logger.Verbose(() => "Not saving to ADAL legacy cache. ");
			}
		}

		internal static DateTimeOffset? CalculateSuggestedCacheExpiry(ITokenCacheAccessor accessor, ILoggerAdapter logger)
		{
			if (accessor.GetAllRefreshTokens().Count == 0)
			{
				List<MsalAccessTokenCacheItem> allAccessTokens = accessor.GetAllAccessTokens();
				if (allAccessTokens.Count == 0)
				{
					logger.Warning("[CalculateSuggestedCacheExpiry] No access tokens or refresh tokens found in the accessor. Not returning any expiration.");
					return null;
				}
				DateTimeOffset dateTimeOffset = allAccessTokens.Max((MsalAccessTokenCacheItem item) => item.ExpiresOn);
				if (dateTimeOffset < DateTimeOffset.UtcNow + Constants.AccessTokenExpirationBuffer)
				{
					return null;
				}
				return dateTimeOffset;
			}
			return null;
		}

		private void MergeWamAccountIds(MsalAccountCacheItem msalAccountCacheItem)
		{
			IDictionary<string, string> other = Accessor.GetAccount(msalAccountCacheItem)?.WamAccountIds;
			msalAccountCacheItem.WamAccountIds.MergeDifferentEntries(other);
		}

		async Task<MsalAccessTokenCacheItem> ITokenCacheInternal.FindAccessTokenAsync(AuthenticationRequestParameters requestParams)
		{
			ILoggerAdapter logger = requestParams.RequestContext.Logger;
			if (requestParams.AuthorityInfo?.CanonicalAuthority == null)
			{
				logger.Warning("[FindAccessTokenAsync] No authority provided. Skipping cache lookup. ");
				return null;
			}
			string keyFromRequest = CacheKeyFactory.GetKeyFromRequest(requestParams);
			List<MsalAccessTokenCacheItem> allAccessTokens = Accessor.GetAllAccessTokens(keyFromRequest, logger);
			requestParams.RequestContext.Logger.Always($"[FindAccessTokenAsync] Discovered {allAccessTokens.Count} access tokens in cache using partition key: {keyFromRequest}");
			if (allAccessTokens.Count == 0)
			{
				logger.Verbose(() => "[FindAccessTokenAsync] No access tokens found in the cache. Skipping filtering. ");
				requestParams.RequestContext.ApiEvent.CacheInfo = CacheRefreshReason.NoCachedAccessToken;
				return null;
			}
			FilterTokensByHomeAccountTenantOrAssertion(allAccessTokens, requestParams);
			FilterTokensByTokenType(allAccessTokens, requestParams);
			FilterTokensByScopes(allAccessTokens, requestParams);
			allAccessTokens = await FilterTokensByEnvironmentAsync(allAccessTokens, requestParams).ConfigureAwait(continueOnCapturedContext: false);
			FilterTokensByClientId(allAccessTokens);
			CacheRefreshReason cacheInfo = CacheRefreshReason.NotApplicable;
			if (allAccessTokens.Count == 0)
			{
				logger.Verbose(() => "[FindAccessTokenAsync] No tokens found for matching authority, client_id, user and scopes. ");
				return null;
			}
			MsalAccessTokenCacheItem singleToken = GetSingleToken(allAccessTokens, requestParams);
			singleToken = FilterTokensByPopKeyId(singleToken, requestParams);
			singleToken = FilterTokensByExpiry(singleToken, requestParams);
			if (singleToken == null)
			{
				cacheInfo = CacheRefreshReason.Expired;
			}
			requestParams.RequestContext.ApiEvent.CacheInfo = cacheInfo;
			return singleToken;
		}

		private static void FilterTokensByScopes(List<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams)
		{
			ILoggerAdapter logger = requestParams.RequestContext.Logger;
			if (tokenCacheItems.Count == 0)
			{
				logger.Verbose(() => "Not filtering by scopes, because there are no candidates");
				return;
			}
			IEnumerable<string> requestScopes = requestParams.Scope.Where((string s) => !OAuth2Value.ReservedScopes.Contains(s));
			tokenCacheItems.FilterWithLogging(delegate(MsalAccessTokenCacheItem item)
			{
				bool accepted = ScopeHelper.ScopeContains(item.ScopeSet, requestScopes);
				if (logger.IsLoggingEnabled(LogLevel.Verbose))
				{
					logger.Verbose(() => "Access token with scopes " + string.Join(" ", item.ScopeSet) + " " + $"passes scope filter? {accepted} ");
				}
				return accepted;
			}, logger, "Filtering by scopes");
		}

		private static void FilterTokensByTokenType(List<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams)
		{
			tokenCacheItems.FilterWithLogging((MsalAccessTokenCacheItem item) => string.Equals(item.TokenType ?? "bearer", requestParams.AuthenticationScheme.AccessTokenType, StringComparison.OrdinalIgnoreCase), requestParams.RequestContext.Logger, "Filtering by token type");
		}

		private static void FilterTokensByHomeAccountTenantOrAssertion(List<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams)
		{
			string requestTenantId = requestParams.Authority.TenantId;
			bool flag = true;
			if (ApiEvent.IsOnBehalfOfRequest(requestParams.ApiId))
			{
				tokenCacheItems.FilterWithLogging((MsalAccessTokenCacheItem item) => !string.IsNullOrEmpty(item.OboCacheKey) && item.OboCacheKey.Equals((!string.IsNullOrEmpty(requestParams.LongRunningOboCacheKey)) ? requestParams.LongRunningOboCacheKey : requestParams.UserAssertion.AssertionHash, StringComparison.OrdinalIgnoreCase), requestParams.RequestContext.Logger, (!string.IsNullOrEmpty(requestParams.LongRunningOboCacheKey)) ? ("Filtering AT by user-provided cache key: " + requestParams.LongRunningOboCacheKey) : ("Filtering AT by user assertion: " + requestParams.UserAssertion.AssertionHash));
				flag = !string.IsNullOrEmpty(requestTenantId) && !AadAuthority.IsCommonOrganizationsOrConsumersTenant(requestTenantId);
			}
			if (flag)
			{
				tokenCacheItems.FilterWithLogging((MsalAccessTokenCacheItem item) => string.Equals(item.TenantId ?? string.Empty, requestTenantId ?? string.Empty, StringComparison.OrdinalIgnoreCase), requestParams.RequestContext.Logger, "Filtering AT by tenant id");
			}
			else
			{
				requestParams.RequestContext.Logger.Warning("Have not filtered by tenant ID. This can happen in OBO scenario where authority is /common or /organizations. Please use tenanted authority.");
			}
			if (requestParams.ApiId != ApiEvent.ApiIds.AcquireTokenForClient && requestParams.ApiId != ApiEvent.ApiIds.AcquireTokenForSystemAssignedManagedIdentity && requestParams.ApiId != ApiEvent.ApiIds.AcquireTokenForUserAssignedManagedIdentity && !ApiEvent.IsOnBehalfOfRequest(requestParams.ApiId))
			{
				tokenCacheItems.FilterWithLogging((MsalAccessTokenCacheItem item) => item.HomeAccountId.Equals(requestParams.Account.HomeAccountId?.Identifier, StringComparison.OrdinalIgnoreCase), requestParams.RequestContext.Logger, "Filtering AT by home account id");
			}
		}

		private MsalAccessTokenCacheItem FilterTokensByExpiry(MsalAccessTokenCacheItem msalAccessTokenCacheItem, AuthenticationRequestParameters requestParams)
		{
			ILoggerAdapter logger = requestParams.RequestContext.Logger;
			if (msalAccessTokenCacheItem != null)
			{
				if (msalAccessTokenCacheItem.ExpiresOn > DateTime.UtcNow + Constants.AccessTokenExpirationBuffer)
				{
					if (msalAccessTokenCacheItem.ExpiresOn > DateTime.UtcNow + TimeSpan.FromDays(3650.0))
					{
						logger.Error("Access token expiration too large. This can be the result of a bug or corrupt cache. Token will be ignored as it is likely expired." + GetAccessTokenExpireLogMessageContent(msalAccessTokenCacheItem));
						return null;
					}
					logger.Info(() => "Access token is not expired. Returning the found cache entry. " + GetAccessTokenExpireLogMessageContent(msalAccessTokenCacheItem));
					return msalAccessTokenCacheItem;
				}
				if (ServiceBundle.Config.IsExtendedTokenLifetimeEnabled && msalAccessTokenCacheItem.ExtendedExpiresOn > DateTime.UtcNow + Constants.AccessTokenExpirationBuffer)
				{
					logger.Info(() => "Access token is expired.  IsExtendedLifeTimeEnabled=TRUE and ExtendedExpiresOn is not exceeded.  Returning the found cache entry. " + GetAccessTokenExpireLogMessageContent(msalAccessTokenCacheItem));
					msalAccessTokenCacheItem.IsExtendedLifeTimeToken = true;
					return msalAccessTokenCacheItem;
				}
				logger.Info(() => "Access token has expired or about to expire. " + GetAccessTokenExpireLogMessageContent(msalAccessTokenCacheItem));
			}
			return null;
		}

		private static MsalAccessTokenCacheItem GetSingleToken(List<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams)
		{
			if (tokenCacheItems.Count == 1)
			{
				return tokenCacheItems[0];
			}
			requestParams.RequestContext.Logger.Error("Multiple access tokens found for matching authority, client_id, user and scopes. ");
			throw new MsalClientException("multiple_matching_tokens_detected", "The cache contains multiple tokens satisfying the requirements. Try to clear token cache. ");
		}

		private async Task<List<MsalAccessTokenCacheItem>> FilterTokensByEnvironmentAsync(List<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams)
		{
			ILoggerAdapter logger = requestParams.RequestContext.Logger;
			if (tokenCacheItems.Count == 0)
			{
				logger.Verbose(() => "Not filtering AT by environment, because there are no candidates");
				return tokenCacheItems;
			}
			InstanceDiscoveryMetadataEntry instanceMetadata = await ServiceBundle.InstanceDiscoveryManager.GetMetadataEntryTryAvoidNetworkAsync(requestParams.AuthorityInfo, tokenCacheItems.Select((MsalAccessTokenCacheItem at) => at.Environment), requestParams.RequestContext).ConfigureAwait(continueOnCapturedContext: false);
			List<MsalAccessTokenCacheItem> itemsFilteredByAlias = tokenCacheItems.FilterWithLogging((MsalAccessTokenCacheItem item) => item.Environment.Equals(instanceMetadata.PreferredCache, StringComparison.OrdinalIgnoreCase), requestParams.RequestContext.Logger, "Filtering AT by preferred environment " + instanceMetadata.PreferredCache, updateOriginalCollection: false);
			if (itemsFilteredByAlias.Count > 0)
			{
				if (logger.IsLoggingEnabled(LogLevel.Verbose))
				{
					logger.Verbose(() => $"Filtered AT by preferred alias returning {itemsFilteredByAlias.Count} tokens.");
				}
				return itemsFilteredByAlias;
			}
			return tokenCacheItems.FilterWithLogging((MsalAccessTokenCacheItem item) => instanceMetadata.Aliases.ContainsOrdinalIgnoreCase(item.Environment), requestParams.RequestContext.Logger, "Filtering AT by environment");
		}

		private static MsalAccessTokenCacheItem FilterTokensByPopKeyId(MsalAccessTokenCacheItem item, AuthenticationRequestParameters authenticationRequest)
		{
			if (item == null)
			{
				return null;
			}
			string requestKid = authenticationRequest.AuthenticationScheme.KeyId;
			if (string.IsNullOrEmpty(item.KeyId) && string.IsNullOrEmpty(requestKid))
			{
				authenticationRequest.RequestContext.Logger.Verbose(() => "Bearer token found");
				return item;
			}
			if (string.Equals(item.KeyId, requestKid, StringComparison.OrdinalIgnoreCase))
			{
				authenticationRequest.RequestContext.Logger.Verbose(() => "Keyed token found");
				return item;
			}
			authenticationRequest.RequestContext.Logger.Info(() => "A token bound to the wrong key was found. Token key id: " + item.KeyId + " Request key id: " + requestKid);
			return null;
		}

		private void FilterTokensByClientId<T>(List<T> tokenCacheItems) where T : MsalCredentialCacheItemBase
		{
			tokenCacheItems.RemoveAll((T x) => !x.ClientId.Equals(ClientId, StringComparison.OrdinalIgnoreCase));
		}

		internal async Task ExpireAllAccessTokensForTestAsync()
		{
			ITokenCacheInternal tokenCacheInternal = this;
			ITokenCacheAccessor accessor = tokenCacheInternal.Accessor;
			foreach (MsalAccessTokenCacheItem allAccessToken in accessor.GetAllAccessTokens())
			{
				accessor.SaveAccessToken(allAccessToken.WithExpiresOn(DateTimeOffset.UtcNow));
			}
			if (tokenCacheInternal.IsAppSubscribedToSerializationEvents())
			{
				TokenCacheNotificationArgs args = new TokenCacheNotificationArgs(this, ClientId, null, hasStateChanged: true, tokenCacheInternal.IsApplicationCache, null, tokenCacheInternal.HasTokensNoLocks(), null, default(CancellationToken), default(Guid), null, null, null, piiLoggingEnabled: false);
				await tokenCacheInternal.OnAfterAccessAsync(args).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		async Task<MsalRefreshTokenCacheItem> ITokenCacheInternal.FindRefreshTokenAsync(AuthenticationRequestParameters requestParams, string familyId)
		{
			if (requestParams.Authority == null)
			{
				return null;
			}
			string keyFromRequest = CacheKeyFactory.GetKeyFromRequest(requestParams);
			List<MsalRefreshTokenCacheItem> refreshTokens = Accessor.GetAllRefreshTokens(keyFromRequest);
			requestParams.RequestContext.Logger.Always($"[FindRefreshTokenAsync] Discovered {refreshTokens.Count} refresh tokens in cache using key: {keyFromRequest}");
			if (refreshTokens.Count != 0)
			{
				FilterRefreshTokensByHomeAccountIdOrAssertion(refreshTokens, requestParams, familyId);
				if (!requestParams.AppConfig.MultiCloudSupportEnabled)
				{
					string[] aliases = (await ServiceBundle.InstanceDiscoveryManager.GetMetadataEntryTryAvoidNetworkAsync(requestParams.AuthorityInfo, refreshTokens.Select((MsalRefreshTokenCacheItem rt) => rt.Environment), requestParams.RequestContext).ConfigureAwait(continueOnCapturedContext: false)).Aliases;
					refreshTokens.RemoveAll((MsalRefreshTokenCacheItem item) => !aliases.ContainsOrdinalIgnoreCase(item.Environment));
				}
				requestParams.RequestContext.Logger.Info(() => "[FindRefreshTokenAsync] Refresh token found in the cache? - " + (refreshTokens.Count != 0));
				if (refreshTokens.Count > 0)
				{
					return refreshTokens.FirstOrDefault();
				}
			}
			else
			{
				requestParams.RequestContext.Logger.Verbose(() => "[FindRefreshTokenAsync] No RTs found in the MSAL cache ");
			}
			requestParams.RequestContext.Logger.Verbose(() => "[FindRefreshTokenAsync] Checking ADAL cache for matching RT. ");
			if (IsLegacyAdalCacheEnabled(requestParams) && requestParams.Account != null && string.IsNullOrEmpty(familyId))
			{
				string[] aliases2 = (await ServiceBundle.InstanceDiscoveryManager.GetMetadataEntryTryAvoidNetworkAsync(requestParams.AuthorityInfo, refreshTokens.Select((MsalRefreshTokenCacheItem rt) => rt.Environment), requestParams.RequestContext).ConfigureAwait(continueOnCapturedContext: false)).Aliases;
				return CacheFallbackOperations.GetRefreshToken(requestParams.RequestContext.Logger, LegacyCachePersistence, aliases2, requestParams.AppConfig.ClientId, requestParams.Account);
			}
			return null;
		}

		private static void FilterRefreshTokensByHomeAccountIdOrAssertion(List<MsalRefreshTokenCacheItem> cacheItems, AuthenticationRequestParameters requestParams, string familyId)
		{
			if (ApiEvent.IsOnBehalfOfRequest(requestParams.ApiId))
			{
				cacheItems.FilterWithLogging((MsalRefreshTokenCacheItem item) => !string.IsNullOrEmpty(item.OboCacheKey) && item.OboCacheKey.Equals((!string.IsNullOrEmpty(requestParams.LongRunningOboCacheKey)) ? requestParams.LongRunningOboCacheKey : requestParams.UserAssertion.AssertionHash, StringComparison.OrdinalIgnoreCase), requestParams.RequestContext.Logger, (!string.IsNullOrEmpty(requestParams.LongRunningOboCacheKey)) ? ("Filtering RT by user-provided cache key: " + requestParams.LongRunningOboCacheKey) : ("Filtering RT by user assertion: " + requestParams.UserAssertion.AssertionHash));
			}
			else
			{
				cacheItems.FilterWithLogging((MsalRefreshTokenCacheItem item) => item.HomeAccountId.Equals(requestParams.Account.HomeAccountId?.Identifier, StringComparison.OrdinalIgnoreCase), requestParams.RequestContext.Logger, "Filtering RT by home account id");
			}
			cacheItems.FilterWithLogging((MsalRefreshTokenCacheItem item) => string.Equals(item.FamilyId ?? string.Empty, familyId ?? string.Empty, StringComparison.OrdinalIgnoreCase), requestParams.RequestContext.Logger, "Filtering RT by family id");
			if (string.IsNullOrEmpty(familyId))
			{
				cacheItems.FilterWithLogging((MsalRefreshTokenCacheItem item) => item.ClientId.Equals(requestParams.AppConfig.ClientId, StringComparison.OrdinalIgnoreCase), requestParams.RequestContext.Logger, "Filtering RT by client id");
			}
		}

		async Task<bool?> ITokenCacheInternal.IsFociMemberAsync(AuthenticationRequestParameters requestParams, string familyId)
		{
			ILoggerAdapter logger = requestParams.RequestContext.Logger;
			if (requestParams?.AuthorityInfo?.CanonicalAuthority == null)
			{
				logger.Warning("No authority details, can't check app metadata. Returning unknown. ");
				return null;
			}
			List<MsalAppMetadataCacheItem> allAppMetadata = Accessor.GetAllAppMetadata();
			MsalAppMetadataCacheItem msalAppMetadataCacheItem = (await ServiceBundle.InstanceDiscoveryManager.GetMetadataEntryTryAvoidNetworkAsync(requestParams.AuthorityInfo, allAppMetadata.Select((MsalAppMetadataCacheItem m) => m.Environment), requestParams.RequestContext).ConfigureAwait(continueOnCapturedContext: false)).Aliases.Select((string env) => Accessor.GetAppMetadata(new MsalAppMetadataCacheItem(ClientId, env, null))).FirstOrDefault((MsalAppMetadataCacheItem item) => item != null);
			if (msalAppMetadataCacheItem == null)
			{
				logger.Warning("No app metadata found. Returning unknown. ");
				return null;
			}
			return msalAppMetadataCacheItem.FamilyId == familyId;
		}

		async Task<IEnumerable<IAccount>> ITokenCacheInternal.GetAccountsAsync(AuthenticationRequestParameters requestParameters)
		{
			ILoggerAdapter logger = requestParameters.RequestContext.Logger;
			string environment = requestParameters.AuthorityInfo.Host;
			bool num = !_featureFlags.IsFociEnabled;
			string keyFromRequest = CacheKeyFactory.GetKeyFromRequest(requestParameters);
			List<MsalRefreshTokenCacheItem> refreshTokenCacheItems = Accessor.GetAllRefreshTokens(keyFromRequest);
			List<MsalAccountCacheItem> accountCacheItems = Accessor.GetAllAccounts(keyFromRequest);
			if (num)
			{
				FilterTokensByClientId(refreshTokenCacheItems);
			}
			if (logger.IsLoggingEnabled(LogLevel.Verbose))
			{
				logger.Verbose(() => $"[GetAccounts] Found {refreshTokenCacheItems.Count} RTs and {accountCacheItems.Count} accounts in MSAL cache. ");
			}
			ISet<string> set = new HashSet<string>(accountCacheItems.Select((MsalAccountCacheItem aci) => aci.Environment), StringComparer.OrdinalIgnoreCase);
			set.UnionWith(refreshTokenCacheItems.Select((MsalRefreshTokenCacheItem rt) => rt.Environment));
			AdalUsersForMsal adalUsersResult = null;
			if (IsLegacyAdalCacheEnabled(requestParameters))
			{
				adalUsersResult = CacheFallbackOperations.GetAllAdalUsersForMsal(logger, LegacyCachePersistence, ClientId);
				set.UnionWith(adalUsersResult.GetAdalUserEnvironments());
			}
			InstanceDiscoveryMetadataEntry instanceMetadata = await ServiceBundle.InstanceDiscoveryManager.GetMetadataEntryTryAvoidNetworkAsync(requestParameters.AuthorityInfo, set, requestParameters.RequestContext).ConfigureAwait(continueOnCapturedContext: false);
			if (!requestParameters.AppConfig.MultiCloudSupportEnabled)
			{
				refreshTokenCacheItems.RemoveAll((MsalRefreshTokenCacheItem rt) => !instanceMetadata.Aliases.ContainsOrdinalIgnoreCase(rt.Environment));
				accountCacheItems.RemoveAll((MsalAccountCacheItem acc) => !instanceMetadata.Aliases.ContainsOrdinalIgnoreCase(acc.Environment));
			}
			if (logger.IsLoggingEnabled(LogLevel.Verbose))
			{
				logger.Verbose(() => $"[GetAccounts] Found {refreshTokenCacheItems.Count} RTs and {accountCacheItems.Count} accounts in MSAL cache after environment filtering. ");
			}
			IDictionary<string, Account> clientInfoToAccountMap = new Dictionary<string, Account>();
			foreach (MsalRefreshTokenCacheItem rtItem in refreshTokenCacheItems)
			{
				foreach (MsalAccountCacheItem account in accountCacheItems)
				{
					if (RtMatchesAccount(rtItem, account))
					{
						IDictionary<string, TenantProfile> dictionary = await GetTenantProfilesAsync(requestParameters, account.HomeAccountId).ConfigureAwait(continueOnCapturedContext: false);
						clientInfoToAccountMap[rtItem.HomeAccountId] = new Account(account.HomeAccountId, account.PreferredUsername, requestParameters.AppConfig.MultiCloudSupportEnabled ? account.Environment : environment, account.WamAccountIds, dictionary?.Values);
						break;
					}
				}
			}
			if (IsLegacyAdalCacheEnabled(requestParameters))
			{
				UpdateMapWithAdalAccountsWithClientInfo(environment, instanceMetadata.Aliases, adalUsersResult, clientInfoToAccountMap);
			}
			if (requestParameters.AppConfig.IsBrokerEnabled && ServiceBundle.PlatformProxy.BrokerSupportsWamAccounts)
			{
				foreach (MsalAccountCacheItem account in accountCacheItems)
				{
					if (!clientInfoToAccountMap.ContainsKey(account.HomeAccountId) && account.WamAccountIds != null && account.WamAccountIds.ContainsKey(requestParameters.AppConfig.ClientId))
					{
						IDictionary<string, TenantProfile> dictionary2 = await GetTenantProfilesAsync(requestParameters, account.HomeAccountId).ConfigureAwait(continueOnCapturedContext: false);
						Account value = new Account(account.HomeAccountId, account.PreferredUsername, account.Environment, account.WamAccountIds, dictionary2?.Values);
						clientInfoToAccountMap[account.HomeAccountId] = value;
					}
				}
			}
			List<IAccount> accounts = new List<IAccount>(clientInfoToAccountMap.Values);
			if (IsLegacyAdalCacheEnabled(requestParameters))
			{
				UpdateWithAdalAccountsWithoutClientInfo(environment, instanceMetadata.Aliases, adalUsersResult, accounts);
			}
			if (!string.IsNullOrEmpty(requestParameters.HomeAccountId))
			{
				accounts = accounts.Where((IAccount acc) => acc.HomeAccountId.Identifier.Equals(requestParameters.HomeAccountId, StringComparison.OrdinalIgnoreCase)).ToList();
				if (logger.IsLoggingEnabled(LogLevel.Verbose))
				{
					logger.Verbose(() => $"Filtered by home account id. Remaining accounts {accounts.Count} ");
				}
			}
			return accounts;
		}

		private static void UpdateMapWithAdalAccountsWithClientInfo(string envFromRequest, IEnumerable<string> envAliases, AdalUsersForMsal adalUsers, IDictionary<string, Account> clientInfoToAccountMap)
		{
			foreach (KeyValuePair<string, AdalUserInfo> item in adalUsers?.GetUsersWithClientInfo(envAliases))
			{
				string text = ClientInfo.CreateFromJson(item.Key).ToAccountIdentifier();
				if (!clientInfoToAccountMap.ContainsKey(text))
				{
					clientInfoToAccountMap[text] = new Account(text, item.Value.DisplayableId, envFromRequest);
				}
			}
		}

		private static void UpdateWithAdalAccountsWithoutClientInfo(string envFromRequest, IEnumerable<string> envAliases, AdalUsersForMsal adalUsers, List<IAccount> accounts)
		{
			List<string> list = accounts.Select((IAccount a) => a.Username).Distinct().ToList();
			foreach (AdalUserInfo item in adalUsers?.GetUsersWithoutClientInfo(envAliases))
			{
				if (!string.IsNullOrEmpty(item.DisplayableId) && !list.Contains(item.DisplayableId))
				{
					accounts.Add(new Account(null, item.DisplayableId, envFromRequest));
					list.Add(item.DisplayableId);
				}
			}
		}

		MsalIdTokenCacheItem ITokenCacheInternal.GetIdTokenCacheItem(MsalAccessTokenCacheItem msalAccessTokenCacheItem)
		{
			return Accessor.GetIdToken(msalAccessTokenCacheItem);
		}

		private async Task<IDictionary<string, TenantProfile>> GetTenantProfilesAsync(AuthenticationRequestParameters requestParameters, string homeAccountId)
		{
			if (!requestParameters.AuthorityInfo.CanBeTenanted)
			{
				return null;
			}
			if (homeAccountId == null)
			{
				requestParameters.RequestContext.Logger.Warning("No homeAccountId, skipping tenant profiles");
				return null;
			}
			List<MsalIdTokenCacheItem> idTokenCacheItems = Accessor.GetAllIdTokens(homeAccountId);
			FilterTokensByClientId(idTokenCacheItems);
			if (!requestParameters.AppConfig.MultiCloudSupportEnabled)
			{
				ISet<string> existingEnvironmentsInCache = new HashSet<string>(idTokenCacheItems.Select((MsalIdTokenCacheItem aci) => aci.Environment), StringComparer.OrdinalIgnoreCase);
				InstanceDiscoveryMetadataEntry instanceMetadata = await ServiceBundle.InstanceDiscoveryManager.GetMetadataEntryTryAvoidNetworkAsync(requestParameters.AuthorityInfo, existingEnvironmentsInCache, requestParameters.RequestContext).ConfigureAwait(continueOnCapturedContext: false);
				idTokenCacheItems.RemoveAll((MsalIdTokenCacheItem idToken) => !instanceMetadata.Aliases.ContainsOrdinalIgnoreCase(idToken.Environment));
			}
			idTokenCacheItems.RemoveAll((MsalIdTokenCacheItem idToken) => !homeAccountId.Equals(idToken.HomeAccountId));
			Dictionary<string, TenantProfile> dictionary = new Dictionary<string, TenantProfile>();
			foreach (MsalIdTokenCacheItem item in idTokenCacheItems)
			{
				dictionary[item.TenantId] = new TenantProfile(item);
			}
			return dictionary;
		}

		async Task<Account> ITokenCacheInternal.GetAccountAssociatedWithAccessTokenAsync(AuthenticationRequestParameters requestParameters, MsalAccessTokenCacheItem msalAccessTokenCacheItem)
		{
			IDictionary<string, TenantProfile> dictionary = await GetTenantProfilesAsync(requestParameters, msalAccessTokenCacheItem.HomeAccountId).ConfigureAwait(continueOnCapturedContext: false);
			MsalAccountCacheItem account = Accessor.GetAccount(new MsalAccountCacheItem(msalAccessTokenCacheItem.Environment, msalAccessTokenCacheItem.TenantId, msalAccessTokenCacheItem.HomeAccountId, requestParameters.Account?.Username));
			return new Account(msalAccessTokenCacheItem.HomeAccountId, account?.PreferredUsername, account?.Environment, account?.WamAccountIds, dictionary?.Values);
		}

		async Task<bool> ITokenCacheInternal.StopLongRunningOboProcessAsync(string longRunningOboCacheKey, AuthenticationRequestParameters requestParameters)
		{
			requestParameters.RequestContext.Logger.Verbose(() => "[StopLongRunningOboProcessAsync] Entering token cache semaphore. Count " + _semaphoreSlim.GetCurrentCountLogMessage());
			await _semaphoreSlim.WaitAsync(requestParameters.RequestContext.UserCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			requestParameters.RequestContext.Logger.Verbose(() => "[StopLongRunningOboProcessAsync] Entered token cache semaphore");
			try
			{
				requestParameters.RequestContext.Logger.Info(() => "[StopLongRunningOboProcessAsync] Stopping long running OBO process by removing tokens from cache.");
				ITokenCacheInternal tokenCacheInternal = this;
				object obj = null;
				bool tokensRemoved = default(bool);
				try
				{
					if (tokenCacheInternal.IsAppSubscribedToSerializationEvents())
					{
						TokenCacheNotificationArgs args = new TokenCacheNotificationArgs(this, ClientId, null, hasStateChanged: false, tokenCacheInternal.IsApplicationCache, longRunningOboCacheKey, tokenCacheInternal.HasTokensNoLocks(), null, requestParameters.RequestContext.UserCancellationToken, requestParameters.RequestContext.CorrelationId, requestParameters.Scope, requestParameters.AuthorityManager.OriginalAuthority.TenantId, requestParameters.RequestContext.Logger.IdentityLogger, requestParameters.RequestContext.Logger.PiiLoggingEnabled);
						await tokenCacheInternal.OnBeforeAccessAsync(args).ConfigureAwait(continueOnCapturedContext: false);
						await tokenCacheInternal.OnBeforeWriteAsync(args).ConfigureAwait(continueOnCapturedContext: false);
					}
					tokensRemoved = RemoveOboTokensInternal(longRunningOboCacheKey, requestParameters.RequestContext);
				}
				catch (object obj2)
				{
					obj = obj2;
				}
				if (tokenCacheInternal.IsAppSubscribedToSerializationEvents())
				{
					TokenCacheNotificationArgs args2 = new TokenCacheNotificationArgs(this, ClientId, null, hasStateChanged: true, tokenCacheInternal.IsApplicationCache, longRunningOboCacheKey, tokenCacheInternal.HasTokensNoLocks(), null, requestParameters.RequestContext.UserCancellationToken, requestParameters.RequestContext.CorrelationId, requestParameters.Scope, requestParameters.AuthorityManager.OriginalAuthority.TenantId, requestParameters.RequestContext.Logger.IdentityLogger, requestParameters.RequestContext.Logger.PiiLoggingEnabled);
					await tokenCacheInternal.OnAfterAccessAsync(args2).ConfigureAwait(continueOnCapturedContext: false);
				}
				object obj3 = obj;
				if (obj3 != null)
				{
					ExceptionDispatchInfo.Capture((obj3 as Exception) ?? throw obj3).Throw();
				}
				return tokensRemoved;
			}
			finally
			{
				HasStateChanged = false;
				_semaphoreSlim.Release();
			}
		}

		async Task ITokenCacheInternal.RemoveAccountAsync(IAccount account, AuthenticationRequestParameters requestParameters)
		{
			requestParameters.RequestContext.Logger.Verbose(() => "[RemoveAccountAsync] Entering token cache semaphore. Count " + _semaphoreSlim.GetCurrentCountLogMessage());
			await _semaphoreSlim.WaitAsync(requestParameters.RequestContext.UserCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			requestParameters.RequestContext.Logger.Verbose(() => "[RemoveAccountAsync] Entered token cache semaphore");
			string cacheKey = account.HomeAccountId?.Identifier;
			try
			{
				requestParameters.RequestContext.Logger.Info("[RemoveAccountAsync] Removing account from cache.");
				ITokenCacheInternal tokenCacheInternal = this;
				object obj = null;
				try
				{
					if (tokenCacheInternal.IsAppSubscribedToSerializationEvents())
					{
						TokenCacheNotificationArgs args = new TokenCacheNotificationArgs(this, ClientId, account, hasStateChanged: true, tokenCacheInternal.IsApplicationCache, cacheKey, tokenCacheInternal.HasTokensNoLocks(), null, requestParameters.RequestContext.UserCancellationToken, requestParameters.RequestContext.CorrelationId, requestParameters.Scope, requestParameters.AuthorityManager.OriginalAuthority.TenantId, requestParameters.RequestContext.Logger.IdentityLogger, requestParameters.RequestContext.Logger.PiiLoggingEnabled);
						await tokenCacheInternal.OnBeforeAccessAsync(args).ConfigureAwait(continueOnCapturedContext: false);
						await tokenCacheInternal.OnBeforeWriteAsync(args).ConfigureAwait(continueOnCapturedContext: false);
					}
					RemoveAccountInternal(account, requestParameters.RequestContext);
					if (IsLegacyAdalCacheEnabled(requestParameters))
					{
						CacheFallbackOperations.RemoveAdalUser(requestParameters.RequestContext.Logger, LegacyCachePersistence, ClientId, account?.Username, cacheKey);
					}
				}
				catch (object obj2)
				{
					obj = obj2;
				}
				if (tokenCacheInternal.IsAppSubscribedToSerializationEvents())
				{
					TokenCacheNotificationArgs args2 = new TokenCacheNotificationArgs(this, ClientId, account, hasStateChanged: true, tokenCacheInternal.IsApplicationCache, cacheKey, tokenCacheInternal.HasTokensNoLocks(), null, requestParameters.RequestContext.UserCancellationToken, requestParameters.RequestContext.CorrelationId, requestParameters.Scope, requestParameters.AuthorityManager.OriginalAuthority.TenantId, requestParameters.RequestContext.Logger.IdentityLogger, requestParameters.RequestContext.Logger.PiiLoggingEnabled);
					await tokenCacheInternal.OnAfterAccessAsync(args2).ConfigureAwait(continueOnCapturedContext: false);
				}
				object obj3 = obj;
				if (obj3 != null)
				{
					ExceptionDispatchInfo.Capture((obj3 as Exception) ?? throw obj3).Throw();
				}
			}
			finally
			{
				HasStateChanged = false;
				_semaphoreSlim.Release();
			}
		}

		bool ITokenCacheInternal.HasTokensNoLocks()
		{
			return Accessor.HasAccessOrRefreshTokens();
		}

		private bool RemoveOboTokensInternal(string oboPartitionKey, RequestContext requestContext)
		{
			ILoggerAdapter logger = requestContext.Logger;
			List<MsalRefreshTokenCacheItem> allRefreshTokens = Accessor.GetAllRefreshTokens(oboPartitionKey, logger);
			allRefreshTokens.RemoveAll((MsalRefreshTokenCacheItem item) => !(item?.OboCacheKey.Equals(oboPartitionKey, StringComparison.OrdinalIgnoreCase)).Value);
			bool filterByClientId;
			int num = RemoveRefreshTokens(allRefreshTokens, logger, out filterByClientId);
			List<MsalAccessTokenCacheItem> allAccessTokens = Accessor.GetAllAccessTokens(oboPartitionKey, logger);
			allAccessTokens.RemoveAll((MsalAccessTokenCacheItem item) => !(item?.OboCacheKey.Equals(oboPartitionKey, StringComparison.OrdinalIgnoreCase)).Value);
			int num2 = RemoveAccessTokens(allAccessTokens, logger, filterByClientId);
			if (num <= 0)
			{
				return num2 > 0;
			}
			return true;
		}

		internal void RemoveAccountInternal(IAccount account, RequestContext requestContext)
		{
			if (account.HomeAccountId != null)
			{
				string partitionKey = account.HomeAccountId.Identifier;
				ILoggerAdapter logger = requestContext.Logger;
				List<MsalRefreshTokenCacheItem> allRefreshTokens = Accessor.GetAllRefreshTokens(partitionKey, logger);
				allRefreshTokens.RemoveAll((MsalRefreshTokenCacheItem item) => !item.HomeAccountId.Equals(partitionKey, StringComparison.OrdinalIgnoreCase));
				RemoveRefreshTokens(allRefreshTokens, logger, out var filterByClientId);
				List<MsalAccessTokenCacheItem> allAccessTokens = Accessor.GetAllAccessTokens(partitionKey, logger);
				allAccessTokens.RemoveAll((MsalAccessTokenCacheItem item) => !item.HomeAccountId.Equals(partitionKey, StringComparison.OrdinalIgnoreCase));
				RemoveAccessTokens(allAccessTokens, logger, filterByClientId);
				RemoveIdTokens(partitionKey, logger, filterByClientId);
				RemoveAccounts(account);
			}
		}

		private int RemoveRefreshTokens(List<MsalRefreshTokenCacheItem> refreshTokens, ILoggerAdapter logger, out bool filterByClientId)
		{
			filterByClientId = !_featureFlags.IsFociEnabled || !FrtExists(refreshTokens);
			if (filterByClientId)
			{
				FilterTokensByClientId(refreshTokens);
			}
			foreach (MsalRefreshTokenCacheItem refreshToken in refreshTokens)
			{
				Accessor.DeleteRefreshToken(refreshToken);
			}
			logger.Info(() => $"[RemoveRefreshTokens] Deleted {refreshTokens.Count} refresh tokens.");
			return refreshTokens.Count;
		}

		private int RemoveAccessTokens(List<MsalAccessTokenCacheItem> accessTokens, ILoggerAdapter logger, bool filterByClientId)
		{
			if (filterByClientId)
			{
				FilterTokensByClientId(accessTokens);
			}
			foreach (MsalAccessTokenCacheItem accessToken in accessTokens)
			{
				Accessor.DeleteAccessToken(accessToken);
			}
			logger.Info(() => $"[RemoveAccessTokens] Deleted {accessTokens.Count} access tokens.");
			return accessTokens.Count;
		}

		private int RemoveIdTokens(string partitionKey, ILoggerAdapter logger, bool filterByClientId)
		{
			List<MsalIdTokenCacheItem> idTokens = Accessor.GetAllIdTokens(partitionKey);
			idTokens.RemoveAll((MsalIdTokenCacheItem item) => !item.HomeAccountId.Equals(partitionKey, StringComparison.OrdinalIgnoreCase));
			if (filterByClientId)
			{
				FilterTokensByClientId(idTokens);
			}
			foreach (MsalIdTokenCacheItem item in idTokens)
			{
				Accessor.DeleteIdToken(item);
			}
			logger.Info(() => $"[RemoveIdTokens] Deleted {idTokens.Count} ID tokens.");
			return idTokens.Count;
		}

		private void RemoveAccounts(IAccount account)
		{
			if (account == null)
			{
				return;
			}
			List<MsalAccountCacheItem> allAccounts = Accessor.GetAllAccounts(account.HomeAccountId.Identifier);
			allAccounts.RemoveAll((MsalAccountCacheItem item) => !item.HomeAccountId.Equals(account.HomeAccountId.Identifier, StringComparison.OrdinalIgnoreCase) || !item.PreferredUsername.Equals(account.Username, StringComparison.OrdinalIgnoreCase));
			foreach (MsalAccountCacheItem item in allAccounts)
			{
				Accessor.DeleteAccount(item);
			}
		}

		bool ITokenCacheInternal.IsAppSubscribedToSerializationEvents()
		{
			if (BeforeAccess == null && AfterAccess == null && BeforeWrite == null && AsyncBeforeAccess == null && AsyncAfterAccess == null)
			{
				return AsyncBeforeWrite != null;
			}
			return true;
		}

		async Task ITokenCacheInternal.OnAfterAccessAsync(TokenCacheNotificationArgs args)
		{
			AfterAccess?.Invoke(args);
			if (AsyncAfterAccess != null)
			{
				await AsyncAfterAccess(args).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		async Task ITokenCacheInternal.OnBeforeAccessAsync(TokenCacheNotificationArgs args)
		{
			BeforeAccess?.Invoke(args);
			if (AsyncBeforeAccess != null)
			{
				await AsyncBeforeAccess(args).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		async Task ITokenCacheInternal.OnBeforeWriteAsync(TokenCacheNotificationArgs args)
		{
			HasStateChanged = true;
			args.HasStateChanged = true;
			BeforeWrite?.Invoke(args);
			if (AsyncBeforeWrite != null)
			{
				await AsyncBeforeWrite(args).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		public void SetBeforeAccess(TokenCacheCallback beforeAccess)
		{
			Validate();
			BeforeAccess = beforeAccess;
		}

		public void SetAfterAccess(TokenCacheCallback afterAccess)
		{
			Validate();
			AfterAccess = afterAccess;
		}

		public void SetBeforeWrite(TokenCacheCallback beforeWrite)
		{
			Validate();
			BeforeWrite = beforeWrite;
		}

		public void SetBeforeAccessAsync(Func<TokenCacheNotificationArgs, Task> beforeAccess)
		{
			Validate();
			AsyncBeforeAccess = beforeAccess;
		}

		public void SetAfterAccessAsync(Func<TokenCacheNotificationArgs, Task> afterAccess)
		{
			Validate();
			AsyncAfterAccess = afterAccess;
		}

		public void SetBeforeWriteAsync(Func<TokenCacheNotificationArgs, Task> beforeWrite)
		{
			Validate();
			AsyncBeforeWrite = beforeWrite;
		}

		private void Validate()
		{
			if (ServiceBundle.Config.AccessorOptions != null)
			{
				throw new MsalClientException("static_cache_with_external_serialization", "You configured MSAL cache serialization at the same time with internal caching options. These are mutually exclusive. Use only one option. Web site and web api scenarios should rely on external cache serialization, as internal cache serialization cannot scale. See https://aka.ms/msal-net-token-cache-serialization .");
			}
		}

		byte[] ITokenCacheSerializer.SerializeAdalV3()
		{
			return LegacyCachePersistence.LoadCache();
		}

		void ITokenCacheSerializer.DeserializeAdalV3(byte[] adalV3State)
		{
			LegacyCachePersistence.WriteCache(adalV3State);
		}

		byte[] ITokenCacheSerializer.SerializeMsalV2()
		{
			return new TokenCacheDictionarySerializer(Accessor).Serialize(_unknownNodes);
		}

		void ITokenCacheSerializer.DeserializeMsalV2(byte[] msalV2State)
		{
			_unknownNodes = new TokenCacheDictionarySerializer(Accessor).Deserialize(msalV2State, clearExistingCacheData: false);
		}

		byte[] ITokenCacheSerializer.SerializeMsalV3()
		{
			return new TokenCacheJsonSerializer(Accessor).Serialize(_unknownNodes);
		}

		void ITokenCacheSerializer.DeserializeMsalV3(byte[] msalV3State, bool shouldClearExistingCache)
		{
			if (msalV3State == null || msalV3State.Length == 0)
			{
				if (shouldClearExistingCache)
				{
					Accessor.Clear();
				}
			}
			else
			{
				_unknownNodes = new TokenCacheJsonSerializer(Accessor).Deserialize(msalV3State, shouldClearExistingCache);
			}
		}
	}
	public class MsalClaimsChallengeException : MsalUiRequiredException
	{
		public MsalClaimsChallengeException(string errorCode, string errorMessage)
			: base(errorCode, errorMessage)
		{
		}

		public MsalClaimsChallengeException(string errorCode, string errorMessage, Exception innerException)
			: this(errorCode, errorMessage, innerException, UiRequiredExceptionClassification.None)
		{
		}

		public MsalClaimsChallengeException(string errorCode, string errorMessage, Exception innerException, UiRequiredExceptionClassification classification)
			: base(errorCode, errorMessage, innerException, classification)
		{
		}
	}
	public class MsalClientException : MsalException
	{
		public MsalClientException(string errorCode)
			: base(errorCode)
		{
		}

		public MsalClientException(string errorCode, string errorMessage)
			: base(errorCode, errorMessage)
		{
		}

		public MsalClientException(string errorCode, string errorMessage, Exception innerException)
			: base(errorCode, errorMessage, innerException)
		{
		}
	}
	public static class MsalError
	{
		public const string InvalidGrantError = "invalid_grant";

		public const string InteractionRequired = "interaction_required";

		public const string NoTokensFoundError = "no_tokens_found";

		public const string UserNullError = "user_null";

		public const string UserAssertionNullError = "user_assertion_null";

		public const string CurrentBrokerAccount = "current_broker_account";

		public const string NoAccountForLoginHint = "no_account_for_login_hint";

		public const string MultipleAccountsForLoginHint = "multiple_accounts_for_login_hint";

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This error code is not in use")]
		public const string TokenCacheNullError = "token_cache_null";

		public const string NoPromptFailedError = "no_prompt_failed";

		public const string ServiceNotAvailable = "service_not_available";

		public const string RequestTimeout = "request_timeout";

		public const string RequestThrottled = "request_throttled";

		public const string UpnRequired = "upn_required";

		public const string MissingPassiveAuthEndpoint = "missing_passive_auth_endpoint";

		public const string InvalidAuthority = "invalid_authority";

		public const string InvalidAuthorityType = "invalid_authority_type";

		public const string UnauthorizedClient = "unauthorized_client";

		public const string UnknownError = "unknown_error";

		public const string UnknownBrokerError = "unknown_broker_error";

		public const string WamFailedToSignout = "wam_failed_to_signout";

		public const string AuthenticationFailed = "authentication_failed";

		public const string AuthorityValidationFailed = "authority_validation_failed";

		public const string InvalidOwnerWindowType = "invalid_owner_window_type";

		public const string EncodedTokenTooLong = "encoded_token_too_long";

		public const string UserMismatch = "user_mismatch";

		public const string FailedToRefreshToken = "failed_to_refresh_token";

		public const string FailedToAcquireTokenSilentlyFromBroker = "failed_to_acquire_token_silently_from_broker";

		public const string RedirectUriValidationFailed = "redirect_uri_validation_failed";

		public const string AuthenticationUiFailed = "authentication_ui_failed";

		public const string InternalError = "internal_error";

		public const string AccessingWsMetadataExchangeFailed = "accessing_ws_metadata_exchange_failed";

		public const string FederatedServiceReturnedError = "federated_service_returned_error";

		public const string UserRealmDiscoveryFailed = "user_realm_discovery_failed";

		public const string RopcDoesNotSupportMsaAccounts = "ropc_not_supported_for_msa";

		public const string MissingFederationMetadataUrl = "missing_federation_metadata_url";

		public const string ParsingWsMetadataExchangeFailed = "parsing_ws_metadata_exchange_failed";

		public const string WsTrustEndpointNotFoundInMetadataDocument = "wstrust_endpoint_not_found";

		public const string ParsingWsTrustResponseFailed = "parsing_wstrust_response_failed";

		public const string IntegratedWindowsAuthenticationFailed = "integrated_windows_authentication_failed";

		public const string UnknownUserType = "unknown_user_type";

		public const string UnknownUser = "unknown_user";

		public const string GetUserNameFailed = "get_user_name_failed";

		public const string PasswordRequiredForManagedUserError = "password_required_for_managed_user";

		public const string InvalidRequest = "invalid_request";

		public const string UapCannotFindDomainUser = "user_information_access_failed";

		public const string UapCannotFindUpn = "uap_cannot_find_upn";

		public const string NonParsableOAuthError = "non_parsable_oauth_error";

		public const string CodeExpired = "code_expired";

		public const string IntegratedWindowsAuthNotSupportedForManagedUser = "integrated_windows_auth_not_supported_managed_user";

		public const string ActivityRequired = "activity_required";

		public const string BrokerResponseHashMismatch = "broker_response_hash_mismatch";

		public const string BrokerResponseReturnedError = "broker_response_returned_error";

		public const string BrokerNonceMismatch = "broker_nonce_mismatch";

		public const string CannotInvokeBroker = "cannot_invoke_broker";

		public const string NoAndroidBrokerAccountFound = "no_broker_account_found";

		public const string NoAndroidBrokerInstalledOnDevice = "No_Broker_Installed_On_Device";

		public const string NullIntentReturnedFromAndroidBroker = "null_intent_returned_from_broker";

		public const string AndroidBrokerSignatureVerificationFailed = "broker_signature_verification_failed";

		public const string AndroidBrokerOperationFailed = "android_broker_operation_failed";

		public const string NoUsernameOrAccountIDProvidedForSilentAndroidBrokerAuthentication = "no_username_or_accountid_provided_for_silent_android_broker_authentication";

		public const string HttpStatusNotFound = "not_found";

		public const string HttpStatusCodeNotOk = "http_status_not_200";

		public const string CustomWebUiReturnedInvalidUri = "custom_webui_returned_invalid_uri";

		public const string CustomWebUiRedirectUriMismatch = "custom_webui_invalid_mismatch";

		public const string AccessDenied = "access_denied";

		public const string CannotAccessUserInformationOrUserNotDomainJoined = "user_information_access_failed";

		public const string DefaultRedirectUriIsInvalid = "redirect_uri_validation_failed";

		public const string NoRedirectUri = "no_redirect_uri";

		public const string MultipleTokensMatchedError = "multiple_matching_tokens_detected";

		public const string NonHttpsRedirectNotSupported = "non_https_redirect_failed";

		[Obsolete("MSAL no longer throws this error - it will allow the HttpClient exceptions to propagate. App developers may write their own logic for detecting access to the network issues, for example by using Xamarin.Essentials. ")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public const string NetworkNotAvailableError = "network_not_available";

		public const string B2CAuthorityHostMismatch = "B2C_authority_host_mismatch";

		public const string AuthorityHostMismatch = "authority_host_mismatch";

		public const string DuplicateQueryParameterError = "duplicate_query_parameter";

		public const string AuthenticationUiFailedError = "authentication_ui_failed";

		public const string AuthenticationCanceledError = "authentication_canceled";

		public const string JsonParseError = "json_parse_failed";

		public const string InvalidJwtError = "invalid_jwt";

		public const string StateMismatchError = "state_mismatch";

		public const string TenantDiscoveryFailedError = "tenant_discovery_failed";

		public const string PlatformNotSupported = "platform_not_supported";

		public const string InvalidAuthorizationUri = "invalid_authorization_uri";

		public const string LoopbackRedirectUri = "loopback_redirect_uri";

		public const string LoopbackResponseUriMismatch = "loopback_response_uri_mismatch";

		public const string LinuxXdgOpen = "linux_xdg_open_failed";

		public const string WebviewUnavailable = "no_system_webview";

		public const string SystemWebviewOptionsNotApplicable = "embedded_webview_not_compatible_default_browser";

		public const string ClientCredentialAuthenticationTypesAreMutuallyExclusive = "Client_Credential_Authentication_Types_Are_Mutually_Exclusive";

		public const string ClientCredentialAuthenticationTypeMustBeDefined = "Client_Credentials_Required_In_Confidential_Client_Application";

		internal const string BasicAction = "basic_action";

		internal const string AdditionalAction = "additional_action";

		internal const string MessageOnly = "message_only";

		internal const string UserPasswordExpired = "user_password_expired";

		internal const string ConsentRequired = "consent_required";

		internal const string BadToken = "bad_token";

		internal const string TokenExpired = "token_expired";

		internal const string ProtectionPolicyRequired = "protection_policy_required";

		internal const string ClientMismatch = "client_mismatch";

		internal const string DeviceAuthenticationFailed = "device_authentication_failed";

		public const string InvalidInstance = "invalid_instance";

		public const string InvalidUserInstanceMetadata = "invalid-custom-instance-metadata";

		public const string ValidateAuthorityOrCustomMetadata = "validate_authority_or_custom_instance_metadata";

		public const string NoClientId = "no_client_id";

		public const string TelemetryConfigOrTelemetryCallback = "telemetry_config_or_telemetry_callback";

		public const string InvalidClient = "invalid_client";

		public const string SSHCertUsedAsHttpHeader = "ssh_cert_used_as_http_header";

		public const string WABError = "wab_error";

		public const string TokenTypeMismatch = "token_type_mismatch";

		public const string AccessTokenTypeMissing = "token_type_missing";

		public const string ExperimentalFeature = "experimental_feature";

		public const string BrokerApplicationRequired = "broker_application_required";

		public const string FailedToGetBrokerResponse = "failed_to_get_broker_response";

		public const string InvalidJsonClaimsFormat = "invalid_json_claims_format";

		public const string AuthorityTypeMismatch = "authority_type_mismatch";

		public const string AuthorityTenantSpecifiedTwice = "authority_tenant_specified_twice";

		public const string CustomMetadataInstanceOrUri = "custom_metadata_instance_or_uri";

		public const string ScopesRequired = "scopes_required_client_credentials";

		public const string CertWithoutPrivateKey = "cert_without_private_key";

		public const string CertificateNotRsa = "certificate_not_rsa";

		public const string DeviceCertificateNotFound = "device_certificate_not_found";

		public const string InvalidAdalCacheMultipleRTs = "invalid_adal_cache";

		public const string RegionDiscoveryFailed = "region_discovery_failed";

		public const string RegionDiscoveryNotEnabled = "region_discovery_unavailable";

		public const string BrokerDoesNotSupportPop = "broker_does_not_support_pop";

		public const string BrokerRequiredForPop = "broker_required_for_pop";

		public const string AdfsNotSupportedWithBroker = "adfs_not_supported_with_broker";

		public const string NonceRequiredForPopOnPCA = "nonce_required_for_pop_on_pca";

		public const string WamUiThread = "wam_ui_thread_only";

		public const string WamNoB2C = "wam_no_b2c";

		public const string WamInteractiveError = "wam_interactive_error";

		public const string WamPickerError = "wam_interactive_picker_error";

		public const string WamScopesRequired = "scopes_required_wam";

		public const string WebView2NotInstalled = "webview2_runtime_not_installed";

		public const string WebView2LoaderNotFound = "webview2loader_not_found";

		public const string RegionalAuthorityValidation = "regional_authority_validation";

		public const string RegionDiscoveryWithCustomInstanceMetadata = "region_discovery_with_custom_instance_metadata";

		public const string HttpListenerError = "http_listener_error";

		public const string InitializeProcessSecurityError = "initialize_process_security_error";

		public const string StaticCacheWithExternalSerialization = "static_cache_with_external_serialization";

		public const string TenantOverrideNonAad = "tenant_override_non_aad";

		public const string RegionalAndAuthorityOverride = "authority_override_regional";

		public const string OboCacheKeyNotInCacheError = "obo_cache_key_not_in_cache_error";

		public const string InvalidTokenProviderResponseValue = "invalid_token_provider_response_value";

		public const string UnableToParseAuthenticationHeader = "unable_to_parse_authentication_header";

		public const string InvalidManagedIdentityResponse = "invalid_managed_identity_response";

		public const string ManagedIdentityRequestFailed = "managed_identity_request_failed";

		public const string ManagedIdentityUnreachableNetwork = "managed_identity_unreachable_network";

		public const string UnknownManagedIdentityError = "unknown_managed_identity_error";

		public const string InvalidManagedIdentityEndpoint = "invalid_managed_identity_endpoint";

		public const string ExactlyOneScopeExpected = "exactly_one_scope_expected";

		public const string UserAssignedManagedIdentityNotSupported = "user_assigned_managed_identity_not_supported";

		public const string UserAssignedManagedIdentityNotConfigurableAtRuntime = "user_assigned_managed_identity_not_configurable_at_runtime";

		public const string CombinedUserAppCacheNotSupported = "combined_user_app_cache_not_supported";

		public const string SetCiamAuthorityAtRequestLevelNotSupported = "set_ciam_authority_at_request_level_not_supported";

		public const string CryptographicError = "cryptographic_error";
	}
	internal static class MsalErrorMessage
	{
		public const string AccessingMetadataDocumentFailed = "Accessing WS metadata exchange failed. ";

		public const string AssemblyNotFoundTemplate = "Assembly required for the platform not found. Make sure assembly '{0}' exists. ";

		public const string AssemblyLoadFailedTemplate = "Loading an assembly required for the platform failed. Make sure assembly for the correct platform '{0}' exists. ";

		public const string AuthenticationUiFailed = "The browser based authentication dialog failed to complete. ";

		public const string DeprecatedAuthorityError = "login.windows.net has been deprecated. Use login.microsoftonline.com instead. ";

		public const string CertificateKeySizeTooSmallTemplate = "The certificate used must have a key size of at least {0} bits. ";

		public const string EmailAddressSuffixMismatch = "No identity provider email address suffix matches the provided address. ";

		public const string EncodedTokenTooLong = "Encoded token size is beyond the upper limit. ";

		public const string FailedToAcquireTokenSilently = "Failed to acquire token silently. Call method AcquireToken. ";

		public const string FailedToRefreshToken = "Failed to refresh token. ";

		public const string IdentityProtocolLoginUrlNull = "The LoginUrl property in identityProvider cannot be null. ";

		public const string IdentityProtocolMismatch = "No identity provider matches the requested protocol. ";

		public const string IdentityProviderRequestFailed = "Token request to identity provider failed. Check InnerException for more details. ";

		public const string InvalidArgumentLength = "Parameter has invalid length. ";

		public const string InvalidAuthenticateHeaderFormat = "Invalid authenticate header format. ";

		public const string InvalidAuthorityTypeTemplate = "This method overload is not supported by '{0}'. ";

		public const string InvalidCredentialType = "Invalid credential type. ";

		public const string InvalidFormatParameterTemplate = "Parameter '{0}' has invalid format. ";

		public const string InvalidTokenCacheKeyFormat = "Invalid token cache key format. ";

		public const string MissingAuthenticateHeader = "WWW-Authenticate header was expected in the response. ";

		public const string MultipleTokensMatched = "The cache contains multiple tokens satisfying the requirements. Try to clear token cache. ";

		public const string NullParameterTemplate = "Parameter '{0}' cannot be null. ";

		public const string ParsingMetadataDocumentFailed = "Parsing WS metadata exchange failed. ";

		public const string ParsingWsTrustResponseFailed = "Parsing WS-Trust response failed. ";

		public const string PasswordRequiredForManagedUserError = "Password is required for managed user. ";

		public const string LoginHintNullForUiOption = "Null login_hint is not allowed for Prompt.ActAsCurrentUser. ";

		public const string ServiceReturnedError = "Service returned error. Check InnerException for more details. ";

		public const string BrokerResponseHashMismatch = "Unencrypted broker response hash did not match the expected hash. ";

		public const string BrokerNonceMismatch = "Broker response nonce does not match the request nonce sent by MSAL.NET. Please see https://aka.ms/msal-net-ios-13-broker for more details. ";

		public const string StsMetadataRequestFailed = "Metadata request to Access Control service failed. Check InnerException for more details. ";

		public const string StsTokenRequestFailed = "Token request to security token service failed.  Check InnerException for more details. ";

		public const string UnauthorizedHttpStatusCodeExpected = "Unauthorized HTTP Status Code (401) was expected in the response. ";

		internal const string iOSBrokerKeyFetchFailed = "A broker key was generated but it could not be retrieved from the KeyChain. Please capture and inspect the logs to see why the fetch operation failed. ";

		public const string UnauthorizedResponseExpected = "Unauthorized HTTP response (status code 401) was expected. ";

		public const string UnexpectedAuthorityValidList = "Unexpected list of valid addresses. ";

		public const string UnsupportedUserType = "Unsupported User Type '{0}'. Please see https://aka.ms/msal-net-up. ";

		public const string UnsupportedMultiRefreshToken = "This authority does not support refresh token for multiple resources. Pass null as a resource. ";

		public const string UserMismatch = "User '{0}' returned by service does not match user '{1}' in the request. ";

		public const string UserCredentialAssertionTypeEmpty = "credential.AssertionType cannot be empty. ";

		public const string NoPromptFailedErrorMessage = "One of two conditions was encountered: 1. The Prompt.Never flag was passed, but the constraint could not be honored, because user interaction was required. 2. An error occurred during a silent web authentication that prevented the HTTP authentication flow from completing in a short enough time frame. ";

		public const string StateMismatchErrorMessage = "Returned state({0}) from authorize endpoint is not the same as the one sent({1}). See https://aka.ms/msal-statemismatcherror for more details. ";

		public const string UserRealmDiscoveryFailed = "User realm discovery failed. ";

		public const string RopcDoesNotSupportMsaAccounts = "ROPC does not support MSA accounts. See https://aka.ms/msal-net-ropc for details. ";

		public const string WsTrustEndpointNotFoundInMetadataDocument = "WS-Trust endpoint not found in metadata document. ";

		public const string GetUserNameFailed = "Failed to get user name. ";

		public const string MissingFederationMetadataUrl = "Federation Metadata URL is missing for federated user. This user type is unsupported. ";

		public const string SpecifyAnyUser = "If you do not need access token for any specific user, pass userId=UserIdentifier.AnyUser instead of userId=null. ";

		public const string IntegratedAuthFailed = "Integrated authentication failed. You may try an alternative authentication method. ";

		public const string DuplicateQueryParameterTemplate = "Duplicate query parameter '{0}' in extraQueryParameters. ";

		public const string DeviceCertificateNotFoundTemplate = "Device Certificate was not found for {0}. ";

		public const string MsalUiRequiredMessage = "No account or login hint was passed to the AcquireTokenSilent call. ";

		public const string UserMismatchSaveToken = "Returned user identifier does not match the sent user identifier when saving the token to the cache. ";

		public const string IwaNotSupportedForManagedUser = "Integrated Windows Auth is not supported for managed users. See https://aka.ms/msal-net-iwa for details. ";

		public const string ActivityRequired = "On the Android platform, you have to pass the Activity to the UIParent object. See https://aka.ms/msal-interactive-android for details. ";

		public const string BrokerResponseReturnedError = "Broker response returned an error which does not contain an error or error description. See https://aka.ms/msal-brokers for details. ";

		public const string BrokerResponseError = "Broker response returned error: ";

		public const string CannotInvokeBroker = "MSAL cannot invoke the broker. The Authenticator App (Broker) may not be installed on the user's device or there was an error invoking the broker. Check logs for more details and see https://aka.ms/msal-brokers. ";

		public const string CannotInvokeBrokerForPop = "MSAL cannot invoke the broker and it is required for Proof-of-Possession. WAM (Broker) may not be installed on the user's device or there was an error invoking the broker. Use IPublicClientApplication.IsProofOfPossessionSupportedByClient to ensure Proof-of-Possession can be performed before using WithProofOfPossession.Check logs for more details and see https://aka.ms/msal-net-pop. ";

		public const string BrokerDoesNotSupportPop = "The broker does not support Proof-of-Possession on the current platform.";

		public const string BrokerRequiredForPop = "The request has Proof-of-Possession configured but does not have broker enabled. Broker is required to use Proof-of-Possession on public clients. Use IPublicClientApplication.IsProofOfPossessionSupportedByClient to ensure Proof-of-Possession can be performed before using WithProofOfPossession.";

		public const string NonceRequiredForPop = "The request has Proof-of-Possession configured for public clients but does not have a nonce provided. A nonce is required for Proof-of-Possession on public clients.";

		public const string AdfsNotSupportedWithBroker = "Broker does not support ADFS environments. If using Proof-of-Possession, use IPublicClientApplication.IsProofOfPossessionSupportedByClient to ensure Proof-of-Possession can be performed before calling WithProofOfPossession.";

		public const string NullIntentReturnedFromBroker = "Broker returned a null intent. Check the Android app settings and logs for more information. ";

		public const string NoAccountForLoginHint = "You are trying to acquire a token silently using a login hint. No account was found in the token cache having this login hint. ";

		public const string MultipleAccountsForLoginHint = "You are trying to acquire a token silently using a login hint. Multiple accounts were found in the token cache having this login hint. Please choose an account manually an pass it in to AcquireTokenSilently. ";

		public const string UnknownUser = "Could not identify the user logged into the OS. See http://aka.ms/msal-net-iwa for details. ";

		public const string HttpRequestUnsuccessful = "Response status code does not indicate success: {0} ({1}). ";

		public const string AuthorityInvalidUriFormat = "The authority (including the tenant ID) must be in a well-formed URI format. ";

		public const string AuthorityNotSupported = "'authority' is not supported. ";

		public const string AuthorityValidationFailed = "Authority validation failed. ";

		public const string AuthorityUriInsecure = "The authority must use HTTPS scheme. ";

		public const string AuthorityUriInvalidPath = "The authority URI should have at least one segment in the path (i.e. https://<host>/<path>/...). ";

		public const string B2cAuthorityUriInvalidPath = "The B2C authority URI should have at least 3 segments in the path (i.e. https://<host>/tfp/<tenant>/<policy>/...). ";

		public const string DstsAuthorityUriInvalidPath = "The DSTS authority URI should have at least 2 segments in the path (i.e. https://<host>/dstsv2/<tenant>/...). ";

		public const string UnsupportedAuthorityValidation = "Authority validation is not supported for this type of authority. See http://aka.ms/valid-authorities for details. ";

		public const string AuthenticationCanceled = "User canceled authentication. ";

		public const string AuthenticationCanceledAndroid = "User canceled authentication. On an Android device, this could be due to the lack of capabilities, such as custom tabs, for the system browser. See https://aka.ms/msal-net-system-browsers for more information. ";

		public const string Unknown = "Unknown error";

		public const string AuthorizationServerInvalidResponse = "The authorization server returned an invalid response. ";

		public const string NonHttpsRedirectNotSupported = "Non-HTTPS URL redirect is not supported in a web view. This error happens when the authorization flow, which collects user credentials, gets redirected to a page that is not supported, for example if the redirect occurs over http. This error does not trigger for the final redirect, which can be http://localhost, but for intermediary redirects.Mitigation: This usually happens when using a federated directory which is not setup correctly. ";

		public const string IDTokenMustHaveTwoParts = "ID Token must have a valid JWT format. ";

		public const string FailedToParseIDToken = "Failed to parse the returned id token. ";

		public const string InvalidAuthorityOpenId = "invalid authority while getting the open id config endpoint. ";

		public const string UpnRequiredForAuthorityValidation = "UPN is required for ADFS authority validation. ";

		public const string CannotFindTheAuthEndpoint = "Cannot find the auth endpoint. ";

		public const string PlatformNotSupported = "Platform Not Supported";

		public const string FederatedServiceReturnedErrorTemplate = "Federated service at {0} returned error: {1} ";

		public const string ParsingWsTrustResponseFailedErrorTemplate = "Federated service at {0} parse error: Body {1} ";

		public const string UnknownUserType = "Unknown User Type";

		public const string ParsingWsTrustResponseFailedDueToConfiguration = "There was an error parsing the WS-Trust response from the endpoint. \nThis may occur if there are issues with your ADFS configuration. See https://aka.ms/msal-net-iwa-troubleshooting for more details.\nEnable logging to see more details. See https://aka.ms/msal-net-logging.";

		public const string InternalErrorCacheEmptyUsername = "Internal error - trying to remove an MSAL user with an empty username. Possible cache corruption. See https://aka.ms/adal_token_cache_serialization. ";

		public const string InternalErrorCacheEmptyIdentifier = "Internal error - trying to remove an MSAL user with an empty identifier. Possible cache corruption. See https://aka.ms/adal_token_cache_serialization. ";

		public const string NonParsableOAuthError = "An error response was returned by the OAuth2 server, but it could not be parsed. Please inspect the exception properties for details. ";

		public const string CannotAccessPublisherKeyChain = "The application cannot access the iOS keychain for the application publisher (the TeamId is null). This is needed to enable Single Sign On between applications of the same publisher. This is an iOS configuration issue. See https://aka.ms/msal-net-enable-keychain-access for more details on enabling keychain access. ";

		public const string MissingEntitlements = "The application does not have keychain access groups enabled in the Entitlements.plist. As a result, there was a failure to save to the iOS keychain. The keychain access group '{0}' is not enabled in the Entitlements.plist. Also, use the WithIosKeychainSecurityGroup api to set the keychain access group. See https://aka.ms/msal-net-enable-keychain-groups for more details on enabling keychain access groups and entitlements.";

		public const string AndroidActivityNotFound = "The Activity cannot be found to launch the given Intent. To ensure authentication, a browser with custom tab support is recommended. See https://aka.ms/msal-net-system-browsers for more details on using system browser on Android.";

		public const string DefaultRedirectUriIsInvalid = "The OAuth2 redirect URI {0} should not be used with the system browser, because the operating system cannot go back to the app. Consider using the default redirect URI for this platform. See https://aka.ms/msal-client-apps for more details. ";

		public const string RedirectUriContainsFragment = "'redirectUri' must NOT include a fragment component. ";

		public const string NoRedirectUri = "No redirectUri was configured. MSAL does not provide any defaults. ";

		public const string ClientApplicationBaseExecutorNotImplemented = "ClientApplicationBase implementation does not implement IClientApplicationBaseExecutor. ";

		public const string ActivityRequiredForParentObjectAndroid = "On Android, you have to specify the current Activity from which the browser pop-up will be displayed using the WithParentActivityOrWindow method. ";

		public const string LoggingCallbackAlreadySet = "LoggingCallback has already been set. ";

		public const string TelemetryCallbackAlreadySet = "TelemetryCallback has already been set. ";

		public const string NoClientIdWasSpecified = "No ClientId was specified. ";

		public const string AdfsNotCurrentlySupportedAuthorityType = "ADFS is not currently a supported authority type. ";

		public const string TenantIdAndAadAuthorityInstanceAreMutuallyExclusive = "TenantId and AadAuthorityAudience are both set, but they're mutually exclusive. ";

		public const string InstanceAndAzureCloudInstanceAreMutuallyExclusive = "Instance and AzureCloudInstance are both set but they're mutually exclusive. ";

		public const string NoRefreshTokenProvided = "A refresh token must be provided. ";

		public const string AadThrottledError = "Your app has been throttled by AAD due to too many requests. To avoid this, cache your tokens see https://aka.ms/msal-net-throttling.";

		public const string NoTokensFoundError = "No Refresh Token found in the cache. ";

		public const string NoRefreshTokenInResponse = "Acquire by refresh token request completed, but no refresh token was found. ";

		public const string ConfidentialClientDoesntImplementIConfidentialClientApplicationExecutor = "ConfidentialClientApplication implementation does not implement IConfidentialClientApplicationExecutor. ";

		public const string ClientCredentialAuthenticationTypesAreMutuallyExclusive = "ClientSecret, Certificate and ClientAssertion are mutually exclusive properties. Only specify one. See https://aka.ms/msal-net-client-credentials. ";

		public const string ClientCredentialAuthenticationTypeMustBeDefined = "One client credential type required either: ClientSecret, Certificate, ClientAssertion or AppTokenProvider must be defined when creating a Confidential Client. Only specify one. See https://aka.ms/msal-net-client-credentials. ";

		public const string TelemetryClassIsObsolete = "Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ";

		public const string LoggingClassIsObsolete = "Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ";

		public const string AuthorityDoesNotHaveTwoSegments = "Authority should be in the form <host>/<audience>, for example https://login.microsoftonline.com/common. ";

		public const string DstsAuthorityDoesNotHaveThreeSegments = "Authority should be in the form <host>/<audience>/<tenantID>, for example https://login.microsoftonline.com/dsts/<tenantid>. ";

		public const string AzureAdMyOrgRequiresSpecifyingATenant = "When specifying AadAuthorityAudience.AzureAdMyOrg, you must also specify a tenant domain or tenant GUID. ";

		public const string CustomWebUiReturnedInvalidUri = "ICustomWebUi returned an invalid URI - it is empty or has no query. ";

		public const string InteractiveAuthNotSupported = "On .Net Core, interactive authentication is not supported. Consider using Device Code Flow https://aka.ms/msal-net-device-code-flow or Integrated Windows Auth https://aka.ms/msal-net-iwa - you can also implement your own web UI - see https://aka.ms/msal-net-custom-web-ui. ";

		public const string CustomWebUiAuthorizationCodeFailed = "CustomWebUi AcquireAuthorizationCode failed. ";

		public const string TokenCacheJsonSerializerFailedParse = "MSAL deserialization failed to parse the cache contents. First characters of the cache string: {0} \r\nPossible cause: token cache encryption is used via Microsoft.Identity.Web.TokenCache and decryption fails, for example. \r\n Full details of inner exception: {1} ";

		public const string TokenCacheDictionarySerializerFailedParse = "MSAL V2 Deserialization failed to parse the cache contents. Is this possibly an earlier format needed for DeserializeMsalV3?  (See https://aka.ms/msal-net-3x-cache-breaking-change). ";

		public const string BrokerNotSupportedOnThisPlatform = "Broker is only supported on mobile platforms (Android and iOS). See https://aka.ms/msal-brokers for details. ";

		public const string MsalExceptionFailedToParse = "Attempted to deserialize an MsalException but the type was unknown. ";

		public const string AdfsDeviceFlowNotSupported = "Device Code Flow is not currently supported for ADFS. ";

		public const string MatsAndTelemetryCallbackCannotBeConfiguredSimultaneously = "MATS cannot be configured at the same time as a TelemetryCallback is provided. These are mutually exclusive. ";

		public const string AkaMsmsalnet3BreakingChanges = "See https://aka.ms/msal-net-3-breaking-changes. ";

		public const string B2CAuthorityHostMisMatch = "The B2C authority host that was used when creating the client application is not the same authority host used in the AcquireToken call. See https://aka.ms/msal-net-b2c for details. ";

		public const string TokenCacheSetCallbackFunctionalityNotAvailableFromWithinCallback = "You cannot set a token cache callback method from within the callback itself. ";

		public const string EmbeddedWebviewDefaultBrowser = "You configured MSAL interactive authentication to use an embedded WebView and you also configured system WebView options. These are mutually exclusive. See https://aka.ms/msal-net-os-browser. ";

		public const string AuthorizeEndpointWasNotFoundInTheOpenIdConfiguration = "Authorize endpoint was not found in the openid configuration. ";

		public const string TokenEndpointWasNotFoundInTheOpenIdConfiguration = "Token endpoint was not found in the openid configuration. ";

		public const string IssuerWasNotFoundInTheOpenIdConfiguration = "Issuer was not found in the openid configuration. ";

		public const string InvalidUserInstanceMetadata = "The json containing instance metadata could not be parsed. See https://aka.ms/msal-net-custom-instance-metadata for details. ";

		public const string UIViewControllerIsRequiredToInvokeiOSBroker = "UIViewController is null, so MSAL.NET cannot invoke the iOS broker. See https://aka.ms/msal-net-ios-broker. ";

		public const string WritingApplicationTokenToKeychainFailed = "This error indicates that the writing of the application token from iOS broker to the keychain threw an exception. No SecStatusCode was returned. ";

		public const string ReadingApplicationTokenFromKeychainFailed = "This error indicates that the reading of the application token from the keychain threw an exception. No SecStatusCode was returned. ";

		public const string ValidateAuthorityOrCustomMetadata = "You have configured custom instance metadata, but the validateAuthority flag is set to true. These are mutually exclusive. Set the validateAuthority flag to false. See https://aka.ms/msal-net-custom-instance-metadata for more details. ";

		public const string InvalidClient = "A configuration issue is preventing authentication - check the error message from the server for details. You can modify the configuration in the application registration portal. See https://aka.ms/msal-net-invalid-client for details. ";

		public const string SSHCertUsedAsHttpHeader = "MSAL was configured to request SSH certificates from AAD, and these cannot be used as an HTTP authentication header. Developers are responsible for transporting the SSH certificates to the target machines. ";

		public const string BrokerApplicationRequired = "Installation of broker failed. The broker application must be installed to continue authentication. ";

		public const string RegionDiscoveryFailed = "Region discovery for the instance failed. Region discovery can only be made if the service resides in Azure function or Azure VM. See https://aka.ms/msal-net-region-discovery for more details. ";

		public const string RegionDiscoveryFailedWithTimeout = "Region discovery failed due to app cancellation or timeout. ";

		public const string RegionDiscoveryNotAvailable = "Region discovery cannot be performed for ADFS authority. Do not set `WithAzureRegion` to true. ";

		public const string RegionDiscoveryWithCustomInstanceMetadata = "Configure either region discovery or custom instance metadata. Custom instance discovery metadata overrides region discovery. ";

		public const string NoAndroidBrokerAccountFound = "Android account manager could not find an account that matched the provided account information. ";

		public const string AndroidBrokerCannotBeInvoked = "The current version of the broker may not support MSAL or power optimization is turned on. In order to perform brokered authentication on android you need to ensure that you have installed either Intune Company Portal (5.0.4689.0 or greater) or Microsoft Authenticator (6.2001.0140 or greater). See https://aka.ms/Brokered-Authentication-for-Android. ";

		public const string CustomMetadataInstanceOrUri = "You have configured your own instance metadata using both an Uri and a string. Only one is supported. See https://aka.ms/msal-net-custom-instance-metadata for more details. ";

		public const string ScopesRequired = "At least one scope needs to be requested for this authentication flow. ";

		public const string InvalidAdalCacheMultipleRTs = "The ADAL cache is invalid as it contains multiple refresh token entries for one user. Deleting invalid ADAL cache. ";

		public const string AccessTokenTypeMissing = "The response from the token endpoint does not contain the token_type parameter. This happens if the identity provider (AAD, B2C, ADFS, etc.) did not include the access token type in the token response. Verify the configuration of the identity provider. ";

		public const string LinuxOpenToolFailed = "Unable to open a web page using xdg-open, gnome-open, kfmclient or wslview tools. See inner exception for details. Possible causes for this error are: tools are not installed or they cannot open a URL. Make sure you can open a web page by invoking from a terminal: xdg-open https://www.bing.com ";

		public const string LinuxOpenAsSudoNotSupported = "Unable to open a web page using xdg-open, gnome-open, kfmclient or wslview tools in sudo mode. Please run the process as non-sudo user.";

		public const string WebView2LoaderNotFound = "The embedded WebView2 browser cannot be started because a runtime component cannot be loaded. For troubleshooting details, see https://aka.ms/msal-net-webview2 .";

		public const string AuthenticationFailedWamElevatedProcess = "WAM Account Picker did not return an account. Either the user cancelled the authentication or the WAM Account Picker crashed because the app is running in an elevated process. For troubleshooting details, see https://aka.ms/msal-net-wam .";

		public const string CcsRoutingHintMissing = "Either the userObjectIdentifier or tenantIdentifier are missing. Both are needed to create the CCS routing hint. See https://aka.ms/msal-net/ccsRouting. ";

		public const string StaticCacheWithExternalSerialization = "You configured MSAL cache serialization at the same time with internal caching options. These are mutually exclusive. Use only one option. Web site and web api scenarios should rely on external cache serialization, as internal cache serialization cannot scale. See https://aka.ms/msal-net-token-cache-serialization .";

		public const string ClientCredentialWrongAuthority = "The current authority is targeting the /common or /organizations endpoint which is not recommended. See https://aka.ms/msal-net-client-credentials for more details.";

		public const string OnBehalfOfWrongAuthority = "The current authority is targeting the /common or /organizations endpoint. Instead, it should target the same tenant as the client, which can be found in the 'tid' claim of the incoming client token. See https://aka.ms/msal-net-on-behalf-of for more details.";

		public const string TenantOverrideNonAad = "WithTenantId can only be used when an AAD authority is specified at the application level.";

		public const string RegionalAndAuthorityOverride = "You configured WithAuthority at the request level, and also WithAzureRegion. This is not supported when the environment changes from application to request. Use WithTenantId at the request level instead.";

		public const string OboCacheKeyNotInCache = "The token cache does not contain a token with an OBO cache key that matches the longRunningProcessSessionKey passed into ILongRunningWebApi.AcquireTokenInLongRunningProcess method. Call ILongRunningWebApi.InitiateLongRunningProcessInWebApi method with this longRunningProcessSessionKey first or call ILongRunningWebApi.AcquireTokenInLongRunningProcess method with an already used longRunningProcessSessionKey. See https://aka.ms/msal-net-long-running-obo .";

		public const string MultiCloudSupportUnavailable = "Multi cloud support unavailable with broker.";

		public const string RequestFailureErrorMessage = "=== Token Acquisition ({0}) failed.\n\tHost: {1}.";

		public const string RequestFailureErrorMessagePii = "=== Token Acquisition ({0}) failed:\n\tAuthority: {1}\n\tClientId: {2}.";

		public const string UnableToParseAuthenticationHeader = "MSAL is unable to parse the authentication header returned from the resource endpoint. This can be a result of a malformed header returned in either the WWW-Authenticate or the Authentication-Info collections acquired from the provided endpoint.";

		public const string ManagedIdentityNoResponseReceived = "[Managed Identity] Authentication unavailable. No response received from the managed identity endpoint.";

		public const string ManagedIdentityInvalidResponse = "[Managed Identity] Invalid response, the authentication response received did not contain the expected fields.";

		public const string ManagedIdentityUnexpectedResponse = "[Managed Identity] Unexpected exception occurred when parsing the response. See the inner exception for details.";

		public const string ManagedIdentityExactlyOneScopeExpected = "[Managed Identity] To acquire token for managed identity, exactly one scope must be passed.";

		public const string ManagedIdentityUnexpectedErrorResponse = "[Managed Identity] The error response was either empty or could not be parsed.";

		public const string ManagedIdentityEndpointInvalidUriError = "[Managed Identity] The environment variable {0} contains an invalid Uri {1} in {2} managed identity source.";

		public const string ManagedIdentityNoChallengeError = "[Managed Identity] Did not receive expected WWW-Authenticate header in the response from Azure Arc Managed Identity Endpoint.";

		public const string ManagedIdentityInvalidChallenge = "[Managed Identity] The WWW-Authenticate header in the response from Azure Arc Managed Identity Endpoint did not match the expected format.";

		public const string ManagedIdentityInvalidFile = "[Managed Identity] The file on the file path in the WWW-Authenticate header is not secure.";

		public const string ManagedIdentityPlatformNotSupported = "[Managed Identity] The platform is not supported by Azure Arc. Azure Arc only supports Windows and Linux.";

		public const string ManagedIdentityUserAssignedNotSupported = "[Managed Identity] User assigned identity is not supported by the {0} Managed Identity. To authenticate with the system assigned identity omit the client id in ManagedIdentityApplicationBuilder.Create().";

		public const string ManagedIdentityUserAssignedNotConfigurableAtRuntime = "[Managed Identity] Service Fabric user assigned managed identity ClientId or ResourceId is not configurable at runtime.";

		public const string CombinedUserAppCacheNotSupported = "Using a combined flat storage, like a file, to store both app and user tokens is not supported. Use a partitioned token cache (for ex. distributed cache like Redis) or separate files for app and user token caches. See https://aka.ms/msal-net-token-cache-serialization .";

		public const string JsonParseErrorMessage = "There was an error parsing the response from the token endpoint, see inner exception for details. Verify that your app is configured correctly. If this is a B2C app, one possible cause is acquiring a token for Microsoft Graph, which is not supported. See https://aka.ms/msal-net-up";

		public const string SetCiamAuthorityAtRequestLevelNotSupported = "Setting the CIAM authority (ex. \"{tenantName}.ciamlogin.com\") at the request level is not supported. The CIAM authority must be set during application creation";

		public const string ClaimsChallenge = "The returned error contains a claims challenge. For additional info on how to handle claims related to multifactor authentication, Conditional Access, and incremental consent, see https://aka.ms/msal-conditional-access-claims. If you are using the On-Behalf-Of flow, see https://aka.ms/msal-conditional-access-claims-obo for details.";

		public const string CryptographicError = "A cryptographic exception occurred. Possible cause: the certificate has been disposed. See inner exception for full details.";

		public static string iOSBrokerKeySaveFailed(string keyChainResult)
		{
			return "A broker key was generated but it was not saved to the KeyChain. KeyChain status code: " + keyChainResult;
		}

		public static string InvalidRedirectUriReceived(string invalidRedirectUri)
		{
			return "Invalid RedirectURI was received (" + invalidRedirectUri + ")  Not parseable into System.Uri class. ";
		}

		public static string RedirectUriMismatch(string expectedUri, string actualUri)
		{
			return "Redirect Uri mismatch.  Expected (" + expectedUri + ") Actual (" + actualUri + "). ";
		}

		public static string AuthorityTypeMismatch(AuthorityType appAuthorityType, AuthorityType requestAuthorityType)
		{
			return string.Format(CultureInfo.InvariantCulture, "A authority of type {0} was used at the application and of type {1} at the request level. Please use the same authority type between the two. ", appAuthorityType, requestAuthorityType);
		}

		public static string ExperimentalFeature(string methodName)
		{
			return "The API " + methodName + " is marked as experimental and you should be mindful about using it in production. It may change without incrementing the major version of the library. Call .WithExperimentalFeatures() when creating the public / confidential client to bypass this. See https://aka.ms/msal-net-experimental-features for details. ";
		}

		public static string NoUserInstanceMetadataEntry(string environment)
		{
			return "The json containing instance metadata does not contain details about the authority in use: " + environment + ". See https://aka.ms/msal-net-custom-instance-metadata for more details. ";
		}

		public static string WABError(string status, string errorDetail, string responseData)
		{
			return "WAB responded with: status = " + status + ", error detail = " + errorDetail + ", response data = " + responseData;
		}

		public static string TokenTypeMismatch(string requestTokenType, string responseTokenType)
		{
			return "You asked for token type " + requestTokenType + ", but receive " + responseTokenType + ". This occurs if the Identity Provider (AAD, B2C, ADFS etc.) does not support the requested token type. If using ADFS, consider upgrading to the latest version. ";
		}

		public static string InvalidJsonClaimsFormat(string claims)
		{
			return "You have configured a claims parameter that is not in JSON format: " + claims + ". Inspect the inner exception for details about the JSON parsing error. To learn more about claim requests, please see https://openid.net/specs/openid-connect-core-1_0.html#ClaimsParameter. ";
		}

		public static string CertMustHavePrivateKey(string certificateName)
		{
			return "The certificate " + certificateName + " does not have a private key. ";
		}

		public static string CertMustBeRsa(string certificateFriendlyName)
		{
			return "The provided certificate is not of type RSA. Please use a certificate of type RSA. Provided certificate's Friendly Name: " + certificateFriendlyName + ".";
		}

		public static string InitializeProcessSecurityError(string errorCode)
		{
			return "Failure setting process security to enable WAM Account Picker in an elevated process (" + errorCode + "). For troubleshooting details, see https://aka.ms/msal-net-wam .";
		}

		public static string InvalidTokenProviderResponseValue(string invalidValueName)
		{
			return "The following token provider result value is invalid: " + invalidValueName + ".";
		}
	}
	public class MsalException : Exception
	{
		private class ExceptionSerializationKey
		{
			internal const string ExceptionTypeKey = "type";

			internal const string ErrorCodeKey = "error_code";

			internal const string ErrorDescriptionKey = "error_description";

			internal const string AdditionalExceptionData = "additional_exception_data";

			internal const string BrokerErrorContext = "broker_error_context";

			internal const string BrokerErrorTag = "broker_error_tag";

			internal const string BrokerErrorStatus = "broker_error_status";

			internal const string BrokerErrorCode = "broker_error_code";

			internal const string BrokerTelemetry = "broker_telemetry";

			internal const string ManagedIdentitySource = "managed_identity_source";
		}

		public const string BrokerErrorContext = "BrokerErrorContext";

		public const string BrokerErrorTag = "BrokerErrorTag";

		public const string BrokerErrorStatus = "BrokerErrorStatus";

		public const string BrokerErrorCode = "BrokerErrorCode";

		public const string BrokerTelemetry = "BrokerTelemetry";

		public const string ManagedIdentitySource = "ManagedIdentitySource";

		private string _errorCode;

		public bool IsRetryable { get; set; }

		public string ErrorCode
		{
			get
			{
				return _errorCode;
			}
			private set
			{
				if (string.IsNullOrWhiteSpace(value))
				{
					throw new ArgumentNullException("ErrorCode");
				}
				_errorCode = value;
			}
		}

		public string CorrelationId { get; set; }

		public IReadOnlyDictionary<string, string> AdditionalExceptionData { get; set; } = CollectionHelpers.GetEmptyDictionary<string, string>();

		public MsalException()
			: base("Unknown error")
		{
			ErrorCode = "unknown_error";
		}

		public MsalException(string errorCode)
		{
			ErrorCode = errorCode;
		}

		public MsalException(string errorCode, string errorMessage)
			: base(errorMessage)
		{
			if (string.IsNullOrWhiteSpace(Message))
			{
				throw new ArgumentNullException("errorMessage");
			}
			ErrorCode = errorCode;
		}

		public MsalException(string errorCode, string errorMessage, Exception innerException)
			: base(errorMessage, innerException)
		{
			if (string.IsNullOrWhiteSpace(Message))
			{
				throw new ArgumentNullException("errorMessage");
			}
			ErrorCode = errorCode;
		}

		public override string ToString()
		{
			string productName = PlatformProxyFactory.CreatePlatformProxy(null).GetProductName();
			string msalVersion = MsalIdHelper.GetMsalVersion();
			string text = ((base.InnerException == null) ? string.Empty : $"\nInner Exception: {base.InnerException}");
			return productName + "." + msalVersion + "." + GetType().Name + ":\r\n\tErrorCode: " + ErrorCode + "\r\n" + base.ToString() + text;
		}

		internal virtual void PopulateJson(JObject jObject)
		{
			jObject["type"] = GetType().Name;
			jObject["error_code"] = ErrorCode;
			jObject["error_description"] = Message;
			JObject jObject2 = new JObject();
			if (AdditionalExceptionData.TryGetValue("BrokerErrorContext", out var value))
			{
				jObject2["broker_error_context"] = value;
			}
			if (AdditionalExceptionData.TryGetValue("BrokerErrorTag", out var value2))
			{
				jObject2["broker_error_tag"] = value2;
			}
			if (AdditionalExceptionData.TryGetValue("BrokerErrorStatus", out var value3))
			{
				jObject2["broker_error_status"] = value3;
			}
			if (AdditionalExceptionData.TryGetValue("BrokerErrorCode", out var value4))
			{
				jObject2["broker_error_code"] = value4;
			}
			if (AdditionalExceptionData.TryGetValue("BrokerTelemetry", out var value5))
			{
				jObject2["broker_telemetry"] = value5;
			}
			if (AdditionalExceptionData.TryGetValue("ManagedIdentitySource", out var value6))
			{
				jObject2["managed_identity_source"] = value6;
			}
			jObject["additional_exception_data"] = jObject2;
		}

		internal virtual void PopulateObjectFromJson(JObject jObject)
		{
			IDictionary<string, string> dictionary = JsonHelper.ExtractInnerJsonAsDictionary(jObject, "additional_exception_data");
			if (dictionary.TryGetValue("broker_error_context", out var value))
			{
				dictionary["BrokerErrorContext"] = value;
				dictionary.Remove("broker_error_context");
			}
			if (dictionary.TryGetValue("broker_error_tag", out var value2))
			{
				dictionary["BrokerErrorTag"] = value2;
				dictionary.Remove("broker_error_tag");
			}
			if (dictionary.TryGetValue("broker_error_status", out var value3))
			{
				dictionary["BrokerErrorStatus"] = value3;
				dictionary.Remove("broker_error_status");
			}
			if (dictionary.TryGetValue("broker_error_code", out var value4))
			{
				dictionary["BrokerErrorCode"] = value4;
				dictionary.Remove("broker_error_code");
			}
			if (dictionary.TryGetValue("broker_telemetry", out var value5))
			{
				dictionary["BrokerTelemetry"] = value5;
				dictionary.Remove("broker_telemetry");
			}
			if (dictionary.TryGetValue("managed_identity_source", out var value6))
			{
				dictionary["ManagedIdentitySource"] = value6;
				dictionary.Remove("managed_identity_source");
			}
			AdditionalExceptionData = (IReadOnlyDictionary<string, string>)dictionary;
		}

		public string ToJsonString()
		{
			JObject jObject = new JObject();
			PopulateJson(jObject);
			return jObject.ToString();
		}

		public static MsalException FromJsonString(string json)
		{
			JObject jObject = JsonHelper.ParseIntoJsonObject(json);
			string value = JsonHelper.GetValue<string>(jObject["type"]);
			string existingOrEmptyString = JsonHelper.GetExistingOrEmptyString(jObject, "error_code");
			string existingOrEmptyString2 = JsonHelper.GetExistingOrEmptyString(jObject, "error_description");
			object obj = value switch
			{
				"MsalException" => new MsalException(existingOrEmptyString, existingOrEmptyString2), 
				"MsalClientException" => new MsalClientException(existingOrEmptyString, existingOrEmptyString2), 
				"MsalServiceException" => new MsalServiceException(existingOrEmptyString, existingOrEmptyString2), 
				"MsalUiRequiredException" => new MsalUiRequiredException(existingOrEmptyString, existingOrEmptyString2), 
				_ => throw new MsalClientException("json_parse_failed", "Attempted to deserialize an MsalException but the type was unknown. "), 
			};
			((MsalException)obj).PopulateObjectFromJson(jObject);
			return (MsalException)obj;
		}
	}
	[Obsolete("MsalManagedIdentityException is deprecated and will be removed in a future release. Catch MsalServiceException instead.", true)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public class MsalManagedIdentityException : MsalServiceException
	{
		public new ManagedIdentitySource ManagedIdentitySource { get; }

		public MsalManagedIdentityException(string errorCode, string errorMessage, ManagedIdentitySource source)
			: this(errorCode, errorMessage, null, source)
		{
		}

		public MsalManagedIdentityException(string errorCode, string errorMessage, ManagedIdentitySource source, int statusCode)
			: this(errorCode, errorMessage, null, source, statusCode)
		{
		}

		public MsalManagedIdentityException(string errorCode, string errorMessage, Exception innerException, ManagedIdentitySource source, int statusCode)
			: this(errorCode, errorMessage, innerException, source)
		{
			base.StatusCode = statusCode;
		}

		public MsalManagedIdentityException(string errorCode, string errorMessage, Exception innerException, ManagedIdentitySource source)
			: base(errorCode, errorMessage, innerException)
		{
			ManagedIdentitySource = source;
		}

		protected override void UpdateIsRetryable()
		{
			switch (base.StatusCode)
			{
			case 404:
			case 408:
			case 429:
			case 500:
			case 503:
			case 504:
				base.IsRetryable = true;
				break;
			default:
				base.IsRetryable = false;
				break;
			}
		}
	}
	public class MsalServiceException : MsalException
	{
		private const string ClaimsKey = "claims";

		private const string ResponseBodyKey = "response_body";

		private const string CorrelationIdKey = "correlation_id";

		private const string SubErrorKey = "sub_error";

		private int _statusCode;

		private string _responseBody;

		private HttpResponseHeaders _headers;

		public int StatusCode
		{
			get
			{
				return _statusCode;
			}
			internal set
			{
				_statusCode = value;
				UpdateIsRetryable();
			}
		}

		public string Claims { get; internal set; }

		public string ResponseBody
		{
			get
			{
				return _responseBody;
			}
			set
			{
				_responseBody = value;
				UpdateIsRetryable();
			}
		}

		public HttpResponseHeaders Headers
		{
			get
			{
				return _headers;
			}
			set
			{
				_headers = value;
				UpdateIsRetryable();
			}
		}

		internal string SubError { get; set; }

		internal string[] ErrorCodes { get; set; }

		public MsalServiceException(string errorCode, string errorMessage)
			: base(errorCode, errorMessage)
		{
			if (string.IsNullOrWhiteSpace(errorMessage))
			{
				throw new ArgumentNullException("errorMessage");
			}
			UpdateIsRetryable();
		}

		public MsalServiceException(string errorCode, string errorMessage, int statusCode)
			: this(errorCode, errorMessage)
		{
			StatusCode = statusCode;
		}

		public MsalServiceException(string errorCode, string errorMessage, Exception innerException)
			: base(errorCode, errorMessage, innerException)
		{
			UpdateIsRetryable();
		}

		public MsalServiceException(string errorCode, string errorMessage, int statusCode, Exception innerException)
			: base(errorCode, errorMessage, innerException)
		{
			StatusCode = statusCode;
			UpdateIsRetryable();
		}

		public MsalServiceException(string errorCode, string errorMessage, int statusCode, string claims, Exception innerException)
			: this(errorCode, errorMessage, statusCode, innerException)
		{
			Claims = claims;
		}

		protected virtual void UpdateIsRetryable()
		{
			base.IsRetryable = (StatusCode >= 500 && StatusCode < 600) || StatusCode == 429 || StatusCode == 408 || string.Equals(base.ErrorCode, "request_timeout", StringComparison.OrdinalIgnoreCase) || string.Equals(base.ErrorCode, "temporarily_unavailable", StringComparison.OrdinalIgnoreCase);
		}

		public override string ToString()
		{
			return base.ToString() + string.Format(CultureInfo.InvariantCulture, "\n\tStatusCode: {0} \n\tResponseBody: {1} \n\tHeaders: {2}", StatusCode, ResponseBody, Headers);
		}

		internal override void PopulateJson(JObject jObject)
		{
			base.PopulateJson(jObject);
			jObject["claims"] = Claims;
			jObject["response_body"] = ResponseBody;
			jObject["correlation_id"] = base.CorrelationId;
			jObject["sub_error"] = SubError;
		}

		internal override void PopulateObjectFromJson(JObject jObject)
		{
			base.PopulateObjectFromJson(jObject);
			Claims = JsonHelper.GetExistingOrEmptyString(jObject, "claims");
			ResponseBody = JsonHelper.GetExistingOrEmptyString(jObject, "response_body");
			base.CorrelationId = JsonHelper.GetExistingOrEmptyString(jObject, "correlation_id");
			SubError = JsonHelper.GetExistingOrEmptyString(jObject, "sub_error");
		}
	}
	internal class MsalServiceExceptionFactory
	{
		private static readonly ISet<string> s_nonUiSubErrors = new HashSet<string>(new string[2] { "client_mismatch", "protection_policy_required" }, StringComparer.OrdinalIgnoreCase);

		internal static MsalServiceException FromHttpResponse(string errorCode, string errorMessage, HttpResponse httpResponse, Exception innerException = null)
		{
			MsalServiceException ex = null;
			OAuth2ResponseBase oAuth2ResponseBase = JsonHelper.TryToDeserializeFromJson<OAuth2ResponseBase>(httpResponse?.Body);
			if (IsInvalidGrant(oAuth2ResponseBase?.Error, oAuth2ResponseBase?.SubError) || IsInteractionRequired(oAuth2ResponseBase?.Error))
			{
				string text = null;
				text = ((!IsThrottled(oAuth2ResponseBase)) ? errorMessage : "Your app has been throttled by AAD due to too many requests. To avoid this, cache your tokens see https://aka.ms/msal-net-throttling.");
				if (oAuth2ResponseBase.Claims == null)
				{
					ex = new MsalUiRequiredException(errorCode, text, innerException);
				}
				else
				{
					text += " The returned error contains a claims challenge. For additional info on how to handle claims related to multifactor authentication, Conditional Access, and incremental consent, see https://aka.ms/msal-conditional-access-claims. If you are using the On-Behalf-Of flow, see https://aka.ms/msal-conditional-access-claims-obo for details.";
					ex = new MsalClaimsChallengeException(errorCode, text, innerException);
				}
			}
			if (string.Equals(oAuth2ResponseBase?.Error, "invalid_client", StringComparison.OrdinalIgnoreCase))
			{
				ex = new MsalServiceException("invalid_client", "A configuration issue is preventing authentication - check the error message from the server for details. You can modify the configuration in the application registration portal. See https://aka.ms/msal-net-invalid-client for details.  Original exception: " + oAuth2ResponseBase?.ErrorDescription, innerException);
			}
			if (ex == null)
			{
				ex = new MsalServiceException(errorCode, errorMessage, innerException);
			}
			SetHttpExceptionData(ex, httpResponse);
			ex.Claims = oAuth2ResponseBase?.Claims;
			ex.CorrelationId = oAuth2ResponseBase?.CorrelationId;
			ex.SubError = oAuth2ResponseBase?.SubError;
			ex.ErrorCodes = oAuth2ResponseBase?.ErrorCodes;
			return ex;
		}

		private static bool IsThrottled(OAuth2ResponseBase oAuth2Response)
		{
			if (oAuth2Response.ErrorDescription != null)
			{
				return oAuth2Response.ErrorDescription.StartsWith("AADSTS50196");
			}
			return false;
		}

		internal static MsalServiceException FromBrokerResponse(MsalTokenResponse msalTokenResponse, string errorMessage)
		{
			string error = msalTokenResponse.Error;
			string correlationId = msalTokenResponse.CorrelationId;
			string text = (string.IsNullOrEmpty(msalTokenResponse.SubError) ? "unknown_broker_error" : msalTokenResponse.SubError);
			HttpResponse httpResponse = msalTokenResponse.HttpResponse;
			MsalServiceException ex = null;
			if (IsAppProtectionPolicyRequired(error, text))
			{
				ex = new IntuneAppProtectionPolicyRequiredException(error, text)
				{
					Upn = msalTokenResponse.Upn,
					AuthorityUrl = msalTokenResponse.AuthorityUrl,
					TenantId = msalTokenResponse.TenantId,
					AccountUserId = msalTokenResponse.AccountUserId
				};
			}
			if (IsInvalidGrant(error, text) || IsInteractionRequired(error))
			{
				ex = new MsalUiRequiredException(error, errorMessage);
			}
			if (string.Equals(error, "invalid_client", StringComparison.OrdinalIgnoreCase))
			{
				ex = new MsalServiceException("invalid_client", "A configuration issue is preventing authentication - check the error message from the server for details. You can modify the configuration in the application registration portal. See https://aka.ms/msal-net-invalid-client for details.  Original exception: " + errorMessage);
			}
			if (ex == null)
			{
				ex = new MsalServiceException(error, errorMessage);
			}
			SetHttpExceptionData(ex, httpResponse);
			ex.CorrelationId = correlationId;
			ex.SubError = text;
			return ex;
		}

		internal static MsalServiceException FromImdsResponse(string errorCode, string errorMessage, HttpResponse httpResponse, Exception innerException = null)
		{
			MsalServiceException ex = new MsalServiceException(errorCode, errorMessage, innerException);
			SetHttpExceptionData(ex, httpResponse);
			return ex;
		}

		internal static MsalException CreateManagedIdentityException(string errorCode, string errorMessage, Exception innerException, ManagedIdentitySource managedIdentitySource, int? statusCode)
		{
			MsalException ex;
			if (!statusCode.HasValue)
			{
				ex = ((innerException == null) ? new MsalServiceException(errorCode, errorMessage) : new MsalServiceException(errorCode, errorMessage, innerException));
			}
			else
			{
				ex = new MsalServiceException(errorCode, errorMessage, statusCode.Value, innerException);
				bool flag;
				switch (statusCode)
				{
				case 404:
				case 408:
				case 429:
				case 500:
				case 503:
				case 504:
					flag = true;
					break;
				default:
					flag = false;
					break;
				}
				bool isRetryable = flag;
				ex.IsRetryable = isRetryable;
			}
			return DecorateExceptionWithManagedIdentitySource(ex, managedIdentitySource);
		}

		private static MsalException DecorateExceptionWithManagedIdentitySource(MsalException exception, ManagedIdentitySource managedIdentitySource)
		{
			Dictionary<string, string> additionalExceptionData = new Dictionary<string, string> { 
			{
				"ManagedIdentitySource",
				managedIdentitySource.ToString()
			} };
			exception.AdditionalExceptionData = additionalExceptionData;
			return exception;
		}

		internal static MsalThrottledServiceException FromThrottledAuthenticationResponse(HttpResponse httpResponse)
		{
			MsalServiceException ex = new MsalServiceException("request_throttled", "Your app has been throttled by AAD due to too many requests. To avoid this, cache your tokens see https://aka.ms/msal-net-throttling.");
			SetHttpExceptionData(ex, httpResponse);
			return new MsalThrottledServiceException(ex);
		}

		private static void SetHttpExceptionData(MsalServiceException ex, HttpResponse httpResponse)
		{
			ex.ResponseBody = httpResponse?.Body;
			ex.StatusCode = (int)(httpResponse?.StatusCode ?? ((HttpStatusCode)0));
			ex.Headers = httpResponse?.Headers;
		}

		private static bool IsInteractionRequired(string errorCode)
		{
			return string.Equals(errorCode, "interaction_required", StringComparison.OrdinalIgnoreCase);
		}

		private static bool IsInvalidGrant(string errorCode, string subErrorCode)
		{
			if (string.Equals(errorCode, "invalid_grant", StringComparison.OrdinalIgnoreCase))
			{
				return IsInvalidGrantSubError(subErrorCode);
			}
			return false;
		}

		private static bool IsAppProtectionPolicyRequired(string errorCode, string subErrorCode)
		{
			return false;
		}

		private static bool IsInvalidGrantSubError(string subError)
		{
			if (string.IsNullOrEmpty(subError))
			{
				return true;
			}
			return !s_nonUiSubErrors.Contains(subError);
		}
	}
	public class MsalThrottledServiceException : MsalServiceException
	{
		public MsalServiceException OriginalServiceException { get; }

		public MsalThrottledServiceException(MsalServiceException originalException)
			: base(originalException.ErrorCode, originalException.Message, originalException.InnerException)
		{
			base.SubError = originalException.SubError;
			base.StatusCode = originalException.StatusCode;
			base.Claims = originalException.Claims;
			base.CorrelationId = originalException.CorrelationId;
			base.ResponseBody = originalException.ResponseBody;
			base.Headers = originalException.Headers;
			OriginalServiceException = originalException;
		}
	}
	public class MsalThrottledUiRequiredException : MsalUiRequiredException
	{
		public MsalUiRequiredException OriginalServiceException { get; }

		public MsalThrottledUiRequiredException(MsalUiRequiredException originalException)
			: base(originalException.ErrorCode, originalException.Message, originalException.InnerException, originalException.Classification)
		{
			base.SubError = originalException.SubError;
			base.StatusCode = originalException.StatusCode;
			base.Claims = originalException.Claims;
			base.CorrelationId = originalException.CorrelationId;
			base.ResponseBody = originalException.ResponseBody;
			base.Headers = originalException.Headers;
			OriginalServiceException = originalException;
		}
	}
	public class MsalUiRequiredException : MsalServiceException
	{
		private readonly UiRequiredExceptionClassification _classification;

		public UiRequiredExceptionClassification Classification
		{
			get
			{
				if (string.Equals(base.SubError, "basic_action", StringComparison.OrdinalIgnoreCase))
				{
					return UiRequiredExceptionClassification.BasicAction;
				}
				if (string.Equals(base.SubError, "additional_action", StringComparison.OrdinalIgnoreCase))
				{
					return UiRequiredExceptionClassification.AdditionalAction;
				}
				if (string.Equals(base.SubError, "message_only", StringComparison.OrdinalIgnoreCase))
				{
					return UiRequiredExceptionClassification.MessageOnly;
				}
				if (string.Equals(base.SubError, "consent_required", StringComparison.OrdinalIgnoreCase))
				{
					return UiRequiredExceptionClassification.ConsentRequired;
				}
				if (string.Equals(base.SubError, "user_password_expired", StringComparison.OrdinalIgnoreCase))
				{
					return UiRequiredExceptionClassification.UserPasswordExpired;
				}
				return _classification;
			}
		}

		public MsalUiRequiredException(string errorCode, string errorMessage)
			: this(errorCode, errorMessage, null)
		{
		}

		public MsalUiRequiredException(string errorCode, string errorMessage, Exception innerException)
			: this(errorCode, errorMessage, innerException, UiRequiredExceptionClassification.None)
		{
		}

		public MsalUiRequiredException(string errorCode, string errorMessage, Exception innerException, UiRequiredExceptionClassification classification)
			: base(errorCode, errorMessage, innerException)
		{
			_classification = classification;
		}
	}
	public static class OsCapabilitiesExtensions
	{
		public static bool IsSystemWebViewAvailable(this IPublicClientApplication publicClientApplication)
		{
			if (publicClientApplication is PublicClientApplication publicClientApplication2)
			{
				return publicClientApplication2.IsSystemWebViewAvailable;
			}
			throw new ArgumentException("This extension method is only available for the PublicClientApplication implementation of the IPublicClientApplication interface.");
		}

		public static bool IsEmbeddedWebViewAvailable(this IPublicClientApplication publicClientApplication)
		{
			if (publicClientApplication is PublicClientApplication publicClientApplication2)
			{
				return publicClientApplication2.IsEmbeddedWebViewAvailable();
			}
			throw new ArgumentException("This extension method is only available for the PublicClientApplication implementation of the IPublicClientApplication interface.");
		}

		public static bool IsUserInteractive(this IPublicClientApplication publicClientApplication)
		{
			if (publicClientApplication is PublicClientApplication publicClientApplication2)
			{
				return publicClientApplication2.IsUserInteractive();
			}
			throw new ArgumentException("This extension method is only available for the PublicClientApplication implementation of the IPublicClientApplication interface.");
		}

		public static X509Certificate2 GetCertificate(this IConfidentialClientApplication confidentialClientApplication)
		{
			if (confidentialClientApplication is ConfidentialClientApplication confidentialClientApplication2)
			{
				return confidentialClientApplication2.Certificate;
			}
			throw new ArgumentException("This extension method is only available for the ConfidentialClientApplication implementation of the IConfidentialClientApplication interface.");
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal class PreserveAttribute : Attribute
	{
		public bool Conditional;

		public bool AllMembers;
	}
	public struct Prompt
	{
		public static readonly Prompt SelectAccount = new Prompt("select_account");

		public static readonly Prompt ForceLogin = new Prompt("login");

		public static readonly Prompt Consent = new Prompt("consent");

		public static readonly Prompt NoPrompt = new Prompt("no_prompt");

		public static readonly Prompt Create = new Prompt("create");

		internal static readonly Prompt NotSpecified = new Prompt("not_specified");

		internal string PromptValue { get; }

		private Prompt(string promptValue)
		{
			PromptValue = promptValue;
		}

		public override bool Equals(object obj)
		{
			if (obj is Prompt prompt)
			{
				return this == prompt;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return PromptValue.GetHashCode();
		}

		public static bool operator ==(Prompt x, Prompt y)
		{
			return x.PromptValue == y.PromptValue;
		}

		public static bool operator !=(Prompt x, Prompt y)
		{
			return !(x == y);
		}
	}
	internal static class KeyTokens
	{
		public const string MSAL = ", PublicKey=00240000048000009400000006020000002400005253413100040000010001002d96616729b54f6d013d71559a017f50aa4861487226c523959d1579b93f3fdf71c08b980fd3130062b03d3de115c4b84e7ac46aef5e192a40e7457d5f3a08f66ceab71143807f2c3cb0da5e23b38f0559769978406f6e5d30ceadd7985fc73a5a609a8b74a1df0a29399074a003a226c943d480fec96dbec7106a87896539ad";
	}
	public class RegionDetails
	{
		public RegionOutcome RegionOutcome { get; }

		public string RegionUsed { get; }

		public string AutoDetectionError { get; }

		public RegionDetails(RegionOutcome regionOutcome, string regionUsed, string autoDetectionError)
		{
			RegionOutcome = regionOutcome;
			RegionUsed = regionUsed;
			AutoDetectionError = autoDetectionError;
		}
	}
	internal delegate void TelemetryCallback(List<Dictionary<string, string>> events);
	public class TenantProfile
	{
		private readonly MsalIdTokenCacheItem _msalIdTokenCacheItem;

		public string Oid => _msalIdTokenCacheItem?.IdToken.ObjectId;

		public string TenantId => _msalIdTokenCacheItem?.IdToken.TenantId;

		public ClaimsPrincipal ClaimsPrincipal => _msalIdTokenCacheItem?.IdToken.ClaimsPrincipal;

		public bool IsHomeTenant => string.Equals(AccountId.ParseFromString(_msalIdTokenCacheItem?.HomeAccountId).TenantId, _msalIdTokenCacheItem?.IdToken.TenantId, StringComparison.OrdinalIgnoreCase);

		internal TenantProfile(MsalIdTokenCacheItem msalIdTokenCacheItem)
		{
			_msalIdTokenCacheItem = msalIdTokenCacheItem;
		}
	}
	public static class TokenCacheExtensions
	{
		public static void SetCacheOptions(this ITokenCache tokenCache, CacheOptions options)
		{
			ValidatePlatform();
			TokenCache obj = (TokenCache)tokenCache;
			ITokenCacheInternal tokenCacheInternal = (ITokenCacheInternal)tokenCache;
			obj.ServiceBundle.Config.AccessorOptions = options;
			if (tokenCacheInternal.IsAppSubscribedToSerializationEvents())
			{
				throw new MsalClientException("static_cache_with_external_serialization", "You configured MSAL cache serialization at the same time with internal caching options. These are mutually exclusive. Use only one option. Web site and web api scenarios should rely on external cache serialization, as internal cache serialization cannot scale. See https://aka.ms/msal-net-token-cache-serialization .");
			}
			IPlatformProxy platformProxy = obj.ServiceBundle?.PlatformProxy ?? PlatformProxyFactory.CreatePlatformProxy(null);
			obj.Accessor = platformProxy.CreateTokenCacheAccessor(options, tokenCacheInternal.IsApplicationCache);
		}

		private static void ValidatePlatform()
		{
		}
	}
	internal static class TokenResponseHelper
	{
		internal const string NullPreferredUsernameDisplayLabel = "Missing from the token response";

		public static string GetTenantId(IdToken idToken, AuthenticationRequestParameters requestParams)
		{
			return Authority.CreateAuthorityWithTenant(requestParams.Authority.AuthorityInfo, idToken?.TenantId).TenantId;
		}

		public static string GetUsernameFromIdToken(IdToken idToken)
		{
			if (idToken == null)
			{
				return "Missing from the token response";
			}
			return idToken.PreferredUsername.NullIfWhiteSpace() ?? idToken.Upn.NullIfWhiteSpace() ?? idToken.Email.NullIfWhiteSpace() ?? idToken.Name.NullIfWhiteSpace() ?? "Missing from the token response";
		}

		public static string GetHomeAccountId(AuthenticationRequestParameters requestParams, MsalTokenResponse response, IdToken idToken)
		{
			string obj = ((response.ClientInfo != null) ? ClientInfo.CreateFromJson(response.ClientInfo) : null)?.ToAccountIdentifier() ?? idToken?.Subject;
			if (obj == null)
			{
				requestParams.RequestContext.Logger.Info("Cannot determine home account ID - or id token or no client info and no subject ");
			}
			return obj;
		}

		public static Dictionary<string, string> GetWamAccountIds(AuthenticationRequestParameters requestParams, MsalTokenResponse response)
		{
			if (!string.IsNullOrEmpty(response.WamAccountId))
			{
				return new Dictionary<string, string> { 
				{
					requestParams.AppConfig.ClientId,
					response.WamAccountId
				} };
			}
			return new Dictionary<string, string>();
		}
	}
	public enum TokenSource
	{
		IdentityProvider,
		Cache,
		Broker
	}
	public enum UiRequiredExceptionClassification
	{
		None,
		MessageOnly,
		BasicAction,
		AdditionalAction,
		ConsentRequired,
		UserPasswordExpired,
		PromptNeverFailed,
		AcquireTokenSilentFailed
	}
	public sealed class UserAssertion
	{
		public string Assertion { get; private set; }

		public string AssertionType { get; private set; }

		internal string AssertionHash { get; set; }

		public UserAssertion(string jwtBearerToken)
			: this(jwtBearerToken, "urn:ietf:params:oauth:grant-type:jwt-bearer")
		{
		}

		public UserAssertion(string assertion, string assertionType)
		{
			if (string.IsNullOrWhiteSpace(assertion))
			{
				throw new ArgumentNullException("assertion");
			}
			if (string.IsNullOrWhiteSpace(assertionType))
			{
				throw new ArgumentNullException("assertionType");
			}
			ICryptographyManager cryptographyManager = PlatformProxyFactory.CreatePlatformProxy(null).CryptographyManager;
			AssertionType = assertionType;
			Assertion = assertion;
			AssertionHash = cryptographyManager.CreateBase64UrlEncodedSha256Hash(Assertion);
		}
	}
	public class WwwAuthenticateParameters
	{
		private static readonly ISet<string> s_knownAuthenticationSchemes = new HashSet<string>(new string[2] { "Bearer", "PoP" }, StringComparer.OrdinalIgnoreCase);

		[Obsolete("The client apps should know which App ID URI it requests scopes for.", true)]
		public string Resource { get; set; }

		[Obsolete("The client apps should know which scopes to request for.", true)]
		public IEnumerable<string> Scopes { get; set; }

		public string Authority { get; set; }

		public string Claims { get; set; }

		public string Error { get; set; }

		public string AuthenticationScheme { get; private set; }

		public string Nonce { get; private set; }

		public string this[string key] => RawParameters[key];

		internal IDictionary<string, string> RawParameters { get; private set; }

		public string GetTenantId()
		{
			return Microsoft.Identity.Client.Instance.Authority.CreateAuthority(Authority, validateAuthority: true)?.TenantId;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This api is now obsolete and has been replaced with CreateFromAuthenticationResponseAsync(...)")]
		public static Task<WwwAuthenticateParameters> CreateFromResourceResponseAsync(string resourceUri)
		{
			return CreateFromResourceResponseAsync(resourceUri, default(CancellationToken));
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This api is now obsolete and has been replaced with CreateFromAuthenticationResponseAsync(...)")]
		public static Task<WwwAuthenticateParameters> CreateFromResourceResponseAsync(string resourceUri, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateFromResourceResponseAsync(AuthenticationHeaderParser.GetHttpClient(), resourceUri, cancellationToken);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This api is now obsolete and has been replaced with replaced with CreateFromAuthenticationResponseAsync(HttpResponseHeaders, string)")]
		public static async Task<WwwAuthenticateParameters> CreateFromResourceResponseAsync(HttpClient httpClient, string resourceUri, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (httpClient == null)
			{
				throw new ArgumentNullException("httpClient");
			}
			if (string.IsNullOrWhiteSpace(resourceUri))
			{
				throw new ArgumentNullException("resourceUri");
			}
			return CreateFromResponseHeaders((await httpClient.GetAsync(resourceUri, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Headers);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This api is now obsolete and has been replaced with CreateFromAuthenticationHeaders(...)")]
		public static WwwAuthenticateParameters CreateFromResponseHeaders(HttpResponseHeaders httpResponseHeaders, string scheme = "Bearer")
		{
			if (httpResponseHeaders.WwwAuthenticate.Any())
			{
				AuthenticationHeaderValue authenticationHeaderValue = httpResponseHeaders.WwwAuthenticate.FirstOrDefault((AuthenticationHeaderValue v) => string.Equals(v.Scheme, scheme, StringComparison.OrdinalIgnoreCase));
				if (authenticationHeaderValue != null)
				{
					WwwAuthenticateParameters wwwAuthenticateParameters = CreateFromWwwAuthenticateHeaderValue(authenticationHeaderValue.Parameter);
					wwwAuthenticateParameters.AuthenticationScheme = scheme;
					return wwwAuthenticateParameters;
				}
			}
			return CreateWwwAuthenticateParameters(new Dictionary<string, string>(), string.Empty);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("This api is now obsolete and should not be used.")]
		public static WwwAuthenticateParameters CreateFromWwwAuthenticateHeaderValue(string wwwAuthenticateValue)
		{
			return CreateFromWwwAuthenticationHeaderValue(wwwAuthenticateValue, string.Empty);
		}

		public static Task<WwwAuthenticateParameters> CreateFromAuthenticationResponseAsync(string resourceUri, string scheme, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateFromAuthenticationResponseAsync(resourceUri, scheme, AuthenticationHeaderParser.GetHttpClient(), cancellationToken);
		}

		public static async Task<WwwAuthenticateParameters> CreateFromAuthenticationResponseAsync(string resourceUri, string scheme, HttpClient httpClient, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (httpClient == null)
			{
				throw new ArgumentNullException("httpClient");
			}
			if (string.IsNullOrWhiteSpace(resourceUri))
			{
				throw new ArgumentNullException("resourceUri");
			}
			return CreateFromAuthenticationHeaders((await httpClient.GetAsync(resourceUri, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Headers, scheme);
		}

		public static WwwAuthenticateParameters CreateFromAuthenticationHeaders(HttpResponseHeaders httpResponseHeaders, string scheme)
		{
			AuthenticationHeaderValue authenticationHeaderValue = httpResponseHeaders.WwwAuthenticate.FirstOrDefault((AuthenticationHeaderValue v) => string.Equals(v.Scheme, scheme, StringComparison.OrdinalIgnoreCase));
			if (authenticationHeaderValue != null)
			{
				string parameter = authenticationHeaderValue.Parameter;
				try
				{
					return CreateFromWwwAuthenticationHeaderValue(parameter, scheme);
				}
				catch (Exception ex)
				{
					if (ex is MsalException)
					{
						throw;
					}
					throw new MsalClientException("unable_to_parse_authentication_header", "MSAL is unable to parse the authentication header returned from the resource endpoint. This can be a result of a malformed header returned in either the WWW-Authenticate or the Authentication-Info collections acquired from the provided endpoint." + $"Response Headers: {httpResponseHeaders} See inner exception for details.", ex);
				}
			}
			return CreateWwwAuthenticateParameters(new Dictionary<string, string>(), string.Empty);
		}

		public static Task<IReadOnlyList<WwwAuthenticateParameters>> CreateFromAuthenticationResponseAsync(string resourceUri, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateFromAuthenticationResponseAsync(resourceUri, AuthenticationHeaderParser.GetHttpClient(), cancellationToken);
		}

		public static async Task<IReadOnlyList<WwwAuthenticateParameters>> CreateFromAuthenticationResponseAsync(string resourceUri, HttpClient httpClient, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (httpClient == null)
			{
				throw new ArgumentNullException("httpClient");
			}
			if (string.IsNullOrWhiteSpace(resourceUri))
			{
				throw new ArgumentNullException("resourceUri");
			}
			return CreateFromAuthenticationHeaders((await httpClient.GetAsync(resourceUri, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Headers);
		}

		public static IReadOnlyList<WwwAuthenticateParameters> CreateFromAuthenticationHeaders(HttpResponseHeaders httpResponseHeaders)
		{
			List<WwwAuthenticateParameters> list = new List<WwwAuthenticateParameters>();
			foreach (AuthenticationHeaderValue item2 in httpResponseHeaders.WwwAuthenticate)
			{
				try
				{
					WwwAuthenticateParameters item = CreateFromWwwAuthenticationHeaderValue(item2.Parameter, item2.Scheme);
					list.Add(item);
				}
				catch (Exception ex) when (!(ex is MsalException))
				{
					throw new MsalClientException("unable_to_parse_authentication_header", "MSAL is unable to parse the authentication header returned from the resource endpoint. This can be a result of a malformed header returned in either the WWW-Authenticate or the Authentication-Info collections acquired from the provided endpoint. See inner exception for details.", ex);
				}
			}
			return list;
		}

		public static string GetClaimChallengeFromResponseHeaders(HttpResponseHeaders httpResponseHeaders, string scheme = "Bearer")
		{
			WwwAuthenticateParameters wwwAuthenticateParameters = CreateFromAuthenticationHeaders(httpResponseHeaders, scheme);
			if (wwwAuthenticateParameters.Claims != null && string.Equals(wwwAuthenticateParameters.Error, "insufficient_claims", StringComparison.OrdinalIgnoreCase))
			{
				return wwwAuthenticateParameters.Claims;
			}
			return null;
		}

		private static WwwAuthenticateParameters CreateFromWwwAuthenticationHeaderValue(string wwwAuthenticateValue, string scheme)
		{
			IDictionary<string, string> values = null;
			if (!string.IsNullOrWhiteSpace(wwwAuthenticateValue))
			{
				values = (from v in GetParsedAuthValueElements(wwwAuthenticateValue)
					select AuthenticationHeaderParser.CreateKeyValuePair(v.Trim(), scheme)).ToDictionary((KeyValuePair<string, string> pair) => pair.Key, (KeyValuePair<string, string> pair) => pair.Value, StringComparer.OrdinalIgnoreCase);
			}
			return CreateWwwAuthenticateParameters(values, scheme);
		}

		private static IEnumerable<string> GetParsedAuthValueElements(string wwwAuthenticateValue)
		{
			char[] charsToTrim = new char[2] { ',', ' ' };
			IReadOnlyList<string> readOnlyList = CoreHelpers.SplitWithQuotes(wwwAuthenticateValue, ' ');
			if (s_knownAuthenticationSchemes.Contains(readOnlyList[0]))
			{
				readOnlyList = readOnlyList.Skip(1).ToList();
			}
			return readOnlyList.Select((string authValue) => authValue.TrimEnd(charsToTrim));
		}

		internal static WwwAuthenticateParameters CreateWwwAuthenticateParameters(IDictionary<string, string> values, string scheme)
		{
			WwwAuthenticateParameters wwwAuthenticateParameters = new WwwAuthenticateParameters();
			wwwAuthenticateParameters.AuthenticationScheme = scheme;
			if (values == null)
			{
				wwwAuthenticateParameters.RawParameters = new Dictionary<string, string>();
				return wwwAuthenticateParameters;
			}
			wwwAuthenticateParameters.RawParameters = values;
			if (values.TryGetValue("authorization_uri", out var value))
			{
				wwwAuthenticateParameters.Authority = value.Replace("/v2.0", string.Empty).Replace("/oauth2/authorize", string.Empty);
			}
			if (string.IsNullOrEmpty(wwwAuthenticateParameters.Authority) && values.TryGetValue("authorization", out value))
			{
				wwwAuthenticateParameters.Authority = value.Replace("/v2.0", string.Empty).Replace("/oauth2/authorize", string.Empty);
			}
			if (string.IsNullOrEmpty(wwwAuthenticateParameters.Authority) && values.TryGetValue("authority", out value))
			{
				wwwAuthenticateParameters.Authority = value.TrimEnd(new char[1] { '/' });
			}
			if (values.TryGetValue("claims", out value))
			{
				wwwAuthenticateParameters.Claims = GetJsonFragment(value);
			}
			if (values.TryGetValue("error", out value))
			{
				wwwAuthenticateParameters.Error = value;
			}
			if (values.TryGetValue("nonce", out value))
			{
				wwwAuthenticateParameters.Nonce = value;
			}
			return wwwAuthenticateParameters;
		}

		private static string GetJsonFragment(string inputString)
		{
			if (string.IsNullOrEmpty(inputString) || inputString.Length % 4 != 0 || inputString.Any(char.IsWhiteSpace))
			{
				return inputString;
			}
			try
			{
				byte[] bytes = Convert.FromBase64String(inputString);
				return Encoding.UTF8.GetString(bytes);
			}
			catch
			{
				return inputString;
			}
		}
	}
}
namespace Microsoft.Identity.Client.Platforms.Features.OpenTelemetry
{
	internal class OtelInstrumentation : IOtelInstrumentation
	{
		public const string MeterName = "MicrosoftIdentityClient_Common_Meter";

		private const string SuccessCounterName = "MsalSuccess";

		private const string FailedCounterName = "MsalFailure";

		private const string TotalDurationHistogramName = "MsalTotalDuration.1A";

		private const string DurationInL1CacheHistogramName = "MsalDurationInL1CacheInUs.1B";

		private const string DurationInL2CacheHistogramName = "MsalDurationInL2Cache.1A";

		private const string DurationInHttpHistogramName = "MsalDurationInHttp.1A";

		internal static readonly Meter Meter = new Meter("MicrosoftIdentityClient_Common_Meter", "1.0.0");

		internal static readonly Lazy<Counter<long>> s_successCounter = new Lazy<Counter<long>>(() => Meter.CreateCounter<long>("MsalSuccess", null, "Number of successful token acquisition calls"));

		internal static readonly Lazy<Counter<long>> s_failureCounter = new Lazy<Counter<long>>(() => Meter.CreateCounter<long>("MsalFailure", null, "Number of failed token acquisition calls"));

		internal static readonly Lazy<Histogram<long>> s_durationTotal = new Lazy<Histogram<long>>(() => Meter.CreateHistogram<long>("MsalTotalDuration.1A", "ms", "Performance of token acquisition calls total latency"));

		internal static readonly Lazy<Histogram<long>> s_durationInL1CacheInUs = new Lazy<Histogram<long>>(() => Meter.CreateHistogram<long>("MsalDurationInL1CacheInUs.1B", "us", "Performance of token acquisition calls total latency in microseconds when L1 cache is used."));

		internal static readonly Lazy<Histogram<long>> s_durationInL2Cache = new Lazy<Histogram<long>>(() => Meter.CreateHistogram<long>("MsalDurationInL2Cache.1A", "ms", "Performance of token acquisition calls cache latency"));

		internal static readonly Lazy<Histogram<long>> s_durationInHttp = new Lazy<Histogram<long>>(() => Meter.CreateHistogram<long>("MsalDurationInHttp.1A", "ms", "Performance of token acquisition calls network latency"));

		public OtelInstrumentation()
		{
			_ = Meter.Version;
		}

		public void LogSuccessMetrics(string platform, ApiEvent.ApiIds apiId, CacheLevel cacheLevel, long totalDurationInUs, AuthenticationResultMetadata authResultMetadata, ILoggerAdapter logger)
		{
			IncrementSuccessCounter(platform, apiId, authResultMetadata.TokenSource, authResultMetadata.CacheRefreshReason, cacheLevel, logger);
			if (s_durationTotal.Value.Enabled)
			{
				s_durationTotal.Value.Record(authResultMetadata.DurationTotalInMs, new KeyValuePair<string, object>("MsalVersion", MsalIdHelper.GetMsalVersion()), new KeyValuePair<string, object>("Platform", platform), new KeyValuePair<string, object>("ApiId", apiId), new KeyValuePair<string, object>("TokenSource", authResultMetadata.TokenSource), new KeyValuePair<string, object>("CacheLevel", cacheLevel), new KeyValuePair<string, object>("CacheRefreshReason", authResultMetadata.CacheRefreshReason));
			}
			if (s_durationInL2Cache.Value.Enabled && cacheLevel == CacheLevel.L2Cache)
			{
				s_durationInL2Cache.Value.Record(authResultMetadata.DurationInCacheInMs, new KeyValuePair<string, object>("MsalVersion", MsalIdHelper.GetMsalVersion()), new KeyValuePair<string, object>("Platform", platform), new KeyValuePair<string, object>("ApiId", apiId), new KeyValuePair<string, object>("CacheRefreshReason", authResultMetadata.CacheRefreshReason));
			}
			if (s_durationInHttp.Value.Enabled && authResultMetadata.TokenSource == TokenSource.IdentityProvider)
			{
				s_durationInHttp.Value.Record(authResultMetadata.DurationInHttpInMs, new KeyValuePair<string, object>("MsalVersion", MsalIdHelper.GetMsalVersion()), new KeyValuePair<string, object>("Platform", platform), new KeyValuePair<string, object>("ApiId", apiId));
			}
			if (s_durationInL1CacheInUs.Value.Enabled && authResultMetadata.TokenSource == TokenSource.Cache && authResultMetadata.CacheLevel.Equals(CacheLevel.L1Cache))
			{
				s_durationInL1CacheInUs.Value.Record(totalDurationInUs, new KeyValuePair<string, object>("MsalVersion", MsalIdHelper.GetMsalVersion()), new KeyValuePair<string, object>("Platform", platform), new KeyValuePair<string, object>("ApiId", apiId), new KeyValuePair<string, object>("TokenSource", authResultMetadata.TokenSource), new KeyValuePair<string, object>("CacheLevel", authResultMetadata.CacheLevel), new KeyValuePair<string, object>("CacheRefreshReason", authResultMetadata.CacheRefreshReason));
			}
		}

		public void IncrementSuccessCounter(string platform, ApiEvent.ApiIds apiId, TokenSource tokenSource, CacheRefreshReason cacheRefreshReason, CacheLevel cacheLevel, ILoggerAdapter logger)
		{
			if (s_successCounter.Value.Enabled)
			{
				s_successCounter.Value.Add(1L, new KeyValuePair<string, object>("MsalVersion", MsalIdHelper.GetMsalVersion()), new KeyValuePair<string, object>("Platform", platform), new KeyValuePair<string, object>("ApiId", apiId), new KeyValuePair<string, object>("TokenSource", tokenSource), new KeyValuePair<string, object>("CacheRefreshReason", cacheRefreshReason), new KeyValuePair<string, object>("CacheLevel", cacheLevel));
				logger.Verbose(() => "[OpenTelemetry] Completed incrementing to success counter.");
			}
		}

		public void LogFailureMetrics(string platform, string errorCode, ApiEvent.ApiIds apiId, CacheRefreshReason cacheRefreshReason)
		{
			if (s_failureCounter.Value.Enabled)
			{
				s_failureCounter.Value.Add(1L, new KeyValuePair<string, object>("MsalVersion", MsalIdHelper.GetMsalVersion()), new KeyValuePair<string, object>("Platform", platform), new KeyValuePair<string, object>("ErrorCode", errorCode), new KeyValuePair<string, object>("ApiId", apiId), new KeyValuePair<string, object>("CacheRefreshReason", cacheRefreshReason));
			}
		}
	}
}
namespace Microsoft.Identity.Client.Platforms.Features.DesktopOs
{
	internal static class SecurityFramework
	{
		private const string SecurityFrameworkLib = "/System/Library/Frameworks/Security.framework/Security";

		public static readonly IntPtr Handle;

		public static readonly IntPtr kSecClass;

		public static readonly IntPtr kSecMatchLimit;

		public static readonly IntPtr kSecReturnAttributes;

		public static readonly IntPtr kSecReturnRef;

		public static readonly IntPtr kSecReturnPersistentRef;

		public static readonly IntPtr kSecClassGenericPassword;

		public static readonly IntPtr kSecMatchLimitOne;

		public static readonly IntPtr kSecMatchItemList;

		public static readonly IntPtr kSecAttrLabel;

		public static readonly IntPtr kSecAttrAccount;

		public static readonly IntPtr kSecAttrService;

		public static readonly IntPtr kSecValueRef;

		public static readonly IntPtr kSecValueData;

		public static readonly IntPtr kSecReturnData;

		public const int CallerSecuritySession = -1;

		public const int OK = 0;

		public const int ErrorSecNoSuchKeychain = -25294;

		public const int ErrorSecInvalidKeychain = -25295;

		public const int ErrorSecAuthFailed = -25293;

		public const int ErrorSecDuplicateItem = -25299;

		public const int ErrorSecItemNotFound = -25300;

		public const int ErrorSecInteractionNotAllowed = -25308;

		public const int ErrorSecInteractionRequired = -25315;

		public const int ErrorSecNoSuchAttr = -25303;

		static SecurityFramework()
		{
			Handle = LibSystem.dlopen("/System/Library/Frameworks/Security.framework/Security", 0);
			kSecClass = LibSystem.GetGlobal(Handle, "kSecClass");
			kSecMatchLimit = LibSystem.GetGlobal(Handle, "kSecMatchLimit");
			kSecReturnAttributes = LibSystem.GetGlobal(Handle, "kSecReturnAttributes");
			kSecReturnRef = LibSystem.GetGlobal(Handle, "kSecReturnRef");
			kSecReturnPersistentRef = LibSystem.GetGlobal(Handle, "kSecReturnPersistentRef");
			kSecClassGenericPassword = LibSystem.GetGlobal(Handle, "kSecClassGenericPassword");
			kSecMatchLimitOne = LibSystem.GetGlobal(Handle, "kSecMatchLimitOne");
			kSecMatchItemList = LibSystem.GetGlobal(Handle, "kSecMatchItemList");
			kSecAttrLabel = LibSystem.GetGlobal(Handle, "kSecAttrLabel");
			kSecAttrAccount = LibSystem.GetGlobal(Handle, "kSecAttrAccount");
			kSecAttrService = LibSystem.GetGlobal(Handle, "kSecAttrService");
			kSecValueRef = LibSystem.GetGlobal(Handle, "kSecValueRef");
			kSecValueData = LibSystem.GetGlobal(Handle, "kSecValueData");
			kSecReturnData = LibSystem.GetGlobal(Handle, "kSecReturnData");
		}

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SessionGetInfo(int session, out int sessionId, out SessionAttributeBits attributes);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SecAccessCreate(IntPtr descriptor, IntPtr trustedList, out IntPtr accessRef);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SecKeychainItemCreateFromContent(IntPtr itemClass, IntPtr attrList, uint length, IntPtr data, IntPtr keychainRef, IntPtr initialAccess, out IntPtr itemRef);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SecKeychainAddGenericPassword(IntPtr keychain, uint serviceNameLength, string serviceName, uint accountNameLength, string accountName, uint passwordLength, byte[] passwordData, out IntPtr itemRef);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SecKeychainFindGenericPassword(IntPtr keychainOrArray, uint serviceNameLength, string serviceName, uint accountNameLength, string accountName, out uint passwordLength, out IntPtr passwordData, out IntPtr itemRef);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public unsafe static extern int SecKeychainItemCopyAttributesAndData(IntPtr itemRef, IntPtr info, IntPtr itemClass, SecKeychainAttributeList** attrList, uint* dataLength, void** data);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SecKeychainItemModifyAttributesAndData(IntPtr itemRef, IntPtr attrList, uint length, byte[] data);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SecKeychainItemDelete(IntPtr itemRef);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SecKeychainItemFreeContent(IntPtr attrList, IntPtr data);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SecKeychainItemFreeAttributesAndData(IntPtr attrList, IntPtr data);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SecItemCopyMatching(IntPtr query, out IntPtr result);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SecKeychainItemCopyFromPersistentReference(IntPtr persistentItemRef, out IntPtr itemRef);

		[DllImport("/System/Library/Frameworks/Security.framework/Security", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int SecKeychainItemCopyContent(IntPtr itemRef, IntPtr itemClass, IntPtr attrList, out uint length, out IntPtr outData);
	}
	[Flags]
	internal enum SessionAttributeBits
	{
		SessionIsRoot = 1,
		SessionHasGraphicAccess = 0x10,
		SessionHasTty = 0x20,
		SessionIsRemote = 0x1000
	}
	internal struct SecKeychainAttributeInfo
	{
		public uint Count;

		public IntPtr Tag;

		public IntPtr Format;
	}
	internal struct SecKeychainAttributeList
	{
		public uint Count;

		public IntPtr Attributes;
	}
	internal struct SecKeychainAttribute
	{
		public SecKeychainAttrType Tag;

		public uint Length;

		public IntPtr Data;
	}
	internal enum CssmDbAttributeFormat : uint
	{
		String,
		SInt32,
		UInt32,
		BigNum,
		Real,
		TimeDate,
		Blob,
		MultiUInt32,
		Complex
	}
	internal enum SecKeychainAttrType : uint
	{
		AccountItem = 1633903476u
	}
	internal static class LibSystem
	{
		private const string LibSystemLib = "/System/Library/Frameworks/System.framework/System";

		[DllImport("/System/Library/Frameworks/System.framework/System", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr dlopen(string name, int flags);

		[DllImport("/System/Library/Frameworks/System.framework/System", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr dlsym(IntPtr handle, string symbol);

		public static IntPtr GetGlobal(IntPtr handle, string symbol)
		{
			return Marshal.PtrToStructure<IntPtr>(dlsym(handle, symbol));
		}
	}
	internal static class WindowsDpiHelper
	{
		public static int ZoomPercent { get; }

		static WindowsDpiHelper()
		{
			IntPtr dC = GetDC(IntPtr.Zero);
			double num;
			double num2;
			if (dC != IntPtr.Zero)
			{
				num = GetDeviceCaps(dC, 88);
				num2 = GetDeviceCaps(dC, 90);
				ReleaseDC(IntPtr.Zero, dC);
			}
			else
			{
				num = 96.0;
				num2 = 96.0;
			}
			int val = (int)(100.0 * (num / 96.0));
			int val2 = (int)(100.0 * (num2 / 96.0));
			ZoomPercent = Math.Min(val, val2);
		}

		[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall, ExactSpelling = true)]
		internal static extern IntPtr GetDC(IntPtr hWnd);

		[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall, ExactSpelling = true)]
		internal static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);

		[DllImport("Gdi32.dll", CallingConvention = CallingConvention.StdCall, ExactSpelling = true)]
		internal static extern int GetDeviceCaps(IntPtr hdc, int nIndex);

		[DllImport("User32.dll", ExactSpelling = true)]
		internal static extern bool IsProcessDPIAware();
	}
	internal static class WindowsNativeMethods
	{
		public enum NetJoinStatus
		{
			NetSetupUnknownStatus,
			NetSetupUnjoined,
			NetSetupWorkgroupName,
			NetSetupDomainName
		}

		private struct SYSTEM_INFO
		{
			public readonly short wProcessorArchitecture;

			public readonly short wReserved;

			public readonly int dwPageSize;

			public readonly IntPtr lpMinimumApplicationAddress;

			public readonly IntPtr lpMaximumApplicationAddress;

			public readonly IntPtr dwActiveProcessorMask;

			public readonly int dwNumberOfProcessors;

			public readonly int dwProcessorType;

			public readonly int dwAllocationGranularity;

			public readonly short wProcessorLevel;

			public readonly short wProcessorRevision;
		}

		private const int PROCESSOR_ARCHITECTURE_AMD64 = 9;

		private const int PROCESSOR_ARCHITECTURE_ARM = 5;

		private const int PROCESSOR_ARCHITECTURE_IA64 = 6;

		private const int PROCESSOR_ARCHITECTURE_INTEL = 0;

		public const int ErrorSuccess = 0;

		[DllImport("kernel32.dll")]
		public static extern uint GetCurrentProcessId();

		[DllImport("user32.dll", SetLastError = true)]
		public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);

		[DllImport("kernel32.dll")]
		private static extern void GetNativeSystemInfo(ref SYSTEM_INFO lpSystemInfo);

		public static string GetProcessorArchitecture()
		{
			try
			{
				SYSTEM_INFO lpSystemInfo = default(SYSTEM_INFO);
				GetNativeSystemInfo(ref lpSystemInfo);
				switch (lpSystemInfo.wProcessorArchitecture)
				{
				case 6:
				case 9:
					return "x64";
				case 5:
					return "ARM";
				case 0:
					return "x86";
				default:
					return "Unknown";
				}
			}
			catch (Exception)
			{
				return "Unknown";
			}
		}

		[DllImport("secur32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.U1)]
		public static extern bool GetUserNameEx(int nameFormat, StringBuilder userName, ref uint userNameSize);

		[DllImport("Netapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
		public static extern int NetGetJoinInformation(string server, out IntPtr domain, out NetJoinStatus status);

		[DllImport("Netapi32.dll")]
		public static extern int NetApiBufferFree(IntPtr Buffer);

		[DllImport("user32.dll")]
		public static extern IntPtr GetDesktopWindow();

		[DllImport("kernel32.dll")]
		public static extern IntPtr GetConsoleWindow();
	}
	internal static class User32
	{
		private const string LibraryName = "user32.dll";

		public const int UOI_FLAGS = 1;

		public const int WSF_VISIBLE = 1;

		[DllImport("user32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
		public static extern IntPtr GetProcessWindowStation();

		[DllImport("user32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
		public unsafe static extern bool GetUserObjectInformation(IntPtr hObj, int nIndex, void* pvBuffer, uint nLength, ref uint lpnLengthNeeded);
	}
	internal struct USEROBJECTFLAGS
	{
		public int fInherit;

		public int fReserved;

		public int dwFlags;
	}
}
namespace Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos
{
	[Flags]
	internal enum AcceptContextFlag
	{
		Zero = 0,
		Delegate = 1,
		MutualAuth = 2,
		ReplayDetect = 4,
		SequenceDetect = 8,
		Confidentiality = 0x10,
		UseSessionKey = 0x20,
		AllocateMemory = 0x100,
		Connection = 0x800,
		AcceptExtendedError = 0x8000,
		AcceptStream = 0x10000,
		AcceptIntegrity = 0x20000,
		AcceptIdentify = 0x80000,
		ProxyBindings = 0x4000000,
		AllowMissingBindings = 0x10000000,
		UnverifiedTargetName = 0x20000000
	}
	internal enum ContextStatus
	{
		RequiresContinuation,
		Accepted,
		Error
	}
	public abstract class Credential
	{
		private class CurrentCredential : Credential
		{
			internal override CredentialHandle Structify()
			{
				return new CredentialHandle(null);
			}
		}

		internal abstract CredentialHandle Structify();

		public static Credential Current()
		{
			return new CurrentCredential();
		}
	}
	internal class CredentialHandle : SafeHandle
	{
		public override bool IsInvalid => handle == IntPtr.Zero;

		public unsafe CredentialHandle(void* cred)
			: base(new IntPtr(cred), ownsHandle: true)
		{
		}

		protected override bool ReleaseHandle()
		{
			return true;
		}
	}
	[Flags]
	internal enum InitContextFlag
	{
		Zero = 0,
		Delegate = 1,
		MutualAuth = 2,
		ReplayDetect = 4,
		SequenceDetect = 8,
		Confidentiality = 0x10,
		UseSessionKey = 0x20,
		AllocateMemory = 0x100,
		Connection = 0x800,
		InitExtendedError = 0x4000,
		InitStream = 0x8000,
		InitIntegrity = 0x10000,
		InitManualCredValidation = 0x80000,
		InitUseSuppliedCreds = 0x80,
		InitIdentify = 0x20000,
		ProxyBindings = 0x4000000,
		AllowMissingBindings = 0x10000000,
		UnverifiedTargetName = 0x20000000
	}
	internal class LsaBufferSafeHandle : SafeHandle
	{
		public override bool IsInvalid => handle == IntPtr.Zero;

		public LsaBufferSafeHandle()
			: base(IntPtr.Zero, ownsHandle: true)
		{
		}

		protected override bool ReleaseHandle()
		{
			NativeMethods.LsaThrowIfError(NativeMethods.LsaFreeReturnBuffer(handle));
			handle = IntPtr.Zero;
			return true;
		}
	}
	internal class LsaSafeHandle : SafeHandle
	{
		public override bool IsInvalid => handle == IntPtr.Zero;

		public LsaSafeHandle()
			: base(IntPtr.Zero, ownsHandle: true)
		{
		}

		protected override bool ReleaseHandle()
		{
			NativeMethods.LsaThrowIfError(NativeMethods.LsaDeregisterLogonProcess(handle));
			handle = IntPtr.Zero;
			return true;
		}
	}
	internal class LsaTokenSafeHandle : SafeHandle
	{
		public bool Impersonating { get; private set; }

		public override bool IsInvalid => handle == IntPtr.Zero;

		public LsaTokenSafeHandle()
			: base(IntPtr.Zero, ownsHandle: true)
		{
		}

		protected override bool ReleaseHandle()
		{
			Revert();
			if (!NativeMethods.CloseHandle(handle))
			{
				throw new Win32Exception(Marshal.GetLastWin32Error());
			}
			return true;
		}

		private void Revert()
		{
			if (Impersonating)
			{
				if (!NativeMethods.RevertToSelf())
				{
					throw new Win32Exception(Marshal.GetLastWin32Error());
				}
				Impersonating = false;
			}
		}
	}
	internal class NativeMethods
	{
		public struct KERB_INTERACTIVE_LOGON
		{
			public KERB_LOGON_SUBMIT_TYPE MessageType;

			public UNICODE_STRING LogonDomainName;

			public UNICODE_STRING UserName;

			public UNICODE_STRING Password;
		}

		public struct TOKEN_SOURCE
		{
			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
			public byte[] SourceName;

			public LUID SourceIdentifier;
		}

		public struct KERB_S4U_LOGON
		{
			public KERB_LOGON_SUBMIT_TYPE MessageType;

			public S4uFlags Flags;

			public UNICODE_STRING ClientUpn;

			public UNICODE_STRING ClientRealm;
		}

		public struct UNICODE_STRING
		{
			public ushort Length;

			public ushort MaximumLength;

			public IntPtr Buffer;
		}

		[Flags]
		public enum S4uFlags
		{
			KERB_S4U_LOGON_FLAG_CHECK_LOGONHOURS = 2,
			KERB_S4U_LOGON_FLAG_IDENTIFY = 8
		}

		public enum KERB_LOGON_SUBMIT_TYPE
		{
			KerbInteractiveLogon = 2,
			KerbSmartCardLogon = 6,
			KerbWorkstationUnlockLogon = 7,
			KerbSmartCardUnlockLogon = 8,
			KerbProxyLogon = 9,
			KerbTicketLogon = 10,
			KerbTicketUnlockLogon = 11,
			KerbS4ULogon = 12,
			KerbCertificateLogon = 13,
			KerbCertificateS4ULogon = 14,
			KerbCertificateUnlockLogon = 15,
			KerbNoElevationLogon = 83,
			KerbLuidLogon = 84
		}

		public enum SECURITY_LOGON_TYPE
		{
			UndefinedLogonType = 0,
			Interactive = 2,
			Network = 3,
			Batch = 4,
			Service = 5,
			Proxy = 6,
			Unlock = 7,
			NetworkCleartext = 8,
			NewCredentials = 9,
			RemoteInteractive = 10,
			CachedInteractive = 11,
			CachedRemoteInteractive = 12,
			CachedUnlock = 13
		}

		internal struct LSA_STRING
		{
			public ushort Length;

			public ushort MaximumLength;

			public string Buffer;
		}

		internal struct LUID
		{
			public uint LowPart;

			public int HighPart;

			public static implicit operator ulong(LUID luid)
			{
				return (ulong)(((long)luid.HighPart << 32) + luid.LowPart);
			}

			public static implicit operator LUID(long luid)
			{
				return new LUID
				{
					LowPart = (uint)(luid & 0xFFFFFFFFu),
					HighPart = (int)(luid >> 32)
				};
			}
		}

		public struct KERB_SUBMIT_TKT_REQUEST
		{
			public KERB_PROTOCOL_MESSAGE_TYPE MessageType;

			public LUID LogonId;

			public int Flags;

			public KERB_CRYPTO_KEY32 Key;

			public int KerbCredSize;

			public int KerbCredOffset;
		}

		public struct KERB_PURGE_TKT_CACHE_EX_REQUEST
		{
			public KERB_PROTOCOL_MESSAGE_TYPE MessageType;

			public LUID LogonId;

			public int Flags;

			public KERB_TICKET_CACHE_INFO_EX TicketTemplate;
		}

		public struct KERB_TICKET_CACHE_INFO_EX
		{
			public UNICODE_STRING ClientName;

			public UNICODE_STRING ClientRealm;

			public UNICODE_STRING ServerName;

			public UNICODE_STRING ServerRealm;

			public long StartTime;

			public long EndTime;

			public long RenewTime;

			public int EncryptionType;

			public int TicketFlags;
		}

		public enum KERB_PROTOCOL_MESSAGE_TYPE : uint
		{
			KerbDebugRequestMessage,
			KerbQueryTicketCacheMessage,
			KerbChangeMachinePasswordMessage,
			KerbVerifyPacMessage,
			KerbRetrieveTicketMessage,
			KerbUpdateAddressesMessage,
			KerbPurgeTicketCacheMessage,
			KerbChangePasswordMessage,
			KerbRetrieveEncodedTicketMessage,
			KerbDecryptDataMessage,
			KerbAddBindingCacheEntryMessage,
			KerbSetPasswordMessage,
			KerbSetPasswordExMessage,
			KerbVerifyCredentialsMessage,
			KerbQueryTicketCacheExMessage,
			KerbPurgeTicketCacheExMessage,
			KerbRefreshSmartcardCredentialsMessage,
			KerbAddExtraCredentialsMessage,
			KerbQuerySupplementalCredentialsMessage,
			KerbTransferCredentialsMessage,
			KerbQueryTicketCacheEx2Message,
			KerbSubmitTicketMessage,
			KerbAddExtraCredentialsExMessage,
			KerbQueryKdcProxyCacheMessage,
			KerbPurgeKdcProxyCacheMessage,
			KerbQueryTicketCacheEx3Message,
			KerbCleanupMachinePkinitCredsMessage,
			KerbAddBindingCacheEntryExMessage,
			KerbQueryBindingCacheMessage,
			KerbPurgeBindingCacheMessage,
			KerbPinKdcMessage,
			KerbUnpinAllKdcsMessage,
			KerbQueryDomainExtendedPoliciesMessage,
			KerbQueryS4U2ProxyCacheMessage,
			KerbRetrieveKeyTabMessage,
			KerbRefreshPolicyMessage
		}

		public struct KERB_CRYPTO_KEY32
		{
			public int KeyType;

			public int Length;

			public int Offset;
		}

		internal enum SecBufferType
		{
			SECBUFFER_VERSION,
			SECBUFFER_DATA,
			SECBUFFER_TOKEN
		}

		internal struct SECURITY_HANDLE
		{
			public ulong dwLower;

			public ulong dwUpper;

			public bool IsSet
			{
				get
				{
					if (dwLower == 0)
					{
						return dwUpper != 0;
					}
					return true;
				}
			}
		}

		internal struct SECURITY_INTEGER
		{
			public uint LowPart;

			public int HighPart;
		}

		internal struct SecPkgContext_SecString
		{
			public unsafe void* sValue;
		}

		internal struct SecBuffer
		{
			public int cbBuffer;

			public SecBufferType BufferType;

			public IntPtr pvBuffer;

			public SecBuffer(int bufferSize)
			{
				cbBuffer = bufferSize;
				BufferType = SecBufferType.SECBUFFER_TOKEN;
				pvBuffer = Marshal.AllocHGlobal(bufferSize);
			}

			public SecBuffer(byte[] secBufferBytes)
				: this(secBufferBytes.Length)
			{
				Marshal.Copy(secBufferBytes, 0, pvBuffer, cbBuffer);
			}

			public void Dispose()
			{
				if (pvBuffer != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(pvBuffer);
					pvBuffer = IntPtr.Zero;
				}
			}
		}

		internal struct SecBufferDesc : IDisposable
		{
			private readonly SecBufferType ulVersion;

			public int cBuffers;

			public IntPtr pBuffers;

			public SecBufferDesc(int bufferSize)
				: this(new SecBuffer(bufferSize))
			{
			}

			public SecBufferDesc(byte[] secBufferBytes)
				: this(new SecBuffer(secBufferBytes))
			{
			}

			private SecBufferDesc(SecBuffer secBuffer)
			{
				ulVersion = SecBufferType.SECBUFFER_VERSION;
				cBuffers = 1;
				pBuffers = Marshal.AllocHGlobal(Marshal.SizeOf(secBuffer));
				Marshal.StructureToPtr(secBuffer, pBuffers, fDeleteOld: false);
			}

			public void Dispose()
			{
				if (pBuffers != IntPtr.Zero)
				{
					ForEachBuffer(delegate(SecBuffer thisSecBuffer)
					{
						thisSecBuffer.Dispose();
					});
					Marshal.FreeHGlobal(pBuffers);
					pBuffers = IntPtr.Zero;
				}
			}

			private void ForEachBuffer(Action<SecBuffer> onBuffer)
			{
				for (int i = 0; i < cBuffers; i++)
				{
					int offset = i * Marshal.SizeOf(typeof(SecBuffer));
					SecBuffer obj = (SecBuffer)Marshal.PtrToStructure(IntPtr.Add(pBuffers, offset), typeof(SecBuffer));
					onBuffer(obj);
				}
			}

			public byte[] ReadBytes()
			{
				if (cBuffers <= 0)
				{
					return Array.Empty<byte>();
				}
				int finalLen = 0;
				List<byte[]> bufferList = new List<byte[]>();
				ForEachBuffer(delegate(SecBuffer thisSecBuffer)
				{
					if (thisSecBuffer.cbBuffer > 0)
					{
						byte[] array2 = new byte[thisSecBuffer.cbBuffer];
						Marshal.Copy(thisSecBuffer.pvBuffer, array2, 0, thisSecBuffer.cbBuffer);
						bufferList.Add(array2);
						finalLen += thisSecBuffer.cbBuffer;
					}
				});
				byte[] array = new byte[finalLen];
				int num = 0;
				for (int num2 = 0; num2 < bufferList.Count; num2++)
				{
					bufferList[num2].CopyTo(array, num);
					num += bufferList[num2].Length - 1;
				}
				return array;
			}
		}

		private const string SECUR32 = "secur32.dll";

		private const string ADVAPI32 = "advapi32.dll";

		private const string KERNEL32 = "kernel32.dll";

		[DllImport("secur32.dll", BestFitMapping = false, CharSet = CharSet.Auto, EntryPoint = "InitializeSecurityContext", SetLastError = true, ThrowOnUnmappableChar = true)]
		internal static extern SecStatus InitializeSecurityContext_0(ref SECURITY_HANDLE phCredential, IntPtr phContext, string pszTargetName, InitContextFlag fContextReq, int Reserved1, int TargetDataRep, IntPtr pInput, int Reserved2, ref SECURITY_HANDLE phNewContext, ref SecBufferDesc pOutput, out InitContextFlag pfContextAttr, IntPtr ptsExpiry);

		[DllImport("secur32.dll", BestFitMapping = false, CharSet = CharSet.Auto, ThrowOnUnmappableChar = true)]
		internal unsafe static extern SecStatus AcquireCredentialsHandle(string pszPrincipal, string pszPackage, int fCredentialUse, IntPtr PAuthenticationID, void* pAuthData, IntPtr pGetKeyFn, IntPtr pvGetKeyArgument, ref SECURITY_HANDLE phCredential, IntPtr ptsExpiry);

		[DllImport("secur32.dll")]
		internal unsafe static extern uint FreeCredentialsHandle(SECURITY_HANDLE* handle);

		[DllImport("secur32.dll")]
		public unsafe static extern SecStatus DeleteSecurityContext(SECURITY_HANDLE* context);

		[DllImport("secur32.dll")]
		public static extern int LsaDeregisterLogonProcess(IntPtr LsaHandle);

		[DllImport("secur32.dll")]
		public static extern int LsaLookupAuthenticationPackage(LsaSafeHandle LsaHandle, ref LSA_STRING PackageName, out int AuthenticationPackage);

		[DllImport("secur32.dll")]
		public static extern int LsaConnectUntrusted(out LsaSafeHandle LsaHandle);

		[DllImport("secur32.dll")]
		public unsafe static extern int LsaCallAuthenticationPackage(LsaSafeHandle LsaHandle, int AuthenticationPackage, void* ProtocolSubmitBuffer, int SubmitBufferLength, out LsaBufferSafeHandle ProtocolReturnBuffer, out int ReturnBufferLength, out int ProtocolStatus);

		[DllImport("secur32.dll")]
		public static extern int LsaFreeReturnBuffer(IntPtr Buffer);

		[DllImport("advapi32.dll")]
		public static extern int LsaNtStatusToWinError(int Status);

		[DllImport("kernel32.dll")]
		public static extern bool CloseHandle(IntPtr hObject);

		[DllImport("advapi32.dll")]
		public static extern bool ImpersonateLoggedOnUser(LsaTokenSafeHandle hToken);

		[DllImport("advapi32.dll")]
		public static extern bool RevertToSelf();

		public static void LsaThrowIfError(int result)
		{
			if (result != 0)
			{
				result = LsaNtStatusToWinError(result);
				throw new Win32Exception(result);
			}
		}
	}
	internal enum SecStatus : uint
	{
		SEC_E_OK = 0u,
		SEC_E_ERROR = 2147483648u,
		SEC_E_INSUFFICIENT_MEMORY = 2148074240u,
		SEC_E_INVALID_HANDLE = 2148074241u,
		SEC_E_TARGET_UNKNOWN = 2148074243u,
		SEC_E_UNSUPPORTED_FUNCTION = 2148074242u,
		SEC_E_INTERNAL_ERROR = 2148074244u,
		SEC_E_SECPKG_NOT_FOUND = 2148074245u,
		SEC_E_INVALID_TOKEN = 2148074248u,
		SEC_E_QOP_NOT_SUPPORTED = 2148074250u,
		SEC_E_LOGON_DENIED = 2148074252u,
		SEC_E_UNKNOWN_CREDENTIALS = 2148074253u,
		SEC_E_NO_CREDENTIALS = 2148074254u,
		SEC_E_MESSAGE_ALTERED = 2148074255u,
		SEC_E_OUT_OF_SEQUENCE = 2148074256u,
		SEC_E_NO_AUTHENTICATING_AUTHORITY = 2148074257u,
		SEC_E_CONTEXT_EXPIRED = 2148074263u,
		SEC_E_INCOMPLETE_MESSAGE = 2148074264u,
		SEC_E_BUFFER_TOO_SMALL = 2148074273u,
		SEC_E_WRONG_PRINCIPAL = 2148074274u,
		SEC_E_CRYPTO_SYSTEM_INVALID = 2148074295u,
		SEC_I_CONTINUE_NEEDED = 590610u,
		SEC_I_CONTEXT_EXPIRED = 590615u,
		SEC_I_INCOMPLETE_CREDENTIALS = 590624u,
		SEC_I_RENEGOTIATE = 590625u
	}
	internal enum SecurityContextAttribute
	{
		SECPKG_ATTR_SIZES = 0,
		SECPKG_ATTR_NAMES = 1,
		SECPKG_ATTR_LIFESPAN = 2,
		SECPKG_ATTR_DCE_INFO = 3,
		SECPKG_ATTR_STREAM_SIZES = 4,
		SECPKG_ATTR_AUTHORITY = 6,
		SECPKG_ATTR_PACKAGE_INFO = 10,
		SECPKG_ATTR_NEGOTIATION_INFO = 12,
		SECPKG_ATTR_UNIQUE_BINDINGS = 25,
		SECPKG_ATTR_ENDPOINT_BINDINGS = 26,
		SECPKG_ATTR_CLIENT_SPECIFIED_TARGET = 27,
		SECPKG_ATTR_APPLICATION_PROTOCOL = 35
	}
	internal class SspiSecurityContext : IDisposable
	{
		private const int SECPKG_CRED_BOTH = 3;

		private const int SECURITY_NETWORK_DREP = 0;

		private const int _maxTokenSize = 16384;

		private const InitContextFlag _defaultRequiredFlags = InitContextFlag.Delegate | InitContextFlag.ReplayDetect | InitContextFlag.SequenceDetect | InitContextFlag.Confidentiality | InitContextFlag.AllocateMemory | InitContextFlag.Connection | InitContextFlag.InitExtendedError;

		private readonly HashSet<object> _disposable = new HashSet<object>();

		private readonly Credential _credential;

		private readonly InitContextFlag _clientFlags;

		private NativeMethods.SECURITY_HANDLE _credentialsHandle;

		private NativeMethods.SECURITY_HANDLE _securityContext;

		private long _logonId;

		public string Package { get; private set; }

		public SspiSecurityContext(Credential credential, string package, long logonId = 0L, InitContextFlag clientFlags = InitContextFlag.Delegate | InitContextFlag.ReplayDetect | InitContextFlag.SequenceDetect | InitContextFlag.Confidentiality | InitContextFlag.AllocateMemory | InitContextFlag.Connection | InitContextFlag.InitExtendedError)
		{
			if (!DesktopOsHelper.IsWindows())
			{
				throw new PlatformNotSupportedException("Ticket Cache interface is not supported for this OS platform.");
			}
			_credential = credential;
			_clientFlags = clientFlags;
			Package = package;
			_logonId = logonId;
		}

		private static void ThrowIfError(uint result)
		{
			if (result != 0 && result != 2148074241u)
			{
				throw new Win32Exception((int)result);
			}
		}

		public ContextStatus InitializeSecurityContext(string targetName, out byte[] clientRequest)
		{
			string pszTargetName = targetName.ToLowerInvariant();
			clientRequest = null;
			SecStatus secStatus = SecStatus.SEC_E_OK;
			int num = 0;
			NativeMethods.SecBufferDesc pOutput = default(NativeMethods.SecBufferDesc);
			try
			{
				do
				{
					pOutput = new NativeMethods.SecBufferDesc(num);
					if (!_credentialsHandle.IsSet || secStatus == SecStatus.SEC_I_CONTINUE_NEEDED)
					{
						AcquireCredentials();
					}
					secStatus = NativeMethods.InitializeSecurityContext_0(ref _credentialsHandle, IntPtr.Zero, pszTargetName, _clientFlags, 0, 0, IntPtr.Zero, 0, ref _securityContext, ref pOutput, out var _, IntPtr.Zero);
					if (secStatus == SecStatus.SEC_E_INSUFFICIENT_MEMORY)
					{
						if (num > 16384)
						{
							break;
						}
						num += 1000;
					}
				}
				while (secStatus == SecStatus.SEC_I_INCOMPLETE_CREDENTIALS || secStatus == SecStatus.SEC_E_INSUFFICIENT_MEMORY);
				if ((uint)secStatus > 2147483648u)
				{
					throw new Win32Exception((int)secStatus);
				}
				clientRequest = pOutput.ReadBytes();
				if (secStatus == SecStatus.SEC_I_CONTINUE_NEEDED)
				{
					return ContextStatus.RequiresContinuation;
				}
				return ContextStatus.Accepted;
			}
			finally
			{
				pOutput.Dispose();
			}
		}

		private void TrackUnmanaged(object thing)
		{
			_disposable.Add(thing);
		}

		private unsafe void AcquireCredentials()
		{
			CredentialHandle credentialHandle = _credential.Structify();
			TrackUnmanaged(credentialHandle);
			IntPtr intPtr = IntPtr.Zero;
			if (_logonId != 0L)
			{
				intPtr = Marshal.AllocHGlobal(Marshal.SizeOf<long>());
				Marshal.StructureToPtr(_logonId, intPtr, fDeleteOld: false);
			}
			SecStatus secStatus = NativeMethods.AcquireCredentialsHandle(null, Package, 3, intPtr, (void*)credentialHandle.DangerousGetHandle(), IntPtr.Zero, IntPtr.Zero, ref _credentialsHandle, IntPtr.Zero);
			if (secStatus != SecStatus.SEC_E_OK)
			{
				throw new Win32Exception((int)secStatus);
			}
			TrackUnmanaged(_credentialsHandle);
		}

		public unsafe void Dispose()
		{
			foreach (object item in _disposable)
			{
				if (item is IDisposable disposable)
				{
					disposable.Dispose();
				}
				else if (item is NativeMethods.SECURITY_HANDLE sECURITY_HANDLE)
				{
					NativeMethods.DeleteSecurityContext(&sECURITY_HANDLE);
					ThrowIfError(NativeMethods.FreeCredentialsHandle(&sECURITY_HANDLE));
				}
				else if (item is IntPtr hglobal)
				{
					Marshal.FreeHGlobal(hglobal);
				}
			}
		}
	}
	internal class TicketCacheReader : IDisposable
	{
		private readonly string _spn;

		private readonly SspiSecurityContext _context;

		private bool _disposedValue;

		public TicketCacheReader(string spn, long logonId = 0L, string package = "Kerberos")
		{
			_spn = spn;
			_context = new SspiSecurityContext(Credential.Current(), package, logonId);
		}

		public byte[] RequestToken()
		{
			if (_context.InitializeSecurityContext(_spn, out var clientRequest) == ContextStatus.Error)
			{
				throw new Win32Exception(Marshal.GetLastWin32Error());
			}
			return clientRequest;
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!_disposedValue)
			{
				if (disposing)
				{
					_context.Dispose();
				}
				_disposedValue = true;
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}
	}
	internal class TicketCacheWriter : IDisposable
	{
		private const string _kerberosPackageName = "Kerberos";

		private const string _negotiatePackageName = "Negotiate";

		private readonly LsaSafeHandle _lsaHandle;

		private readonly int _selectedAuthPackage;

		private readonly int _negotiateAuthPackage;

		private bool _disposedValue;

		internal TicketCacheWriter(LsaSafeHandle lsaHandle, string packageName = "Kerberos")
		{
			_lsaHandle = lsaHandle;
			NativeMethods.LSA_STRING PackageName = new NativeMethods.LSA_STRING
			{
				Buffer = packageName,
				Length = (ushort)packageName.Length,
				MaximumLength = (ushort)packageName.Length
			};
			NativeMethods.LsaThrowIfError(NativeMethods.LsaLookupAuthenticationPackage(_lsaHandle, ref PackageName, out _selectedAuthPackage));
			NativeMethods.LSA_STRING PackageName2 = new NativeMethods.LSA_STRING
			{
				Buffer = "Negotiate",
				Length = (ushort)"Negotiate".Length,
				MaximumLength = (ushort)"Negotiate".Length
			};
			NativeMethods.LsaThrowIfError(NativeMethods.LsaLookupAuthenticationPackage(_lsaHandle, ref PackageName2, out _negotiateAuthPackage));
		}

		public static TicketCacheWriter Connect(string package = "Kerberos")
		{
			if (string.IsNullOrWhiteSpace(package))
			{
				package = "Kerberos";
			}
			NativeMethods.LsaThrowIfError(NativeMethods.LsaConnectUntrusted(out var LsaHandle));
			return new TicketCacheWriter(LsaHandle, package);
		}

		public unsafe void ImportCredential(byte[] ticketBytes, long luid = 0L)
		{
			if (ticketBytes == null)
			{
				throw new ArgumentNullException("ticketBytes");
			}
			NativeMethods.KERB_SUBMIT_TKT_REQUEST structure = new NativeMethods.KERB_SUBMIT_TKT_REQUEST
			{
				MessageType = NativeMethods.KERB_PROTOCOL_MESSAGE_TYPE.KerbSubmitTicketMessage,
				KerbCredSize = ticketBytes.Length,
				KerbCredOffset = Marshal.SizeOf(typeof(NativeMethods.KERB_SUBMIT_TKT_REQUEST)),
				LogonId = luid
			};
			int num = structure.KerbCredOffset + ticketBytes.Length;
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			Marshal.StructureToPtr(structure, intPtr, fDeleteOld: false);
			Marshal.Copy(ticketBytes, 0, intPtr + structure.KerbCredOffset, ticketBytes.Length);
			LsaCallAuthenticationPackage(intPtr.ToPointer(), num);
		}

		private unsafe void LsaCallAuthenticationPackage(void* pBuffer, int bufferSize)
		{
			LsaBufferSafeHandle ProtocolReturnBuffer = null;
			try
			{
				NativeMethods.LsaThrowIfError(NativeMethods.LsaCallAuthenticationPackage(_lsaHandle, _selectedAuthPackage, pBuffer, bufferSize, out ProtocolReturnBuffer, out var _, out var ProtocolStatus));
				NativeMethods.LsaThrowIfError(ProtocolStatus);
			}
			finally
			{
				ProtocolReturnBuffer?.Dispose();
			}
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!_disposedValue)
			{
				_lsaHandle.Dispose();
				_disposedValue = true;
			}
		}

		~TicketCacheWriter()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}
	}
}
namespace Microsoft.Identity.Client.Platforms.netstandard
{
	internal class NetStandardPlatformProxy : NetCorePlatformProxy
	{
		public NetStandardPlatformProxy(ILoggerAdapter logger)
			: base(logger)
		{
		}

		protected override string InternalGetProductName()
		{
			return "MSAL.CoreCLR";
		}
	}
}
namespace Microsoft.Identity.Client.Platforms.Shared.DefaultOSBrowser
{
	internal class HttpListenerInterceptor : IUriInterceptor
	{
		private ILoggerAdapter _logger;

		public Action TestBeforeTopLevelCall { get; set; }

		public Action<string> TestBeforeStart { get; set; }

		public Action TestBeforeGetContext { get; set; }

		public HttpListenerInterceptor(ILoggerAdapter logger)
		{
			_logger = logger;
		}

		public async Task<Uri> ListenToSingleRequestAndRespondAsync(int port, string path, Func<Uri, MessageAndHttpCode> responseProducer, CancellationToken cancellationToken)
		{
			TestBeforeTopLevelCall?.Invoke();
			cancellationToken.ThrowIfCancellationRequested();
			HttpListener httpListener = null;
			string urlToListenTo = string.Empty;
			try
			{
				path = ((!string.IsNullOrEmpty(path)) ? (path.StartsWith("/") ? path : ("/" + path)) : "/");
				urlToListenTo = "http://localhost:" + port + path;
				if (!urlToListenTo.EndsWith("/"))
				{
					urlToListenTo += "/";
				}
				httpListener = new HttpListener();
				httpListener.Prefixes.Add(urlToListenTo);
				TestBeforeStart?.Invoke(urlToListenTo);
				httpListener.Start();
				_logger.Info(() => "Listening for authorization code on " + urlToListenTo);
				using (cancellationToken.Register(delegate
				{
					_logger.Warning("HttpListener stopped because cancellation was requested.");
					TryStopListening(httpListener);
				}))
				{
					TestBeforeGetContext?.Invoke();
					HttpListenerContext httpListenerContext = await httpListener.GetContextAsync().ConfigureAwait(continueOnCapturedContext: false);
					cancellationToken.ThrowIfCancellationRequested();
					Respond(responseProducer, httpListenerContext);
					_logger.Verbose(() => "HttpListner received a message on " + urlToListenTo);
					return httpListenerContext.Request.Url;
				}
			}
			catch (Exception ex) when (ex is HttpListenerException || ex is ObjectDisposedException)
			{
				_logger.Info(() => "HttpListenerException - cancellation requested? " + cancellationToken.IsCancellationRequested);
				cancellationToken.ThrowIfCancellationRequested();
				if (ex is HttpListenerException)
				{
					throw new MsalClientException("http_listener_error", "An HttpListenerException occurred while listening on " + urlToListenTo + " for the system browser to complete the login. Possible cause and mitigation: the app is unable to listen on the specified URL; run 'netsh http add iplisten 127.0.0.1' from the Admin command prompt.", ex);
				}
				throw;
			}
			finally
			{
				TryStopListening(httpListener);
			}
		}

		private static void TryStopListening(HttpListener httpListener)
		{
			try
			{
				httpListener?.Abort();
			}
			catch
			{
			}
		}

		private void Respond(Func<Uri, MessageAndHttpCode> responseProducer, HttpListenerContext context)
		{
			MessageAndHttpCode messageAndCode = responseProducer(context.Request.Url);
			_logger.Info(() => "Processing a response message to the browser. HttpStatus:" + messageAndCode.HttpCode);
			switch (messageAndCode.HttpCode)
			{
			case HttpStatusCode.Found:
				context.Response.StatusCode = 302;
				context.Response.RedirectLocation = messageAndCode.Message;
				break;
			case HttpStatusCode.OK:
			{
				byte[] bytes = Encoding.UTF8.GetBytes(messageAndCode.Message);
				context.Response.ContentLength64 = bytes.Length;
				context.Response.OutputStream.Write(bytes, 0, bytes.Length);
				break;
			}
			default:
				throw new NotImplementedException("HttpCode not supported" + messageAndCode.HttpCode);
			}
			context.Response.OutputStream.Close();
		}
	}
}
namespace Microsoft.Identity.Client.Platforms.Shared.Desktop.OsBrowser
{
	internal class DefaultOsBrowserWebUi : IWebUI
	{
		internal const string DefaultSuccessHtml = "<html>\r\n  <head><title>Authentication Complete</title></head>\r\n  <body>\r\n    Authentication complete. You can return to the application. Feel free to close this browser tab.\r\n  </body>\r\n</html>";

		internal const string DefaultFailureHtml = "<html>\r\n  <head><title>Authentication Failed</title></head>\r\n  <body>\r\n    Authentication failed. You can return to the application. Feel free to close this browser tab.\r\n</br></br></br></br>\r\n    Error details: error {0} error_description: {1}\r\n  </body>\r\n</html>";

		private readonly IUriInterceptor _uriInterceptor;

		private readonly ILoggerAdapter _logger;

		private readonly SystemWebViewOptions _webViewOptions;

		private readonly IPlatformProxy _platformProxy;

		public DefaultOsBrowserWebUi(IPlatformProxy proxy, ILoggerAdapter logger, SystemWebViewOptions webViewOptions, IUriInterceptor uriInterceptor = null)
		{
			_logger = logger ?? throw new ArgumentNullException("logger");
			_webViewOptions = webViewOptions;
			_platformProxy = proxy ?? throw new ArgumentNullException("proxy");
			_uriInterceptor = uriInterceptor ?? new HttpListenerInterceptor(_logger);
		}

		public async Task<AuthorizationResult> AcquireAuthorizationAsync(Uri authorizationUri, Uri redirectUri, RequestContext requestContext, CancellationToken cancellationToken)
		{
			try
			{
				Uri uri = await InterceptAuthorizationUriAsync(authorizationUri, redirectUri, requestContext.ServiceBundle.Config.IsBrokerEnabled, cancellationToken).ConfigureAwait(continueOnCapturedContext: true);
				if (!uri.Authority.Equals(redirectUri.Authority, StringComparison.OrdinalIgnoreCase) || !uri.AbsolutePath.Equals(redirectUri.AbsolutePath))
				{
					throw new MsalClientException("loopback_response_uri_mismatch", MsalErrorMessage.RedirectUriMismatch(uri.AbsolutePath, redirectUri.AbsolutePath));
				}
				return AuthorizationResult.FromUri(uri.OriginalString);
			}
			catch (HttpListenerException)
			{
				cancellationToken.ThrowIfCancellationRequested();
				throw;
			}
		}

		public Uri UpdateRedirectUri(Uri redirectUri)
		{
			if (!redirectUri.IsLoopback)
			{
				throw new MsalClientException("loopback_redirect_uri", "Only loopback redirect uri is supported, but " + redirectUri.AbsoluteUri + " was found. Configure http://localhost or http://localhost:port both during app registration and when you create the PublicClientApplication object. See https://aka.ms/msal-net-os-browser for details");
			}
			if (redirectUri.Scheme != "http")
			{
				throw new MsalClientException("loopback_redirect_uri", "Only http uri scheme is supported, but " + redirectUri.Scheme + " was found. Configure http://localhost or http://localhost:port both during app registration and when you create the PublicClientApplication object. See https://aka.ms/msal-net-os-browser for details");
			}
			return FindFreeLocalhostRedirectUri(redirectUri);
		}

		private static Uri FindFreeLocalhostRedirectUri(Uri redirectUri)
		{
			if (redirectUri.Port > 0 && redirectUri.Port != 80)
			{
				return redirectUri;
			}
			TcpListener tcpListener = new TcpListener(IPAddress.Loopback, 0);
			try
			{
				tcpListener.Start();
				return new Uri("http://localhost:" + ((IPEndPoint)tcpListener.LocalEndpoint).Port);
			}
			finally
			{
				tcpListener?.Stop();
			}
		}

		private async Task<Uri> InterceptAuthorizationUriAsync(Uri authorizationUri, Uri redirectUri, bool isBrokerConfigured, CancellationToken cancellationToken)
		{
			Func<Uri, Task> func = (Uri u) => _platformProxy.StartDefaultOsBrowserAsync(u.AbsoluteUri, isBrokerConfigured);
			Func<Uri, Task> obj = _webViewOptions?.OpenBrowserAsync ?? func;
			cancellationToken.ThrowIfCancellationRequested();
			await obj(authorizationUri).ConfigureAwait(continueOnCapturedContext: false);
			cancellationToken.ThrowIfCancellationRequested();
			return await _uriInterceptor.ListenToSingleRequestAndRespondAsync(redirectUri.Port, redirectUri.AbsolutePath, GetResponseMessage, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal MessageAndHttpCode GetResponseMessage(Uri authCodeUri)
		{
			AuthorizationResult authorizationResult = AuthorizationResult.FromUri(authCodeUri.OriginalString);
			if (!string.IsNullOrEmpty(authorizationResult.Error))
			{
				_logger.Warning("Default OS Browser intercepted an Uri with an error: " + authorizationResult.Error + " " + authorizationResult.ErrorDescription);
				string message = string.Format(CultureInfo.InvariantCulture, _webViewOptions?.HtmlMessageError ?? "<html>\r\n  <head><title>Authentication Failed</title></head>\r\n  <body>\r\n    Authentication failed. You can return to the application. Feel free to close this browser tab.\r\n</br></br></br></br>\r\n    Error details: error {0} error_description: {1}\r\n  </body>\r\n</html>", authorizationResult.Error, authorizationResult.ErrorDescription);
				return GetMessage(_webViewOptions?.BrowserRedirectError, message);
			}
			return GetMessage(_webViewOptions?.BrowserRedirectSuccess, _webViewOptions?.HtmlMessageSuccess ?? "<html>\r\n  <head><title>Authentication Complete</title></head>\r\n  <body>\r\n    Authentication complete. You can return to the application. Feel free to close this browser tab.\r\n  </body>\r\n</html>");
		}

		private static MessageAndHttpCode GetMessage(Uri redirectUri, string message)
		{
			if (redirectUri != null)
			{
				return new MessageAndHttpCode(HttpStatusCode.Found, redirectUri.ToString());
			}
			return new MessageAndHttpCode(HttpStatusCode.OK, message);
		}
	}
	internal interface IUriInterceptor
	{
		Task<Uri> ListenToSingleRequestAndRespondAsync(int port, string path, Func<Uri, MessageAndHttpCode> responseProducer, CancellationToken cancellationToken);
	}
	internal class MessageAndHttpCode
	{
		public HttpStatusCode HttpCode { get; }

		public string Message { get; }

		public MessageAndHttpCode(HttpStatusCode httpCode, string message)
		{
			HttpCode = httpCode;
			Message = message ?? throw new ArgumentNullException("message");
		}
	}
}
namespace Microsoft.Identity.Client.Platforms.Shared.NetStdCore
{
	internal class NetCoreWebUIFactory : IWebUIFactory
	{
		public bool IsSystemWebViewAvailable => IsUserInteractive;

		public bool IsUserInteractive => DesktopOsHelper.IsUserInteractive();

		public bool IsEmbeddedWebViewAvailable => false;

		public IWebUI CreateAuthenticationDialog(CoreUIParent coreUIParent, WebViewPreference webViewPreference, RequestContext requestContext)
		{
			if (webViewPreference == WebViewPreference.Embedded)
			{
				throw new MsalClientException("no_system_webview", "To enable the embedded webview on Windows, reference Microsoft.Identity.Client.Desktop and call the extension method .WithWindowsEmbeddedBrowserSupport().");
			}
			requestContext.Logger.Info("Using system browser.");
			return new DefaultOsBrowserWebUi(requestContext.ServiceBundle.PlatformProxy, requestContext.Logger, coreUIParent.SystemWebViewOptions);
		}
	}
}
namespace Microsoft.Identity.Client.Platforms.netcore
{
	internal class NetCoreFeatureFlags : IFeatureFlags
	{
		public bool IsFociEnabled => true;
	}
	internal class NetCorePlatformProxy : AbstractPlatformProxy
	{
		public override bool BrokerSupportsWamAccounts => true;

		public NetCorePlatformProxy(ILoggerAdapter logger)
			: base(logger)
		{
		}

		public override Task<string> GetUserPrincipalNameAsync()
		{
			return Task.FromResult(GetUserPrincipalName(8));
		}

		private string GetUserPrincipalName(int nameFormat)
		{
			if (DesktopOsHelper.IsWindows())
			{
				uint userNameSize = 0u;
				WindowsNativeMethods.GetUserNameEx(nameFormat, null, ref userNameSize);
				if (userNameSize == 0)
				{
					throw new MsalClientException("get_user_name_failed", "Failed to get user name. ", new Win32Exception(Marshal.GetLastWin32Error()));
				}
				StringBuilder stringBuilder = new StringBuilder((int)userNameSize);
				if (!WindowsNativeMethods.GetUserNameEx(nameFormat, stringBuilder, ref userNameSize))
				{
					throw new MsalClientException("get_user_name_failed", "Failed to get user name. ", new Win32Exception(Marshal.GetLastWin32Error()));
				}
				return stringBuilder.ToString();
			}
			throw new PlatformNotSupportedException("MSAL cannot determine the username (UPN) of the currently logged in user.For Integrated Windows Authentication and Username/Password flows, please use .WithUsername() before calling ExecuteAsync(). For more details see https://aka.ms/msal-net-iwa");
		}

		protected override string InternalGetProcessorArchitecture()
		{
			if (!DesktopOsHelper.IsWindows())
			{
				return null;
			}
			return WindowsNativeMethods.GetProcessorArchitecture();
		}

		protected override string InternalGetOperatingSystem()
		{
			if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
			{
				return RuntimeInformation.OSDescription;
			}
			if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
			{
				return "MacOS";
			}
			if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
			{
				return "Linux";
			}
			return RuntimeInformation.OSDescription;
		}

		protected override string InternalGetDeviceModel()
		{
			return null;
		}

		public override string GetDefaultRedirectUri(string clientId, bool useRecommendedRedirectUri = false)
		{
			if (useRecommendedRedirectUri)
			{
				return "http://localhost";
			}
			return "urn:ietf:wg:oauth:2.0:oob";
		}

		protected override string InternalGetProductName()
		{
			return "MSAL.NetCore";
		}

		protected override string InternalGetCallingApplicationName()
		{
			return Assembly.GetEntryAssembly()?.GetName()?.Name?.ToString(CultureInfo.InvariantCulture);
		}

		protected override string InternalGetCallingApplicationVersion()
		{
			return Assembly.GetEntryAssembly()?.GetName()?.Version?.ToString();
		}

		protected override string InternalGetDeviceId()
		{
			return Environment.MachineName;
		}

		public override ILegacyCachePersistence CreateLegacyCachePersistence()
		{
			return new InMemoryLegacyCachePersistance();
		}

		protected override IWebUIFactory CreateWebUiFactory()
		{
			return new NetCoreWebUIFactory();
		}

		protected override ICryptographyManager InternalGetCryptographyManager()
		{
			return new CommonCryptographyManager(base.Logger);
		}

		protected override IPlatformLogger InternalGetPlatformLogger()
		{
			return new EventSourcePlatformLogger();
		}

		protected override IFeatureFlags CreateFeatureFlags()
		{
			return new NetCoreFeatureFlags();
		}

		public override Task StartDefaultOsBrowserAsync(string url, bool isBrokerConfigured)
		{
			if (DesktopOsHelper.IsWindows())
			{
				try
				{
					Process.Start(new ProcessStartInfo
					{
						FileName = url,
						UseShellExecute = true
					});
				}
				catch
				{
					url = url.Replace("&", "^&");
					Process.Start(new ProcessStartInfo("cmd", "/c start msedge " + url)
					{
						CreateNoWindow = true
					});
				}
			}
			else if (DesktopOsHelper.IsLinux())
			{
				if (!string.IsNullOrWhiteSpace(Environment.GetEnvironmentVariable("SUDO_USER")))
				{
					throw new MsalClientException("linux_xdg_open_failed", "Unable to open a web page using xdg-open, gnome-open, kfmclient or wslview tools in sudo mode. Please run the process as non-sudo user.");
				}
				try
				{
					bool flag = false;
					string[] openToolsLinux = GetOpenToolsLinux(isBrokerConfigured);
					foreach (string executable in openToolsLinux)
					{
						if (TryGetExecutablePath(executable, out var path))
						{
							OpenLinuxBrowser(path, url);
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						throw new MsalClientException("linux_xdg_open_failed", "Unable to open a web page using xdg-open, gnome-open, kfmclient or wslview tools. See inner exception for details. Possible causes for this error are: tools are not installed or they cannot open a URL. Make sure you can open a web page by invoking from a terminal: xdg-open https://www.bing.com ");
					}
				}
				catch (Exception innerException)
				{
					throw new MsalClientException("linux_xdg_open_failed", "Unable to open a web page using xdg-open, gnome-open, kfmclient or wslview tools. See inner exception for details. Possible causes for this error are: tools are not installed or they cannot open a URL. Make sure you can open a web page by invoking from a terminal: xdg-open https://www.bing.com ", innerException);
				}
			}
			else
			{
				if (!DesktopOsHelper.IsMac())
				{
					throw new PlatformNotSupportedException(RuntimeInformation.OSDescription);
				}
				Process.Start("/usr/bin/open", url);
			}
			return Task.FromResult(0);
		}

		private void OpenLinuxBrowser(string openToolPath, string url)
		{
			Process.Start(new ProcessStartInfo(openToolPath, url)
			{
				RedirectStandardOutput = true,
				RedirectStandardError = true
			});
		}

		private string[] GetOpenToolsLinux(bool isBrokerConfigured)
		{
			if (!isBrokerConfigured)
			{
				return new string[5] { "xdg-open", "gnome-open", "kfmclient", "microsoft-edge", "wslview" };
			}
			return new string[5] { "microsoft-edge", "xdg-open", "gnome-open", "kfmclient", "wslview" };
		}

		public override IPoPCryptoProvider GetDefaultPoPCryptoProvider()
		{
			return PoPProviderFactory.GetOrCreateProvider();
		}

		private bool TryGetExecutablePath(string executable, out string path)
		{
			string environmentVariable = Environment.GetEnvironmentVariable("PATH");
			if (environmentVariable != null)
			{
				string[] array = environmentVariable.Split(new char[1] { ':' });
				foreach (string path2 in array)
				{
					path = Path.Combine(path2, executable);
					if (File.Exists(path))
					{
						return true;
					}
				}
			}
			path = null;
			return false;
		}

		public override IDeviceAuthManager CreateDeviceAuthManager()
		{
			return new DeviceAuthManager(base.CryptographyManager);
		}
	}
}
namespace Microsoft.Identity.Client.WsTrust
{
	internal class CommonNonInteractiveHandler
	{
		private readonly RequestContext _requestContext;

		private readonly IServiceBundle _serviceBundle;

		public CommonNonInteractiveHandler(RequestContext requestContext, IServiceBundle serviceBundle)
		{
			_requestContext = requestContext;
			_serviceBundle = serviceBundle;
		}

		public async Task<string> GetPlatformUserAsync()
		{
			string platformUsername = await _serviceBundle.PlatformProxy.GetUserPrincipalNameAsync().ConfigureAwait(continueOnCapturedContext: false);
			if (string.IsNullOrWhiteSpace(platformUsername))
			{
				_requestContext.Logger.Error("Could not find UPN for logged in user. ");
				throw new MsalClientException("unknown_user", "Could not identify the user logged into the OS. See http://aka.ms/msal-net-iwa for details. ");
			}
			_requestContext.Logger.InfoPii(() => "Logged in user detected with user name '" + platformUsername + "'", () => "Logged in user detected. ");
			return platformUsername;
		}

		public async Task<UserRealmDiscoveryResponse> QueryUserRealmDataAsync(string userRealmUriPrefix, string username)
		{
			UserRealmDiscoveryResponse userRealmResponse = await _serviceBundle.WsTrustWebRequestManager.GetUserRealmAsync(userRealmUriPrefix, username, _requestContext).ConfigureAwait(continueOnCapturedContext: false);
			if (string.Equals(userRealmResponse.DomainName, "live.com"))
			{
				throw new MsalClientException("ropc_not_supported_for_msa", "ROPC does not support MSA accounts. See https://aka.ms/msal-net-ropc for details. ");
			}
			_requestContext.Logger.InfoPii(() => "User with user name '" + username + "' detected as '" + userRealmResponse.AccountType + "'. ", () => "User detected as '" + userRealmResponse.AccountType + "'. ");
			return userRealmResponse;
		}

		public async Task<WsTrustResponse> PerformWsTrustMexExchangeAsync(string federationMetadataUrl, string cloudAudienceUrn, UserAuthType userAuthType, string username, string password, string federationMetadataFilename)
		{
			MexDocument mexDocument;
			try
			{
				mexDocument = await _serviceBundle.WsTrustWebRequestManager.GetMexDocumentAsync(federationMetadataUrl, _requestContext, federationMetadataFilename).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (XmlException innerException)
			{
				throw new MsalClientException("parsing_ws_metadata_exchange_failed", "Parsing WS metadata exchange failed. ", innerException);
			}
			WsTrustEndpoint wsTrustEndpoint = ((userAuthType == UserAuthType.IntegratedAuth) ? mexDocument.GetWsTrustWindowsTransportEndpoint() : mexDocument.GetWsTrustUsernamePasswordEndpoint());
			if (wsTrustEndpoint == null)
			{
				throw new MsalClientException("wstrust_endpoint_not_found", "WS-Trust endpoint not found in metadata document. ");
			}
			_requestContext.Logger.VerbosePii(() => string.Format(CultureInfo.InvariantCulture, "WS-Trust endpoint '{0}' being used from MEX at '{1}'", wsTrustEndpoint.Uri, federationMetadataUrl), () => "Fetched and parsed MEX. ");
			WsTrustResponse wsTrustResponse = await GetWsTrustResponseAsync(userAuthType, cloudAudienceUrn, wsTrustEndpoint, username, password).ConfigureAwait(continueOnCapturedContext: false);
			_requestContext.Logger.Info(() => "Token of type '" + wsTrustResponse.TokenType + "' acquired from WS-Trust endpoint. ");
			return wsTrustResponse;
		}

		internal async Task<WsTrustResponse> GetWsTrustResponseAsync(UserAuthType userAuthType, string cloudAudienceUrn, WsTrustEndpoint endpoint, string username, string password)
		{
			string wsTrustRequest = ((userAuthType == UserAuthType.IntegratedAuth) ? endpoint.BuildTokenRequestMessageWindowsIntegratedAuth(cloudAudienceUrn) : endpoint.BuildTokenRequestMessageUsernamePassword(cloudAudienceUrn, username, password));
			try
			{
				WsTrustResponse wsTrustResponse = await _serviceBundle.WsTrustWebRequestManager.GetWsTrustResponseAsync(endpoint, wsTrustRequest, _requestContext).ConfigureAwait(continueOnCapturedContext: false);
				_requestContext.Logger.Info(() => "Token of type '" + wsTrustResponse.TokenType + "' acquired from WS-Trust endpoint. ");
				return wsTrustResponse;
			}
			catch (Exception ex) when (!(ex is MsalClientException))
			{
				throw new MsalClientException("parsing_wstrust_response_failed", "There was an error parsing the WS-Trust response from the endpoint. \nThis may occur if there are issues with your ADFS configuration. See https://aka.ms/msal-net-iwa-troubleshooting for more details.\nEnable logging to see more details. See https://aka.ms/msal-net-logging. Error Message: " + ex.Message, ex);
			}
		}
	}
	internal interface IWsTrustWebRequestManager
	{
		Task<MexDocument> GetMexDocumentAsync(string federationMetadataUrl, RequestContext requestContext, string federationMetadata = null);

		Task<WsTrustResponse> GetWsTrustResponseAsync(WsTrustEndpoint wsTrustEndpoint, string wsTrustRequest, RequestContext requestContext);

		Task<UserRealmDiscoveryResponse> GetUserRealmAsync(string userRealmUriPrefix, string userName, RequestContext requestContext);
	}
	internal enum WsTrustVersion
	{
		WsTrust13,
		WsTrust2005
	}
	internal enum UserAuthType
	{
		IntegratedAuth,
		UsernamePassword
	}
	internal class MexDocument
	{
		private class MexPolicy
		{
			public WsTrustVersion Version { get; set; }

			public string Id { get; set; }

			public UserAuthType AuthType { get; set; }

			public Uri Url { get; set; }
		}

		private const string WsTrustSoapTransport = "http://schemas.xmlsoap.org/soap/http";

		private readonly Dictionary<string, MexPolicy> _policies = new Dictionary<string, MexPolicy>();

		private readonly Dictionary<string, MexPolicy> _bindings = new Dictionary<string, MexPolicy>();

		public MexDocument(string responseBody)
		{
			XDocument xDocument = XDocument.Parse(responseBody, LoadOptions.None);
			ReadPolicies(xDocument);
			ReadPolicyBindings(xDocument);
			SetPolicyEndpointAddresses(xDocument);
		}

		public WsTrustEndpoint GetWsTrustUsernamePasswordEndpoint()
		{
			return GetWsTrustEndpoint(UserAuthType.UsernamePassword);
		}

		public WsTrustEndpoint GetWsTrustWindowsTransportEndpoint()
		{
			return GetWsTrustEndpoint(UserAuthType.IntegratedAuth);
		}

		private WsTrustEndpoint GetWsTrustEndpoint(UserAuthType userAuthType)
		{
			MexPolicy mexPolicy = SelectPolicy(userAuthType);
			if (mexPolicy == null)
			{
				return null;
			}
			return new WsTrustEndpoint(mexPolicy.Url, mexPolicy.Version);
		}

		private MexPolicy SelectPolicy(UserAuthType userAuthType)
		{
			return _policies.Values.FirstOrDefault((MexPolicy p) => p.Url != null && p.AuthType == userAuthType && p.Version == WsTrustVersion.WsTrust13) ?? _policies.Values.FirstOrDefault((MexPolicy p) => p.Url != null && p.AuthType == userAuthType);
		}

		private void ReadPolicies(XContainer mexDocument)
		{
			foreach (XElement item in FindElements(mexDocument, XmlNamespace.Wsp, "Policy"))
			{
				XElement xElement = item.Elements(XmlNamespace.Wsp + "ExactlyOne").FirstOrDefault();
				if (xElement == null)
				{
					continue;
				}
				foreach (XElement item2 in xElement.Descendants(XmlNamespace.Wsp + "All"))
				{
					XNamespace sp = XmlNamespace.Sp;
					XElement xElement2 = item2.Elements(XmlNamespace.Http + "NegotiateAuthentication").FirstOrDefault();
					if (xElement2 != null)
					{
						AddPolicy(item, UserAuthType.IntegratedAuth);
					}
					xElement2 = item2.Elements(sp + "SignedEncryptedSupportingTokens").FirstOrDefault();
					if (xElement2 == null && (xElement2 = item2.Elements(XmlNamespace.Sp2005 + "SignedSupportingTokens").FirstOrDefault()) == null)
					{
						continue;
					}
					sp = XmlNamespace.Sp2005;
					XElement xElement3 = xElement2.Elements(XmlNamespace.Wsp + "Policy").FirstOrDefault();
					if (xElement3 == null)
					{
						continue;
					}
					XElement xElement4 = xElement3.Elements(sp + "UsernameToken").FirstOrDefault();
					if (xElement4 != null)
					{
						XElement xElement5 = xElement4.Elements(XmlNamespace.Wsp + "Policy").FirstOrDefault();
						if (xElement5 != null && xElement5.Elements(sp + "WssUsernameToken10").FirstOrDefault() != null)
						{
							AddPolicy(item, UserAuthType.UsernamePassword);
						}
					}
				}
			}
		}

		private void ReadPolicyBindings(XContainer mexDocument)
		{
			foreach (XElement item in FindElements(mexDocument, XmlNamespace.Wsdl, "binding"))
			{
				foreach (XElement item2 in item.Elements(XmlNamespace.Wsp + "PolicyReference"))
				{
					XAttribute xAttribute = item2.Attribute("URI");
					if (xAttribute == null || !_policies.ContainsKey(xAttribute.Value))
					{
						continue;
					}
					XAttribute xAttribute2 = item.Attribute("name");
					if (xAttribute2 == null)
					{
						continue;
					}
					XElement xElement = item.Elements(XmlNamespace.Wsdl + "operation").FirstOrDefault();
					if (xElement == null)
					{
						continue;
					}
					XElement xElement2 = xElement.Elements(XmlNamespace.Soap12 + "operation").FirstOrDefault();
					if (xElement2 == null)
					{
						continue;
					}
					XAttribute xAttribute3 = xElement2.Attribute("soapAction");
					if (xAttribute3 == null || (string.Compare(XmlNamespace.Issue.ToString(), xAttribute3.Value, StringComparison.OrdinalIgnoreCase) != 0 && string.Compare(XmlNamespace.Issue2005.ToString(), xAttribute3.Value, StringComparison.OrdinalIgnoreCase) != 0))
					{
						continue;
					}
					bool flag = string.Compare(XmlNamespace.Issue2005.ToString(), xAttribute3.Value, StringComparison.OrdinalIgnoreCase) == 0;
					_policies[xAttribute.Value].Version = (flag ? WsTrustVersion.WsTrust2005 : WsTrustVersion.WsTrust13);
					XElement xElement3 = item.Elements(XmlNamespace.Soap12 + "binding").FirstOrDefault();
					if (xElement3 != null)
					{
						XAttribute xAttribute4 = xElement3.Attribute("transport");
						if (xAttribute4 != null && string.Compare("http://schemas.xmlsoap.org/soap/http", xAttribute4.Value, StringComparison.OrdinalIgnoreCase) == 0)
						{
							_bindings.Add(xAttribute2.Value, _policies[xAttribute.Value]);
						}
					}
				}
			}
		}

		private void SetPolicyEndpointAddresses(XContainer mexDocument)
		{
			foreach (XElement item in FindElements(mexDocument, XmlNamespace.Wsdl, "service").First().Elements(XmlNamespace.Wsdl + "port"))
			{
				XAttribute xAttribute = item.Attribute("binding");
				if (xAttribute == null)
				{
					continue;
				}
				string[] array = xAttribute.Value.Split(new char[1] { ':' }, 2);
				if (array.Length < 2 || !_bindings.ContainsKey(array[1]))
				{
					continue;
				}
				XElement xElement = item.Elements(XmlNamespace.Wsa10 + "EndpointReference").FirstOrDefault();
				if (xElement != null)
				{
					XElement xElement2 = xElement.Elements(XmlNamespace.Wsa10 + "Address").FirstOrDefault();
					if (xElement2 != null && Uri.IsWellFormedUriString(xElement2.Value, UriKind.Absolute))
					{
						_bindings[array[1]].Url = new Uri(xElement2.Value);
					}
				}
			}
		}

		private static IEnumerable<XElement> FindElements(XContainer mexDocument, XNamespace xNamespace, string element)
		{
			IEnumerable<XElement> enumerable = mexDocument.Elements()?.First()?.Elements(xNamespace + element);
			if (enumerable == null)
			{
				throw new MsalClientException("parsing_ws_metadata_exchange_failed", "Parsing WS metadata exchange failed.  Could not find XML data.");
			}
			if (!enumerable.Any())
			{
				enumerable = mexDocument.Elements().DescendantsAndSelf().Elements(xNamespace + element);
				if (!enumerable.Any())
				{
					throw new MsalClientException("parsing_ws_metadata_exchange_failed", "Parsing WS metadata exchange failed.  Could not find element " + element + ".");
				}
			}
			return enumerable;
		}

		private void AddPolicy(XElement policy, UserAuthType policyAuthType)
		{
			if ((policy.Descendants(XmlNamespace.Sp + "TransportBinding").FirstOrDefault() ?? policy.Descendants(XmlNamespace.Sp2005 + "TransportBinding").FirstOrDefault()) != null)
			{
				XAttribute xAttribute = policy.Attribute(XmlNamespace.Wsu + "Id");
				if (xAttribute != null)
				{
					_policies.Add("#" + xAttribute.Value, new MexPolicy
					{
						Id = xAttribute.Value,
						AuthType = policyAuthType
					});
				}
			}
		}
	}
	internal static class SecureStringExtensions
	{
		public static char[] PasswordToCharArray(this SecureString secureString)
		{
			if (secureString == null)
			{
				return null;
			}
			char[] array = new char[secureString.Length];
			IntPtr intPtr = Marshal.SecureStringToCoTaskMemUnicode(secureString);
			for (int i = 0; i < secureString.Length; i++)
			{
				array[i] = (char)Marshal.ReadInt16(intPtr, i * 2);
			}
			Marshal.ZeroFreeCoTaskMemUnicode(intPtr);
			return array;
		}
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal sealed class UserRealmDiscoveryResponse
	{
		[JsonProperty("ver")]
		public string Version { get; set; }

		[JsonProperty("account_type")]
		public string AccountType { get; set; }

		[JsonProperty("federation_protocol")]
		public string FederationProtocol { get; set; }

		[JsonProperty("federation_metadata_url")]
		public string FederationMetadataUrl { get; set; }

		[JsonProperty("federation_active_auth_url")]
		public string FederationActiveAuthUrl { get; set; }

		[JsonProperty("cloud_audience_urn")]
		public string CloudAudienceUrn { get; set; }

		[JsonProperty("domain_name")]
		public string DomainName { get; set; }

		public bool IsFederated => string.Equals(AccountType, "federated", StringComparison.OrdinalIgnoreCase);

		public bool IsManaged => string.Equals(AccountType, "managed", StringComparison.OrdinalIgnoreCase);
	}
	internal class WsTrustEndpoint
	{
		private const string EnvelopeNamespaceValue = "http://www.w3.org/2003/05/soap-envelope";

		private const string WsuNamespaceValue = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd";

		private readonly ITimeService _timeService;

		private readonly IGuidFactory _guidFactory;

		public Uri Uri { get; }

		public WsTrustVersion Version { get; }

		public WsTrustEndpoint(Uri uri, WsTrustVersion version, ITimeService timeService = null, IGuidFactory guidFactory = null)
		{
			Uri = uri;
			Version = version;
			_timeService = timeService ?? new TimeService();
			_guidFactory = guidFactory ?? new GuidFactory();
		}

		public string BuildTokenRequestMessageWindowsIntegratedAuth(string cloudAudienceUri)
		{
			return BuildTokenRequestMessage(UserAuthType.IntegratedAuth, cloudAudienceUri, string.Empty, string.Empty);
		}

		public string BuildTokenRequestMessageUsernamePassword(string cloudAudienceUri, string username, string password)
		{
			return BuildTokenRequestMessage(UserAuthType.UsernamePassword, cloudAudienceUri, username, password);
		}

		private string BuildTokenRequestMessage(UserAuthType authType, string cloudAudienceUri, string username, string password)
		{
			string text;
			string ns;
			string text2;
			string text3;
			if (Version == WsTrustVersion.WsTrust2005)
			{
				text = "http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue";
				ns = "http://schemas.xmlsoap.org/ws/2005/02/trust";
				text2 = "http://schemas.xmlsoap.org/ws/2005/05/identity/NoProofKey";
				text3 = "http://schemas.xmlsoap.org/ws/2005/02/trust/Issue";
			}
			else
			{
				text = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue";
				ns = "http://docs.oasis-open.org/ws-sx/ws-trust/200512";
				text2 = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Bearer";
				text3 = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue";
			}
			using StringWriterWithEncoding stringWriterWithEncoding = new StringWriterWithEncoding(Encoding.UTF8);
			using (XmlWriter xmlWriter = XmlWriter.Create(stringWriterWithEncoding, new XmlWriterSettings
			{
				Async = false,
				Encoding = Encoding.UTF8,
				CloseOutput = false
			}))
			{
				xmlWriter.WriteStartElement("s", "Envelope", "http://www.w3.org/2003/05/soap-envelope");
				xmlWriter.WriteAttributeString("wsa", "http://www.w3.org/2000/xmlns/", "http://www.w3.org/2005/08/addressing");
				xmlWriter.WriteAttributeString("wsu", "http://www.w3.org/2000/xmlns/", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd");
				xmlWriter.WriteStartElement("Header", "http://www.w3.org/2003/05/soap-envelope");
				xmlWriter.WriteStartElement("Action", "http://www.w3.org/2005/08/addressing");
				xmlWriter.WriteAttributeString("mustUnderstand", "http://www.w3.org/2003/05/soap-envelope", "1");
				xmlWriter.WriteString(text);
				xmlWriter.WriteEndElement();
				xmlWriter.WriteStartElement("MessageID", "http://www.w3.org/2005/08/addressing");
				xmlWriter.WriteString("urn:uuid:" + _guidFactory.NewGuid().ToString("D"));
				xmlWriter.WriteEndElement();
				xmlWriter.WriteStartElement("ReplyTo", "http://www.w3.org/2005/08/addressing");
				xmlWriter.WriteStartElement("Address", "http://www.w3.org/2005/08/addressing");
				xmlWriter.WriteString("http://www.w3.org/2005/08/addressing/anonymous");
				xmlWriter.WriteEndElement();
				xmlWriter.WriteEndElement();
				xmlWriter.WriteStartElement("To", "http://www.w3.org/2005/08/addressing");
				xmlWriter.WriteAttributeString("mustUnderstand", "http://www.w3.org/2003/05/soap-envelope", "1");
				xmlWriter.WriteString(Uri.ToString());
				xmlWriter.WriteEndElement();
				if (authType == UserAuthType.UsernamePassword)
				{
					AppendSecurityHeader(xmlWriter, username, password);
				}
				xmlWriter.WriteEndElement();
				xmlWriter.WriteStartElement("Body", "http://www.w3.org/2003/05/soap-envelope");
				xmlWriter.WriteStartElement("wst", "RequestSecurityToken", ns);
				xmlWriter.WriteStartElement("wsp", "AppliesTo", "http://schemas.xmlsoap.org/ws/2004/09/policy");
				xmlWriter.WriteStartElement("EndpointReference", "http://www.w3.org/2005/08/addressing");
				xmlWriter.WriteStartElement("Address", "http://www.w3.org/2005/08/addressing");
				xmlWriter.WriteString(cloudAudienceUri);
				xmlWriter.WriteEndElement();
				xmlWriter.WriteEndElement();
				xmlWriter.WriteEndElement();
				xmlWriter.WriteStartElement("KeyType", ns);
				xmlWriter.WriteString(text2);
				xmlWriter.WriteEndElement();
				xmlWriter.WriteStartElement("RequestType", ns);
				xmlWriter.WriteString(text3);
				xmlWriter.WriteEndElement();
				xmlWriter.WriteEndElement();
				xmlWriter.WriteEndElement();
				xmlWriter.WriteEndElement();
			}
			return stringWriterWithEncoding.ToString();
		}

		private void AppendSecurityHeader(XmlWriter writer, string username, string password)
		{
			DateTime utcNow = _timeService.GetUtcNow();
			string value = BuildTimeString(utcNow);
			string value2 = BuildTimeString(utcNow.AddMinutes(10.0));
			string value3 = ((Version == WsTrustVersion.WsTrust2005) ? "UnPwSecTok2005-" : "UnPwSecTok13-") + _guidFactory.NewGuid().ToString("D");
			writer.WriteStartElement("wsse", "Security", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd");
			writer.WriteAttributeString("mustUnderstand", "http://www.w3.org/2003/05/soap-envelope", "1");
			writer.WriteStartElement("Timestamp", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd");
			writer.WriteAttributeString("Id", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd", "MSATimeStamp");
			writer.WriteElementString("Created", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd", value);
			writer.WriteElementString("Expires", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd", value2);
			writer.WriteEndElement();
			writer.WriteStartElement("UsernameToken", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd");
			writer.WriteAttributeString("Id", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd", value3);
			writer.WriteElementString("Username", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", username);
			writer.WriteElementString("Password", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", password);
			writer.WriteEndElement();
			writer.WriteEndElement();
		}

		private static string BuildTimeString(DateTime utcTime)
		{
			return utcTime.ToString("yyyy-MM-ddTHH:mm:ss.068Z", CultureInfo.InvariantCulture);
		}
	}
	internal class WsTrustResponse
	{
		public const string Saml1Assertion = "urn:oasis:names:tc:SAML:1.0:assertion";

		public string Token { get; private set; }

		public string TokenType { get; private set; }

		public static WsTrustResponse CreateFromResponse(string response, WsTrustVersion version)
		{
			return CreateFromResponseDocument(XDocument.Parse(response, LoadOptions.PreserveWhitespace), version);
		}

		public static string ReadErrorResponse(XDocument responseDocument)
		{
			string text = null;
			XElement xElement = responseDocument.Descendants(XmlNamespace.SoapEnvelope + "Body").FirstOrDefault();
			if (xElement != null)
			{
				XElement xElement2 = xElement.Elements(XmlNamespace.SoapEnvelope + "Fault").FirstOrDefault();
				if (xElement2 != null)
				{
					text = GetFaultMessage(xElement2);
				}
			}
			if (string.IsNullOrWhiteSpace(text))
			{
				text = responseDocument.ToString();
			}
			return text;
		}

		private static string GetFaultMessage(XElement fault)
		{
			XElement xElement = fault.Elements(XmlNamespace.SoapEnvelope + "Reason").FirstOrDefault();
			if (xElement != null)
			{
				XElement xElement2 = xElement.Elements(XmlNamespace.SoapEnvelope + "Text").FirstOrDefault();
				if (xElement2 != null)
				{
					using (XmlReader xmlReader = xElement2.CreateReader())
					{
						xmlReader.MoveToContent();
						return xmlReader.ReadInnerXml();
					}
				}
			}
			return null;
		}

		internal static WsTrustResponse CreateFromResponseDocument(XDocument responseDocument, WsTrustVersion version)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			XNamespace xNamespace = XmlNamespace.Trust;
			if (version == WsTrustVersion.WsTrust2005)
			{
				xNamespace = XmlNamespace.Trust2005;
			}
			bool flag = true;
			if (version == WsTrustVersion.WsTrust13 && responseDocument.Descendants(xNamespace + "RequestSecurityTokenResponseCollection").FirstOrDefault() == null)
			{
				flag = false;
			}
			if (!flag)
			{
				return null;
			}
			foreach (XElement item in responseDocument.Descendants(xNamespace + "RequestSecurityTokenResponse"))
			{
				XElement xElement = item.Elements(xNamespace + "TokenType").FirstOrDefault();
				if (xElement == null)
				{
					continue;
				}
				XElement xElement2 = item.Elements(xNamespace + "RequestedSecurityToken").FirstOrDefault();
				if (xElement2 == null)
				{
					continue;
				}
				StringBuilder stringBuilder = new StringBuilder();
				foreach (XNode item2 in xElement2.Nodes())
				{
					stringBuilder.Append(item2.ToString(SaveOptions.DisableFormatting));
				}
				dictionary.Add(xElement.Value, stringBuilder.ToString());
			}
			if (dictionary.Count == 0)
			{
				return null;
			}
			string text = (dictionary.ContainsKey("urn:oasis:names:tc:SAML:1.0:assertion") ? "urn:oasis:names:tc:SAML:1.0:assertion" : dictionary.Keys.First());
			return new WsTrustResponse
			{
				TokenType = text,
				Token = dictionary[text]
			};
		}
	}
	internal class WsTrustWebRequestManager : IWsTrustWebRequestManager
	{
		private readonly IHttpManager _httpManager;

		public WsTrustWebRequestManager(IHttpManager httpManager)
		{
			_httpManager = httpManager;
		}

		public async Task<MexDocument> GetMexDocumentAsync(string federationMetadataUrl, RequestContext requestContext, string federationMetadata = null)
		{
			if (!string.IsNullOrEmpty(federationMetadata))
			{
				MexDocument result = new MexDocument(federationMetadata);
				requestContext.Logger.Info(() => "MEX document fetched and parsed from provided federation metadata");
				return result;
			}
			IDictionary<string, string> msalIdParameters = MsalIdHelper.GetMsalIdParameters(requestContext.Logger);
			UriBuilder uriBuilder = new UriBuilder(federationMetadataUrl);
			HttpResponse httpResponse = await _httpManager.SendGetAsync(uriBuilder.Uri, msalIdParameters, requestContext.Logger, retry: true, requestContext.UserCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (httpResponse.StatusCode != HttpStatusCode.OK)
			{
				string errorMessage = string.Format(CultureInfo.CurrentCulture, "Response status code does not indicate success: {0} ({1}). See https://aka.ms/msal-net-ropc for more information. ", (int)httpResponse.StatusCode, httpResponse.StatusCode);
				requestContext.Logger.ErrorPii($"=== Token Acquisition ({requestContext.ApiEvent?.ApiIdString}) failed:\n\tAuthority: {requestContext.ServiceBundle.Config.Authority.AuthorityInfo.CanonicalAuthority}\n\tClientId: {requestContext.ServiceBundle.Config.ClientId}.", $"=== Token Acquisition ({requestContext.ApiEvent?.ApiIdString}) failed.\n\tHost: {requestContext.ServiceBundle.Config.Authority.AuthorityInfo.Host}.");
				throw MsalServiceExceptionFactory.FromHttpResponse("accessing_ws_metadata_exchange_failed", errorMessage, httpResponse);
			}
			MexDocument result2 = new MexDocument(httpResponse.Body);
			requestContext.Logger.InfoPii(() => "MEX document fetched and parsed from '" + federationMetadataUrl + "'", () => "Fetched and parsed MEX");
			return result2;
		}

		public async Task<WsTrustResponse> GetWsTrustResponseAsync(WsTrustEndpoint wsTrustEndpoint, string wsTrustRequest, RequestContext requestContext)
		{
			Dictionary<string, string> headers = new Dictionary<string, string> { 
			{
				"SOAPAction",
				(wsTrustEndpoint.Version == WsTrustVersion.WsTrust2005) ? XmlNamespace.Issue2005.ToString() : XmlNamespace.Issue.ToString()
			} };
			StringContent body = new StringContent(wsTrustRequest, Encoding.UTF8, "application/soap+xml");
			HttpResponse httpResponse = await _httpManager.SendPostForceResponseAsync(wsTrustEndpoint.Uri, headers, body, requestContext.Logger, requestContext.UserCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (httpResponse.StatusCode != HttpStatusCode.OK)
			{
				string arg;
				try
				{
					arg = WsTrustResponse.ReadErrorResponse(XDocument.Parse(httpResponse.Body, LoadOptions.None));
				}
				catch (XmlException)
				{
					arg = httpResponse.Body;
				}
				requestContext.Logger.ErrorPii("Ws-Trust request failed. See error message for more details." + $"Status code: {httpResponse.StatusCode} \nError message: {arg}", "Ws-Trust request failed. See error message for more details." + $"Status code: {httpResponse.StatusCode}");
				string errorMessage = string.Format(CultureInfo.CurrentCulture, "Federated service at {0} returned error: {1} ", wsTrustEndpoint.Uri, arg);
				throw MsalServiceExceptionFactory.FromHttpResponse("federated_service_returned_error", errorMessage, httpResponse);
			}
			try
			{
				WsTrustResponse wsTrustResponse = WsTrustResponse.CreateFromResponse(httpResponse.Body, wsTrustEndpoint.Version);
				if (wsTrustResponse == null)
				{
					requestContext.Logger.ErrorPii("Token not found in the ws trust response. See response for more details: \n" + httpResponse.Body, "Token not found in WS-Trust response.");
					throw new MsalClientException("parsing_wstrust_response_failed", "There was an error parsing the WS-Trust response from the endpoint. \nThis may occur if there are issues with your ADFS configuration. See https://aka.ms/msal-net-iwa-troubleshooting for more details.\nEnable logging to see more details. See https://aka.ms/msal-net-logging.");
				}
				return wsTrustResponse;
			}
			catch (XmlException innerException)
			{
				string errorMessage2 = string.Format(CultureInfo.CurrentCulture, "Federated service at {0} parse error: Body {1} ", wsTrustEndpoint.Uri, httpResponse.Body);
				throw new MsalClientException("parsing_wstrust_response_failed", errorMessage2, innerException);
			}
		}

		public async Task<UserRealmDiscoveryResponse> GetUserRealmAsync(string userRealmUriPrefix, string userName, RequestContext requestContext)
		{
			requestContext.Logger.Info("Sending request to userrealm endpoint. ");
			IDictionary<string, string> msalIdParameters = MsalIdHelper.GetMsalIdParameters(requestContext.Logger);
			Uri uri = new UriBuilder(userRealmUriPrefix + userName + "?api-version=1.0").Uri;
			HttpResponse httpResponse = await _httpManager.SendGetAsync(uri, msalIdParameters, requestContext.Logger, retry: true, requestContext.UserCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (httpResponse.StatusCode == HttpStatusCode.OK)
			{
				return JsonHelper.DeserializeFromJson<UserRealmDiscoveryResponse>(httpResponse.Body);
			}
			string errorMessage = string.Format(CultureInfo.CurrentCulture, "Response status code does not indicate success: {0} ({1}). ", (int)httpResponse.StatusCode, httpResponse.StatusCode);
			requestContext.Logger.ErrorPii($"=== Token Acquisition ({requestContext.ApiEvent?.ApiIdString}) failed:\n\tAuthority: {requestContext.ServiceBundle.Config.Authority.AuthorityInfo.CanonicalAuthority}\n\tClientId: {requestContext.ServiceBundle.Config.ClientId}.", $"=== Token Acquisition ({requestContext.ApiEvent?.ApiIdString}) failed.\n\tHost: {requestContext.ServiceBundle.Config.Authority.AuthorityInfo.Host}.");
			throw MsalServiceExceptionFactory.FromHttpResponse("user_realm_discovery_failed", errorMessage, httpResponse);
		}
	}
}
namespace Microsoft.Identity.Client.Utils
{
	internal static class AuthorityHelpers
	{
		public static string GetTenantId(Uri authorityUri)
		{
			return AuthorityInfo.FromAuthorityUri(authorityUri.ToString(), validateAuthority: false).CreateAuthority().TenantId;
		}
	}
	internal static class Base64UrlHelpers
	{
		private const char base64PadCharacter = '=';

		private const char base64Character62 = '+';

		private const char base64Character63 = '/';

		private const char base64UrlCharacter62 = '-';

		private const char base64UrlCharacter63 = '_';

		internal static readonly char[] s_base64Table = new char[64]
		{
			'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
			'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
			'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',
			'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
			'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',
			'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7',
			'8', '9', '-', '_'
		};

		public static string Encode(string arg)
		{
			if (arg == null)
			{
				return null;
			}
			return Encode(Encoding.UTF8.GetBytes(arg));
		}

		private static string Encode(byte[] inArray, int offset, int length)
		{
			if (inArray == null)
			{
				throw new ArgumentNullException("inArray");
			}
			if (length == 0)
			{
				return string.Empty;
			}
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			if (offset < 0 || inArray.Length < offset)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (inArray.Length < offset + length)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			int num = length % 3;
			int num2 = offset + (length - num);
			char[] array = new char[(length + 2) / 3 * 4];
			char[] array2 = s_base64Table;
			int num3 = 0;
			int i;
			for (i = offset; i < num2; i += 3)
			{
				byte b = inArray[i];
				byte b2 = inArray[i + 1];
				byte b3 = inArray[i + 2];
				array[num3] = array2[b >> 2];
				array[num3 + 1] = array2[((b & 3) << 4) | (b2 >> 4)];
				array[num3 + 2] = array2[((b2 & 0xF) << 2) | (b3 >> 6)];
				array[num3 + 3] = array2[b3 & 0x3F];
				num3 += 4;
			}
			i = num2;
			switch (num)
			{
			case 2:
			{
				byte b5 = inArray[i];
				byte b6 = inArray[i + 1];
				array[num3] = array2[b5 >> 2];
				array[num3 + 1] = array2[((b5 & 3) << 4) | (b6 >> 4)];
				array[num3 + 2] = array2[(b6 & 0xF) << 2];
				num3 += 3;
				break;
			}
			case 1:
			{
				byte b4 = inArray[i];
				array[num3] = array2[b4 >> 2];
				array[num3 + 1] = array2[(b4 & 3) << 4];
				num3 += 2;
				break;
			}
			}
			return new string(array, 0, num3);
		}

		public static string Encode(byte[] inArray)
		{
			if (inArray == null)
			{
				return null;
			}
			return Encode(inArray, 0, inArray.Length);
		}

		internal static string EncodeString(string str)
		{
			if (str == null)
			{
				return null;
			}
			return Encode(Encoding.UTF8.GetBytes(str));
		}

		public static byte[] DecodeBytes(string str)
		{
			if (str == null)
			{
				return null;
			}
			return UnsafeDecode(str);
		}

		private unsafe static byte[] UnsafeDecode(string str)
		{
			int num = str.Length % 4;
			if (num == 1)
			{
				throw new FormatException("Unable to decode: " + str + " as Base64url encoded string.");
			}
			bool flag = false;
			int num2 = str.Length + (4 - num) % 4;
			for (int i = 0; i < str.Length; i++)
			{
				if (str[i] == '-' || str[i] == '_')
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				string text = new string('\0', num2);
				fixed (char* ptr = text)
				{
					int j;
					for (j = 0; j < str.Length; j++)
					{
						if (str[j] == '-')
						{
							ptr[j] = '+';
						}
						else if (str[j] == '_')
						{
							ptr[j] = '/';
						}
						else
						{
							ptr[j] = str[j];
						}
					}
					for (; j < num2; j++)
					{
						ptr[j] = '=';
					}
				}
				return Convert.FromBase64String(text);
			}
			if (num2 == str.Length)
			{
				return Convert.FromBase64String(str);
			}
			string text2 = new string('\0', num2);
			fixed (char* source = str)
			{
				fixed (char* ptr2 = text2)
				{
					Buffer.MemoryCopy(source, ptr2, str.Length * 2, str.Length * 2);
					ptr2[str.Length] = '=';
					if (str.Length + 2 == num2)
					{
						ptr2[str.Length + 1] = '=';
					}
				}
			}
			return Convert.FromBase64String(text2);
		}

		public static string Decode(string arg)
		{
			return Encoding.UTF8.GetString(DecodeBytes(arg));
		}
	}
	internal static class CollectionHelpers
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static IReadOnlyList<T> GetEmptyReadOnlyList<T>()
		{
			return Array.Empty<T>();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static List<T> GetEmptyList<T>()
		{
			return new List<T>();
		}

		public static IReadOnlyDictionary<TKey, TValue> GetEmptyDictionary<TKey, TValue>()
		{
			return new Dictionary<TKey, TValue>();
		}
	}
	[DebuggerDisplay("Count = {Count}")]
	internal class ConcurrentHashSet<T> : IReadOnlyCollection<T>, IEnumerable<T>, IEnumerable, ICollection<T>
	{
		private class Tables
		{
			public readonly Node[] Buckets;

			public readonly object[] Locks;

			public volatile int[] CountPerLock;

			public Tables(Node[] buckets, object[] locks, int[] countPerLock)
			{
				Buckets = buckets;
				Locks = locks;
				CountPerLock = countPerLock;
			}
		}

		private class Node
		{
			public readonly T Item;

			public readonly int Hashcode;

			public volatile Node Next;

			public Node(T item, int hashcode, Node next)
			{
				Item = item;
				Hashcode = hashcode;
				Next = next;
			}
		}

		private const int DefaultCapacity = 31;

		private const int MaxLockNumber = 1024;

		private readonly IEqualityComparer<T> _comparer;

		private readonly bool _growLockArray;

		private int _budget;

		private volatile Tables _tables;

		private static int DefaultConcurrencyLevel => ProcessorCounter.ProcessorCount;

		public int Count
		{
			get
			{
				int num = 0;
				int locksAcquired = 0;
				try
				{
					AcquireAllLocks(ref locksAcquired);
					for (int i = 0; i < _tables.CountPerLock.Length; i++)
					{
						num += _tables.CountPerLock[i];
					}
					return num;
				}
				finally
				{
					ReleaseLocks(0, locksAcquired);
				}
			}
		}

		public bool IsEmpty
		{
			get
			{
				int locksAcquired = 0;
				try
				{
					AcquireAllLocks(ref locksAcquired);
					for (int i = 0; i < _tables.CountPerLock.Length; i++)
					{
						if (_tables.CountPerLock[i] != 0)
						{
							return false;
						}
					}
				}
				finally
				{
					ReleaseLocks(0, locksAcquired);
				}
				return true;
			}
		}

		bool ICollection<T>.IsReadOnly => false;

		public ConcurrentHashSet()
			: this(DefaultConcurrencyLevel, 31, growLockArray: true, (IEqualityComparer<T>)null)
		{
		}

		public ConcurrentHashSet(int concurrencyLevel, int capacity)
			: this(concurrencyLevel, capacity, growLockArray: false, (IEqualityComparer<T>)null)
		{
		}

		public ConcurrentHashSet(IEnumerable<T> collection)
			: this(collection, (IEqualityComparer<T>)null)
		{
		}

		public ConcurrentHashSet(IEqualityComparer<T> comparer)
			: this(DefaultConcurrencyLevel, 31, growLockArray: true, comparer)
		{
		}

		public ConcurrentHashSet(IEnumerable<T> collection, IEqualityComparer<T> comparer)
			: this(comparer)
		{
			if (collection == null)
			{
				throw new ArgumentNullException("collection");
			}
			InitializeFromCollection(collection);
		}

		public ConcurrentHashSet(int concurrencyLevel, IEnumerable<T> collection, IEqualityComparer<T> comparer)
			: this(concurrencyLevel, 31, growLockArray: false, comparer)
		{
			if (collection == null)
			{
				throw new ArgumentNullException("collection");
			}
			InitializeFromCollection(collection);
		}

		public ConcurrentHashSet(int concurrencyLevel, int capacity, IEqualityComparer<T> comparer)
			: this(concurrencyLevel, capacity, growLockArray: false, comparer)
		{
		}

		private ConcurrentHashSet(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer<T> comparer)
		{
			if (concurrencyLevel < 1)
			{
				throw new ArgumentOutOfRangeException("concurrencyLevel");
			}
			if (capacity < 0)
			{
				throw new ArgumentOutOfRangeException("capacity");
			}
			if (capacity < concurrencyLevel)
			{
				capacity = concurrencyLevel;
			}
			object[] array = new object[concurrencyLevel];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new object();
			}
			int[] countPerLock = new int[array.Length];
			Node[] array2 = new Node[capacity];
			_tables = new Tables(array2, array, countPerLock);
			_growLockArray = growLockArray;
			_budget = array2.Length / array.Length;
			_comparer = comparer ?? EqualityComparer<T>.Default;
		}

		public bool Add(T item)
		{
			return AddInternal(item, _comparer.GetHashCode(item), acquireLock: true);
		}

		public void Clear()
		{
			int locksAcquired = 0;
			try
			{
				AcquireAllLocks(ref locksAcquired);
				Tables tables = (_tables = new Tables(new Node[31], _tables.Locks, new int[_tables.CountPerLock.Length]));
				_budget = Math.Max(1, tables.Buckets.Length / tables.Locks.Length);
			}
			finally
			{
				ReleaseLocks(0, locksAcquired);
			}
		}

		public bool Contains(T item)
		{
			int hashCode = _comparer.GetHashCode(item);
			Tables tables = _tables;
			int bucket = GetBucket(hashCode, tables.Buckets.Length);
			for (Node node = Volatile.Read(ref tables.Buckets[bucket]); node != null; node = node.Next)
			{
				if (hashCode == node.Hashcode && _comparer.Equals(node.Item, item))
				{
					return true;
				}
			}
			return false;
		}

		public bool TryRemove(T item)
		{
			int hashCode = _comparer.GetHashCode(item);
			while (true)
			{
				Tables tables = _tables;
				GetBucketAndLockNo(hashCode, out var bucketNo, out var lockNo, tables.Buckets.Length, tables.Locks.Length);
				lock (tables.Locks[lockNo])
				{
					if (tables != _tables)
					{
						continue;
					}
					Node node = null;
					for (Node node2 = tables.Buckets[bucketNo]; node2 != null; node2 = node2.Next)
					{
						if (hashCode == node2.Hashcode && _comparer.Equals(node2.Item, item))
						{
							if (node == null)
							{
								Volatile.Write(ref tables.Buckets[bucketNo], node2.Next);
							}
							else
							{
								node.Next = node2.Next;
							}
							tables.CountPerLock[lockNo]--;
							return true;
						}
						node = node2;
					}
					break;
				}
			}
			return false;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public IEnumerator<T> GetEnumerator()
		{
			Node[] buckets = _tables.Buckets;
			for (int i = 0; i < buckets.Length; i++)
			{
				for (Node current = Volatile.Read(ref buckets[i]); current != null; current = current.Next)
				{
					yield return current.Item;
				}
			}
		}

		void ICollection<T>.Add(T item)
		{
			Add(item);
		}

		void ICollection<T>.CopyTo(T[] array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (arrayIndex < 0)
			{
				throw new ArgumentOutOfRangeException("arrayIndex");
			}
			int locksAcquired = 0;
			try
			{
				AcquireAllLocks(ref locksAcquired);
				int num = 0;
				for (int i = 0; i < _tables.Locks.Length; i++)
				{
					if (num < 0)
					{
						break;
					}
					num += _tables.CountPerLock[i];
				}
				if (array.Length - num < arrayIndex || num < 0)
				{
					throw new ArgumentException("The index is equal to or greater than the length of the array, or the number of elements in the set is greater than the available space from index to the end of the destination array.");
				}
				CopyToItems(array, arrayIndex);
			}
			finally
			{
				ReleaseLocks(0, locksAcquired);
			}
		}

		bool ICollection<T>.Remove(T item)
		{
			return TryRemove(item);
		}

		private void InitializeFromCollection(IEnumerable<T> collection)
		{
			foreach (T item in collection)
			{
				AddInternal(item, _comparer.GetHashCode(item), acquireLock: false);
			}
			if (_budget == 0)
			{
				_budget = _tables.Buckets.Length / _tables.Locks.Length;
			}
		}

		private bool AddInternal(T item, int hashcode, bool acquireLock)
		{
			checked
			{
				Tables tables;
				bool flag;
				while (true)
				{
					tables = _tables;
					GetBucketAndLockNo(hashcode, out var bucketNo, out var lockNo, tables.Buckets.Length, tables.Locks.Length);
					flag = false;
					bool lockTaken = false;
					try
					{
						if (acquireLock)
						{
							Monitor.Enter(tables.Locks[lockNo], ref lockTaken);
						}
						if (tables != _tables)
						{
							continue;
						}
						for (Node node = tables.Buckets[bucketNo]; node != null; node = node.Next)
						{
							if (hashcode == node.Hashcode && _comparer.Equals(node.Item, item))
							{
								return false;
							}
						}
						Volatile.Write(ref tables.Buckets[bucketNo], new Node(item, hashcode, tables.Buckets[bucketNo]));
						tables.CountPerLock[lockNo]++;
						if (tables.CountPerLock[lockNo] > _budget)
						{
							flag = true;
						}
						break;
					}
					finally
					{
						if (lockTaken)
						{
							Monitor.Exit(tables.Locks[lockNo]);
						}
					}
				}
				if (flag)
				{
					GrowTable(tables);
				}
				return true;
			}
		}

		private static int GetBucket(int hashcode, int bucketCount)
		{
			return (hashcode & 0x7FFFFFFF) % bucketCount;
		}

		private static void GetBucketAndLockNo(int hashcode, out int bucketNo, out int lockNo, int bucketCount, int lockCount)
		{
			bucketNo = (hashcode & 0x7FFFFFFF) % bucketCount;
			lockNo = bucketNo % lockCount;
		}

		private void GrowTable(Tables tables)
		{
			int locksAcquired = 0;
			try
			{
				AcquireLocks(0, 1, ref locksAcquired);
				if (tables != _tables)
				{
					return;
				}
				long num = 0L;
				for (int i = 0; i < tables.CountPerLock.Length; i++)
				{
					num += tables.CountPerLock[i];
				}
				if (num < tables.Buckets.Length / 4)
				{
					_budget = 2 * _budget;
					if (_budget < 0)
					{
						_budget = int.MaxValue;
					}
					return;
				}
				int j = 0;
				bool flag = false;
				try
				{
					for (j = checked(tables.Buckets.Length * 2 + 1); j % 3 == 0 || j % 5 == 0 || j % 7 == 0; j = checked(j + 2))
					{
					}
					if (j > 2146435071)
					{
						flag = true;
					}
				}
				catch (OverflowException)
				{
					flag = true;
				}
				if (flag)
				{
					j = 2146435071;
					_budget = int.MaxValue;
				}
				AcquireLocks(1, tables.Locks.Length, ref locksAcquired);
				object[] array = tables.Locks;
				if (_growLockArray && tables.Locks.Length < 1024)
				{
					array = new object[tables.Locks.Length * 2];
					Array.Copy(tables.Locks, 0, array, 0, tables.Locks.Length);
					for (int k = tables.Locks.Length; k < array.Length; k++)
					{
						array[k] = new object();
					}
				}
				Node[] array2 = new Node[j];
				int[] array3 = new int[array.Length];
				for (int l = 0; l < tables.Buckets.Length; l++)
				{
					Node node = tables.Buckets[l];
					checked
					{
						while (node != null)
						{
							Node next = node.Next;
							GetBucketAndLockNo(node.Hashcode, out var bucketNo, out var lockNo, array2.Length, array.Length);
							array2[bucketNo] = new Node(node.Item, node.Hashcode, array2[bucketNo]);
							array3[lockNo]++;
							node = next;
						}
					}
				}
				_budget = Math.Max(1, array2.Length / array.Length);
				_tables = new Tables(array2, array, array3);
			}
			finally
			{
				ReleaseLocks(0, locksAcquired);
			}
		}

		private void AcquireAllLocks(ref int locksAcquired)
		{
			AcquireLocks(0, 1, ref locksAcquired);
			AcquireLocks(1, _tables.Locks.Length, ref locksAcquired);
		}

		private void AcquireLocks(int fromInclusive, int toExclusive, ref int locksAcquired)
		{
			object[] locks = _tables.Locks;
			for (int i = fromInclusive; i < toExclusive; i++)
			{
				bool lockTaken = false;
				try
				{
					Monitor.Enter(locks[i], ref lockTaken);
				}
				finally
				{
					if (lockTaken)
					{
						locksAcquired++;
					}
				}
			}
		}

		private void ReleaseLocks(int fromInclusive, int toExclusive)
		{
			for (int i = fromInclusive; i < toExclusive; i++)
			{
				Monitor.Exit(_tables.Locks[i]);
			}
		}

		private void CopyToItems(T[] array, int index)
		{
			Node[] buckets = _tables.Buckets;
			for (int i = 0; i < buckets.Length; i++)
			{
				for (Node node = buckets[i]; node != null; node = node.Next)
				{
					array[index] = node.Item;
					index++;
				}
			}
		}
	}
	internal static class ProcessorCounter
	{
		private const int ProcessorCountRefreshIntervalMs = 30000;

		private static volatile int _processorCount;

		private static volatile int _lastProcessorCountRefreshTicks;

		internal static int ProcessorCount
		{
			get
			{
				int tickCount = Environment.TickCount;
				if (_processorCount == 0 || tickCount - _lastProcessorCountRefreshTicks >= 30000)
				{
					_processorCount = Environment.ProcessorCount;
					_lastProcessorCountRefreshTicks = tickCount;
				}
				return _processorCount;
			}
		}
	}
	internal static class CoreHelpers
	{
		internal static string ByteArrayToString(byte[] input)
		{
			if (input == null || input.Length == 0)
			{
				return null;
			}
			return Encoding.UTF8.GetString(input, 0, input.Length);
		}

		public static string UrlEncode(string message)
		{
			if (string.IsNullOrEmpty(message))
			{
				return message;
			}
			message = Uri.EscapeDataString(message);
			message = message.Replace("%20", "+");
			return message;
		}

		public static string UrlDecode(string message)
		{
			if (string.IsNullOrEmpty(message))
			{
				return message;
			}
			message = message.Replace("+", "%20");
			message = Uri.UnescapeDataString(message);
			return message;
		}

		public static void AddKeyValueString(StringBuilder messageBuilder, string key, string value)
		{
			AddKeyValueString(messageBuilder, key, value.ToCharArray());
		}

		public static string ToQueryParameter(this IDictionary<string, string> input)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (input.Count > 0)
			{
				foreach (string key in input.Keys)
				{
					stringBuilder.AppendFormat(CultureInfo.InvariantCulture, "{0}={1}&", key, UrlEncode(input[key]));
				}
				if (stringBuilder.Length > 0)
				{
					stringBuilder.Remove(stringBuilder.Length - 1, 1);
				}
			}
			return stringBuilder.ToString();
		}

		public static Dictionary<string, string> ParseKeyValueList(string input, char delimiter, bool urlDecode, bool lowercaseKeys, RequestContext requestContext)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			foreach (string item in SplitWithQuotes(input, delimiter))
			{
				IReadOnlyList<string> readOnlyList = SplitWithQuotes(item, '=');
				if (readOnlyList.Count == 2 && !string.IsNullOrWhiteSpace(readOnlyList[0]) && !string.IsNullOrWhiteSpace(readOnlyList[1]))
				{
					string text = readOnlyList[0];
					string text2 = readOnlyList[1];
					if (urlDecode)
					{
						text = UrlDecode(text);
						text2 = UrlDecode(text2);
					}
					if (lowercaseKeys)
					{
						text = text.Trim().ToLowerInvariant();
					}
					text2 = text2.Trim().Trim(new char[1] { '"' }).Trim();
					if (dictionary.ContainsKey(text))
					{
						requestContext?.Logger.Warning(string.Format(CultureInfo.InvariantCulture, "Key/value pair list contains redundant key '{0}'.", text));
					}
					dictionary[text] = text2;
				}
			}
			return dictionary;
		}

		public static Dictionary<string, string> ParseKeyValueList(string input, char delimiter, bool urlDecode, RequestContext requestContext)
		{
			return ParseKeyValueList(input, delimiter, urlDecode, lowercaseKeys: true, requestContext);
		}

		internal static IReadOnlyList<string> SplitWithQuotes(string input, char delimiter)
		{
			if (string.IsNullOrWhiteSpace(input))
			{
				return Array.Empty<string>();
			}
			List<string> list = new List<string>();
			int num = 0;
			bool flag = false;
			string text;
			for (int i = 0; i < input.Length; i++)
			{
				if (input[i] == delimiter && !flag)
				{
					text = input.Substring(num, i - num);
					if (!string.IsNullOrWhiteSpace(text.Trim()))
					{
						list.Add(text);
					}
					num = i + 1;
				}
				else if (input[i] == '"')
				{
					flag = !flag;
				}
			}
			text = input.Substring(num);
			if (!string.IsNullOrWhiteSpace(text.Trim()))
			{
				list.Add(text);
			}
			return list;
		}

		private static void AddKeyValueString(StringBuilder messageBuilder, string key, char[] value)
		{
			string arg = ((messageBuilder.Length == 0) ? string.Empty : "&");
			messageBuilder.AppendFormat(CultureInfo.InvariantCulture, "{0}{1}=", arg, key);
			messageBuilder.Append(value);
		}

		internal static string GetCcsClientInfoHint(string userObjectId, string userTenantID)
		{
			if (!string.IsNullOrEmpty(userObjectId) && !string.IsNullOrEmpty(userTenantID))
			{
				return "oid:" + userObjectId + "@" + userTenantID;
			}
			return string.Empty;
		}

		internal static string GetCcsUpnHint(string upn)
		{
			if (!string.IsNullOrEmpty(upn))
			{
				return "upn:" + upn;
			}
			return string.Empty;
		}
	}
	internal static class DateTimeHelpers
	{
		public static DateTimeOffset UnixTimestampToDateTime(double unixTimestamp)
		{
			DateTime dateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc).AddSeconds(unixTimestamp).ToUniversalTime();
			return dateTime;
		}

		public static DateTimeOffset? UnixTimestampToDateTimeOrNull(double unixTimestamp)
		{
			if (unixTimestamp == 0.0)
			{
				return null;
			}
			DateTime dateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc).AddSeconds(unixTimestamp).ToUniversalTime();
			return dateTime;
		}

		public static string DateTimeToUnixTimestamp(DateTimeOffset dateTimeOffset)
		{
			DateTime dateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
			return ((long)dateTimeOffset.Subtract(dateTime).TotalSeconds).ToString(CultureInfo.InvariantCulture);
		}

		public static long CurrDateTimeInUnixTimestamp()
		{
			DateTime value = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
			return (long)DateTime.UtcNow.Subtract(value).TotalSeconds;
		}

		public static long GetDurationFromWindowsTimestamp(string windowsTimestampInFuture, ILoggerAdapter logger)
		{
			if (string.IsNullOrEmpty(windowsTimestampInFuture))
			{
				return 0L;
			}
			if (!ulong.TryParse(windowsTimestampInFuture, out var result) || result <= 11644473600L || result == ulong.MaxValue)
			{
				logger.Warning("Invalid Universal time " + windowsTimestampInFuture);
				return 0L;
			}
			return (long)(result - 11644473600L) - CurrDateTimeInUnixTimestamp();
		}

		public static long GetDurationFromNowInSeconds(string unixTimestampInFuture)
		{
			if (string.IsNullOrEmpty(unixTimestampInFuture))
			{
				return 0L;
			}
			return long.Parse(unixTimestampInFuture, CultureInfo.InvariantCulture) - CurrDateTimeInUnixTimestamp();
		}

		public static DateTimeOffset? DateTimeOffsetFromDuration(long? duration)
		{
			if (duration.HasValue)
			{
				return DateTimeOffsetFromDuration(duration.Value);
			}
			return null;
		}

		public static DateTimeOffset DateTimeOffsetFromDuration(long duration)
		{
			return DateTime.UtcNow + TimeSpan.FromSeconds(duration);
		}
	}
	internal static class EnumerableExtensions
	{
		internal static bool IsNullOrEmpty<T>(this IEnumerable<T> input)
		{
			if (input != null)
			{
				return !input.Any();
			}
			return true;
		}

		internal static string AsSingleString(this IEnumerable<string> input)
		{
			if (input.IsNullOrEmpty())
			{
				return string.Empty;
			}
			return string.Join(" ", input);
		}

		internal static bool ContainsOrdinalIgnoreCase(this IEnumerable<string> set, string toLookFor)
		{
			return set.Any((string el) => el.Equals(toLookFor, StringComparison.OrdinalIgnoreCase));
		}

		internal static List<T> FilterWithLogging<T>(this List<T> list, Func<T, bool> predicate, ILoggerAdapter logger, string logPrefix, bool updateOriginalCollection = true)
		{
			logger.Verbose(() => $"{logPrefix} - item count before: {list.Count} ");
			if (updateOriginalCollection)
			{
				list.RemoveAll((T e) => !predicate(e));
			}
			else
			{
				list = list.Where(predicate).ToList();
			}
			logger.Verbose(() => $"{logPrefix} - item count after: {list.Count} ");
			return list;
		}

		internal static void MergeDifferentEntries<TKey, TValue>(this IDictionary<TKey, TValue> source, IDictionary<TKey, TValue> other)
		{
			if (source == null || other == null)
			{
				return;
			}
			foreach (KeyValuePair<TKey, TValue> item in other)
			{
				if (!source.ContainsKey(item.Key))
				{
					source[item.Key] = item.Value;
				}
			}
		}
	}
	internal class GuidFactory : IGuidFactory
	{
		public Guid NewGuid()
		{
			return Guid.NewGuid();
		}
	}
	internal interface IGuidFactory
	{
		Guid NewGuid();
	}
	internal interface ITimeService
	{
		DateTime GetUtcNow();
	}
	internal static class JsonHelper
	{
		internal static string SerializeToJson<T>(T toEncode)
		{
			return JsonConvert.SerializeObject(toEncode);
		}

		internal static T DeserializeFromJson<T>(string json)
		{
			if (string.IsNullOrEmpty(json))
			{
				return default(T);
			}
			return JsonConvert.DeserializeObject<T>(json, new JsonSerializerSettings
			{
				DateParseHandling = DateParseHandling.None
			});
		}

		internal static T TryToDeserializeFromJson<T>(string json, RequestContext requestContext = null)
		{
			if (string.IsNullOrEmpty(json))
			{
				return default(T);
			}
			T result = default(T);
			try
			{
				result = DeserializeFromJson<T>(json.ToByteArray());
				return result;
			}
			catch (JsonException exWithPii)
			{
				requestContext?.Logger?.WarningPii(exWithPii);
			}
			return result;
		}

		internal static T DeserializeFromJson<T>(byte[] jsonByteArray)
		{
			if (jsonByteArray == null || jsonByteArray.Length == 0)
			{
				return default(T);
			}
			using MemoryStream stream = new MemoryStream(jsonByteArray);
			using StreamReader reader = new StreamReader(stream, Encoding.UTF8);
			return (T)JsonSerializer.Create().Deserialize(reader, typeof(T));
		}

		internal static string GetExistingOrEmptyString(JObject json, string key)
		{
			if (TryGetValue(json, key, out var value))
			{
				return GetValue<string>(value);
			}
			return string.Empty;
		}

		internal static string ExtractExistingOrEmptyString(JObject json, string key)
		{
			if (TryGetValue(json, key, out var value))
			{
				string value2 = GetValue<string>(value);
				json.Remove(key);
				return value2;
			}
			return string.Empty;
		}

		internal static IDictionary<string, string> ExtractInnerJsonAsDictionary(JObject json, string key)
		{
			if (TryGetValue(json, key, out var value))
			{
				Dictionary<string, string?> result = ToJsonObject(value).ToDictionary((KeyValuePair<string, JToken> pair) => pair.Key, (KeyValuePair<string, JToken> pair) => (string?)pair.Value);
				json.Remove(key);
				return result;
			}
			return null;
		}

		internal static T ExtractExistingOrDefault<T>(JObject json, string key)
		{
			if (TryGetValue(json, key, out var value))
			{
				T value2 = GetValue<T>(value);
				json.Remove(key);
				return value2;
			}
			return default(T);
		}

		internal static long ExtractParsedIntOrZero(JObject json, string key)
		{
			string text = ExtractExistingOrEmptyString(json, key);
			if (!string.IsNullOrWhiteSpace(text) && long.TryParse(text, out var result))
			{
				return result;
			}
			return 0L;
		}

		internal static string JsonObjectToString(JObject jsonObject)
		{
			return jsonObject.ToString(Microsoft.Identity.Json.Formatting.None);
		}

		internal static JObject ParseIntoJsonObject(string json)
		{
			return JObject.Parse(json);
		}

		internal static JObject ToJsonObject(JToken jsonNode)
		{
			return (JObject)jsonNode;
		}

		internal static bool TryGetValue(JObject json, string propertyName, out JToken value)
		{
			return json.TryGetValue(propertyName, out value);
		}

		internal static T GetValue<T>(JToken json)
		{
			return json.Value<T>();
		}
	}
	internal struct MeasureDurationResult<TResult>
	{
		private const int TicksPerMicrosecond = 10;

		private static readonly double s_tickFrequency = 10000000.0 / (double)Stopwatch.Frequency;

		public TResult Result { get; }

		public long Milliseconds { get; }

		public long Microseconds { get; }

		public long Ticks { get; }

		public MeasureDurationResult(TResult result, long ticks)
		{
			Result = result;
			Milliseconds = (long)((double)ticks / s_tickFrequency / 10000.0);
			Microseconds = (long)((double)ticks * s_tickFrequency / 10.0 % 1000.0);
			Ticks = ticks;
		}
	}
	internal struct MeasureDurationResult
	{
		private const int TicksPerMicrosecond = 10;

		private static readonly double s_tickFrequency = 10000000.0 / (double)Stopwatch.Frequency;

		public long Milliseconds { get; }

		public long Microseconds { get; }

		public long Ticks { get; }

		public MeasureDurationResult(long ticks)
		{
			Milliseconds = (long)((double)ticks * s_tickFrequency / 10000.0 % 1000.0);
			Microseconds = (long)((double)ticks * s_tickFrequency / 10.0 % 1000.0);
			Ticks = ticks;
		}
	}
	internal class OptionalSemaphoreSlim
	{
		private readonly bool _useRealSemaphore;

		private int _noLockCurrentCount;

		private SemaphoreSlim _semaphoreSlim;

		public int CurrentCount
		{
			get
			{
				if (!_useRealSemaphore)
				{
					return _noLockCurrentCount;
				}
				return _semaphoreSlim.CurrentCount;
			}
		}

		public string GetCurrentCountLogMessage()
		{
			return $"Real semaphore: {_useRealSemaphore}. Count: {CurrentCount}";
		}

		public OptionalSemaphoreSlim(bool useRealSemaphore)
		{
			_useRealSemaphore = useRealSemaphore;
			if (_useRealSemaphore)
			{
				_semaphoreSlim = new SemaphoreSlim(1, 1);
			}
			_noLockCurrentCount = 1;
		}

		public void Release()
		{
			if (_useRealSemaphore)
			{
				_semaphoreSlim.Release();
			}
			else
			{
				Interlocked.Increment(ref _noLockCurrentCount);
			}
		}

		public Task WaitAsync(CancellationToken cancellationToken)
		{
			if (_useRealSemaphore)
			{
				return _semaphoreSlim.WaitAsync(cancellationToken);
			}
			Interlocked.Decrement(ref _noLockCurrentCount);
			return Task.FromResult(result: true);
		}

		public void Wait()
		{
			if (_useRealSemaphore)
			{
				_semaphoreSlim.Wait();
			}
			else
			{
				Interlocked.Decrement(ref _noLockCurrentCount);
			}
		}
	}
	internal static class RetryOperationHelper
	{
		public static async Task<T> ExecuteWithRetryAsync<T>(Func<Task<T>> func, int maxAttempts, TimeSpan? retryInterval = null, Action<int, Exception> onAttemptFailed = null, ISet<Type> allowedExceptions = null)
		{
			if (func == null)
			{
				throw new ArgumentNullException("func");
			}
			if (maxAttempts < 1)
			{
				throw new ArgumentOutOfRangeException("maxAttempts", maxAttempts, "The maximum number of attempts must not be less than 1.");
			}
			int attempt = 0;
			while (true)
			{
				if (attempt > 0 && retryInterval.HasValue)
				{
					await Task.Delay(retryInterval.Value).ConfigureAwait(continueOnCapturedContext: true);
				}
				try
				{
					return await func().ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (Exception ex)
				{
					if (allowedExceptions != null && !allowedExceptions.Contains(ex.GetType()))
					{
						throw;
					}
					attempt++;
					onAttemptFailed?.Invoke(attempt, ex);
					if (attempt >= maxAttempts)
					{
						throw;
					}
				}
			}
		}

		public static async Task ExecuteWithRetryAsync(Func<Task> func, int maxAttempts, TimeSpan? retryInterval = null, Action<int, Exception> onAttemptFailed = null, ISet<Type> allowedExceptions = null)
		{
			if (func == null)
			{
				throw new ArgumentNullException("func");
			}
			await ExecuteWithRetryAsync(async delegate
			{
				await func().ConfigureAwait(continueOnCapturedContext: false);
				return true;
			}, maxAttempts, retryInterval, onAttemptFailed, allowedExceptions).ConfigureAwait(continueOnCapturedContext: true);
		}
	}
	internal static class ScopeHelper
	{
		private const string DefaultSuffix = "/.default";

		public static string OrderScopesAlphabetically(string originalScopes)
		{
			string[] array = originalScopes.Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
			Array.Sort(array, StringComparer.OrdinalIgnoreCase);
			return string.Join(" ", array);
		}

		public static bool ScopeContains(ISet<string> outerSet, IEnumerable<string> possibleContainedSet)
		{
			foreach (string item in possibleContainedSet)
			{
				if (!outerSet.Contains(item) && !string.IsNullOrEmpty(item))
				{
					return false;
				}
			}
			return true;
		}

		public static HashSet<string> GetMsalScopes(HashSet<string> userScopes)
		{
			return new HashSet<string>(userScopes.Concat(OAuth2Value.ReservedScopes));
		}

		public static string GetMsalRuntimeScopes()
		{
			return string.Join(" ", OAuth2Value.ReservedScopes);
		}

		public static bool HasNonMsalScopes(HashSet<string> userScopes)
		{
			if (userScopes == null)
			{
				return false;
			}
			foreach (string userScope in userScopes)
			{
				if (!string.IsNullOrWhiteSpace(userScope) && !OAuth2Value.ReservedScopes.Contains(userScope))
				{
					return true;
				}
			}
			return false;
		}

		public static HashSet<string> ConvertStringToScopeSet(string singleString)
		{
			if (string.IsNullOrEmpty(singleString))
			{
				return new HashSet<string>();
			}
			return new HashSet<string>(singleString.Split(new char[1] { ' ' }), StringComparer.OrdinalIgnoreCase);
		}

		public static HashSet<string> CreateScopeSet(IEnumerable<string> input)
		{
			if (input == null)
			{
				return new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			}
			return new HashSet<string>(input, StringComparer.OrdinalIgnoreCase);
		}

		public static string ScopesToResource(string[] scopes)
		{
			if (scopes == null)
			{
				throw new MsalClientException("exactly_one_scope_expected", "[Managed Identity] To acquire token for managed identity, exactly one scope must be passed.");
			}
			if (scopes.Length != 1)
			{
				throw new MsalClientException("exactly_one_scope_expected", "[Managed Identity] To acquire token for managed identity, exactly one scope must be passed.");
			}
			if (!scopes[0].EndsWith("/.default", StringComparison.Ordinal))
			{
				return scopes[0];
			}
			return scopes[0].Remove(scopes[0].LastIndexOf("/.default", StringComparison.Ordinal));
		}

		public static string RemoveDefaultSuffixIfPresent(string resource)
		{
			if (!resource.EndsWith("/.default", StringComparison.Ordinal))
			{
				return resource;
			}
			return resource.Remove(resource.LastIndexOf("/.default", StringComparison.Ordinal));
		}
	}
	internal static class StopwatchService
	{
		internal static readonly Stopwatch Watch = Stopwatch.StartNew();

		internal static long CurrentElapsedMilliseconds => Watch.ElapsedMilliseconds;

		internal static MeasureDurationResult MeasureCodeBlock(Action codeBlock)
		{
			if (codeBlock == null)
			{
				throw new ArgumentNullException("codeBlock");
			}
			long elapsedTicks = Watch.ElapsedTicks;
			codeBlock();
			return new MeasureDurationResult(Watch.ElapsedTicks - elapsedTicks);
		}

		internal static async Task<MeasureDurationResult> MeasureCodeBlockAsync(Func<Task> codeBlock)
		{
			if (codeBlock == null)
			{
				throw new ArgumentNullException("codeBlock");
			}
			long startTicks = Watch.ElapsedTicks;
			await codeBlock().ConfigureAwait(continueOnCapturedContext: false);
			return new MeasureDurationResult(Watch.ElapsedTicks - startTicks);
		}

		internal static async Task<MeasureDurationResult<TResult>> MeasureCodeBlockAsync<TResult>(Func<Task<TResult>> codeBlock)
		{
			if (codeBlock == null)
			{
				throw new ArgumentNullException("codeBlock");
			}
			long startTicks = Watch.ElapsedTicks;
			return new MeasureDurationResult<TResult>(await codeBlock().ConfigureAwait(continueOnCapturedContext: false), Watch.ElapsedTicks - startTicks);
		}

		internal static async Task<MeasureDurationResult> MeasureAsync(this Task task)
		{
			if (task == null)
			{
				throw new ArgumentNullException("task");
			}
			long startTicks = Watch.ElapsedTicks;
			await task.ConfigureAwait(continueOnCapturedContext: false);
			return new MeasureDurationResult(Watch.ElapsedTicks - startTicks);
		}

		internal static async Task<MeasureDurationResult<TResult>> MeasureAsync<TResult>(this Task<TResult> task)
		{
			if (task == null)
			{
				throw new ArgumentNullException("task");
			}
			long startTicks = Watch.ElapsedTicks;
			return new MeasureDurationResult<TResult>(await task.ConfigureAwait(continueOnCapturedContext: true), Watch.ElapsedTicks - startTicks);
		}
	}
	internal static class StringExtensions
	{
		private static UTF8Encoding utf8Encoding = new UTF8Encoding();

		public static byte[] ToByteArray(this string stringInput)
		{
			return utf8Encoding.GetBytes(stringInput);
		}

		public static string NullIfEmpty(this string s)
		{
			if (!string.IsNullOrEmpty(s))
			{
				return s;
			}
			return null;
		}

		public static string NullIfWhiteSpace(this string s)
		{
			if (!string.IsNullOrWhiteSpace(s))
			{
				return s;
			}
			return null;
		}

		public static bool Contains(this string source, string toCheck, StringComparison comp)
		{
			if (source != null && toCheck != null)
			{
				return source.IndexOf(toCheck, comp) >= 0;
			}
			return false;
		}
	}
	internal class StringWriterWithEncoding : StringWriter
	{
		public override Encoding Encoding { get; }

		public StringWriterWithEncoding(Encoding encoding)
			: base(CultureInfo.InvariantCulture)
		{
			Encoding = encoding;
		}
	}
	internal class TimeService : ITimeService
	{
		public DateTime GetUtcNow()
		{
			return DateTime.UtcNow;
		}
	}
	internal class TraceWrapper
	{
		public static void WriteLine(string message)
		{
		}
	}
	internal static class UriBuilderExtensions
	{
		private const int DefaultHttpsPort = 443;

		public static void AppendQueryParameters(this UriBuilder builder, string queryParams)
		{
			if (builder != null && !string.IsNullOrEmpty(queryParams))
			{
				if (builder.Query.Length > 1)
				{
					builder.Query = builder.Query.Substring(1) + "&" + queryParams;
				}
				else
				{
					builder.Query = queryParams;
				}
			}
		}

		public static void AppendQueryParameters(this UriBuilder builder, IDictionary<string, string> queryParams)
		{
			List<string> list = new List<string>();
			foreach (KeyValuePair<string, string> queryParam in queryParams)
			{
				list.Add(queryParam.Key + "=" + queryParam.Value);
			}
			builder.AppendQueryParameters(string.Join("&", list));
		}

		public static void AppendOrReplaceQueryParameter(this UriBuilder builder, string key, string value)
		{
			if (builder != null && !string.IsNullOrEmpty(key) && !string.IsNullOrEmpty(value))
			{
				Dictionary<string, string> dictionary = CoreHelpers.ParseKeyValueList(builder.Query.Substring(1), '&', urlDecode: true, null);
				dictionary[key] = value;
				builder.Query = dictionary.ToQueryParameter();
			}
		}

		public static string GetHttpsUriWithOptionalPort(string host, string tenant, string path, int port)
		{
			UriBuilder uriBuilder = new UriBuilder("https", host);
			uriBuilder.Path = string.Format(CultureInfo.InvariantCulture, "{0}/{1}", tenant, path);
			if (port != 443)
			{
				uriBuilder.Port = port;
			}
			return uriBuilder.Uri.AbsoluteUri;
		}

		public static string GetHttpsUriWithOptionalPort(string uri, int port)
		{
			if (port != 443)
			{
				return new UriBuilder(uri)
				{
					Port = port
				}.Uri.AbsoluteUri;
			}
			return uri;
		}
	}
}
namespace Microsoft.Identity.Client.Utils.Windows
{
	[Obsolete("This workaround for previous WAM broker implementation is not necessary with the improved broker.", true)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static class WindowsNativeUtils
	{
		private enum RpcAuthnLevel
		{
			Default,
			None,
			Connect,
			Call,
			Pkt,
			PktIntegrity,
			PktPrivacy
		}

		private enum RpcImpLevel
		{
			Default,
			Anonymous,
			Identify,
			Impersonate,
			Delegate
		}

		private enum EoAuthnCap
		{
			None = 0,
			MutualAuth = 1,
			StaticCloaking = 32,
			DynamicCloaking = 64,
			AnyAuthority = 128,
			MakeFullSIC = 256,
			Default = 2048,
			SecureRefs = 2,
			AccessControl = 4,
			AppID = 8,
			Dynamic = 16,
			RequireFullSIC = 512,
			AutoImpersonate = 1024,
			NoCustomMarshal = 8192,
			DisableAAA = 4096
		}

		public static bool IsElevatedUser()
		{
			return IsUserAnAdmin();
		}

		public static void InitializeProcessSecurity()
		{
			int num = CoInitializeSecurity(IntPtr.Zero, -1, IntPtr.Zero, IntPtr.Zero, RpcAuthnLevel.None, RpcImpLevel.Impersonate, IntPtr.Zero, EoAuthnCap.None, IntPtr.Zero);
			if (num != 0)
			{
				throw new MsalClientException("initialize_process_security_error", MsalErrorMessage.InitializeProcessSecurityError($"0x{num:x}"));
			}
		}

		[DllImport("shell32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool IsUserAnAdmin();

		[DllImport("ole32.dll")]
		private static extern int CoInitializeSecurity(IntPtr pVoid, int cAuthSvc, IntPtr asAuthSvc, IntPtr pReserved1, RpcAuthnLevel level, RpcImpLevel impers, IntPtr pAuthList, EoAuthnCap dwCapabilities, IntPtr pReserved3);
	}
}
namespace Microsoft.Identity.Client.UI
{
	internal enum AuthorizationStatus
	{
		Success,
		ErrorHttp,
		ProtocolError,
		UserCancel,
		UnknownError
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class AuthorizationResult
	{
		public AuthorizationStatus Status { get; private set; }

		[JsonProperty]
		public string Code { get; set; }

		[JsonProperty]
		public string Error { get; set; }

		[JsonProperty]
		public string ErrorDescription { get; set; }

		[JsonProperty]
		public string CloudInstanceHost { get; set; }

		public string ClientInfo { get; set; }

		public string State { get; set; }

		public static AuthorizationResult FromUri(string webAuthenticationResult)
		{
			if (string.IsNullOrWhiteSpace(webAuthenticationResult))
			{
				return FromStatus(AuthorizationStatus.UnknownError, "authentication_failed", "The authorization server returned an invalid response. ");
			}
			string query = new Uri(webAuthenticationResult).Query;
			if (string.IsNullOrWhiteSpace(query))
			{
				return FromStatus(AuthorizationStatus.UnknownError, "authentication_failed", "The authorization server returned an invalid response. ");
			}
			return FromParsedValues(CoreHelpers.ParseKeyValueList(query.Substring(1), '&', urlDecode: true, null), webAuthenticationResult);
		}

		public static AuthorizationResult FromPostData(byte[] postData)
		{
			if (postData == null)
			{
				return FromStatus(AuthorizationStatus.UnknownError, "authentication_failed", "The authorization server returned an invalid response. ");
			}
			return FromParsedValues(CoreHelpers.ParseKeyValueList(Encoding.UTF8.GetString(postData).TrimEnd(new char[1]), '&', urlDecode: true, null));
		}

		private static AuthorizationResult FromParsedValues(Dictionary<string, string> parameters, string url = null)
		{
			if (parameters.TryGetValue("error", out var value))
			{
				if (parameters.TryGetValue("error_subcode", out var value2) && "cancel".Equals(value2, StringComparison.OrdinalIgnoreCase))
				{
					return FromStatus(AuthorizationStatus.UserCancel);
				}
				string value3;
				return FromStatus(AuthorizationStatus.ProtocolError, value, parameters.TryGetValue("error_description", out value3) ? value3 : null);
			}
			AuthorizationResult authorizationResult = new AuthorizationResult
			{
				Status = AuthorizationStatus.Success
			};
			if (parameters.TryGetValue("state", out var value4))
			{
				authorizationResult.State = value4;
			}
			if (parameters.TryGetValue("cloud_instance_host_name", out var value5))
			{
				authorizationResult.CloudInstanceHost = value5;
			}
			if (parameters.TryGetValue("client_info", out var value6))
			{
				authorizationResult.ClientInfo = value6;
			}
			if (parameters.TryGetValue("code", out var value7))
			{
				authorizationResult.Code = value7;
			}
			else
			{
				if (string.IsNullOrEmpty(url) || !url.StartsWith("msauth://", StringComparison.OrdinalIgnoreCase))
				{
					return FromStatus(AuthorizationStatus.UnknownError, "authentication_failed", "The authorization server returned an invalid response. ");
				}
				authorizationResult.Code = url;
			}
			return authorizationResult;
		}

		internal static AuthorizationResult FromStatus(AuthorizationStatus status)
		{
			if (status == AuthorizationStatus.Success)
			{
				throw new InvalidOperationException("Use the FromUri builder");
			}
			AuthorizationResult authorizationResult = new AuthorizationResult
			{
				Status = status
			};
			switch (status)
			{
			case AuthorizationStatus.UserCancel:
				authorizationResult.Error = "authentication_canceled";
				authorizationResult.ErrorDescription = "User canceled authentication. ";
				break;
			case AuthorizationStatus.UnknownError:
				authorizationResult.Error = "unknown_error";
				authorizationResult.ErrorDescription = "Unknown error";
				break;
			}
			return authorizationResult;
		}

		public static AuthorizationResult FromStatus(AuthorizationStatus status, string error, string errorDescription)
		{
			return new AuthorizationResult
			{
				Status = status,
				Error = error,
				ErrorDescription = errorDescription
			};
		}
	}
	internal class CoreUIParent
	{
		internal SynchronizationContext SynchronizationContext { get; set; }

		internal SystemWebViewOptions SystemWebViewOptions { get; set; }

		internal EmbeddedWebViewOptions EmbeddedWebviewOptions { get; set; }

		internal object OwnerWindow { get; set; }
	}
	internal class CustomWebUiHandler : IWebUI
	{
		private readonly ICustomWebUi _customWebUi;

		public CustomWebUiHandler(ICustomWebUi customWebUi)
		{
			_customWebUi = customWebUi;
		}

		public async Task<AuthorizationResult> AcquireAuthorizationAsync(Uri authorizationUri, Uri redirectUri, RequestContext requestContext, CancellationToken cancellationToken)
		{
			requestContext.Logger.Info("Using CustomWebUi to acquire the authorization code");
			try
			{
				requestContext.Logger.InfoPii(() => LogMessages.CustomWebUiCallingAcquireAuthorizationCodePii(authorizationUri, redirectUri), () => "Calling CustomWebUi.AcquireAuthorizationCode");
				Uri uri = await _customWebUi.AcquireAuthorizationCodeAsync(authorizationUri, redirectUri, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (uri == null || string.IsNullOrWhiteSpace(uri.Query))
				{
					throw new MsalClientException("custom_webui_returned_invalid_uri", "ICustomWebUi returned an invalid URI - it is empty or has no query. ");
				}
				if (uri.Authority.Equals(redirectUri.Authority, StringComparison.OrdinalIgnoreCase) && uri.AbsolutePath.Equals(redirectUri.AbsolutePath))
				{
					requestContext.Logger.Info("Redirect Uri was matched.  Returning success from CustomWebUiHandler.");
					return AuthorizationResult.FromUri(uri.OriginalString);
				}
				throw new MsalClientException("custom_webui_invalid_mismatch", MsalErrorMessage.RedirectUriMismatch(uri.AbsolutePath, redirectUri.AbsolutePath));
			}
			catch (OperationCanceledException)
			{
				requestContext.Logger.Info("CustomWebUi AcquireAuthorizationCode was canceled");
				return AuthorizationResult.FromStatus(AuthorizationStatus.UserCancel);
			}
			catch (Exception exWithPii)
			{
				requestContext.Logger.WarningPiiWithPrefix(exWithPii, "CustomWebUi AcquireAuthorizationCode failed. ");
				throw;
			}
		}

		public Uri UpdateRedirectUri(Uri redirectUri)
		{
			RedirectUriHelper.Validate(redirectUri);
			return redirectUri;
		}
	}
	internal static class EmbeddedUiCommon
	{
		public static bool IsAllowedIeOrEdgeAuthorizationRedirect(Uri uri)
		{
			if (!uri.Scheme.Equals("https", StringComparison.OrdinalIgnoreCase) && !uri.AbsoluteUri.Equals("about:blank", StringComparison.OrdinalIgnoreCase) && !uri.Scheme.Equals("javascript", StringComparison.OrdinalIgnoreCase))
			{
				return uri.Scheme.Equals("res", StringComparison.OrdinalIgnoreCase);
			}
			return true;
		}
	}
	internal interface IWebUI
	{
		Task<AuthorizationResult> AcquireAuthorizationAsync(Uri authorizationUri, Uri redirectUri, RequestContext requestContext, CancellationToken cancellationToken);

		Uri UpdateRedirectUri(Uri redirectUri);
	}
	internal interface IWebUIFactory
	{
		bool IsSystemWebViewAvailable { get; }

		bool IsUserInteractive { get; }

		bool IsEmbeddedWebViewAvailable { get; }

		IWebUI CreateAuthenticationDialog(CoreUIParent coreUIParent, WebViewPreference webViewPreference, RequestContext requestContext);
	}
}
namespace Microsoft.Identity.Client.TelemetryCore
{
	internal enum AssertionType
	{
		None,
		CertificateWithoutSni,
		CertificateWithSni,
		Secret,
		ClientAssertion,
		ManagedIdentity
	}
	internal interface IHttpTelemetryManager
	{
		void RecordStoppedEvent(ApiEvent apiEvent);

		string GetCurrentRequestHeader(ApiEvent currentApiEvent);

		string GetLastRequestHeader();

		void ResetPreviousUnsentData();
	}
	internal interface ITelemetryReceiver
	{
		void HandleTelemetryEvents(List<Dictionary<string, string>> events);
	}
	internal static class TelemetryConstants
	{
		public const char HttpTelemetrySchemaVersion = '5';

		public const char HttpTelemetryPipe = '|';

		public const string XClientCurrentTelemetry = "x-client-current-telemetry";

		public const string XClientLastTelemetry = "x-client-last-telemetry";

		public const string False = "false";

		public const string True = "true";

		public const char One = '1';

		public const char Zero = '0';

		public const char CommaDelimiter = ',';

		public const string PlatformFields = "platform_fields";

		public const string AcquireTokenEventName = "acquire_token";

		public const string ConfigurationUpdateEventName = "config_update";

		public const string MsalVersion = "MsalVersion";

		public const string RemainingLifetime = "RemainingLifetime";

		public const string TokenType = "TokenType";

		public const string TokenSource = "TokenSource";

		public const string CacheInfoTelemetry = "CacheInfoTelemetry";

		public const string CacheRefreshReason = "CacheRefreshReason";

		public const string ErrorCode = "ErrorCode";

		public const string StsErrorCode = "StsErrorCode";

		public const string ErrorMessage = "ErrorMessage";

		public const string Duration = "Duration";

		public const string DurationInUs = "DurationInUs";

		public const string Succeeded = "Succeeded";

		public const string DurationInCache = "DurationInCache";

		public const string DurationInHttp = "DurationInHttp";

		public const string ActivityId = "ActivityId";

		public const string Resource = "Resource";

		public const string RefreshOn = "RefreshOn";

		public const string CacheLevel = "CacheLevel";

		public const string AssertionType = "AssertionType";

		public const string Endpoint = "Endpoint";

		public const string Scopes = "Scopes";

		public const string ClientId = "ClientId";

		public const string Platform = "Platform";

		public const string ApiId = "ApiId";

		public const string IsProactiveRefresh = "IsProactiveRefresh";
	}
	internal sealed class TelemetryHelper : IDisposable
	{
		private readonly ApiEvent _eventToEnd;

		private readonly IHttpTelemetryManager _httpTelemetryManager;

		private bool _disposedValue;

		public TelemetryHelper(IHttpTelemetryManager httpTelemetryManager, ApiEvent eventBase)
		{
			_httpTelemetryManager = httpTelemetryManager;
			_eventToEnd = eventBase;
		}

		private void Dispose(bool disposing)
		{
			if (!_disposedValue)
			{
				if (disposing)
				{
					_httpTelemetryManager?.RecordStoppedEvent(_eventToEnd);
				}
				_disposedValue = true;
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}
	}
}
namespace Microsoft.Identity.Client.TelemetryCore.TelemetryClient
{
	internal class MsalTelemetryEventDetails : TelemetryEventDetails
	{
		public MsalTelemetryEventDetails(string eventName)
		{
			Name = eventName;
		}
	}
	internal static class TelemetryClientExtensions
	{
		internal static bool HasEnabledClients(this ITelemetryClient[] clients, string eventName)
		{
			for (int i = 0; i < clients.Length; i++)
			{
				if (clients[i].IsEnabled(eventName))
				{
					return true;
				}
			}
			return false;
		}

		internal static void TrackEvent(this ITelemetryClient[] clients, TelemetryEventDetails eventDetails)
		{
			foreach (ITelemetryClient telemetryClient in clients)
			{
				if (telemetryClient.IsEnabled(eventDetails.Name))
				{
					telemetryClient.TrackEvent(eventDetails);
				}
			}
		}
	}
	public class TelemetryData
	{
		public CacheLevel CacheLevel { get; set; }
	}
}
namespace Microsoft.Identity.Client.TelemetryCore.OpenTelemetry
{
	internal interface IOtelInstrumentation
	{
		internal void LogSuccessMetrics(string platform, ApiEvent.ApiIds apiId, CacheLevel cacheLevel, long totalDurationInUs, AuthenticationResultMetadata authResultMetadata, ILoggerAdapter logger);

		internal void IncrementSuccessCounter(string platform, ApiEvent.ApiIds apiId, TokenSource tokenSource, CacheRefreshReason cacheRefreshReason, CacheLevel cacheLevel, ILoggerAdapter logger);

		internal void LogFailureMetrics(string platform, string errorCode, ApiEvent.ApiIds apiId, CacheRefreshReason cacheRefreshReason);
	}
	internal class NullOtelInstrumentation : IOtelInstrumentation
	{
		public void LogSuccessMetrics(string platform, ApiEvent.ApiIds apiId, CacheLevel cacheLevel, long totalDurationInUs, AuthenticationResultMetadata authResultMetadata, ILoggerAdapter logger)
		{
		}

		public void LogFailureMetrics(string platform, string errorCode, ApiEvent.ApiIds apiId, CacheRefreshReason cacheRefreshReason)
		{
		}

		void IOtelInstrumentation.IncrementSuccessCounter(string platform, ApiEvent.ApiIds apiId, TokenSource tokenSource, CacheRefreshReason cacheRefreshReason, CacheLevel cacheLevel, ILoggerAdapter logger)
		{
		}
	}
}
namespace Microsoft.Identity.Client.TelemetryCore.Internal.Events
{
	internal class ApiEvent
	{
		public enum ApiIds
		{
			None = 0,
			AcquireTokenByAuthorizationCode = 1000,
			AcquireTokenByRefreshToken = 1001,
			AcquireTokenByIntegratedWindowsAuth = 1002,
			AcquireTokenByUsernamePassword = 1003,
			AcquireTokenForClient = 1004,
			AcquireTokenInteractive = 1005,
			AcquireTokenOnBehalfOf = 1006,
			AcquireTokenSilent = 1007,
			AcquireTokenByDeviceCode = 1008,
			GetAuthorizationRequestUrl = 1009,
			GetAccounts = 1010,
			GetAccountById = 1011,
			GetAccountsByUserFlow = 1012,
			RemoveAccount = 1013,
			RemoveOboTokens = 1014,
			AcquireTokenForSystemAssignedManagedIdentity = 1015,
			AcquireTokenForUserAssignedManagedIdentity = 1016,
			InitiateLongRunningObo = 1017,
			AcquireTokenInLongRunningObo = 1018
		}

		private RegionAutodetectionSource? _regionAutodetectionSource;

		private RegionOutcome? _regionOutcome;

		private CacheRefreshReason? _cacheInfo;

		public Guid CorrelationId { get; set; }

		public ApiIds ApiId { get; set; }

		public string ApiIdString => ApiId.ToString("D");

		public string TokenEndpoint { get; set; }

		public bool IsAccessTokenCacheHit { get; set; }

		public string ApiErrorCode { get; set; }

		public string RegionUsed { get; set; }

		public RegionAutodetectionSource RegionAutodetectionSource
		{
			get
			{
				return _regionAutodetectionSource.GetValueOrDefault();
			}
			set
			{
				_regionAutodetectionSource = value;
			}
		}

		public string RegionAutodetectionSourceString
		{
			get
			{
				if (!_regionAutodetectionSource.HasValue)
				{
					return null;
				}
				return _regionAutodetectionSource.Value.ToString("D");
			}
		}

		public RegionOutcome RegionOutcome
		{
			get
			{
				return _regionOutcome.GetValueOrDefault();
			}
			set
			{
				_regionOutcome = value;
			}
		}

		public string RegionOutcomeString
		{
			get
			{
				if (!_regionOutcome.HasValue)
				{
					return null;
				}
				return _regionOutcome.Value.ToString("D");
			}
		}

		public string AutoDetectedRegion { get; internal set; }

		public string RegionDiscoveryFailureReason { get; set; }

		public bool IsTokenCacheSerialized { get; set; }

		public char IsTokenCacheSerializedString
		{
			get
			{
				if (!IsTokenCacheSerialized)
				{
					return '0';
				}
				return '1';
			}
		}

		public bool IsLegacyCacheEnabled { get; set; }

		public char IsLegacyCacheEnabledString
		{
			get
			{
				if (!IsLegacyCacheEnabled)
				{
					return '0';
				}
				return '1';
			}
		}

		public CacheRefreshReason CacheInfo
		{
			get
			{
				return _cacheInfo.GetValueOrDefault();
			}
			set
			{
				_cacheInfo = value;
			}
		}

		public string CacheInfoString
		{
			get
			{
				if (!_cacheInfo.HasValue)
				{
					return null;
				}
				return _cacheInfo.Value.ToString("D");
			}
		}

		public long DurationInHttpInMs { get; set; }

		public long DurationInCacheInMs { get; set; }

		public TokenType? TokenType { get; set; }

		public string TokenTypeString
		{
			get
			{
				if (!TokenType.HasValue)
				{
					return null;
				}
				return TokenType.Value.ToString("D");
			}
		}

		public AssertionType AssertionType { get; set; }

		public CacheLevel CacheLevel { get; set; }

		public string MsalRuntimeTelemetry { get; set; }

		public ApiEvent(Guid correlationId)
		{
			CorrelationId = correlationId;
		}

		public static bool IsLongRunningObo(ApiIds apiId)
		{
			if (apiId != ApiIds.InitiateLongRunningObo)
			{
				return apiId == ApiIds.AcquireTokenInLongRunningObo;
			}
			return true;
		}

		public static bool IsOnBehalfOfRequest(ApiIds apiId)
		{
			if (apiId != ApiIds.AcquireTokenOnBehalfOf)
			{
				return IsLongRunningObo(apiId);
			}
			return true;
		}
	}
}
namespace Microsoft.Identity.Client.TelemetryCore.Http
{
	internal class HttpHeaderSanitizer
	{
		private static readonly string[] s_headerEncodingTable = new string[32]
		{
			"%00", "%01", "%02", "%03", "%04", "%05", "%06", "%07", "%08", "%09",
			"%0a", "%0b", "%0c", "%0d", "%0e", "%0f", "%10", "%11", "%12", "%13",
			"%14", "%15", "%16", "%17", "%18", "%19", "%1a", "%1b", "%1c", "%1d",
			"%1e", "%1f"
		};

		public static string SanitizeHeader(string value)
		{
			string result = value;
			if (HeaderValueNeedsEncoding(value))
			{
				StringBuilder stringBuilder = new StringBuilder();
				foreach (char c in value)
				{
					if (c < ' ' && c != '\t')
					{
						stringBuilder.Append(s_headerEncodingTable[(uint)c]);
					}
					else if (c == '\u007f')
					{
						stringBuilder.Append("%7f");
					}
					else
					{
						stringBuilder.Append(c);
					}
				}
				result = stringBuilder.ToString();
			}
			return result;
		}

		private static bool HeaderValueNeedsEncoding(string value)
		{
			foreach (char c in value)
			{
				if ((c < ' ' && c != '\t') || c == '\u007f')
				{
					return true;
				}
			}
			return false;
		}
	}
	internal class HttpTelemetryManager : IHttpTelemetryManager
	{
		private int _successfullSilentCallCount;

		private ConcurrentQueue<ApiEvent> _failedEvents = new ConcurrentQueue<ApiEvent>();

		public void ResetPreviousUnsentData()
		{
			_successfullSilentCallCount = 0;
			ApiEvent result;
			while (_failedEvents.TryDequeue(out result))
			{
			}
		}

		public void RecordStoppedEvent(ApiEvent stoppedEvent)
		{
			if (!string.IsNullOrEmpty(stoppedEvent.ApiErrorCode))
			{
				_failedEvents.Enqueue(stoppedEvent);
			}
			if (stoppedEvent.IsAccessTokenCacheHit)
			{
				_successfullSilentCallCount++;
			}
		}

		public string GetLastRequestHeader()
		{
			StringBuilder stringBuilder = new StringBuilder();
			StringBuilder stringBuilder2 = new StringBuilder();
			bool flag = true;
			foreach (ApiEvent failedEvent in _failedEvents)
			{
				if (!flag)
				{
					stringBuilder2.Append(',');
				}
				stringBuilder2.Append(HttpHeaderSanitizer.SanitizeHeader(failedEvent.ApiErrorCode));
				if (!flag)
				{
					stringBuilder.Append(',');
				}
				stringBuilder.Append(failedEvent.ApiIdString);
				stringBuilder.Append(',');
				stringBuilder.Append(failedEvent.CorrelationId.ToString());
				flag = false;
			}
			string text = $"{'5'}|" + $"{_successfullSilentCallCount}|" + $"{stringBuilder}|" + $"{stringBuilder2}|";
			if (text.Length > 3800)
			{
				ResetPreviousUnsentData();
				return string.Empty;
			}
			return text;
		}

		public string GetCurrentRequestHeader(ApiEvent eventInProgress)
		{
			if (eventInProgress == null)
			{
				return string.Empty;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append('5');
			stringBuilder.Append('|');
			stringBuilder.Append(eventInProgress.ApiIdString);
			stringBuilder.Append(',');
			stringBuilder.Append(eventInProgress.CacheInfoString);
			stringBuilder.Append(',');
			stringBuilder.Append(eventInProgress.RegionUsed);
			stringBuilder.Append(',');
			stringBuilder.Append(eventInProgress.RegionAutodetectionSourceString);
			stringBuilder.Append(',');
			stringBuilder.Append(eventInProgress.RegionOutcomeString);
			stringBuilder.Append('|');
			stringBuilder.Append(eventInProgress.IsTokenCacheSerializedString);
			stringBuilder.Append(',');
			stringBuilder.Append(eventInProgress.IsLegacyCacheEnabledString);
			stringBuilder.Append(',');
			stringBuilder.Append(eventInProgress.TokenTypeString);
			return stringBuilder.ToString();
		}
	}
}
namespace Microsoft.Identity.Client.PlatformsCommon.Shared
{
	internal abstract class AbstractPlatformProxy : IPlatformProxy
	{
		public const string MacOsDescriptionForSTS = "MacOS";

		public const string LinuxOSDescriptionForSTS = "Linux";

		private readonly Lazy<string> _callingApplicationName;

		private readonly Lazy<string> _callingApplicationVersion;

		private readonly Lazy<ICryptographyManager> _cryptographyManager;

		private readonly Lazy<string> _deviceId;

		private readonly Lazy<string> _deviceModel;

		private readonly Lazy<string> _operatingSystem;

		private readonly Lazy<IPlatformLogger> _platformLogger;

		private readonly Lazy<string> _processorArchitecture;

		private readonly Lazy<string> _productName;

		private readonly Lazy<string> _runtimeVersion;

		private readonly Lazy<IOtelInstrumentation> _otelInstrumentation;

		protected IFeatureFlags OverloadFeatureFlags { get; set; }

		protected ILoggerAdapter Logger { get; }

		public ITokenCacheAccessor UserTokenCacheAccessorForTest { get; set; }

		public ITokenCacheAccessor AppTokenCacheAccessorForTest { get; set; }

		public ICryptographyManager CryptographyManager => _cryptographyManager.Value;

		public IPlatformLogger PlatformLogger => _platformLogger.Value;

		public IOtelInstrumentation OtelInstrumentation => _otelInstrumentation.Value;

		public virtual bool BrokerSupportsWamAccounts => false;

		public virtual bool LegacyCacheRequiresSerialization => true;

		protected AbstractPlatformProxy(ILoggerAdapter logger)
		{
			Logger = logger;
			_deviceModel = new Lazy<string>(InternalGetDeviceModel);
			_operatingSystem = new Lazy<string>(InternalGetOperatingSystem);
			_processorArchitecture = new Lazy<string>(InternalGetProcessorArchitecture);
			_callingApplicationName = new Lazy<string>(InternalGetCallingApplicationName);
			_callingApplicationVersion = new Lazy<string>(InternalGetCallingApplicationVersion);
			_deviceId = new Lazy<string>(InternalGetDeviceId);
			_productName = new Lazy<string>(InternalGetProductName);
			_cryptographyManager = new Lazy<ICryptographyManager>(InternalGetCryptographyManager);
			_platformLogger = new Lazy<IPlatformLogger>(InternalGetPlatformLogger);
			_runtimeVersion = new Lazy<string>(InternalGetRuntimeVersion);
			_otelInstrumentation = new Lazy<IOtelInstrumentation>(InternalGetOtelInstrumentation);
		}

		private IOtelInstrumentation InternalGetOtelInstrumentation()
		{
			try
			{
				return new OtelInstrumentation();
			}
			catch (FileNotFoundException ex)
			{
				Logger.Warning("Failed instantiating OpenTelemetry instrumentation. Exception: " + ex.Message);
				return new NullOtelInstrumentation();
			}
		}

		public IWebUIFactory GetWebUiFactory(ApplicationConfiguration appConfig)
		{
			if (appConfig.WebUiFactoryCreator == null)
			{
				return CreateWebUiFactory();
			}
			return appConfig.WebUiFactoryCreator();
		}

		public string GetDeviceModel()
		{
			return _deviceModel.Value;
		}

		public string GetOperatingSystem()
		{
			return _operatingSystem.Value;
		}

		public string GetProcessorArchitecture()
		{
			return _processorArchitecture.Value;
		}

		public abstract Task<string> GetUserPrincipalNameAsync();

		public string GetCallingApplicationName()
		{
			return _callingApplicationName.Value;
		}

		public string GetCallingApplicationVersion()
		{
			return _callingApplicationVersion.Value;
		}

		public string GetDeviceId()
		{
			return _deviceId.Value;
		}

		public abstract string GetDefaultRedirectUri(string clientId, bool useRecommendedRedirectUri = false);

		public string GetProductName()
		{
			return _productName.Value;
		}

		public string GetRuntimeVersion()
		{
			return _runtimeVersion.Value;
		}

		public abstract ILegacyCachePersistence CreateLegacyCachePersistence();

		public virtual ITokenCacheAccessor CreateTokenCacheAccessor(CacheOptions tokenCacheAccessorOptions, bool isApplicationTokenCache = false)
		{
			if (isApplicationTokenCache)
			{
				return AppTokenCacheAccessorForTest ?? new InMemoryPartitionedAppTokenCacheAccessor(Logger, tokenCacheAccessorOptions);
			}
			return UserTokenCacheAccessorForTest ?? new InMemoryPartitionedUserTokenCacheAccessor(Logger, tokenCacheAccessorOptions);
		}

		protected abstract IWebUIFactory CreateWebUiFactory();

		protected abstract IFeatureFlags CreateFeatureFlags();

		protected abstract string InternalGetDeviceModel();

		protected abstract string InternalGetOperatingSystem();

		protected abstract string InternalGetProcessorArchitecture();

		protected abstract string InternalGetCallingApplicationName();

		protected abstract string InternalGetCallingApplicationVersion();

		protected abstract string InternalGetDeviceId();

		protected abstract string InternalGetProductName();

		protected abstract ICryptographyManager InternalGetCryptographyManager();

		protected abstract IPlatformLogger InternalGetPlatformLogger();

		protected virtual string InternalGetRuntimeVersion()
		{
			return RuntimeInformation.FrameworkDescription;
		}

		public virtual IFeatureFlags GetFeatureFlags()
		{
			return OverloadFeatureFlags ?? CreateFeatureFlags();
		}

		public void SetFeatureFlags(IFeatureFlags featureFlags)
		{
			OverloadFeatureFlags = featureFlags;
		}

		public virtual Task StartDefaultOsBrowserAsync(string url, bool IBrokerConfigured)
		{
			throw new NotImplementedException();
		}

		public virtual IBroker CreateBroker(ApplicationConfiguration appConfig, CoreUIParent uiParent)
		{
			if (appConfig.BrokerCreatorFunc == null)
			{
				return new NullBroker(Logger);
			}
			return appConfig.BrokerCreatorFunc(uiParent, appConfig, Logger);
		}

		public virtual bool CanBrokerSupportSilentAuth()
		{
			return true;
		}

		public virtual IPoPCryptoProvider GetDefaultPoPCryptoProvider()
		{
			throw new NotImplementedException();
		}

		public virtual IDeviceAuthManager CreateDeviceAuthManager()
		{
			return new NullDeviceAuthManager();
		}

		public virtual IMsalHttpClientFactory CreateDefaultHttpClientFactory()
		{
			return new SimpleHttpClientFactory();
		}
	}
	[Preserve(AllMembers = true)]
	internal class CommonCryptographyManager : ICryptographyManager
	{
		private static readonly ConcurrentDictionary<string, RSA> s_certificateToRsaMap = new ConcurrentDictionary<string, RSA>();

		private static readonly int s_maximumMapSize = 1000;

		protected ILoggerAdapter Logger { get; }

		public CommonCryptographyManager(ILoggerAdapter logger = null)
		{
			Logger = logger;
		}

		public string CreateBase64UrlEncodedSha256Hash(string input)
		{
			if (!string.IsNullOrEmpty(input))
			{
				return Base64UrlHelpers.Encode(CreateSha256HashBytes(input));
			}
			return null;
		}

		public string GenerateCodeVerifier()
		{
			byte[] array = new byte[96];
			using (RandomNumberGenerator randomNumberGenerator = RandomNumberGenerator.Create())
			{
				randomNumberGenerator.GetBytes(array);
			}
			return Base64UrlHelpers.Encode(array);
		}

		public string CreateSha256Hash(string input)
		{
			if (!string.IsNullOrEmpty(input))
			{
				return Convert.ToBase64String(CreateSha256HashBytes(input));
			}
			return null;
		}

		public byte[] CreateSha256HashBytes(string input)
		{
			using SHA256 sHA = SHA256.Create();
			return sHA.ComputeHash(Encoding.UTF8.GetBytes(input));
		}

		public virtual byte[] SignWithCertificate(string message, X509Certificate2 certificate, RSASignaturePadding signaturePadding)
		{
			if (!s_certificateToRsaMap.TryGetValue(certificate.Thumbprint, out var rsa))
			{
				if (s_certificateToRsaMap.Count >= s_maximumMapSize)
				{
					s_certificateToRsaMap.Clear();
				}
				rsa = certificate.GetRSAPrivateKey();
			}
			if (rsa == null)
			{
				throw new MsalClientException("certificate_not_rsa", MsalErrorMessage.CertMustBeRsa(certificate.PublicKey?.Oid?.FriendlyName));
			}
			try
			{
				return SignDataAndCacheProvider(message);
			}
			catch (Exception arg)
			{
				Logger?.Warning($"Exception occurred when signing data with a certificate. {arg}");
				rsa = certificate.GetRSAPrivateKey();
				return SignDataAndCacheProvider(message);
			}
			byte[] SignDataAndCacheProvider(string s)
			{
				byte[] result = rsa.SignData(Encoding.UTF8.GetBytes(s), HashAlgorithmName.SHA256, signaturePadding);
				s_certificateToRsaMap[certificate.Thumbprint] = rsa;
				return result;
			}
		}
	}
	internal class ConsolePlatformLogger : IPlatformLogger
	{
		public void Always(string message)
		{
			Console.WriteLine(message);
		}

		public void Error(string message)
		{
			Console.WriteLine(message);
		}

		public void Warning(string message)
		{
			Console.WriteLine(message);
		}

		public void Verbose(string message)
		{
			Console.WriteLine(message);
		}

		public void Information(string message)
		{
			Console.WriteLine(message);
		}
	}
	internal static class DesktopOsHelper
	{
		private static Lazy<bool> s_wamSupportedOSLazy = new Lazy<bool>(IsWamSupportedOSInternal);

		private static Lazy<string> s_winVersionLazy = new Lazy<string>(GetWindowsVersionStringInternal);

		public static bool IsWindows()
		{
			return RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
		}

		public static bool IsLinux()
		{
			return RuntimeInformation.IsOSPlatform(OSPlatform.Linux);
		}

		public static bool IsMac()
		{
			return RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
		}

		private static bool IsWamSupportedOSInternal()
		{
			if (IsWindows() && Win32VersionApi.IsWamSupportedOs())
			{
				return true;
			}
			return false;
		}

		private static string GetWindowsVersionStringInternal()
		{
			return RuntimeInformation.OSDescription;
		}

		public static string GetWindowsVersionString()
		{
			return s_winVersionLazy.Value;
		}

		public static bool IsWin10OrServerEquivalent()
		{
			return s_wamSupportedOSLazy.Value;
		}

		public static bool IsUserInteractive()
		{
			if (IsWindows())
			{
				return IsInteractiveSessionWindows();
			}
			if (IsMac())
			{
				return IsInteractiveSessionMac();
			}
			if (IsLinux())
			{
				return IsInteractiveSessionLinux();
			}
			throw new PlatformNotSupportedException();
		}

		private unsafe static bool IsInteractiveSessionWindows()
		{
			IntPtr processWindowStation = User32.GetProcessWindowStation();
			if (processWindowStation != IntPtr.Zero)
			{
				USEROBJECTFLAGS uSEROBJECTFLAGS = default(USEROBJECTFLAGS);
				uint lpnLengthNeeded = 0u;
				if (User32.GetUserObjectInformation(processWindowStation, 1, &uSEROBJECTFLAGS, (uint)sizeof(USEROBJECTFLAGS), ref lpnLengthNeeded))
				{
					return (uSEROBJECTFLAGS.dwFlags & 1) != 0;
				}
			}
			return true;
		}

		private static bool IsInteractiveSessionMac()
		{
			if (SecurityFramework.SessionGetInfo(-1, out var _, out var attributes) == 0 && (attributes & SessionAttributeBits.SessionHasGraphicAccess) != 0)
			{
				return true;
			}
			return IsInteractiveSessionLinux();
		}

		private static bool IsInteractiveSessionLinux()
		{
			return !string.IsNullOrWhiteSpace(Environment.GetEnvironmentVariable("DISPLAY"));
		}
	}
	internal class DeviceAuthHelper
	{
		public static IDictionary<string, string> ParseChallengeData(HttpResponseHeaders responseHeaders)
		{
			IDictionary<string, string> dictionary = new Dictionary<string, string>();
			string text = responseHeaders.GetValues("WWW-Authenticate").SingleOrDefault()?.Substring("PKeyAuth".Length + 1);
			if (string.IsNullOrEmpty(text))
			{
				return dictionary;
			}
			foreach (string item in CoreHelpers.SplitWithQuotes(text, ','))
			{
				IReadOnlyList<string> readOnlyList = CoreHelpers.SplitWithQuotes(item, '=');
				if (readOnlyList.Count == 2)
				{
					dictionary.Add(readOnlyList[0].Trim(), readOnlyList[1].Trim().Replace("\"", ""));
				}
			}
			return dictionary;
		}

		public static bool IsDeviceAuthChallenge(HttpResponseHeaders responseHeaders)
		{
			if (responseHeaders != null && responseHeaders.Contains("WWW-Authenticate"))
			{
				return responseHeaders.GetValues("WWW-Authenticate").First().StartsWith("PKeyAuth", StringComparison.OrdinalIgnoreCase);
			}
			return false;
		}

		public static string GetBypassChallengeResponse(HttpResponseHeaders responseHeaders)
		{
			IDictionary<string, string> dictionary = ParseChallengeData(responseHeaders);
			return string.Format(CultureInfo.InvariantCulture, "PKeyAuth Context=\"{0}\",Version=\"{1}\"", dictionary["Context"], dictionary["Version"]);
		}

		public static string GetBypassChallengeResponse(Dictionary<string, string> response)
		{
			return string.Format(CultureInfo.InvariantCulture, "PKeyAuth Context=\"{0}\",Version=\"{1}\"", response["Context"], response["Version"]);
		}

		public static bool CanOSPerformPKeyAuth()
		{
			try
			{
				if (!DesktopOsHelper.IsWindows())
				{
					return false;
				}
				return !DesktopOsHelper.IsWin10OrServerEquivalent();
			}
			catch (DllNotFoundException)
			{
				return false;
			}
		}
	}
	internal class DeviceAuthManager : IDeviceAuthManager
	{
		private readonly ICryptographyManager _cryptographyManager;

		public DeviceAuthManager(ICryptographyManager cryptographyManager)
		{
			_cryptographyManager = cryptographyManager;
		}

		public bool TryCreateDeviceAuthChallengeResponse(HttpResponseHeaders responseHeaders, Uri endpointUri, out string responseHeader)
		{
			responseHeader = string.Empty;
			X509Certificate2 certificate = null;
			if (!DeviceAuthHelper.IsDeviceAuthChallenge(responseHeaders))
			{
				return false;
			}
			if (!DeviceAuthHelper.CanOSPerformPKeyAuth())
			{
				responseHeader = DeviceAuthHelper.GetBypassChallengeResponse(responseHeaders);
				return true;
			}
			IDictionary<string, string> dictionary = DeviceAuthHelper.ParseChallengeData(responseHeaders);
			if (!dictionary.TryGetValue("SubmitUrl", out var value))
			{
				value = endpointUri.AbsoluteUri;
			}
			try
			{
				certificate = FindCertificate(dictionary);
			}
			catch (MsalException ex)
			{
				if (ex.ErrorCode == "device_certificate_not_found")
				{
					responseHeader = DeviceAuthHelper.GetBypassChallengeResponse(responseHeaders);
					return true;
				}
			}
			string responseToSign = GetDeviceAuthJwtResponse(value, dictionary["nonce"], certificate).GetResponseToSign();
			FormatResponseHeader(_cryptographyManager.SignWithCertificate(responseToSign, certificate, RSASignaturePadding.Pkcs1), dictionary, responseToSign, out responseHeader);
			return true;
		}

		private static DeviceAuthJWTResponse GetDeviceAuthJwtResponse(string submitUrl, string nonce, X509Certificate2 certificate)
		{
			return new DeviceAuthJWTResponse(submitUrl, nonce, Convert.ToBase64String(certificate.GetRawCertData()));
		}

		private static void FormatResponseHeader(byte[] signedResponse, IDictionary<string, string> challengeData, string responseToSign, out string responseHeader)
		{
			string text = Base64UrlHelpers.Encode(signedResponse);
			responseHeader = "PKeyAuth AuthToken=\"" + responseToSign + "." + text + "\", Context=\"" + challengeData["Context"] + "\", Version=\"" + challengeData["Version"] + "\"";
		}

		private static X509Certificate2 FindCertificate(IDictionary<string, string> challengeData)
		{
			X509Store x509Store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
			try
			{
				x509Store.Open(OpenFlags.ReadOnly);
				X509Certificate2Collection certificates = x509Store.Certificates;
				if (challengeData.ContainsKey("CertAuthorities"))
				{
					return FindCertificateByCertAuthorities(challengeData, certificates);
				}
				X509Certificate2Collection x509Certificate2Collection = certificates.Find(X509FindType.FindByThumbprint, challengeData["CertThumbprint"], validOnly: false);
				if (x509Certificate2Collection.Count == 0)
				{
					throw new MsalException("device_certificate_not_found", string.Format(CultureInfo.CurrentCulture, "Device Certificate was not found for {0}. ", "Cert thumbprint:" + challengeData["CertThumbprint"]));
				}
				return x509Certificate2Collection[0];
			}
			finally
			{
				x509Store.Dispose();
			}
		}

		private static X509Certificate2 FindCertificateByCertAuthorities(IDictionary<string, string> challengeData, X509Certificate2Collection certCollection)
		{
			X509Certificate2Collection x509Certificate2Collection = null;
			string[] array = challengeData["CertAuthorities"].Split(new string[1] { ";" }, StringSplitOptions.None);
			for (int i = 0; i < array.Length; i++)
			{
				string[] array2 = array[i].Split(new string[1] { "," }, StringSplitOptions.None);
				string text = array2[^1];
				for (int num = array2.Length - 2; num >= 0; num--)
				{
					text = text + " + " + array2[num].Trim();
				}
				x509Certificate2Collection = certCollection.Find(X509FindType.FindByIssuerDistinguishedName, text, validOnly: false);
				if (x509Certificate2Collection.Count > 0)
				{
					break;
				}
			}
			if (x509Certificate2Collection == null || x509Certificate2Collection.Count == 0)
			{
				throw new MsalException("device_certificate_not_found", string.Format(CultureInfo.CurrentCulture, "Device Certificate was not found for {0}. ", "Cert Authorities:" + challengeData["CertAuthorities"]));
			}
			return x509Certificate2Collection[0];
		}
	}
	internal class EventSourcePlatformLogger : IPlatformLogger
	{
		internal static MsalEventSource MsalEventSource { get; }

		static EventSourcePlatformLogger()
		{
			MsalEventSource = new MsalEventSource();
		}

		public void Always(string message)
		{
			MsalEventSource.Information(message);
		}

		public void Error(string message)
		{
			MsalEventSource.Error(message);
		}

		public void Warning(string message)
		{
			MsalEventSource.Error(message);
		}

		public void Verbose(string message)
		{
			MsalEventSource.Error(message);
		}

		public void Information(string message)
		{
			MsalEventSource.Error(message);
		}
	}
	internal class InMemoryLegacyCachePersistance : ILegacyCachePersistence
	{
		private byte[] data;

		public byte[] LoadCache()
		{
			return data;
		}

		public void WriteCache(byte[] serializedCache)
		{
			data = serializedCache;
		}
	}
	internal class InMemoryPartitionedAppTokenCacheAccessor : ITokenCacheAccessor
	{
		internal readonly ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>> AccessTokenCacheDictionary;

		internal readonly ConcurrentDictionary<string, MsalAppMetadataCacheItem> AppMetadataDictionary;

		private static readonly ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>> s_accessTokenCacheDictionary = new ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>>();

		private static readonly ConcurrentDictionary<string, MsalAppMetadataCacheItem> s_appMetadataDictionary = new ConcurrentDictionary<string, MsalAppMetadataCacheItem>(1, 1);

		protected readonly ILoggerAdapter _logger;

		private readonly CacheOptions _tokenCacheAccessorOptions;

		public InMemoryPartitionedAppTokenCacheAccessor(ILoggerAdapter logger, CacheOptions tokenCacheAccessorOptions)
		{
			_logger = logger ?? throw new ArgumentNullException("logger");
			_tokenCacheAccessorOptions = tokenCacheAccessorOptions ?? new CacheOptions();
			if (_tokenCacheAccessorOptions.UseSharedCache)
			{
				AccessTokenCacheDictionary = s_accessTokenCacheDictionary;
				AppMetadataDictionary = s_appMetadataDictionary;
			}
			else
			{
				AccessTokenCacheDictionary = new ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>>();
				AppMetadataDictionary = new ConcurrentDictionary<string, MsalAppMetadataCacheItem>();
			}
		}

		public void SaveAccessToken(MsalAccessTokenCacheItem item)
		{
			string cacheKey = item.CacheKey;
			string clientCredentialKey = CacheKeyFactory.GetClientCredentialKey(item.ClientId, item.TenantId, item.KeyId);
			AccessTokenCacheDictionary.GetOrAdd(clientCredentialKey, new ConcurrentDictionary<string, MsalAccessTokenCacheItem>())[cacheKey] = item;
		}

		public void SaveRefreshToken(MsalRefreshTokenCacheItem item)
		{
			throw new MsalClientException("combined_user_app_cache_not_supported", "Using a combined flat storage, like a file, to store both app and user tokens is not supported. Use a partitioned token cache (for ex. distributed cache like Redis) or separate files for app and user token caches. See https://aka.ms/msal-net-token-cache-serialization .");
		}

		public void SaveIdToken(MsalIdTokenCacheItem item)
		{
			throw new MsalClientException("combined_user_app_cache_not_supported", "Using a combined flat storage, like a file, to store both app and user tokens is not supported. Use a partitioned token cache (for ex. distributed cache like Redis) or separate files for app and user token caches. See https://aka.ms/msal-net-token-cache-serialization .");
		}

		public void SaveAccount(MsalAccountCacheItem item)
		{
			throw new MsalClientException("combined_user_app_cache_not_supported", "Using a combined flat storage, like a file, to store both app and user tokens is not supported. Use a partitioned token cache (for ex. distributed cache like Redis) or separate files for app and user token caches. See https://aka.ms/msal-net-token-cache-serialization .");
		}

		public void SaveAppMetadata(MsalAppMetadataCacheItem item)
		{
			string cacheKey = item.CacheKey;
			AppMetadataDictionary[cacheKey] = item;
		}

		public MsalIdTokenCacheItem GetIdToken(MsalAccessTokenCacheItem accessTokenCacheItem)
		{
			throw new MsalClientException("combined_user_app_cache_not_supported", "Using a combined flat storage, like a file, to store both app and user tokens is not supported. Use a partitioned token cache (for ex. distributed cache like Redis) or separate files for app and user token caches. See https://aka.ms/msal-net-token-cache-serialization .");
		}

		public MsalAccountCacheItem GetAccount(MsalAccountCacheItem accountCacheItem)
		{
			throw new MsalClientException("combined_user_app_cache_not_supported", "Using a combined flat storage, like a file, to store both app and user tokens is not supported. Use a partitioned token cache (for ex. distributed cache like Redis) or separate files for app and user token caches. See https://aka.ms/msal-net-token-cache-serialization .");
		}

		public MsalAppMetadataCacheItem GetAppMetadata(MsalAppMetadataCacheItem appMetadataItem)
		{
			AppMetadataDictionary.TryGetValue(appMetadataItem.CacheKey, out var value);
			return value;
		}

		public void DeleteAccessToken(MsalAccessTokenCacheItem item)
		{
			string clientCredentialKey = CacheKeyFactory.GetClientCredentialKey(item.ClientId, item.TenantId, item.KeyId);
			AccessTokenCacheDictionary.TryGetValue(clientCredentialKey, out var value);
			if (value == null || !value.TryRemove(item.CacheKey, out var _))
			{
				_logger.InfoPii(() => "[Internal cache] Cannot delete access token because it was not found in the cache. Key " + item.CacheKey + ".", () => "[Internal cache] Cannot delete access token because it was not found in the cache.");
			}
		}

		public void DeleteRefreshToken(MsalRefreshTokenCacheItem item)
		{
			throw new MsalClientException("combined_user_app_cache_not_supported", "Using a combined flat storage, like a file, to store both app and user tokens is not supported. Use a partitioned token cache (for ex. distributed cache like Redis) or separate files for app and user token caches. See https://aka.ms/msal-net-token-cache-serialization .");
		}

		public void DeleteIdToken(MsalIdTokenCacheItem item)
		{
			throw new MsalClientException("combined_user_app_cache_not_supported", "Using a combined flat storage, like a file, to store both app and user tokens is not supported. Use a partitioned token cache (for ex. distributed cache like Redis) or separate files for app and user token caches. See https://aka.ms/msal-net-token-cache-serialization .");
		}

		public void DeleteAccount(MsalAccountCacheItem item)
		{
			throw new MsalClientException("combined_user_app_cache_not_supported", "Using a combined flat storage, like a file, to store both app and user tokens is not supported. Use a partitioned token cache (for ex. distributed cache like Redis) or separate files for app and user token caches. See https://aka.ms/msal-net-token-cache-serialization .");
		}

		public virtual List<MsalAccessTokenCacheItem> GetAllAccessTokens(string partitionKey = null, ILoggerAdapter requestlogger = null)
		{
			(requestlogger ?? _logger).Always($"[Internal cache] Total number of cache partitions found while getting access tokens: {AccessTokenCacheDictionary.Count}");
			if (string.IsNullOrEmpty(partitionKey))
			{
				return (from kv in AccessTokenCacheDictionary.SelectMany((KeyValuePair<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>> dict) => dict.Value)
					select kv.Value).ToList();
			}
			AccessTokenCacheDictionary.TryGetValue(partitionKey, out var value);
			return value?.Select((KeyValuePair<string, MsalAccessTokenCacheItem> kv) => kv.Value)?.ToList() ?? CollectionHelpers.GetEmptyList<MsalAccessTokenCacheItem>();
		}

		public virtual List<MsalRefreshTokenCacheItem> GetAllRefreshTokens(string partitionKey = null, ILoggerAdapter requestlogger = null)
		{
			return CollectionHelpers.GetEmptyList<MsalRefreshTokenCacheItem>();
		}

		public virtual List<MsalIdTokenCacheItem> GetAllIdTokens(string partitionKey = null, ILoggerAdapter requestlogger = null)
		{
			return CollectionHelpers.GetEmptyList<MsalIdTokenCacheItem>();
		}

		public virtual List<MsalAccountCacheItem> GetAllAccounts(string partitionKey = null, ILoggerAdapter requestlogger = null)
		{
			return CollectionHelpers.GetEmptyList<MsalAccountCacheItem>();
		}

		public List<MsalAppMetadataCacheItem> GetAllAppMetadata()
		{
			return AppMetadataDictionary.Select((KeyValuePair<string, MsalAppMetadataCacheItem> kv) => kv.Value).ToList();
		}

		public void SetiOSKeychainSecurityGroup(string keychainSecurityGroup)
		{
			throw new NotImplementedException();
		}

		public virtual void Clear(ILoggerAdapter requestlogger = null)
		{
			ILoggerAdapter logger = requestlogger ?? _logger;
			AccessTokenCacheDictionary.Clear();
			logger.Always("[Internal cache] Clearing app token cache accessor.");
		}

		public virtual bool HasAccessOrRefreshTokens()
		{
			return AccessTokenCacheDictionary.Any((KeyValuePair<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>> partition) => partition.Value.Any((KeyValuePair<string, MsalAccessTokenCacheItem> token) => !token.Value.IsExpiredWithBuffer()));
		}
	}
	internal class InMemoryPartitionedUserTokenCacheAccessor : ITokenCacheAccessor
	{
		internal readonly ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>> AccessTokenCacheDictionary;

		internal readonly ConcurrentDictionary<string, ConcurrentDictionary<string, MsalRefreshTokenCacheItem>> RefreshTokenCacheDictionary;

		internal readonly ConcurrentDictionary<string, ConcurrentDictionary<string, MsalIdTokenCacheItem>> IdTokenCacheDictionary;

		internal readonly ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccountCacheItem>> AccountCacheDictionary;

		internal readonly ConcurrentDictionary<string, MsalAppMetadataCacheItem> AppMetadataDictionary;

		private static readonly ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>> s_accessTokenCacheDictionary = new ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>>();

		private static readonly ConcurrentDictionary<string, ConcurrentDictionary<string, MsalRefreshTokenCacheItem>> s_refreshTokenCacheDictionary = new ConcurrentDictionary<string, ConcurrentDictionary<string, MsalRefreshTokenCacheItem>>();

		private static readonly ConcurrentDictionary<string, ConcurrentDictionary<string, MsalIdTokenCacheItem>> s_idTokenCacheDictionary = new ConcurrentDictionary<string, ConcurrentDictionary<string, MsalIdTokenCacheItem>>();

		private static readonly ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccountCacheItem>> s_accountCacheDictionary = new ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccountCacheItem>>();

		private static readonly ConcurrentDictionary<string, MsalAppMetadataCacheItem> s_appMetadataDictionary = new ConcurrentDictionary<string, MsalAppMetadataCacheItem>();

		protected readonly ILoggerAdapter _logger;

		private readonly CacheOptions _tokenCacheAccessorOptions;

		public InMemoryPartitionedUserTokenCacheAccessor(ILoggerAdapter logger, CacheOptions tokenCacheAccessorOptions)
		{
			_logger = logger ?? throw new ArgumentNullException("logger");
			_tokenCacheAccessorOptions = tokenCacheAccessorOptions ?? new CacheOptions();
			if (_tokenCacheAccessorOptions.UseSharedCache)
			{
				AccessTokenCacheDictionary = s_accessTokenCacheDictionary;
				RefreshTokenCacheDictionary = s_refreshTokenCacheDictionary;
				IdTokenCacheDictionary = s_idTokenCacheDictionary;
				AccountCacheDictionary = s_accountCacheDictionary;
				AppMetadataDictionary = s_appMetadataDictionary;
			}
			else
			{
				AccessTokenCacheDictionary = new ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>>();
				RefreshTokenCacheDictionary = new ConcurrentDictionary<string, ConcurrentDictionary<string, MsalRefreshTokenCacheItem>>();
				IdTokenCacheDictionary = new ConcurrentDictionary<string, ConcurrentDictionary<string, MsalIdTokenCacheItem>>();
				AccountCacheDictionary = new ConcurrentDictionary<string, ConcurrentDictionary<string, MsalAccountCacheItem>>();
				AppMetadataDictionary = new ConcurrentDictionary<string, MsalAppMetadataCacheItem>();
			}
		}

		public void SaveAccessToken(MsalAccessTokenCacheItem item)
		{
			string cacheKey = item.CacheKey;
			string keyFromCachedItem = CacheKeyFactory.GetKeyFromCachedItem(item);
			AccessTokenCacheDictionary.GetOrAdd(keyFromCachedItem, new ConcurrentDictionary<string, MsalAccessTokenCacheItem>())[cacheKey] = item;
		}

		public void SaveRefreshToken(MsalRefreshTokenCacheItem item)
		{
			string cacheKey = item.CacheKey;
			string keyFromCachedItem = CacheKeyFactory.GetKeyFromCachedItem(item);
			RefreshTokenCacheDictionary.GetOrAdd(keyFromCachedItem, new ConcurrentDictionary<string, MsalRefreshTokenCacheItem>())[cacheKey] = item;
		}

		public void SaveIdToken(MsalIdTokenCacheItem item)
		{
			string cacheKey = item.CacheKey;
			string keyFromCachedItem = CacheKeyFactory.GetKeyFromCachedItem(item);
			IdTokenCacheDictionary.GetOrAdd(keyFromCachedItem, new ConcurrentDictionary<string, MsalIdTokenCacheItem>())[cacheKey] = item;
		}

		public void SaveAccount(MsalAccountCacheItem item)
		{
			string cacheKey = item.CacheKey;
			string keyFromCachedItem = CacheKeyFactory.GetKeyFromCachedItem(item);
			AccountCacheDictionary.GetOrAdd(keyFromCachedItem, new ConcurrentDictionary<string, MsalAccountCacheItem>())[cacheKey] = item;
		}

		public void SaveAppMetadata(MsalAppMetadataCacheItem item)
		{
			string cacheKey = item.CacheKey;
			AppMetadataDictionary[cacheKey] = item;
		}

		public MsalIdTokenCacheItem GetIdToken(MsalAccessTokenCacheItem accessTokenCacheItem)
		{
			string idTokenKeyFromCachedItem = CacheKeyFactory.GetIdTokenKeyFromCachedItem(accessTokenCacheItem);
			IdTokenCacheDictionary.TryGetValue(idTokenKeyFromCachedItem, out var value);
			if (value != null && value.TryGetValue(accessTokenCacheItem.GetIdTokenItem().CacheKey, out var value2))
			{
				return value2;
			}
			_logger.WarningPii("[Internal cache] Could not find an id token for the access token with key " + accessTokenCacheItem.CacheKey, "[Internal cache] Could not find an id token for the access token for realm " + accessTokenCacheItem.TenantId + " ");
			return null;
		}

		public MsalAccountCacheItem GetAccount(MsalAccountCacheItem accountCacheItem)
		{
			string keyFromAccount = CacheKeyFactory.GetKeyFromAccount(accountCacheItem);
			AccountCacheDictionary.TryGetValue(keyFromAccount, out var value);
			MsalAccountCacheItem value2 = null;
			value?.TryGetValue(accountCacheItem.CacheKey, out value2);
			return value2;
		}

		public MsalAppMetadataCacheItem GetAppMetadata(MsalAppMetadataCacheItem appMetadataItem)
		{
			AppMetadataDictionary.TryGetValue(appMetadataItem.CacheKey, out var value);
			return value;
		}

		public void DeleteAccessToken(MsalAccessTokenCacheItem item)
		{
			string keyFromCachedItem = CacheKeyFactory.GetKeyFromCachedItem(item);
			AccessTokenCacheDictionary.TryGetValue(keyFromCachedItem, out var value);
			if (value == null || !value.TryRemove(item.CacheKey, out var _))
			{
				_logger.InfoPii(() => "[Internal cache] Cannot delete access token because it was not found in the cache. Key " + item.CacheKey + ".", () => "[Internal cache] Cannot delete access token because it was not found in the cache.");
			}
		}

		public void DeleteRefreshToken(MsalRefreshTokenCacheItem item)
		{
			string keyFromCachedItem = CacheKeyFactory.GetKeyFromCachedItem(item);
			RefreshTokenCacheDictionary.TryGetValue(keyFromCachedItem, out var value);
			if (value == null || !value.TryRemove(item.CacheKey, out var _))
			{
				_logger.InfoPii(() => "[Internal cache] Cannot delete refresh token because it was not found in the cache. Key " + item.CacheKey + ".", () => "[Internal cache] Cannot delete refresh token because it was not found in the cache.");
			}
		}

		public void DeleteIdToken(MsalIdTokenCacheItem item)
		{
			string keyFromCachedItem = CacheKeyFactory.GetKeyFromCachedItem(item);
			IdTokenCacheDictionary.TryGetValue(keyFromCachedItem, out var value);
			if (value == null || !value.TryRemove(item.CacheKey, out var _))
			{
				_logger.InfoPii(() => "[Internal cache] Cannot delete ID token because it was not found in the cache. Key " + item.CacheKey + ".", () => "[Internal cache] Cannot delete ID token because it was not found in the cache.");
			}
		}

		public void DeleteAccount(MsalAccountCacheItem item)
		{
			string keyFromCachedItem = CacheKeyFactory.GetKeyFromCachedItem(item);
			AccountCacheDictionary.TryGetValue(keyFromCachedItem, out var value);
			if (value == null || !value.TryRemove(item.CacheKey, out var _))
			{
				_logger.InfoPii(() => "[Internal cache] Cannot delete account because it was not found in the cache. Key " + item.CacheKey + ".", () => "[Internal cache] Cannot delete account because it was not found in the cache");
			}
		}

		public virtual List<MsalAccessTokenCacheItem> GetAllAccessTokens(string partitionKey = null, ILoggerAdapter requestlogger = null)
		{
			(requestlogger ?? _logger).Always($"[Internal cache] Total number of cache partitions found while getting access tokens: {AccessTokenCacheDictionary.Count}");
			if (string.IsNullOrEmpty(partitionKey))
			{
				return (from kv in AccessTokenCacheDictionary.SelectMany((KeyValuePair<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>> dict) => dict.Value)
					select kv.Value).ToList();
			}
			AccessTokenCacheDictionary.TryGetValue(partitionKey, out var value);
			return value?.Select((KeyValuePair<string, MsalAccessTokenCacheItem> kv) => kv.Value)?.ToList() ?? CollectionHelpers.GetEmptyList<MsalAccessTokenCacheItem>();
		}

		public virtual List<MsalRefreshTokenCacheItem> GetAllRefreshTokens(string partitionKey = null, ILoggerAdapter requestlogger = null)
		{
			(requestlogger ?? _logger).Always($"[Internal cache] Total number of cache partitions found while getting refresh tokens: {RefreshTokenCacheDictionary.Count}");
			if (string.IsNullOrEmpty(partitionKey))
			{
				return (from kv in RefreshTokenCacheDictionary.SelectMany((KeyValuePair<string, ConcurrentDictionary<string, MsalRefreshTokenCacheItem>> dict) => dict.Value)
					select kv.Value).ToList();
			}
			RefreshTokenCacheDictionary.TryGetValue(partitionKey, out var value);
			return value?.Select((KeyValuePair<string, MsalRefreshTokenCacheItem> kv) => kv.Value)?.ToList() ?? CollectionHelpers.GetEmptyList<MsalRefreshTokenCacheItem>();
		}

		public virtual List<MsalIdTokenCacheItem> GetAllIdTokens(string partitionKey = null, ILoggerAdapter requestlogger = null)
		{
			if (string.IsNullOrEmpty(partitionKey))
			{
				return (from kv in IdTokenCacheDictionary.SelectMany((KeyValuePair<string, ConcurrentDictionary<string, MsalIdTokenCacheItem>> dict) => dict.Value)
					select kv.Value).ToList();
			}
			IdTokenCacheDictionary.TryGetValue(partitionKey, out var value);
			return value?.Select((KeyValuePair<string, MsalIdTokenCacheItem> kv) => kv.Value)?.ToList() ?? CollectionHelpers.GetEmptyList<MsalIdTokenCacheItem>();
		}

		public virtual List<MsalAccountCacheItem> GetAllAccounts(string partitionKey = null, ILoggerAdapter requestlogger = null)
		{
			if (string.IsNullOrEmpty(partitionKey))
			{
				return (from kv in AccountCacheDictionary.SelectMany((KeyValuePair<string, ConcurrentDictionary<string, MsalAccountCacheItem>> dict) => dict.Value)
					select kv.Value).ToList();
			}
			AccountCacheDictionary.TryGetValue(partitionKey, out var value);
			return value?.Select((KeyValuePair<string, MsalAccountCacheItem> kv) => kv.Value)?.ToList() ?? CollectionHelpers.GetEmptyList<MsalAccountCacheItem>();
		}

		public virtual List<MsalAppMetadataCacheItem> GetAllAppMetadata()
		{
			return AppMetadataDictionary.Select((KeyValuePair<string, MsalAppMetadataCacheItem> kv) => kv.Value).ToList();
		}

		public void SetiOSKeychainSecurityGroup(string keychainSecurityGroup)
		{
			throw new NotImplementedException();
		}

		public virtual void Clear(ILoggerAdapter requestlogger = null)
		{
			(requestlogger ?? _logger).Always("[Internal cache] Clearing user token cache accessor.");
			AccessTokenCacheDictionary.Clear();
			RefreshTokenCacheDictionary.Clear();
			IdTokenCacheDictionary.Clear();
			AccountCacheDictionary.Clear();
		}

		public virtual bool HasAccessOrRefreshTokens()
		{
			if (!RefreshTokenCacheDictionary.Any((KeyValuePair<string, ConcurrentDictionary<string, MsalRefreshTokenCacheItem>> partition) => partition.Value.Count > 0))
			{
				return AccessTokenCacheDictionary.Any((KeyValuePair<string, ConcurrentDictionary<string, MsalAccessTokenCacheItem>> partition) => partition.Value.Any((KeyValuePair<string, MsalAccessTokenCacheItem> token) => !token.Value.IsExpiredWithBuffer()));
			}
			return true;
		}
	}
	[EventSource(Name = "Microsoft.Identity.Client")]
	internal class MsalEventSource : EventSource
	{
		[Event(1, Level = EventLevel.Verbose)]
		internal void Verbose(string message)
		{
			WriteEvent(1, message);
		}

		[Event(2, Level = EventLevel.Informational)]
		internal void Information(string message)
		{
			WriteEvent(2, message);
		}

		[Event(3, Level = EventLevel.Warning)]
		internal void Warning(string message)
		{
			WriteEvent(3, message);
		}

		[Event(4, Level = EventLevel.Error)]
		internal void Error(string message)
		{
			WriteEvent(4, message);
		}
	}
	internal class NullDeviceAuthManager : IDeviceAuthManager
	{
		public bool TryCreateDeviceAuthChallengeResponse(HttpResponseHeaders headers, Uri endpointUri, out string responseHeader)
		{
			if (!DeviceAuthHelper.IsDeviceAuthChallenge(headers))
			{
				responseHeader = string.Empty;
				return false;
			}
			responseHeader = DeviceAuthHelper.GetBypassChallengeResponse(headers);
			return true;
		}
	}
	internal class NullLegacyCachePersistence : ILegacyCachePersistence
	{
		public byte[] LoadCache()
		{
			return null;
		}

		public void WriteCache(byte[] serializedCache)
		{
		}
	}
	internal class PKeyAuthConstants
	{
		public const string DeviceAuthHeaderName = "x-ms-PKeyAuth";

		public const string DeviceAuthHeaderValue = "1.0";

		public const string WwwAuthenticateHeader = "WWW-Authenticate";

		public const string PKeyAuthName = "PKeyAuth";

		public const string ChallengeResponseContext = "Context";

		public const string ChallengeResponseVersion = "Version";

		public const string PKeyAuthBypassReponseFormat = "PKeyAuth Context=\"{0}\",Version=\"{1}\"";
	}
	internal class SimpleHttpClientFactory : IMsalHttpClientFactory
	{
		private static readonly Lazy<HttpClient> s_httpClient = new Lazy<HttpClient>(InitializeClient);

		private static HttpClient InitializeClient()
		{
			HttpClient httpClient = new HttpClient(new HttpClientHandler
			{
				UseDefaultCredentials = true
			});
			HttpClientConfig.ConfigureRequestHeadersAndSize(httpClient);
			return httpClient;
		}

		public HttpClient GetHttpClient()
		{
			return s_httpClient.Value;
		}
	}
	internal static class Win32VersionApi
	{
		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		private struct OSVERSIONINFOEXW
		{
			public int dwOSVersionInfoSize;

			public int dwMajorVersion;

			public int dwMinorVersion;

			public int dwBuildNumber;

			public int dwPlatformId;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
			public string scZSDVersion;

			public ushort wServicePackMajor;

			public ushort wServicePackMinor;

			public short wSuiteMask;

			public byte wProductType;

			public byte wReserved;
		}

		private const byte VER_NT_WORKSTATION = 1;

		private const byte VER_NT_DOMAIN_CONTROLLER = 2;

		private const byte VER_NT_SERVER = 3;

		private const byte NT_STATUS_SUCCESS = 0;

		private const int WamSupportedWindows10BuildNumber = 15063;

		private const int Windows2019BuildNumber = 17763;

		[DllImport("ntdll.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
		private static extern int RtlGetVersion(ref OSVERSIONINFOEXW versionInformation);

		public static bool IsWamSupportedOs()
		{
			try
			{
				OSVERSIONINFOEXW versionInformation = new OSVERSIONINFOEXW
				{
					dwOSVersionInfoSize = Marshal.SizeOf<OSVERSIONINFOEXW>()
				};
				if (RtlGetVersion(ref versionInformation) == 0)
				{
					switch (versionInformation.wProductType)
					{
					case 1:
						if (versionInformation.dwMajorVersion == 10)
						{
							if (versionInformation.dwBuildNumber >= 15063)
							{
								return true;
							}
							return false;
						}
						return false;
					case 2:
					case 3:
						if (versionInformation.dwMajorVersion == 10)
						{
							if (versionInformation.dwBuildNumber >= 17763)
							{
								return true;
							}
							return false;
						}
						return false;
					default:
						return false;
					}
				}
				return false;
			}
			catch
			{
				return false;
			}
		}
	}
}
namespace Microsoft.Identity.Client.PlatformsCommon.Interfaces
{
	internal interface ICryptographyManager
	{
		string CreateBase64UrlEncodedSha256Hash(string input);

		string GenerateCodeVerifier();

		string CreateSha256Hash(string input);

		byte[] CreateSha256HashBytes(string input);

		byte[] SignWithCertificate(string message, X509Certificate2 certificate, RSASignaturePadding signaturePadding);
	}
	internal interface IDeviceAuthManager
	{
		bool TryCreateDeviceAuthChallengeResponse(HttpResponseHeaders headers, Uri endpointUri, out string responseHeader);
	}
	internal interface IFeatureFlags
	{
		bool IsFociEnabled { get; }
	}
	internal interface IPlatformLogger
	{
		void Always(string message);

		void Error(string message);

		void Warning(string message);

		void Verbose(string message);

		void Information(string message);
	}
	internal interface IPlatformProxy
	{
		bool LegacyCacheRequiresSerialization { get; }

		ICryptographyManager CryptographyManager { get; }

		IPlatformLogger PlatformLogger { get; }

		IOtelInstrumentation OtelInstrumentation { get; }

		bool BrokerSupportsWamAccounts { get; }

		string GetDeviceModel();

		string GetOperatingSystem();

		string GetProcessorArchitecture();

		Task<string> GetUserPrincipalNameAsync();

		string GetCallingApplicationName();

		string GetCallingApplicationVersion();

		string GetDeviceId();

		string GetDefaultRedirectUri(string clientId, bool useRecommendedRedirectUri = false);

		string GetProductName();

		string GetRuntimeVersion();

		ILegacyCachePersistence CreateLegacyCachePersistence();

		ITokenCacheAccessor CreateTokenCacheAccessor(CacheOptions accessorOptions, bool isApplicationTokenCache = false);

		IWebUIFactory GetWebUiFactory(ApplicationConfiguration appConfig);

		IPoPCryptoProvider GetDefaultPoPCryptoProvider();

		IFeatureFlags GetFeatureFlags();

		void SetFeatureFlags(IFeatureFlags featureFlags);

		Task StartDefaultOsBrowserAsync(string url, bool isBrokerConfigured);

		IBroker CreateBroker(ApplicationConfiguration appConfig, CoreUIParent uiParent);

		IDeviceAuthManager CreateDeviceAuthManager();

		bool CanBrokerSupportSilentAuth();

		IMsalHttpClientFactory CreateDefaultHttpClientFactory();
	}
}
namespace Microsoft.Identity.Client.PlatformsCommon.Factories
{
	internal static class PlatformProxyFactory
	{
		public static IPlatformProxy CreatePlatformProxy(ILoggerAdapter logger)
		{
			return new NetStandardPlatformProxy(logger ?? LoggerHelper.NullLogger);
		}
	}
}
namespace Microsoft.Identity.Client.OAuth2
{
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class DeviceAuthHeader
	{
		[JsonProperty("x5c")]
		public IList<string> X5c { get; set; }

		[JsonProperty("typ")]
		public string Type { get; set; }

		[JsonProperty("alg")]
		public string Alg { get; private set; }

		public DeviceAuthHeader(string base64EncodedCertificate)
		{
			Alg = "RS256";
			Type = "JWT";
			X5c = new List<string>();
			X5c.Add(base64EncodedCertificate);
		}
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class DeviceAuthPayload
	{
		private readonly Lazy<long> _defaultDeviceAuthJWTTimeSpan = new Lazy<long>(() => (long)(DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds);

		[JsonProperty("iat")]
		public long Iat { get; set; }

		[JsonProperty("aud")]
		public string Audience { get; set; }

		[JsonProperty("nonce")]
		public string Nonce { get; private set; }

		public DeviceAuthPayload(string audience, string nonce)
		{
			Nonce = nonce;
			Audience = audience;
			Iat = _defaultDeviceAuthJWTTimeSpan.Value;
		}
	}
	internal class DeviceAuthJWTResponse
	{
		private readonly DeviceAuthHeader _header;

		private readonly DeviceAuthPayload _payload;

		public DeviceAuthJWTResponse(string audience, string nonce, string base64EncodedCertificate)
		{
			_header = new DeviceAuthHeader(base64EncodedCertificate);
			_payload = new DeviceAuthPayload(audience, nonce);
		}

		public string GetResponseToSign()
		{
			return string.Format(CultureInfo.InvariantCulture, "{0}.{1}", Base64UrlHelpers.Encode(JsonHelper.SerializeToJson(_header).ToByteArray()), Base64UrlHelpers.Encode(JsonHelper.SerializeToJson(_payload).ToByteArray()));
		}
	}
	internal class TokenResponseClaim : OAuth2ResponseBaseClaim
	{
		public const string Code = "code";

		public const string TokenType = "token_type";

		public const string AccessToken = "access_token";

		public const string RefreshToken = "refresh_token";

		public const string IdToken = "id_token";

		public const string Scope = "scope";

		public const string ClientInfo = "client_info";

		public const string ExpiresIn = "expires_in";

		public const string CloudInstanceHost = "cloud_instance_host_name";

		public const string CreatedOn = "created_on";

		public const string ExtendedExpiresIn = "ext_expires_in";

		public const string Authority = "authority";

		public const string FamilyId = "foci";

		public const string RefreshIn = "refresh_in";

		public const string ErrorSubcode = "error_subcode";

		public const string ErrorSubcodeCancel = "cancel";

		public const string TenantId = "tenant_id";

		public const string Upn = "username";

		public const string LocalAccountId = "local_account_id";

		public const string SpaCode = "spa_code";
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class MsalTokenResponse : OAuth2ResponseBase
	{
		private const string iOSBrokerErrorMetadata = "error_metadata";

		private const string iOSBrokerHomeAccountId = "home_account_id";

		[JsonExtensionData]
		public Dictionary<string, JToken> ExtensionData { get; set; }

		[JsonProperty("token_type")]
		public string TokenType { get; set; }

		[JsonProperty("access_token")]
		public string AccessToken { get; set; }

		[JsonProperty("refresh_token")]
		public string RefreshToken { get; set; }

		[JsonProperty("scope")]
		public string Scope { get; set; }

		[JsonProperty("client_info")]
		public string ClientInfo { get; set; }

		[JsonProperty("id_token")]
		public string IdToken { get; set; }

		[JsonProperty("expires_in")]
		public long ExpiresIn { get; set; }

		[JsonProperty("ext_expires_in")]
		public long ExtendedExpiresIn { get; set; }

		[JsonProperty("refresh_in")]
		public long? RefreshIn { get; set; }

		[JsonProperty("foci")]
		public string FamilyId { get; set; }

		[JsonProperty("spa_code")]
		public string SpaAuthCode { get; set; }

		[JsonProperty("authority")]
		public string AuthorityUrl { get; set; }

		public string TenantId { get; set; }

		public string Upn { get; set; }

		public string AccountUserId { get; set; }

		public string WamAccountId { get; set; }

		public TokenSource TokenSource { get; set; }

		public HttpResponse HttpResponse { get; set; }

		public IReadOnlyDictionary<string, string> CreateExtensionDataStringMap()
		{
			if (ExtensionData == null || ExtensionData.Count == 0)
			{
				return CollectionHelpers.GetEmptyDictionary<string, string>();
			}
			Dictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			foreach (KeyValuePair<string, JToken> extensionDatum in ExtensionData)
			{
				if (extensionDatum.Value.Type == JTokenType.String || extensionDatum.Value.Type == JTokenType.Uri || extensionDatum.Value.Type == JTokenType.Boolean || extensionDatum.Value.Type == JTokenType.Date || extensionDatum.Value.Type == JTokenType.Float || extensionDatum.Value.Type == JTokenType.Guid || extensionDatum.Value.Type == JTokenType.Integer || extensionDatum.Value.Type == JTokenType.TimeSpan || extensionDatum.Value.Type == JTokenType.Null)
				{
					dictionary.Add(extensionDatum.Key, extensionDatum.Value.ToString());
				}
			}
			return dictionary;
		}

		internal static MsalTokenResponse CreateFromiOSBrokerResponse(Dictionary<string, string> responseDictionary)
		{
			if (responseDictionary.TryGetValue("broker_error_code", out var value))
			{
				string value2;
				string text = (responseDictionary.TryGetValue("error_metadata", out value2) ? value2 : null);
				Dictionary<string, string> dictionary = null;
				if (text != null)
				{
					dictionary = JsonConvert.DeserializeObject<Dictionary<string, string>>(Uri.UnescapeDataString(text));
				}
				string value3 = null;
				dictionary?.TryGetValue("home_account_id", out value3);
				string value4;
				string value5;
				string value6;
				return new MsalTokenResponse
				{
					Error = value,
					ErrorDescription = (responseDictionary.TryGetValue("error_description", out value4) ? CoreHelpers.UrlDecode(value4) : string.Empty),
					SubError = (responseDictionary.TryGetValue("suberror", out value5) ? value5 : string.Empty),
					AccountUserId = ((value3 != null) ? AccountId.ParseFromString(value3).ObjectId : null),
					TenantId = ((value3 != null) ? AccountId.ParseFromString(value3).TenantId : null),
					Upn = ((dictionary != null && dictionary.ContainsKey("username")) ? dictionary["username"] : null),
					CorrelationId = (responseDictionary.TryGetValue("correlation_id", out value6) ? value6 : null)
				};
			}
			string value7;
			string value8;
			string value9;
			MsalTokenResponse msalTokenResponse = new MsalTokenResponse
			{
				AccessToken = responseDictionary["access_token"],
				RefreshToken = (responseDictionary.TryGetValue("refresh_token", out value7) ? value7 : null),
				IdToken = responseDictionary["id_token"],
				TokenType = "Bearer",
				CorrelationId = responseDictionary["correlation_id"],
				Scope = responseDictionary["scope"],
				ExpiresIn = (responseDictionary.TryGetValue("expires_on", out value8) ? DateTimeHelpers.GetDurationFromNowInSeconds(value8) : 0),
				ClientInfo = (responseDictionary.TryGetValue("client_info", out value9) ? value9 : null),
				TokenSource = TokenSource.Broker
			};
			if (responseDictionary.TryGetValue("refresh_in", out var value10))
			{
				msalTokenResponse.RefreshIn = long.Parse(value10, CultureInfo.InvariantCulture);
			}
			return msalTokenResponse;
		}

		internal static MsalTokenResponse CreateFromManagedIdentityResponse(ManagedIdentityResponse managedIdentityResponse)
		{
			ValidateManagedIdentityResult(managedIdentityResponse);
			long durationFromNowInSeconds = DateTimeHelpers.GetDurationFromNowInSeconds(managedIdentityResponse.ExpiresOn);
			return new MsalTokenResponse
			{
				AccessToken = managedIdentityResponse.AccessToken,
				ExpiresIn = durationFromNowInSeconds,
				TokenType = managedIdentityResponse.TokenType,
				TokenSource = TokenSource.IdentityProvider,
				RefreshIn = InferManagedIdentityRefreshInValue(durationFromNowInSeconds)
			};
		}

		private static long? InferManagedIdentityRefreshInValue(long expiresIn)
		{
			if (expiresIn > 7200)
			{
				return expiresIn / 2;
			}
			return null;
		}

		private static void ValidateManagedIdentityResult(ManagedIdentityResponse response)
		{
			if (string.IsNullOrEmpty(response.AccessToken))
			{
				HandleInvalidExternalValueError("AccessToken");
			}
			if (DateTimeHelpers.GetDurationFromNowInSeconds(response.ExpiresOn) <= 0)
			{
				HandleInvalidExternalValueError("ExpiresOn");
			}
		}

		internal static MsalTokenResponse CreateFromAppProviderResponse(AppTokenProviderResult tokenProviderResponse)
		{
			ValidateTokenProviderResult(tokenProviderResponse);
			return new MsalTokenResponse
			{
				AccessToken = tokenProviderResponse.AccessToken,
				RefreshToken = null,
				IdToken = null,
				TokenType = "Bearer",
				ExpiresIn = tokenProviderResponse.ExpiresInSeconds,
				ClientInfo = null,
				TokenSource = TokenSource.IdentityProvider,
				TenantId = null,
				RefreshIn = (tokenProviderResponse.RefreshInSeconds ?? EstimateRefreshIn(tokenProviderResponse.ExpiresInSeconds))
			};
		}

		private static long? EstimateRefreshIn(long expiresInSeconds)
		{
			if (expiresInSeconds >= 7200)
			{
				return expiresInSeconds / 2;
			}
			return null;
		}

		private static void ValidateTokenProviderResult(AppTokenProviderResult TokenProviderResult)
		{
			if (string.IsNullOrEmpty(TokenProviderResult.AccessToken))
			{
				HandleInvalidExternalValueError("AccessToken");
			}
			if (TokenProviderResult.ExpiresInSeconds == 0L || TokenProviderResult.ExpiresInSeconds < 0)
			{
				HandleInvalidExternalValueError("ExpiresInSeconds");
			}
		}

		private static void HandleInvalidExternalValueError(string nameOfValue)
		{
			throw new MsalClientException("invalid_token_provider_response_value", MsalErrorMessage.InvalidTokenProviderResponseValue(nameOfValue));
		}

		internal static MsalTokenResponse CreateFromAndroidBrokerResponse(string jsonResponse, string correlationId)
		{
			JObject jObject = JsonHelper.ParseIntoJsonObject(jsonResponse);
			string text = jObject["broker_error_code"]?.ToString();
			if (!string.IsNullOrEmpty(text))
			{
				return new MsalTokenResponse
				{
					Error = text,
					ErrorDescription = jObject["broker_error_message"]?.ToString(),
					AuthorityUrl = jObject["authority"]?.ToString(),
					TenantId = jObject["tenant_id"]?.ToString(),
					Upn = jObject["username"]?.ToString(),
					AccountUserId = jObject["local_account_id"]?.ToString()
				};
			}
			return new MsalTokenResponse
			{
				AccessToken = jObject["access_token"].ToString(),
				IdToken = jObject["id_token"].ToString(),
				CorrelationId = correlationId,
				Scope = jObject["scopes"].ToString(),
				ExpiresIn = DateTimeHelpers.GetDurationFromNowInSeconds(jObject["expires_on"].ToString()),
				ExtendedExpiresIn = DateTimeHelpers.GetDurationFromNowInSeconds(jObject["ext_expires_on"].ToString()),
				ClientInfo = jObject["client_info"].ToString(),
				TokenType = (jObject["token_type"]?.ToString() ?? "Bearer"),
				TokenSource = TokenSource.Broker,
				AuthorityUrl = jObject["authority"]?.ToString(),
				TenantId = jObject["tenant_id"]?.ToString(),
				Upn = jObject["username"]?.ToString(),
				AccountUserId = jObject["local_account_id"]?.ToString()
			};
		}

		public void Log(ILoggerAdapter logger, LogLevel logLevel)
		{
			if (logger.IsLoggingEnabled(logLevel))
			{
				string messageWithPii = $"\r\n[MsalTokenResponse]\r\nError: {base.Error}\r\nErrorDescription: {base.ErrorDescription}\r\nScopes: {Scope}\r\nExpiresIn: {ExpiresIn}\r\nRefreshIn: {RefreshIn}\r\nAccessToken returned: {!string.IsNullOrEmpty(AccessToken)}\r\nAccessToken Type: {TokenType}\r\nRefreshToken returned: {!string.IsNullOrEmpty(RefreshToken)}\r\nIdToken returned: {!string.IsNullOrEmpty(IdToken)}\r\nClientInfo: {ClientInfo}\r\nFamilyId: {FamilyId}\r\nWamAccountId exists: {!string.IsNullOrEmpty(WamAccountId)}";
				string messageScrubbed = $"\r\n[MsalTokenResponse]\r\nError: {base.Error}\r\nErrorDescription: {base.ErrorDescription}\r\nScopes: {Scope}\r\nExpiresIn: {ExpiresIn}\r\nRefreshIn: {RefreshIn}\r\nAccessToken returned: {!string.IsNullOrEmpty(AccessToken)}\r\nAccessToken Type: {TokenType}\r\nRefreshToken returned: {!string.IsNullOrEmpty(RefreshToken)}\r\nIdToken returned: {!string.IsNullOrEmpty(IdToken)}\r\nClientInfo returned: {!string.IsNullOrEmpty(ClientInfo)}\r\nFamilyId: {FamilyId}\r\nWamAccountId exists: {!string.IsNullOrEmpty(WamAccountId)}";
				logger.Log(logLevel, messageWithPii, messageScrubbed);
			}
		}
	}
	internal class OAuth2Client
	{
		private readonly Dictionary<string, string> _headers;

		private readonly Dictionary<string, string> _queryParameters = new Dictionary<string, string>();

		private readonly IDictionary<string, string> _bodyParameters = new Dictionary<string, string>();

		private readonly IHttpManager _httpManager;

		public OAuth2Client(ILoggerAdapter logger, IHttpManager httpManager)
		{
			_headers = new Dictionary<string, string>(MsalIdHelper.GetMsalIdParameters(logger));
			_httpManager = httpManager ?? throw new ArgumentNullException("httpManager");
		}

		public void AddQueryParameter(string key, string value)
		{
			if (!string.IsNullOrWhiteSpace(key) && !string.IsNullOrWhiteSpace(value))
			{
				_queryParameters[key] = value;
			}
		}

		public void AddBodyParameter(string key, string value)
		{
			if (!string.IsNullOrWhiteSpace(key) && !string.IsNullOrWhiteSpace(value))
			{
				_bodyParameters[key] = value;
			}
		}

		internal void AddHeader(string key, string value)
		{
			_headers[key] = value;
		}

		internal IReadOnlyDictionary<string, string> GetBodyParameters()
		{
			return new ReadOnlyDictionary<string, string>(_bodyParameters);
		}

		public Task<InstanceDiscoveryResponse> DiscoverAadInstanceAsync(Uri endpoint, RequestContext requestContext)
		{
			return ExecuteRequestAsync<InstanceDiscoveryResponse>(endpoint, HttpMethod.Get, requestContext);
		}

		public Task<OidcMetadata> DiscoverOidcMetadataAsync(Uri endpoint, RequestContext requestContext)
		{
			return ExecuteRequestAsync<OidcMetadata>(endpoint, HttpMethod.Get, requestContext);
		}

		internal Task<MsalTokenResponse> GetTokenAsync(Uri endPoint, RequestContext requestContext, bool addCommonHeaders, Func<OnBeforeTokenRequestData, Task> onBeforePostRequestHandler)
		{
			return ExecuteRequestAsync<MsalTokenResponse>(endPoint, HttpMethod.Post, requestContext, expectErrorsOn200OK: false, addCommonHeaders, onBeforePostRequestHandler);
		}

		internal async Task<T> ExecuteRequestAsync<T>(Uri endPoint, HttpMethod method, RequestContext requestContext, bool expectErrorsOn200OK = false, bool addCommonHeaders = true, Func<OnBeforeTokenRequestData, Task> onBeforePostRequestData = null)
		{
			if (addCommonHeaders)
			{
				AddCommonHeaders(requestContext);
			}
			Uri endpointUri = AddExtraQueryParams(endPoint);
			HttpResponse httpResponse;
			using (requestContext.Logger.LogBlockDuration($"[Oauth2Client] Sending {method} request "))
			{
				_ = 2;
				try
				{
					if (method == HttpMethod.Post)
					{
						if (onBeforePostRequestData != null)
						{
							OnBeforeTokenRequestData requestData = new OnBeforeTokenRequestData(_bodyParameters, _headers, endpointUri, requestContext.UserCancellationToken);
							await onBeforePostRequestData(requestData).ConfigureAwait(continueOnCapturedContext: false);
							endpointUri = requestData.RequestUri;
						}
						httpResponse = await _httpManager.SendPostAsync(endpointUri, _headers, _bodyParameters, requestContext.Logger, requestContext.UserCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						httpResponse = await _httpManager.SendGetAsync(endpointUri, _headers, requestContext.Logger, retry: true, requestContext.UserCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
				}
				catch (Exception ex)
				{
					if (ex is TaskCanceledException && requestContext.UserCancellationToken.IsCancellationRequested)
					{
						throw;
					}
					requestContext.Logger.ErrorPii(string.Format("=== Token Acquisition ({0}) failed:\n\tAuthority: {1}\n\tClientId: {2}.", requestContext.ApiEvent?.ApiIdString, endpointUri.Scheme + "://" + endpointUri.Host + endpointUri.AbsolutePath, requestContext.ServiceBundle.Config.ClientId), string.Format("=== Token Acquisition ({0}) failed.\n\tHost: {1}.", requestContext.ApiEvent?.ApiIdString, endpointUri.Scheme + "://" + endpointUri.Host));
					requestContext.Logger.ErrorPii(ex);
					throw;
				}
			}
			if (requestContext.ApiEvent != null)
			{
				requestContext.ApiEvent.DurationInHttpInMs += _httpManager.LastRequestDurationInMs;
			}
			if (httpResponse.StatusCode != HttpStatusCode.OK || expectErrorsOn200OK)
			{
				requestContext.Logger.Verbose(() => "[Oauth2Client] Processing error response ");
				try
				{
					if (!string.IsNullOrWhiteSpace(httpResponse.Body))
					{
						MsalTokenResponse msalTokenResponse = JsonHelper.DeserializeFromJson<MsalTokenResponse>(httpResponse.Body);
						if (httpResponse.StatusCode == HttpStatusCode.OK && expectErrorsOn200OK && !string.IsNullOrEmpty(msalTokenResponse?.Error))
						{
							ThrowServerException(httpResponse, requestContext);
						}
					}
				}
				catch (JsonException)
				{
				}
			}
			return CreateResponse<T>(httpResponse, requestContext);
		}

		internal void AddBodyParameter(KeyValuePair<string, string> kvp)
		{
			_bodyParameters.Add(kvp);
		}

		private void AddCommonHeaders(RequestContext requestContext)
		{
			_headers.Add("client-request-id", requestContext.CorrelationId.ToString());
			_headers.Add("return-client-request-id", "true");
			if (!string.IsNullOrWhiteSpace(requestContext.Logger.ClientName))
			{
				_headers.Add("x-app-name", requestContext.Logger.ClientName);
			}
			if (!string.IsNullOrWhiteSpace(requestContext.Logger.ClientVersion))
			{
				_headers.Add("x-app-ver", requestContext.Logger.ClientVersion);
			}
		}

		public static T CreateResponse<T>(HttpResponse response, RequestContext requestContext)
		{
			if (response.StatusCode != HttpStatusCode.OK)
			{
				ThrowServerException(response, requestContext);
			}
			VerifyCorrelationIdHeaderInResponse(response.HeadersAsDictionary, requestContext);
			using (requestContext.Logger.LogBlockDuration("[OAuth2Client] Deserializing response"))
			{
				return JsonHelper.DeserializeFromJson<T>(response.Body);
			}
		}

		private static void ThrowServerException(HttpResponse response, RequestContext requestContext)
		{
			bool shouldLogAsError = true;
			string text = string.Format(CultureInfo.InvariantCulture, "HttpStatusCode: {0}: {1}", (int)response.StatusCode, response.StatusCode.ToString());
			requestContext.Logger.Info(text);
			MsalServiceException ex;
			try
			{
				ex = ExtractErrorsFromTheResponse(response, ref shouldLogAsError);
			}
			catch (JsonException)
			{
				ex = MsalServiceExceptionFactory.FromHttpResponse("non_parsable_oauth_error", "An error response was returned by the OAuth2 server, but it could not be parsed. Please inspect the exception properties for details. ", response);
			}
			catch (Exception innerException)
			{
				ex = MsalServiceExceptionFactory.FromHttpResponse("unknown_error", response.Body, response, innerException);
			}
			if (ex == null)
			{
				ex = MsalServiceExceptionFactory.FromHttpResponse((response.StatusCode == HttpStatusCode.NotFound) ? "not_found" : "http_status_not_200", text, response);
			}
			if (shouldLogAsError)
			{
				requestContext.Logger.ErrorPii($"=== Token Acquisition ({requestContext.ApiEvent?.ApiIdString}) failed:\n\tAuthority: {requestContext.ServiceBundle.Config.Authority.AuthorityInfo.CanonicalAuthority}\n\tClientId: {requestContext.ServiceBundle.Config.ClientId}.", $"=== Token Acquisition ({requestContext.ApiEvent?.ApiIdString}) failed.\n\tHost: {requestContext.ServiceBundle.Config.Authority.AuthorityInfo.Host}.");
				requestContext.Logger.ErrorPii(ex);
			}
			else
			{
				requestContext.Logger.InfoPii(ex);
			}
			throw ex;
		}

		private static MsalServiceException ExtractErrorsFromTheResponse(HttpResponse response, ref bool shouldLogAsError)
		{
			if (string.IsNullOrWhiteSpace(response.Body))
			{
				return null;
			}
			MsalTokenResponse msalTokenResponse;
			try
			{
				msalTokenResponse = JsonHelper.DeserializeFromJson<MsalTokenResponse>(response.Body);
			}
			catch (JsonException)
			{
				if (response.StatusCode == HttpStatusCode.TooManyRequests)
				{
					return MsalServiceExceptionFactory.FromThrottledAuthenticationResponse(response);
				}
				throw;
			}
			if (msalTokenResponse == null || msalTokenResponse.Error == null)
			{
				return null;
			}
			if (string.Compare(msalTokenResponse.Error, "authorization_pending", StringComparison.OrdinalIgnoreCase) == 0)
			{
				shouldLogAsError = false;
			}
			return MsalServiceExceptionFactory.FromHttpResponse(msalTokenResponse.Error, msalTokenResponse.ErrorDescription, response);
		}

		private Uri AddExtraQueryParams(Uri endPoint)
		{
			UriBuilder uriBuilder = new UriBuilder(endPoint);
			string queryParams = _queryParameters.ToQueryParameter();
			uriBuilder.AppendQueryParameters(queryParams);
			return uriBuilder.Uri;
		}

		private static void VerifyCorrelationIdHeaderInResponse(IDictionary<string, string> headers, RequestContext requestContext)
		{
			foreach (string key in headers.Keys)
			{
				string text = key.Trim();
				if (string.Compare(text, "client-request-id", StringComparison.OrdinalIgnoreCase) == 0)
				{
					string text2 = headers[text].Trim();
					if (string.Compare(text2, requestContext.CorrelationId.ToString(), StringComparison.OrdinalIgnoreCase) != 0)
					{
						requestContext.Logger.WarningPii(string.Format(CultureInfo.InvariantCulture, "Returned correlation id '{0}' does not match the sent correlation id '{1}'", text2, requestContext.CorrelationId), "Returned correlation id does not match the sent correlation id");
					}
					break;
				}
			}
		}
	}
	internal class OAuth2ResponseBaseClaim
	{
		public const string Claims = "claims";

		public const string Error = "error";

		public const string SubError = "suberror";

		public const string ErrorDescription = "error_description";

		public const string ErrorCodes = "error_codes";

		public const string CorrelationId = "correlation_id";
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class OAuth2ResponseBase
	{
		[JsonProperty("error")]
		public string Error { get; set; }

		[JsonProperty("suberror")]
		public string SubError { get; set; }

		[JsonProperty("error_description")]
		public string ErrorDescription { get; set; }

		[JsonProperty("error_codes")]
		public string[] ErrorCodes { get; set; }

		[JsonProperty("correlation_id")]
		public string CorrelationId { get; set; }

		[JsonProperty("claims")]
		public string Claims { get; set; }
	}
	internal static class OAuth2Parameter
	{
		public const string ResponseType = "response_type";

		public const string GrantType = "grant_type";

		public const string ClientId = "client_id";

		public const string ClientSecret = "client_secret";

		public const string ClientAssertion = "client_assertion";

		public const string ClientAssertionType = "client_assertion_type";

		public const string RefreshToken = "refresh_token";

		public const string RedirectUri = "redirect_uri";

		public const string Resource = "resource";

		public const string Code = "code";

		public const string DeviceCode = "device_code";

		public const string Scope = "scope";

		public const string Assertion = "assertion";

		public const string RequestedTokenUse = "requested_token_use";

		public const string Username = "username";

		public const string Password = "password";

		public const string LoginHint = "login_hint";

		public const string CorrelationId = "client-request-id";

		public const string State = "state";

		public const string CodeChallengeMethod = "code_challenge_method";

		public const string CodeChallenge = "code_challenge";

		public const string PkceCodeVerifier = "code_verifier";

		public const string LoginReq = "login_req";

		public const string DomainReq = "domain_req";

		public const string Prompt = "prompt";

		public const string ClientInfo = "client_info";

		public const string Claims = "claims";

		public const string TokenType = "token_type";

		public const string RequestConfirmation = "req_cnf";

		public const string SpaCode = "return_spa_code";
	}
	internal static class OAuth2GrantType
	{
		public const string AuthorizationCode = "authorization_code";

		public const string RefreshToken = "refresh_token";

		public const string ClientCredentials = "client_credentials";

		public const string Saml11Bearer = "urn:ietf:params:oauth:grant-type:saml1_1-bearer";

		public const string Saml20Bearer = "urn:ietf:params:oauth:grant-type:saml2-bearer";

		public const string JwtBearer = "urn:ietf:params:oauth:grant-type:jwt-bearer";

		public const string Password = "password";

		public const string DeviceCode = "device_code";
	}
	internal static class OAuth2ResponseType
	{
		public const string Code = "code";
	}
	internal static class OAuth2AssertionType
	{
		public const string JwtBearer = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer";
	}
	internal static class OAuth2RequestedTokenUse
	{
		public const string OnBehalfOf = "on_behalf_of";
	}
	internal static class OAuth2Header
	{
		public const string CorrelationId = "client-request-id";

		public const string RequestCorrelationIdInResponse = "return-client-request-id";

		public const string AppName = "x-app-name";

		public const string AppVer = "x-app-ver";
	}
	internal static class OAuth2Error
	{
		public const string LoginRequired = "login_required";

		public const string AuthorizationPending = "authorization_pending";
	}
	internal static class OAuth2Value
	{
		public const string CodeChallengeMethodValue = "S256";

		public const string ScopeOpenId = "openid";

		public const string ScopeOfflineAccess = "offline_access";

		public const string ScopeProfile = "profile";

		public static readonly HashSet<string> ReservedScopes = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { "openid", "profile", "offline_access" };
	}
	internal class PromptValue
	{
		public const string Login = "login";

		public const string RefreshSession = "refresh_session";

		public const string AttemptNone = "attempt_none";
	}
	internal class TokenClient
	{
		private readonly AuthenticationRequestParameters _requestParams;

		private readonly IServiceBundle _serviceBundle;

		private readonly OAuth2Client _oAuth2Client;

		private volatile bool _requestInProgress;

		public TokenClient(AuthenticationRequestParameters requestParams)
		{
			_requestParams = requestParams ?? throw new ArgumentNullException("requestParams");
			_serviceBundle = _requestParams.RequestContext.ServiceBundle;
			_oAuth2Client = new OAuth2Client(_serviceBundle.ApplicationLogger, _serviceBundle.HttpManager);
		}

		public async Task<MsalTokenResponse> SendTokenRequestAsync(IDictionary<string, string> additionalBodyParameters, string scopeOverride = null, string tokenEndpointOverride = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using (_requestParams.RequestContext.Logger.LogMethodDuration(LogLevel.Verbose, "SendTokenRequestAsync", "/_/src/client/Microsoft.Identity.Client/OAuth2/TokenClient.cs"))
			{
				cancellationToken.ThrowIfCancellationRequested();
				string tokenEndpoint = tokenEndpointOverride;
				if (tokenEndpoint == null)
				{
					tokenEndpoint = await _requestParams.Authority.GetTokenEndpointAsync(_requestParams.RequestContext).ConfigureAwait(continueOnCapturedContext: false);
				}
				_requestParams.RequestContext.ApiEvent.TokenEndpoint = tokenEndpoint;
				string scopes = ((!string.IsNullOrEmpty(scopeOverride)) ? scopeOverride : GetDefaultScopes(_requestParams.Scope));
				await AddBodyParamsAndHeadersAsync(additionalBodyParameters, scopes, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				AddThrottlingHeader();
				_serviceBundle.ThrottlingManager.TryThrottle(_requestParams, _oAuth2Client.GetBodyParameters());
				MsalTokenResponse msalTokenResponse;
				try
				{
					msalTokenResponse = await SendHttpAndClearTelemetryAsync(tokenEndpoint, _requestParams.RequestContext.Logger).ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (MsalServiceException ex)
				{
					_serviceBundle.ThrottlingManager.RecordException(_requestParams, _oAuth2Client.GetBodyParameters(), ex);
					throw;
				}
				if (string.IsNullOrEmpty(msalTokenResponse.Scope))
				{
					msalTokenResponse.Scope = _requestParams.Scope.AsSingleString();
					_requestParams.RequestContext.Logger.Info("ScopeSet was missing from the token response, so using developer provided scopes in the result. ");
				}
				if (string.IsNullOrEmpty(msalTokenResponse.TokenType))
				{
					throw new MsalClientException("token_type_missing", "The response from the token endpoint does not contain the token_type parameter. This happens if the identity provider (AAD, B2C, ADFS, etc.) did not include the access token type in the token response. Verify the configuration of the identity provider. ");
				}
				if (!string.Equals(msalTokenResponse.TokenType, _requestParams.AuthenticationScheme.AccessTokenType, StringComparison.OrdinalIgnoreCase))
				{
					throw new MsalClientException("token_type_mismatch", MsalErrorMessage.TokenTypeMismatch(_requestParams.AuthenticationScheme.AccessTokenType, msalTokenResponse.TokenType));
				}
				return msalTokenResponse;
			}
		}

		private void AddThrottlingHeader()
		{
			_oAuth2Client.AddHeader("x-ms-lib-capability", "retry-after, h429");
		}

		private async Task AddBodyParamsAndHeadersAsync(IDictionary<string, string> additionalBodyParameters, string scopes, CancellationToken cancellationToken)
		{
			_oAuth2Client.AddBodyParameter("client_id", _requestParams.AppConfig.ClientId);
			if (_serviceBundle.Config.ClientCredential != null)
			{
				_requestParams.RequestContext.Logger.Verbose(() => "[TokenClient] Before adding the client assertion / secret");
				string tokenEndpoint = await _requestParams.Authority.GetTokenEndpointAsync(_requestParams.RequestContext).ConfigureAwait(continueOnCapturedContext: false);
				bool isSha2CredentialSupported = _requestParams.AuthorityManager.Authority.AuthorityInfo.IsSha2CredentialSupported;
				await _serviceBundle.Config.ClientCredential.AddConfidentialClientParametersAsync(_oAuth2Client, _requestParams.RequestContext.Logger, _serviceBundle.PlatformProxy.CryptographyManager, _requestParams.AppConfig.ClientId, tokenEndpoint, _requestParams.SendX5C, isSha2CredentialSupported, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				_requestParams.RequestContext.Logger.Verbose(() => "[TokenClient] After adding the client assertion / secret");
			}
			_oAuth2Client.AddBodyParameter("scope", scopes);
			AddClaims();
			foreach (KeyValuePair<string, string> additionalBodyParameter in additionalBodyParameters)
			{
				_oAuth2Client.AddBodyParameter(additionalBodyParameter.Key, additionalBodyParameter.Value);
			}
			foreach (KeyValuePair<string, string> tokenRequestParam in _requestParams.AuthenticationScheme.GetTokenRequestParams())
			{
				_oAuth2Client.AddBodyParameter(tokenRequestParam.Key, tokenRequestParam.Value);
			}
			_oAuth2Client.AddHeader("x-client-current-telemetry", _serviceBundle.HttpTelemetryManager.GetCurrentRequestHeader(_requestParams.RequestContext.ApiEvent));
			if (!_requestInProgress)
			{
				_requestInProgress = true;
				_oAuth2Client.AddHeader("x-client-last-telemetry", _serviceBundle.HttpTelemetryManager.GetLastRequestHeader());
			}
			if (DeviceAuthHelper.CanOSPerformPKeyAuth())
			{
				_oAuth2Client.AddHeader("x-ms-PKeyAuth", "1.0");
			}
			AddExtraHttpHeaders();
		}

		private void AddClaims()
		{
			string kerberosTicketClaim = KerberosSupplementalTicketManager.GetKerberosTicketClaim(_requestParams.RequestContext.ServiceBundle.Config.KerberosServicePrincipalName, _requestParams.RequestContext.ServiceBundle.Config.TicketContainer);
			string resolvedClaims;
			if (string.IsNullOrEmpty(kerberosTicketClaim))
			{
				resolvedClaims = _requestParams.ClaimsAndClientCapabilities;
			}
			else if (!string.IsNullOrEmpty(_requestParams.ClaimsAndClientCapabilities))
			{
				JObject capabilitiesJson = JsonHelper.ParseIntoJsonObject(_requestParams.ClaimsAndClientCapabilities);
				JObject jsonObject = ClaimsHelper.MergeClaimsIntoCapabilityJson(kerberosTicketClaim, capabilitiesJson);
				resolvedClaims = JsonHelper.JsonObjectToString(jsonObject);
				_requestParams.RequestContext.Logger.Verbose(() => "Adding kerberos claim + Claims/ClientCapabilities to request: " + resolvedClaims);
			}
			else
			{
				resolvedClaims = kerberosTicketClaim;
				_requestParams.RequestContext.Logger.Verbose(() => "Adding kerberos claim to request: " + resolvedClaims);
			}
			_oAuth2Client.AddBodyParameter("claims", resolvedClaims);
		}

		private void AddExtraHttpHeaders()
		{
			if (_requestParams.ExtraHttpHeaders == null)
			{
				return;
			}
			foreach (KeyValuePair<string, string> extraHttpHeader in _requestParams.ExtraHttpHeaders)
			{
				if (!string.IsNullOrEmpty(extraHttpHeader.Key) && !string.IsNullOrEmpty(extraHttpHeader.Value))
				{
					_oAuth2Client.AddHeader(extraHttpHeader.Key, extraHttpHeader.Value);
				}
			}
		}

		public void AddHeaderToClient(string name, string value)
		{
			_oAuth2Client.AddHeader(name, value);
		}

		private async Task<MsalTokenResponse> SendHttpAndClearTelemetryAsync(string tokenEndpoint, ILoggerAdapter logger)
		{
			UriBuilder uriBuilder = new UriBuilder(tokenEndpoint);
			uriBuilder.AppendQueryParameters(_requestParams.ExtraQueryParameters);
			Uri tokenEndpointWithQueryParams = uriBuilder.Uri;
			MsalTokenResponse result = default(MsalTokenResponse);
			try
			{
				logger.Verbose(() => "[Token Client] Fetching MsalTokenResponse .... ");
				MsalTokenResponse obj = await _oAuth2Client.GetTokenAsync(tokenEndpointWithQueryParams, _requestParams.RequestContext, addCommonHeaders: true, _requestParams.OnBeforeTokenRequestHandler).ConfigureAwait(continueOnCapturedContext: false);
				_serviceBundle.HttpTelemetryManager.ResetPreviousUnsentData();
				result = obj;
				return result;
			}
			catch (MsalServiceException ex)
			{
				MsalServiceException ex2 = ex;
				if (!ex2.IsRetryable)
				{
					_serviceBundle.HttpTelemetryManager.ResetPreviousUnsentData();
				}
				if (ex2.StatusCode == 401 && _serviceBundle.DeviceAuthManager.TryCreateDeviceAuthChallengeResponse(ex2.Headers, new Uri(tokenEndpoint), out var responseHeader))
				{
					_oAuth2Client.AddHeader("Authorization", responseHeader);
					result = await _oAuth2Client.GetTokenAsync(tokenEndpointWithQueryParams, _requestParams.RequestContext, addCommonHeaders: false, _requestParams.OnBeforeTokenRequestHandler).ConfigureAwait(continueOnCapturedContext: false);
					return result;
				}
				ExceptionDispatchInfo.Capture((ex as Exception) ?? throw ex).Throw();
			}
			finally
			{
				_requestInProgress = false;
			}
			return result;
		}

		private static string GetDefaultScopes(ISet<string> inputScope)
		{
			SortedSet<string> sortedSet = new SortedSet<string>(inputScope, StringComparer.OrdinalIgnoreCase);
			sortedSet.UnionWith(OAuth2Value.ReservedScopes);
			return sortedSet.AsSingleString();
		}
	}
}
namespace Microsoft.Identity.Client.OAuth2.Throttling
{
	internal class HttpStatusProvider : IThrottlingProvider
	{
		internal static readonly TimeSpan s_throttleDuration = TimeSpan.FromSeconds(60.0);

		internal ThrottlingCache ThrottlingCache { get; }

		public HttpStatusProvider()
		{
			ThrottlingCache = new ThrottlingCache();
		}

		public void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary<string, string> bodyParams, MsalServiceException ex)
		{
			ILoggerAdapter logger = requestParams.RequestContext.Logger;
			if (IsRequestSupported(requestParams) && (ex.StatusCode == 429 || (ex.StatusCode >= 500 && ex.StatusCode < 600)) && !RetryAfterProvider.TryGetRetryAfterValue(ex.Headers, out var _))
			{
				logger.Info(delegate
				{
					string text = $"[Throttling] HTTP status code {ex.StatusCode} encountered - ";
					TimeSpan timeSpan = s_throttleDuration;
					return text + $"throttling for {timeSpan.TotalSeconds} seconds. ";
				});
				string requestStrictThumbprint = ThrottleCommon.GetRequestStrictThumbprint(bodyParams, requestParams.AuthorityInfo.CanonicalAuthority.ToString(), requestParams.Account?.HomeAccountId?.Identifier);
				ThrottlingCacheEntry entry = new ThrottlingCacheEntry(ex, s_throttleDuration);
				ThrottlingCache.AddAndCleanup(requestStrictThumbprint, entry, logger);
			}
		}

		public void ResetCache()
		{
			ThrottlingCache.Clear();
		}

		public void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary<string, string> bodyParams)
		{
			if (!ThrottlingCache.IsEmpty() && IsRequestSupported(requestParams))
			{
				ILoggerAdapter logger = requestParams.RequestContext.Logger;
				ThrottleCommon.TryThrowServiceException(ThrottleCommon.GetRequestStrictThumbprint(bodyParams, requestParams.AuthorityInfo.CanonicalAuthority.ToString(), requestParams.Account?.HomeAccountId?.Identifier), ThrottlingCache, logger, "HttpStatusProvider");
			}
		}

		private static bool IsRequestSupported(AuthenticationRequestParameters requestParameters)
		{
			return !requestParameters.AppConfig.IsConfidentialClient;
		}
	}
	internal interface IThrottlingProvider
	{
		void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary<string, string> bodyParams);

		void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary<string, string> bodyParams, MsalServiceException ex);

		void ResetCache();
	}
	internal class RetryAfterProvider : IThrottlingProvider
	{
		internal static readonly TimeSpan MaxRetryAfter = TimeSpan.FromSeconds(3600.0);

		internal ThrottlingCache ThrottlingCache { get; }

		public RetryAfterProvider()
		{
			ThrottlingCache = new ThrottlingCache();
		}

		public void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary<string, string> bodyParams, MsalServiceException ex)
		{
			if (TryGetRetryAfterValue(ex.Headers, out var retryAfterTimespan))
			{
				retryAfterTimespan = GetSafeValue(retryAfterTimespan);
				ILoggerAdapter logger = requestParams.RequestContext.Logger;
				logger.Info(() => "[Throttling] Retry-After header detected, " + $"value: {retryAfterTimespan.TotalSeconds} seconds");
				string requestStrictThumbprint = ThrottleCommon.GetRequestStrictThumbprint(bodyParams, requestParams.AuthorityInfo.CanonicalAuthority.ToString(), requestParams.Account?.HomeAccountId?.Identifier);
				ThrottlingCacheEntry entry = new ThrottlingCacheEntry(ex, retryAfterTimespan);
				ThrottlingCache.AddAndCleanup(requestStrictThumbprint, entry, logger);
			}
		}

		public void ResetCache()
		{
			ThrottlingCache.Clear();
		}

		public void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary<string, string> bodyParams)
		{
			if (!ThrottlingCache.IsEmpty())
			{
				ILoggerAdapter logger = requestParams.RequestContext.Logger;
				ThrottleCommon.TryThrowServiceException(ThrottleCommon.GetRequestStrictThumbprint(bodyParams, requestParams.AuthorityInfo.CanonicalAuthority.ToString(), requestParams.Account?.HomeAccountId?.Identifier), ThrottlingCache, logger, "RetryAfterProvider");
			}
		}

		public static bool TryGetRetryAfterValue(HttpResponseHeaders headers, out TimeSpan retryAfterTimespan)
		{
			retryAfterTimespan = TimeSpan.Zero;
			DateTimeOffset? dateTimeOffset = headers?.RetryAfter?.Date;
			if (dateTimeOffset.HasValue)
			{
				retryAfterTimespan = dateTimeOffset.Value - DateTimeOffset.Now;
				return true;
			}
			TimeSpan? timeSpan = headers?.RetryAfter?.Delta;
			if (timeSpan.HasValue)
			{
				retryAfterTimespan = timeSpan.Value;
				return true;
			}
			return false;
		}

		private static TimeSpan GetSafeValue(TimeSpan headerValue)
		{
			if (headerValue > MaxRetryAfter)
			{
				return MaxRetryAfter;
			}
			return headerValue;
		}
	}
	internal class SingletonThrottlingManager : IThrottlingProvider
	{
		private static readonly Lazy<SingletonThrottlingManager> lazyPrivateCtor = new Lazy<SingletonThrottlingManager>(() => new SingletonThrottlingManager());

		public IEnumerable<IThrottlingProvider> ThrottlingProviders { get; }

		private SingletonThrottlingManager()
		{
			ThrottlingProviders = new List<IThrottlingProvider>
			{
				new RetryAfterProvider(),
				new HttpStatusProvider(),
				new UiRequiredProvider()
			};
		}

		public static SingletonThrottlingManager GetInstance()
		{
			return lazyPrivateCtor.Value;
		}

		public void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary<string, string> bodyParams, MsalServiceException ex)
		{
			if (ex is MsalThrottledServiceException)
			{
				return;
			}
			foreach (IThrottlingProvider throttlingProvider in ThrottlingProviders)
			{
				throttlingProvider.RecordException(requestParams, bodyParams, ex);
			}
		}

		public void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary<string, string> bodyParams)
		{
			foreach (IThrottlingProvider throttlingProvider in ThrottlingProviders)
			{
				throttlingProvider.TryThrottle(requestParams, bodyParams);
			}
		}

		public void ResetCache()
		{
			foreach (IThrottlingProvider throttlingProvider in ThrottlingProviders)
			{
				throttlingProvider.ResetCache();
			}
		}
	}
	internal static class ThrottleCommon
	{
		public const string ThrottleRetryAfterHeaderName = "x-ms-lib-capability";

		public const string ThrottleRetryAfterHeaderValue = "retry-after, h429";

		internal const char KeyDelimiter = '.';

		public static string GetRequestStrictThumbprint(IReadOnlyDictionary<string, string> bodyParams, string authority, string homeAccountId)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (bodyParams.TryGetValue("client_id", out var value))
			{
				stringBuilder.Append(value);
				stringBuilder.Append('.');
			}
			stringBuilder.Append(authority);
			stringBuilder.Append('.');
			if (bodyParams.TryGetValue("scope", out var value2))
			{
				stringBuilder.Append(value2);
				stringBuilder.Append('.');
			}
			stringBuilder.Append(homeAccountId);
			stringBuilder.Append('.');
			return stringBuilder.ToString();
		}

		public static void TryThrowServiceException(string thumbprint, ThrottlingCache cache, ILoggerAdapter logger, string providerName)
		{
			if (cache.TryGetOrRemoveExpired(thumbprint, logger, out var ex))
			{
				logger.WarningPii("[Throttling] Exception thrown because of throttling rule " + providerName + " - thumbprint: " + thumbprint, "[Throttling] Exception thrown because of throttling rule " + providerName);
				throw new MsalThrottledServiceException(ex);
			}
		}
	}
	internal class ThrottlingCache
	{
		internal const int DefaultCleanupIntervalMs = 300000;

		private volatile bool _cleanupInProgress;

		private static readonly object _padlock = new object();

		private readonly TimeSpan s_cleanupCacheInterval;

		private DateTimeOffset _lastCleanupTime = DateTimeOffset.UtcNow;

		private readonly ConcurrentDictionary<string, ThrottlingCacheEntry> _cache = new ConcurrentDictionary<string, ThrottlingCacheEntry>();

		internal ConcurrentDictionary<string, ThrottlingCacheEntry> CacheForTest => _cache;

		public ThrottlingCache(int? customCleanupIntervalMs = null)
		{
			s_cleanupCacheInterval = (customCleanupIntervalMs.HasValue ? TimeSpan.FromMilliseconds(customCleanupIntervalMs.Value) : TimeSpan.FromMilliseconds(300000.0));
		}

		public void AddAndCleanup(string key, ThrottlingCacheEntry entry, ILoggerAdapter logger)
		{
			_cache.AddOrUpdate(key, entry, (string _, ThrottlingCacheEntry oldEntry) => (!(entry.CreationTime > oldEntry.CreationTime)) ? oldEntry : entry);
			CleanCache(logger);
		}

		public bool TryGetOrRemoveExpired(string key, ILoggerAdapter logger, out MsalServiceException ex)
		{
			ex = null;
			if (_cache.TryGetValue(key, out var entry))
			{
				logger.Info(() => $"[Throttling] Entry found. Creation: {entry.CreationTime} Expiration: {entry.ExpirationTime} ");
				if (entry.IsExpired)
				{
					logger.Info(() => "[Throttling] Removing entry because it is expired");
					_cache.TryRemove(key, out var _);
					return false;
				}
				logger.InfoPii(() => "[Throttling] Returning valid entry for key " + key, () => "[Throttling] Returning valid entry.");
				ex = entry.Exception;
				return true;
			}
			return false;
		}

		public void Clear()
		{
			_cache.Clear();
		}

		public bool IsEmpty()
		{
			return !_cache.Any();
		}

		private void CleanCache(ILoggerAdapter logger)
		{
			if (!(_lastCleanupTime + s_cleanupCacheInterval < DateTimeOffset.UtcNow) || _cleanupInProgress)
			{
				return;
			}
			logger.Verbose(() => "[Throttling] Acquiring lock to cleanup throttling state");
			lock (_padlock)
			{
				if (!_cleanupInProgress)
				{
					logger.Verbose(() => $"[Throttling] Cache size before cleaning up {_cache.Count}");
					_cleanupInProgress = true;
					CleanupCacheNoLocks();
					_lastCleanupTime = DateTimeOffset.UtcNow;
					_cleanupInProgress = false;
					logger.Verbose(() => $"[Throttling] Cache size after cleaning up {_cache.Count}");
				}
			}
		}

		private void CleanupCacheNoLocks()
		{
			List<string> list = new List<string>();
			foreach (KeyValuePair<string, ThrottlingCacheEntry> item in _cache)
			{
				if (item.Value.IsExpired)
				{
					list.Add(item.Key);
				}
			}
			foreach (string item2 in list)
			{
				_cache.TryRemove(item2, out var _);
			}
		}
	}
	internal class ThrottlingCacheEntry
	{
		public MsalServiceException Exception { get; }

		public DateTimeOffset CreationTime { get; }

		public DateTimeOffset ExpirationTime { get; }

		public bool IsExpired
		{
			get
			{
				if (!(ExpirationTime < DateTimeOffset.Now))
				{
					return CreationTime > DateTimeOffset.Now;
				}
				return true;
			}
		}

		public ThrottlingCacheEntry(MsalServiceException exception, TimeSpan lifetime)
		{
			Exception = exception ?? throw new ArgumentNullException("exception");
			CreationTime = DateTimeOffset.UtcNow;
			ExpirationTime = CreationTime.Add(lifetime);
		}

		public ThrottlingCacheEntry(MsalServiceException exception, DateTimeOffset creationTime, DateTimeOffset expirationTime)
		{
			Exception = exception ?? throw new ArgumentNullException("exception");
			CreationTime = creationTime;
			ExpirationTime = expirationTime;
		}
	}
	internal class UiRequiredProvider : IThrottlingProvider
	{
		internal static readonly TimeSpan s_uiRequiredExpiration = TimeSpan.FromSeconds(120.0);

		internal ThrottlingCache ThrottlingCache { get; }

		public UiRequiredProvider()
		{
			ThrottlingCache = new ThrottlingCache();
		}

		public void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary<string, string> bodyParams, MsalServiceException ex)
		{
			if (ex is MsalUiRequiredException && IsRequestSupported(requestParams))
			{
				ILoggerAdapter logger = requestParams.RequestContext.Logger;
				logger.Info(delegate
				{
					TimeSpan timeSpan = s_uiRequiredExpiration;
					return "[Throttling] MsalUiRequiredException encountered - " + $"throttling for {timeSpan.TotalSeconds} seconds. ";
				});
				string requestStrictThumbprint = GetRequestStrictThumbprint(bodyParams, requestParams.AuthorityInfo.CanonicalAuthority.ToString(), requestParams.RequestContext.ServiceBundle.PlatformProxy.CryptographyManager);
				ThrottlingCacheEntry entry = new ThrottlingCacheEntry(ex, s_uiRequiredExpiration);
				ThrottlingCache.AddAndCleanup(requestStrictThumbprint, entry, logger);
			}
		}

		public void ResetCache()
		{
			ThrottlingCache.Clear();
		}

		public void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary<string, string> bodyParams)
		{
			if (!ThrottlingCache.IsEmpty() && IsRequestSupported(requestParams))
			{
				ILoggerAdapter logger = requestParams.RequestContext.Logger;
				string requestStrictThumbprint = GetRequestStrictThumbprint(bodyParams, requestParams.AuthorityInfo.CanonicalAuthority.ToString(), requestParams.RequestContext.ServiceBundle.PlatformProxy.CryptographyManager);
				TryThrowException(requestStrictThumbprint, logger);
			}
		}

		private void TryThrowException(string thumbprint, ILoggerAdapter logger)
		{
			if (ThrottlingCache.TryGetOrRemoveExpired(thumbprint, logger, out var ex) && ex is MsalUiRequiredException originalException)
			{
				logger.WarningPii("[Throttling] Exception thrown because of throttling rule UiRequired - thumbprint: " + thumbprint, "[Throttling] Exception thrown because of throttling rule UiRequired ");
				throw new MsalThrottledUiRequiredException(originalException);
			}
		}

		private static bool IsRequestSupported(AuthenticationRequestParameters requestParams)
		{
			if (!requestParams.AppConfig.IsConfidentialClient)
			{
				return requestParams.ApiId == ApiEvent.ApiIds.AcquireTokenSilent;
			}
			return false;
		}

		private static string GetRequestStrictThumbprint(IReadOnlyDictionary<string, string> bodyParams, string authority, ICryptographyManager crypto)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (bodyParams.TryGetValue("client_id", out var value))
			{
				stringBuilder.Append(value);
				stringBuilder.Append('.');
			}
			stringBuilder.Append(authority);
			stringBuilder.Append('.');
			if (bodyParams.TryGetValue("scope", out var value2))
			{
				stringBuilder.Append(value2);
				stringBuilder.Append('.');
			}
			if (bodyParams.TryGetValue("refresh_token", out var value3) && !string.IsNullOrEmpty(value3))
			{
				stringBuilder.Append(crypto.CreateSha256Hash(value3));
				stringBuilder.Append('.');
			}
			if (bodyParams.TryGetValue("microsoft_enrollment_id", out var value4))
			{
				stringBuilder.Append(crypto.CreateSha256Hash(value4));
				stringBuilder.Append('.');
			}
			return stringBuilder.ToString();
		}
	}
}
namespace Microsoft.Identity.Client.ManagedIdentity
{
	internal abstract class AbstractManagedIdentity
	{
		protected readonly RequestContext _requestContext;

		internal const string TimeoutError = "[Managed Identity] Authentication unavailable. The request to the managed identity endpoint timed out.";

		internal readonly ManagedIdentitySource _sourceType;

		private const string ManagedIdentityPrefix = "[Managed Identity] ";

		protected AbstractManagedIdentity(RequestContext requestContext, ManagedIdentitySource sourceType)
		{
			_requestContext = requestContext;
			_sourceType = sourceType;
		}

		public virtual async Task<ManagedIdentityResponse> AuthenticateAsync(AcquireTokenForManagedIdentityParameters parameters, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				_requestContext.Logger.Error("[Managed Identity] Authentication unavailable. The request to the managed identity endpoint timed out.");
				cancellationToken.ThrowIfCancellationRequested();
			}
			string resource = parameters.Resource;
			ManagedIdentityRequest managedIdentityRequest = CreateRequest(resource);
			try
			{
				HttpResponse httpResponse = ((!(managedIdentityRequest.Method == HttpMethod.Get)) ? (await _requestContext.ServiceBundle.HttpManager.SendPostForceResponseAsync(managedIdentityRequest.ComputeUri(), managedIdentityRequest.Headers, managedIdentityRequest.BodyParameters, _requestContext.Logger, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)) : (await _requestContext.ServiceBundle.HttpManager.SendGetForceResponseAsync(managedIdentityRequest.ComputeUri(), managedIdentityRequest.Headers, _requestContext.Logger, retry: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
				HttpResponse response = httpResponse;
				return await HandleResponseAsync(parameters, response, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (Exception ex)
			{
				HandleException(ex);
				throw;
			}
		}

		protected virtual Task<ManagedIdentityResponse> HandleResponseAsync(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken)
		{
			if (response.StatusCode == HttpStatusCode.OK)
			{
				_requestContext.Logger.Info("[Managed Identity] Successful response received.");
				return Task.FromResult(GetSuccessfulResponse(response));
			}
			string messageFromErrorResponse = GetMessageFromErrorResponse(response);
			_requestContext.Logger.Error($"[Managed Identity] request failed, HttpStatusCode: {response.StatusCode} Error message: {messageFromErrorResponse}");
			throw MsalServiceExceptionFactory.CreateManagedIdentityException("managed_identity_request_failed", messageFromErrorResponse, null, _sourceType, (int)response.StatusCode);
		}

		protected abstract ManagedIdentityRequest CreateRequest(string resource);

		protected ManagedIdentityResponse GetSuccessfulResponse(HttpResponse response)
		{
			ManagedIdentityResponse managedIdentityResponse = JsonHelper.DeserializeFromJson<ManagedIdentityResponse>(response.Body);
			if (managedIdentityResponse == null || managedIdentityResponse.AccessToken.IsNullOrEmpty() || managedIdentityResponse.ExpiresOn.IsNullOrEmpty())
			{
				_requestContext.Logger.Error("[Managed Identity] Response is either null or insufficient for authentication.");
				throw MsalServiceExceptionFactory.CreateManagedIdentityException("managed_identity_request_failed", "[Managed Identity] Invalid response, the authentication response received did not contain the expected fields.", null, _sourceType, null);
			}
			return managedIdentityResponse;
		}

		internal string GetMessageFromErrorResponse(HttpResponse response)
		{
			if (string.IsNullOrEmpty(response?.Body))
			{
				return "[Managed Identity] Authentication unavailable. No response received from the managed identity endpoint.";
			}
			try
			{
				ManagedIdentityErrorResponse managedIdentityErrorResponse = JsonHelper.DeserializeFromJson<ManagedIdentityErrorResponse>(response?.Body);
				return ExtractErrorMessageFromManagedIdentityErrorResponse(managedIdentityErrorResponse);
			}
			catch
			{
				return TryGetMessageFromNestedErrorResponse(response.Body);
			}
		}

		private string ExtractErrorMessageFromManagedIdentityErrorResponse(ManagedIdentityErrorResponse managedIdentityErrorResponse)
		{
			StringBuilder stringBuilder = new StringBuilder("[Managed Identity] ");
			if (!string.IsNullOrEmpty(managedIdentityErrorResponse.Error))
			{
				stringBuilder.Append("Error Code: " + managedIdentityErrorResponse.Error + " ");
			}
			if (!string.IsNullOrEmpty(managedIdentityErrorResponse.Message))
			{
				stringBuilder.Append("Error Message: " + managedIdentityErrorResponse.Message + " ");
			}
			if (!string.IsNullOrEmpty(managedIdentityErrorResponse.ErrorDescription))
			{
				stringBuilder.Append("Error Description: " + managedIdentityErrorResponse.ErrorDescription + " ");
			}
			if (!string.IsNullOrEmpty(managedIdentityErrorResponse.CorrelationId))
			{
				stringBuilder.Append("Managed Identity Correlation ID: " + managedIdentityErrorResponse.CorrelationId + " Use this Correlation ID for further investigation.");
			}
			if (stringBuilder.Length == "[Managed Identity] ".Length)
			{
				return "[Managed Identity] The error response was either empty or could not be parsed..";
			}
			return stringBuilder.ToString();
		}

		private string TryGetMessageFromNestedErrorResponse(string response)
		{
			try
			{
				JsonHelper.TryGetValue(JsonHelper.ParseIntoJsonObject(response), "error", out var value);
				StringBuilder stringBuilder = new StringBuilder("[Managed Identity] ");
				if (JsonHelper.TryGetValue(JsonHelper.ToJsonObject(value), "code", out var value2))
				{
					stringBuilder.Append($"Error Code: {value2} ");
				}
				if (JsonHelper.TryGetValue(JsonHelper.ToJsonObject(value), "message", out var value3))
				{
					stringBuilder.Append($"Error Message: {value3}");
				}
				if (value3 != null || value2 != null)
				{
					return stringBuilder.ToString();
				}
			}
			catch
			{
			}
			_requestContext.Logger.Error("[Managed Identity] The error response was either empty or could not be parsed.. Error response received from the server: " + response + ".");
			return "[Managed Identity] The error response was either empty or could not be parsed.. Error response received from the server: " + response + ".";
		}

		private void HandleException(Exception ex, ManagedIdentitySource managedIdentitySource = ManagedIdentitySource.None, string additionalInfo = null)
		{
			ManagedIdentitySource source = ((managedIdentitySource != ManagedIdentitySource.None) ? managedIdentitySource : _sourceType);
			if (ex is HttpRequestException ex2)
			{
				CreateAndThrowException("managed_identity_unreachable_network", ex2.Message, ex2, source);
			}
			else if (ex is TaskCanceledException)
			{
				_requestContext.Logger.Error("[Managed Identity] Authentication unavailable. The request to the managed identity endpoint timed out.");
			}
			else if (ex is FormatException ex3)
			{
				string text = additionalInfo ?? ex3.Message;
				_requestContext.Logger.Error("[Managed Identity] Format Exception: " + text);
				CreateAndThrowException("invalid_managed_identity_endpoint", text, ex3, source);
			}
			else if (!(ex is MsalServiceException))
			{
				_requestContext.Logger.Error("[Managed Identity] Exception: " + ex.Message);
				CreateAndThrowException("managed_identity_request_failed", ex.Message, ex, source);
			}
		}

		private static void CreateAndThrowException(string errorCode, string errorMessage, Exception innerException, ManagedIdentitySource source)
		{
			throw MsalServiceExceptionFactory.CreateManagedIdentityException(errorCode, errorMessage, innerException, source, null);
		}
	}
	internal class AppServiceManagedIdentitySource : AbstractManagedIdentity
	{
		private const string AppServiceMsiApiVersion = "2019-08-01";

		private const string SecretHeaderName = "X-IDENTITY-HEADER";

		private readonly Uri _endpoint;

		private readonly string _secret;

		public static AbstractManagedIdentity Create(RequestContext requestContext)
		{
			requestContext.Logger.Info(() => "[Managed Identity] App service managed identity is available.");
			if (!TryValidateEnvVars(EnvironmentVariables.IdentityEndpoint, requestContext.Logger, out var endpointUri))
			{
				return null;
			}
			return new AppServiceManagedIdentitySource(requestContext, endpointUri, EnvironmentVariables.IdentityHeader);
		}

		private AppServiceManagedIdentitySource(RequestContext requestContext, Uri endpoint, string secret)
			: base(requestContext, ManagedIdentitySource.AppService)
		{
			_endpoint = endpoint;
			_secret = secret;
		}

		private static bool TryValidateEnvVars(string msiEndpoint, ILoggerAdapter logger, out Uri endpointUri)
		{
			endpointUri = null;
			try
			{
				endpointUri = new Uri(msiEndpoint);
			}
			catch (FormatException innerException)
			{
				string errorMessage = string.Format(CultureInfo.InvariantCulture, "[Managed Identity] The environment variable {0} contains an invalid Uri {1} in {2} managed identity source.", "IDENTITY_ENDPOINT", msiEndpoint, "App Service");
				throw MsalServiceExceptionFactory.CreateManagedIdentityException("invalid_managed_identity_endpoint", errorMessage, innerException, ManagedIdentitySource.AppService, null);
			}
			logger.Info($"[Managed Identity] Environment variables validation passed for app service managed identity. Endpoint URI: {endpointUri}. Creating App Service managed identity.");
			return true;
		}

		protected override ManagedIdentityRequest CreateRequest(string resource)
		{
			ManagedIdentityRequest managedIdentityRequest = new ManagedIdentityRequest(HttpMethod.Get, _endpoint);
			managedIdentityRequest.Headers.Add("X-IDENTITY-HEADER", _secret);
			managedIdentityRequest.QueryParameters["api-version"] = "2019-08-01";
			managedIdentityRequest.QueryParameters["resource"] = resource;
			switch (_requestContext.ServiceBundle.Config.ManagedIdentityId.IdType)
			{
			case ManagedIdentityIdType.ClientId:
				_requestContext.Logger.Info("[Managed Identity] Adding user assigned client id to the request.");
				managedIdentityRequest.QueryParameters["client_id"] = _requestContext.ServiceBundle.Config.ManagedIdentityId.UserAssignedId;
				break;
			case ManagedIdentityIdType.ResourceId:
				_requestContext.Logger.Info("[Managed Identity] Adding user assigned resource id to the request.");
				managedIdentityRequest.QueryParameters["mi_res_id"] = _requestContext.ServiceBundle.Config.ManagedIdentityId.UserAssignedId;
				break;
			case ManagedIdentityIdType.ObjectId:
				_requestContext.Logger.Info("[Managed Identity] Adding user assigned object id to the request.");
				managedIdentityRequest.QueryParameters["object_id"] = _requestContext.ServiceBundle.Config.ManagedIdentityId.UserAssignedId;
				break;
			}
			return managedIdentityRequest;
		}
	}
	internal class AzureArcManagedIdentitySource : AbstractManagedIdentity
	{
		private const string ArcApiVersion = "2019-11-01";

		private const string AzureArc = "Azure Arc";

		private readonly Uri _endpoint;

		public static AbstractManagedIdentity Create(RequestContext requestContext)
		{
			string identityEndpoint = EnvironmentVariables.IdentityEndpoint;
			requestContext.Logger.Info(() => "[Managed Identity] Azure Arc managed identity is available.");
			if (!Uri.TryCreate(identityEndpoint, UriKind.Absolute, out var endpointUri))
			{
				string errorMessage = string.Format(CultureInfo.InvariantCulture, "[Managed Identity] The environment variable {0} contains an invalid Uri {1} in {2} managed identity source.", "IDENTITY_ENDPOINT", identityEndpoint, "Azure Arc");
				throw MsalServiceExceptionFactory.CreateManagedIdentityException("invalid_managed_identity_endpoint", errorMessage, null, ManagedIdentitySource.AzureArc, null);
			}
			requestContext.Logger.Verbose(() => "[Managed Identity] Creating Azure Arc managed identity. Endpoint URI: " + endpointUri);
			return new AzureArcManagedIdentitySource(endpointUri, requestContext);
		}

		private AzureArcManagedIdentitySource(Uri endpoint, RequestContext requestContext)
			: base(requestContext, ManagedIdentitySource.AzureArc)
		{
			_endpoint = endpoint;
			if (requestContext.ServiceBundle.Config.ManagedIdentityId.IsUserAssigned)
			{
				string errorMessage = string.Format(CultureInfo.InvariantCulture, "[Managed Identity] User assigned identity is not supported by the {0} Managed Identity. To authenticate with the system assigned identity omit the client id in ManagedIdentityApplicationBuilder.Create().", "Azure Arc");
				throw MsalServiceExceptionFactory.CreateManagedIdentityException("user_assigned_managed_identity_not_supported", errorMessage, null, ManagedIdentitySource.AzureArc, null);
			}
		}

		protected override ManagedIdentityRequest CreateRequest(string resource)
		{
			ManagedIdentityRequest managedIdentityRequest = new ManagedIdentityRequest(HttpMethod.Get, _endpoint);
			managedIdentityRequest.Headers.Add("Metadata", "true");
			managedIdentityRequest.QueryParameters["api-version"] = "2019-11-01";
			managedIdentityRequest.QueryParameters["resource"] = resource;
			return managedIdentityRequest;
		}

		protected override async Task<ManagedIdentityResponse> HandleResponseAsync(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken)
		{
			_requestContext.Logger.Verbose(() => $"[Managed Identity] Response received. Status code: {response.StatusCode}");
			if (response.StatusCode == HttpStatusCode.Unauthorized)
			{
				if (!response.HeadersAsDictionary.TryGetValue("WWW-Authenticate", out var value))
				{
					_requestContext.Logger.Error("[Managed Identity] WWW-Authenticate header is expected but not found.");
					throw MsalServiceExceptionFactory.CreateManagedIdentityException("managed_identity_request_failed", "[Managed Identity] Did not receive expected WWW-Authenticate header in the response from Azure Arc Managed Identity Endpoint.", null, ManagedIdentitySource.AzureArc, null);
				}
				string[] array = value.Split(new char[1] { '=' }, StringSplitOptions.RemoveEmptyEntries);
				ValidateSplitChallenge(array);
				string value2 = "Basic " + File.ReadAllText(array[1]);
				ManagedIdentityRequest managedIdentityRequest = CreateRequest(parameters.Resource);
				_requestContext.Logger.Verbose(() => "[Managed Identity] Adding authorization header to the request.");
				managedIdentityRequest.Headers.Add("Authorization", value2);
				response = await _requestContext.ServiceBundle.HttpManager.SendGetAsync(managedIdentityRequest.ComputeUri(), managedIdentityRequest.Headers, _requestContext.Logger, retry: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				return await base.HandleResponseAsync(parameters, response, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return await base.HandleResponseAsync(parameters, response, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private void ValidateSplitChallenge(string[] splitChallenge)
		{
			if (splitChallenge.Length != 2)
			{
				throw CreateManagedIdentityException("managed_identity_request_failed", "[Managed Identity] The WWW-Authenticate header in the response from Azure Arc Managed Identity Endpoint did not match the expected format.");
			}
			_requestContext.Logger.Verbose(() => "[Managed Identity] Challenge is valid. FilePath: " + splitChallenge[1]);
			if (!IsValidPath(splitChallenge[1]))
			{
				throw CreateManagedIdentityException("managed_identity_request_failed", "[Managed Identity] The file on the file path in the WWW-Authenticate header is not secure.");
			}
			_requestContext.Logger.Verbose(() => "[Managed Identity] File path is valid. Path: " + splitChallenge[1]);
			long length = new FileInfo(splitChallenge[1]).Length;
			if (!File.Exists(splitChallenge[1]) || length > 4096)
			{
				_requestContext.Logger.Error($"[Managed Identity] File does not exist or is greater than 4096 bytes. File exists: {File.Exists(splitChallenge[1])}. Length of file: {length}");
				throw CreateManagedIdentityException("managed_identity_request_failed", "[Managed Identity] The file on the file path in the WWW-Authenticate header is not secure.");
			}
			_requestContext.Logger.Verbose(() => "[Managed Identity] File exists and is less than 4096 bytes.");
		}

		private MsalException CreateManagedIdentityException(string errorCode, string errorMessage)
		{
			return MsalServiceExceptionFactory.CreateManagedIdentityException(errorCode, errorMessage, null, ManagedIdentitySource.AzureArc, null);
		}

		private bool IsValidPath(string path)
		{
			string value;
			if (DesktopOsHelper.IsWindows())
			{
				value = Environment.ExpandEnvironmentVariables("%ProgramData%\\AzureConnectedMachineAgent\\Tokens\\") + Path.GetFileNameWithoutExtension(path) + ".key";
			}
			else
			{
				if (!DesktopOsHelper.IsLinux())
				{
					throw CreateManagedIdentityException("managed_identity_request_failed", "[Managed Identity] The platform is not supported by Azure Arc. Azure Arc only supports Windows and Linux.");
				}
				value = "/var/opt/azcmagent/tokens/" + Path.GetFileNameWithoutExtension(path) + ".key";
			}
			return path.Equals(value);
		}
	}
	internal class CloudShellManagedIdentitySource : AbstractManagedIdentity
	{
		private readonly Uri _endpoint;

		private const string CloudShell = "Cloud Shell";

		public static AbstractManagedIdentity Create(RequestContext requestContext)
		{
			string msiEndpoint = EnvironmentVariables.MsiEndpoint;
			requestContext.Logger.Info(() => "[Managed Identity] Cloud shell managed identity is available.");
			Uri endpoint;
			try
			{
				endpoint = new Uri(msiEndpoint);
			}
			catch (FormatException innerException)
			{
				requestContext.Logger.Error("[Managed Identity] Invalid endpoint found for the environment variable MSI_ENDPOINT: " + msiEndpoint);
				string errorMessage = string.Format(CultureInfo.InvariantCulture, "[Managed Identity] The environment variable {0} contains an invalid Uri {1} in {2} managed identity source.", "MSI_ENDPOINT", msiEndpoint, "Cloud Shell");
				throw MsalServiceExceptionFactory.CreateManagedIdentityException("invalid_managed_identity_endpoint", errorMessage, innerException, ManagedIdentitySource.CloudShell, null);
			}
			requestContext.Logger.Verbose(() => "[Managed Identity] Creating cloud shell managed identity. Endpoint URI: " + msiEndpoint);
			return new CloudShellManagedIdentitySource(endpoint, requestContext);
		}

		private CloudShellManagedIdentitySource(Uri endpoint, RequestContext requestContext)
			: base(requestContext, ManagedIdentitySource.CloudShell)
		{
			_endpoint = endpoint;
			if (requestContext.ServiceBundle.Config.ManagedIdentityId.IsUserAssigned)
			{
				string errorMessage = string.Format(CultureInfo.InvariantCulture, "[Managed Identity] User assigned identity is not supported by the {0} Managed Identity. To authenticate with the system assigned identity omit the client id in ManagedIdentityApplicationBuilder.Create().", "Cloud Shell");
				throw MsalServiceExceptionFactory.CreateManagedIdentityException("user_assigned_managed_identity_not_supported", errorMessage, null, ManagedIdentitySource.CloudShell, null);
			}
		}

		protected override ManagedIdentityRequest CreateRequest(string resource)
		{
			return new ManagedIdentityRequest(HttpMethod.Post, _endpoint)
			{
				Headers = 
				{
					{ "ContentType", "application/x-www-form-urlencoded" },
					{ "Metadata", "true" }
				},
				BodyParameters = { { "resource", resource } }
			};
		}
	}
	internal class EnvironmentVariables
	{
		public static string IdentityEndpoint => Environment.GetEnvironmentVariable("IDENTITY_ENDPOINT");

		public static string IdentityHeader => Environment.GetEnvironmentVariable("IDENTITY_HEADER");

		public static string PodIdentityEndpoint => Environment.GetEnvironmentVariable("AZURE_POD_IDENTITY_AUTHORITY_HOST");

		public static string ImdsEndpoint => Environment.GetEnvironmentVariable("IMDS_ENDPOINT");

		public static string MsiEndpoint => Environment.GetEnvironmentVariable("MSI_ENDPOINT");

		public static string IdentityServerThumbprint => Environment.GetEnvironmentVariable("IDENTITY_SERVER_THUMBPRINT");
	}
	internal class ImdsManagedIdentitySource : AbstractManagedIdentity
	{
		private static readonly Uri s_imdsEndpoint = new Uri("http://169.254.169.254/metadata/identity/oauth2/token");

		private const string ImdsTokenPath = "/metadata/identity/oauth2/token";

		private const string ImdsApiVersion = "2018-02-01";

		private const string DefaultMessage = "[Managed Identity] Service request failed.";

		internal const string IdentityUnavailableError = "[Managed Identity] Authentication unavailable. Either the requested identity has not been assigned to this resource, or other errors could be present. Ensure the identity is correctly assigned and check the inner exception for more details. For more information, visit https://aka.ms/msal-managed-identity.";

		internal const string GatewayError = "[Managed Identity] Authentication unavailable. The request failed due to a gateway error.";

		private readonly Uri _imdsEndpoint;

		internal ImdsManagedIdentitySource(RequestContext requestContext)
			: base(requestContext, ManagedIdentitySource.Imds)
		{
			requestContext.Logger.Info(() => "[Managed Identity] Defaulting to IMDS endpoint for managed identity.");
			if (!string.IsNullOrEmpty(EnvironmentVariables.PodIdentityEndpoint))
			{
				requestContext.Logger.Verbose(() => "[Managed Identity] Environment variable AZURE_POD_IDENTITY_AUTHORITY_HOST for IMDS returned endpoint: " + EnvironmentVariables.PodIdentityEndpoint);
				UriBuilder uriBuilder = new UriBuilder(EnvironmentVariables.PodIdentityEndpoint)
				{
					Path = "/metadata/identity/oauth2/token"
				};
				_imdsEndpoint = uriBuilder.Uri;
			}
			else
			{
				requestContext.Logger.Verbose(() => "[Managed Identity] Unable to find AZURE_POD_IDENTITY_AUTHORITY_HOST environment variable for IMDS, using the default endpoint.");
				_imdsEndpoint = s_imdsEndpoint;
			}
			requestContext.Logger.Verbose(() => "[Managed Identity] Creating IMDS managed identity source. Endpoint URI: " + _imdsEndpoint);
		}

		protected override ManagedIdentityRequest CreateRequest(string resource)
		{
			ManagedIdentityRequest managedIdentityRequest = new ManagedIdentityRequest(HttpMethod.Get, _imdsEndpoint);
			managedIdentityRequest.Headers.Add("Metadata", "true");
			managedIdentityRequest.QueryParameters["api-version"] = "2018-02-01";
			managedIdentityRequest.QueryParameters["resource"] = resource;
			switch (_requestContext.ServiceBundle.Config.ManagedIdentityId.IdType)
			{
			case ManagedIdentityIdType.ClientId:
				_requestContext.Logger.Info("[Managed Identity] Adding user assigned client id to the request.");
				managedIdentityRequest.QueryParameters["client_id"] = _requestContext.ServiceBundle.Config.ManagedIdentityId.UserAssignedId;
				break;
			case ManagedIdentityIdType.ResourceId:
				_requestContext.Logger.Info("[Managed Identity] Adding user assigned resource id to the request.");
				managedIdentityRequest.QueryParameters["mi_res_id"] = _requestContext.ServiceBundle.Config.ManagedIdentityId.UserAssignedId;
				break;
			case ManagedIdentityIdType.ObjectId:
				_requestContext.Logger.Info("[Managed Identity] Adding user assigned object id to the request.");
				managedIdentityRequest.QueryParameters["object_id"] = _requestContext.ServiceBundle.Config.ManagedIdentityId.UserAssignedId;
				break;
			}
			return managedIdentityRequest;
		}

		protected override async Task<ManagedIdentityResponse> HandleResponseAsync(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken)
		{
			string text = response.StatusCode switch
			{
				HttpStatusCode.BadRequest => "[Managed Identity] Authentication unavailable. Either the requested identity has not been assigned to this resource, or other errors could be present. Ensure the identity is correctly assigned and check the inner exception for more details. For more information, visit https://aka.ms/msal-managed-identity.", 
				HttpStatusCode.BadGateway => "[Managed Identity] Authentication unavailable. The request failed due to a gateway error.", 
				HttpStatusCode.GatewayTimeout => "[Managed Identity] Authentication unavailable. The request failed due to a gateway error.", 
				_ => null, 
			};
			if (text != null)
			{
				string text2 = CreateRequestFailedMessage(response, text);
				string messageFromErrorResponse = GetMessageFromErrorResponse(response);
				text2 = text2 + Environment.NewLine + messageFromErrorResponse;
				_requestContext.Logger.Error($"Error message: {text2} Http status code: {response.StatusCode}");
				throw MsalServiceExceptionFactory.CreateManagedIdentityException("managed_identity_request_failed", text2, null, ManagedIdentitySource.Imds, null);
			}
			return await base.HandleResponseAsync(parameters, response, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal static string CreateRequestFailedMessage(HttpResponse response, string message)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine(message ?? "[Managed Identity] Service request failed.").Append("Status: ").Append(response.StatusCode.ToString());
			if (response.Body != null)
			{
				stringBuilder.AppendLine().AppendLine("Content:").AppendLine(response.Body);
			}
			stringBuilder.AppendLine().AppendLine("Headers:");
			foreach (KeyValuePair<string, string> item in response.HeadersAsDictionary)
			{
				stringBuilder.AppendLine(item.Key + ": " + item.Value);
			}
			return stringBuilder.ToString();
		}
	}
	internal class ManagedIdentityClient
	{
		private readonly AbstractManagedIdentity _identitySource;

		internal static Lazy<ManagedIdentitySource> s_managedIdentitySourceDetected = new Lazy<ManagedIdentitySource>(() => GetManagedIdentitySource());

		internal static void resetCachedSource()
		{
			s_managedIdentitySourceDetected = new Lazy<ManagedIdentitySource>(() => GetManagedIdentitySource());
		}

		public ManagedIdentityClient(RequestContext requestContext)
		{
			using (requestContext.Logger.LogMethodDuration(LogLevel.Verbose, ".ctor", "/_/src/client/Microsoft.Identity.Client/ManagedIdentity/ManagedIdentityClient.cs"))
			{
				_identitySource = SelectManagedIdentitySource(requestContext);
			}
		}

		internal Task<ManagedIdentityResponse> SendTokenRequestForManagedIdentityAsync(AcquireTokenForManagedIdentityParameters parameters, CancellationToken cancellationToken)
		{
			return _identitySource.AuthenticateAsync(parameters, cancellationToken);
		}

		private static AbstractManagedIdentity SelectManagedIdentitySource(RequestContext requestContext)
		{
			return s_managedIdentitySourceDetected.Value switch
			{
				ManagedIdentitySource.ServiceFabric => ServiceFabricManagedIdentitySource.Create(requestContext), 
				ManagedIdentitySource.AppService => AppServiceManagedIdentitySource.Create(requestContext), 
				ManagedIdentitySource.CloudShell => CloudShellManagedIdentitySource.Create(requestContext), 
				ManagedIdentitySource.AzureArc => AzureArcManagedIdentitySource.Create(requestContext), 
				_ => new ImdsManagedIdentitySource(requestContext), 
			};
		}

		private static ManagedIdentitySource GetManagedIdentitySource()
		{
			string identityEndpoint = EnvironmentVariables.IdentityEndpoint;
			string identityHeader = EnvironmentVariables.IdentityHeader;
			string identityServerThumbprint = EnvironmentVariables.IdentityServerThumbprint;
			_ = EnvironmentVariables.IdentityHeader;
			string msiEndpoint = EnvironmentVariables.MsiEndpoint;
			string imdsEndpoint = EnvironmentVariables.ImdsEndpoint;
			_ = EnvironmentVariables.PodIdentityEndpoint;
			if (!string.IsNullOrEmpty(identityEndpoint) && !string.IsNullOrEmpty(identityHeader))
			{
				if (!string.IsNullOrEmpty(identityServerThumbprint))
				{
					return ManagedIdentitySource.ServiceFabric;
				}
				return ManagedIdentitySource.AppService;
			}
			if (!string.IsNullOrEmpty(msiEndpoint))
			{
				return ManagedIdentitySource.CloudShell;
			}
			if (!string.IsNullOrEmpty(identityEndpoint) && !string.IsNullOrEmpty(imdsEndpoint))
			{
				return ManagedIdentitySource.AzureArc;
			}
			return ManagedIdentitySource.DefaultToImds;
		}
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class ManagedIdentityErrorResponse
	{
		[JsonProperty("message")]
		public string Message { get; set; }

		[JsonProperty("correlationId")]
		public string CorrelationId { get; set; }

		[JsonProperty("error")]
		public string Error { get; set; }

		[JsonProperty("error_description")]
		public string ErrorDescription { get; set; }
	}
	internal class ManagedIdentityRequest
	{
		private readonly Uri _baseEndpoint;

		public HttpMethod Method { get; }

		public IDictionary<string, string> Headers { get; }

		public IDictionary<string, string> BodyParameters { get; }

		public IDictionary<string, string> QueryParameters { get; }

		public ManagedIdentityRequest(HttpMethod method, Uri endpoint)
		{
			Method = method;
			_baseEndpoint = endpoint;
			Headers = new Dictionary<string, string>();
			BodyParameters = new Dictionary<string, string>();
			QueryParameters = new Dictionary<string, string>();
		}

		public Uri ComputeUri()
		{
			UriBuilder uriBuilder = new UriBuilder(_baseEndpoint);
			uriBuilder.AppendQueryParameters(QueryParameters);
			return uriBuilder.Uri;
		}
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class ManagedIdentityResponse
	{
		[JsonProperty("access_token")]
		public string AccessToken { get; set; }

		[JsonProperty("expires_on")]
		public string ExpiresOn { get; set; }

		[JsonProperty("resource")]
		public string Resource { get; set; }

		[JsonProperty("token_type")]
		public string TokenType { get; set; }

		[JsonProperty("client_id")]
		public string ClientId { get; set; }
	}
	public enum ManagedIdentitySource
	{
		None,
		Imds,
		AppService,
		AzureArc,
		CloudShell,
		ServiceFabric,
		DefaultToImds
	}
	internal class ServiceFabricManagedIdentitySource : AbstractManagedIdentity
	{
		private const string ServiceFabricMsiApiVersion = "2019-07-01-preview";

		private readonly Uri _endpoint;

		private readonly string _identityHeaderValue;

		public static AbstractManagedIdentity Create(RequestContext requestContext)
		{
			string identityEndpoint = EnvironmentVariables.IdentityEndpoint;
			requestContext.Logger.Info(() => "[Managed Identity] Service fabric managed identity is available.");
			if (!Uri.TryCreate(identityEndpoint, UriKind.Absolute, out var result))
			{
				string errorMessage = string.Format(CultureInfo.InvariantCulture, "[Managed Identity] The environment variable {0} contains an invalid Uri {1} in {2} managed identity source.", "IDENTITY_ENDPOINT", identityEndpoint, "Service Fabric");
				throw MsalServiceExceptionFactory.CreateManagedIdentityException("invalid_managed_identity_endpoint", errorMessage, null, ManagedIdentitySource.ServiceFabric, null);
			}
			requestContext.Logger.Verbose(() => "[Managed Identity] Creating Service Fabric managed identity. Endpoint URI: " + identityEndpoint);
			return new ServiceFabricManagedIdentitySource(requestContext, result, EnvironmentVariables.IdentityHeader);
		}

		private ServiceFabricManagedIdentitySource(RequestContext requestContext, Uri endpoint, string identityHeaderValue)
			: base(requestContext, ManagedIdentitySource.ServiceFabric)
		{
			_endpoint = endpoint;
			_identityHeaderValue = identityHeaderValue;
			if (requestContext.ServiceBundle.Config.ManagedIdentityId.IsUserAssigned)
			{
				requestContext.Logger.Warning("[Managed Identity] Service Fabric user assigned managed identity ClientId or ResourceId is not configurable at runtime.");
			}
		}

		protected override ManagedIdentityRequest CreateRequest(string resource)
		{
			ManagedIdentityRequest managedIdentityRequest = new ManagedIdentityRequest(HttpMethod.Get, _endpoint);
			managedIdentityRequest.Headers["secret"] = _identityHeaderValue;
			managedIdentityRequest.QueryParameters["api-version"] = "2019-07-01-preview";
			managedIdentityRequest.QueryParameters["resource"] = resource;
			switch (_requestContext.ServiceBundle.Config.ManagedIdentityId.IdType)
			{
			case ManagedIdentityIdType.ClientId:
				_requestContext.Logger.Info("[Managed Identity] Adding user assigned client id to the request.");
				managedIdentityRequest.QueryParameters["client_id"] = _requestContext.ServiceBundle.Config.ManagedIdentityId.UserAssignedId;
				break;
			case ManagedIdentityIdType.ResourceId:
				_requestContext.Logger.Info("[Managed Identity] Adding user assigned resource id to the request.");
				managedIdentityRequest.QueryParameters["mi_res_id"] = _requestContext.ServiceBundle.Config.ManagedIdentityId.UserAssignedId;
				break;
			case ManagedIdentityIdType.ObjectId:
				_requestContext.Logger.Info("[Managed Identity] Adding user assigned object id to the request.");
				managedIdentityRequest.QueryParameters["object_id"] = _requestContext.ServiceBundle.Config.ManagedIdentityId.UserAssignedId;
				break;
			}
			return managedIdentityRequest;
		}
	}
}
namespace Microsoft.Identity.Client.Kerberos
{
	public enum KerberosKeyTypes
	{
		None = 0,
		DecCbcCrc = 1,
		DesCbcMd5 = 3,
		Aes128CtsHmacSha196 = 17,
		Aes256CtsHmacSha196 = 18
	}
	public class KerberosSupplementalTicket
	{
		[JsonProperty("clientKey")]
		public string ClientKey { get; set; }

		[JsonProperty("keyType")]
		public KerberosKeyTypes KeyType { get; set; }

		[JsonProperty("messageBuffer")]
		public string KerberosMessageBuffer { get; set; }

		[JsonProperty("error")]
		public string ErrorMessage { get; set; }

		[JsonProperty("realm")]
		public string Realm { get; set; }

		[JsonProperty("sn")]
		public string ServicePrincipalName { get; set; }

		[JsonProperty("cn")]
		public string ClientName { get; set; }

		public KerberosSupplementalTicket()
		{
		}

		public KerberosSupplementalTicket(string errorMessage)
		{
			ErrorMessage = errorMessage;
		}

		public override string ToString()
		{
			return $"[ Realm: {Realm}, sp: {ServicePrincipalName}, cn: {ClientName}, KeyType: {KeyType} ]";
		}
	}
	public static class KerberosSupplementalTicketManager
	{
		private const int DefaultLogonId = 0;

		private const string KerberosClaimType = "xms_as_rep";

		private const string IdTokenAsRepTemplate = "{{\"id_token\": {{ \"xms_as_rep\":{{\"essential\":\"false\",\"value\":\"{0}\"}} }} }}";

		private const string AccessTokenAsRepTemplate = "{{\"access_token\": {{ \"xms_as_rep\":{{\"essential\":\"false\",\"value\":\"{0}\"}} }} }}";

		public static KerberosSupplementalTicket FromIdToken(string idToken)
		{
			if (string.IsNullOrEmpty(idToken) || idToken.Length < 128)
			{
				return null;
			}
			string[] array = idToken.Split(new char[1] { '.' });
			if (array.Length != 3)
			{
				return null;
			}
			byte[] bytes = Base64UrlHelpers.DecodeBytes(array[1]);
			string text = Encoding.UTF8.GetString(bytes);
			if (string.IsNullOrEmpty(text))
			{
				return null;
			}
			if (!JsonHelper.TryGetValue(JsonHelper.ParseIntoJsonObject(text), "xms_as_rep", out var value))
			{
				return null;
			}
			return JsonHelper.DeserializeFromJson<KerberosSupplementalTicket>(JsonHelper.GetValue<string>(value));
		}

		public static void SaveToWindowsTicketCache(KerberosSupplementalTicket ticket)
		{
			SaveToWindowsTicketCache(ticket, 0L);
		}

		public static void SaveToWindowsTicketCache(KerberosSupplementalTicket ticket, long logonId)
		{
			if (!DesktopOsHelper.IsWindows())
			{
				throw new PlatformNotSupportedException("Ticket Cache interface is not supported on this OS. It is supported on Windows only.");
			}
			if (ticket == null || string.IsNullOrEmpty(ticket.KerberosMessageBuffer))
			{
				throw new ArgumentException("Kerberos Ticket information is not valid");
			}
			using TicketCacheWriter ticketCacheWriter = TicketCacheWriter.Connect();
			byte[] ticketBytes = Convert.FromBase64String(ticket.KerberosMessageBuffer);
			ticketCacheWriter.ImportCredential(ticketBytes, logonId);
		}

		public static byte[] GetKerberosTicketFromWindowsTicketCache(string servicePrincipalName)
		{
			return GetKerberosTicketFromWindowsTicketCache(servicePrincipalName, 0L);
		}

		public static byte[] GetKerberosTicketFromWindowsTicketCache(string servicePrincipalName, long logonId)
		{
			if (!DesktopOsHelper.IsWindows())
			{
				throw new PlatformNotSupportedException("Ticket Cache interface is not supported on this OS. It is supported on Windows only.");
			}
			using TicketCacheReader ticketCacheReader = new TicketCacheReader(servicePrincipalName, logonId);
			return ticketCacheReader.RequestToken();
		}

		public static byte[] GetKrbCred(KerberosSupplementalTicket ticket)
		{
			if (!string.IsNullOrEmpty(ticket.KerberosMessageBuffer))
			{
				return Convert.FromBase64String(ticket.KerberosMessageBuffer);
			}
			return null;
		}

		internal static string GetKerberosTicketClaim(string servicePrincipalName, KerberosTicketContainer ticketContainer)
		{
			if (string.IsNullOrEmpty(servicePrincipalName))
			{
				return string.Empty;
			}
			if (ticketContainer == KerberosTicketContainer.IdToken)
			{
				return string.Format(CultureInfo.InvariantCulture, "{{\"id_token\": {{ \"xms_as_rep\":{{\"essential\":\"false\",\"value\":\"{0}\"}} }} }}", servicePrincipalName);
			}
			return string.Format(CultureInfo.InvariantCulture, "{{\"access_token\": {{ \"xms_as_rep\":{{\"essential\":\"false\",\"value\":\"{0}\"}} }} }}", servicePrincipalName);
		}
	}
	public enum KerberosTicketContainer
	{
		IdToken,
		AccessToken
	}
}
namespace Microsoft.Identity.Client.Core
{
	internal interface ILoggerAdapter
	{
		bool PiiLoggingEnabled { get; }

		bool IsDefaultPlatformLoggingEnabled { get; }

		string ClientName { get; }

		string ClientVersion { get; }

		IIdentityLogger IdentityLogger { get; }

		bool IsLoggingEnabled(LogLevel logLevel);

		void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed);

		DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel = LogLevel.Verbose);

		DurationLogHelper LogMethodDuration(LogLevel logLevel = LogLevel.Verbose, [CallerMemberName] string methodName = null, [CallerFilePath] string filePath = null);
	}
	internal static class MsalLoggerExtensions
	{
		public static void Always(this ILoggerAdapter logger, string message)
		{
			logger.Log(LogLevel.Always, string.Empty, message);
		}

		public static void AlwaysPii(this ILoggerAdapter logger, string messageWithPii, string messageScrubbed)
		{
			logger.Log(LogLevel.Always, messageWithPii, messageScrubbed);
		}

		public static void Error(this ILoggerAdapter logger, string message)
		{
			logger.Log(LogLevel.Error, string.Empty, message);
		}

		public static void ErrorPiiWithPrefix(this ILoggerAdapter logger, Exception exWithPii, string prefix)
		{
			logger.Log(LogLevel.Error, prefix + exWithPii, prefix + LoggerHelper.GetPiiScrubbedExceptionDetails(exWithPii));
		}

		public static void ErrorPii(this ILoggerAdapter logger, string messageWithPii, string messageScrubbed)
		{
			logger.Log(LogLevel.Error, messageWithPii, messageScrubbed);
		}

		public static void ErrorPii(this ILoggerAdapter logger, Exception exWithPii)
		{
			logger.Log(LogLevel.Error, exWithPii.ToString(), LoggerHelper.GetPiiScrubbedExceptionDetails(exWithPii));
		}

		public static void Warning(this ILoggerAdapter logger, string message)
		{
			logger.Log(LogLevel.Warning, string.Empty, message);
		}

		public static void WarningPii(this ILoggerAdapter logger, string messageWithPii, string messageScrubbed)
		{
			logger.Log(LogLevel.Warning, messageWithPii, messageScrubbed);
		}

		public static void WarningPii(this ILoggerAdapter logger, Exception exWithPii)
		{
			logger.Log(LogLevel.Warning, exWithPii.ToString(), LoggerHelper.GetPiiScrubbedExceptionDetails(exWithPii));
		}

		public static void WarningPiiWithPrefix(this ILoggerAdapter logger, Exception exWithPii, string prefix)
		{
			logger.Log(LogLevel.Warning, prefix + exWithPii, prefix + LoggerHelper.GetPiiScrubbedExceptionDetails(exWithPii));
		}

		public static void Info(this ILoggerAdapter logger, string message)
		{
			logger.Log(LogLevel.Info, string.Empty, message);
		}

		public static void Info(this ILoggerAdapter logger, Func<string> messageProducer)
		{
			if (logger.IsLoggingEnabled(LogLevel.Info))
			{
				logger.Log(LogLevel.Info, string.Empty, messageProducer());
			}
		}

		public static void InfoPii(this ILoggerAdapter logger, string messageWithPii, string messageScrubbed)
		{
			logger.Log(LogLevel.Info, messageWithPii, messageScrubbed);
		}

		public static void InfoPii(this ILoggerAdapter logger, Func<string> messageWithPiiProducer, Func<string> messageScrubbedProducer)
		{
			if (logger.IsLoggingEnabled(LogLevel.Info))
			{
				logger.Log(LogLevel.Info, messageWithPiiProducer(), messageScrubbedProducer());
			}
		}

		public static void InfoPii(this ILoggerAdapter logger, Exception exWithPii)
		{
			logger.Log(LogLevel.Info, exWithPii?.ToString(), LoggerHelper.GetPiiScrubbedExceptionDetails(exWithPii));
		}

		public static void Verbose(this ILoggerAdapter logger, Func<string> messageProducer)
		{
			if (logger.IsLoggingEnabled(LogLevel.Verbose))
			{
				logger.Log(LogLevel.Verbose, string.Empty, messageProducer());
			}
		}

		public static void VerbosePii(this ILoggerAdapter logger, Func<string> messageWithPiiProducer, Func<string> messageScrubbedProducer)
		{
			if (logger.IsLoggingEnabled(LogLevel.Verbose))
			{
				logger.Log(LogLevel.Verbose, messageWithPiiProducer(), messageScrubbedProducer());
			}
		}
	}
}
namespace Microsoft.Identity.Client.Internal
{
	internal static class ClaimsHelper
	{
		private const string AccessTokenClaim = "access_token";

		private const string XmsClientCapability = "xms_cc";

		internal static string GetMergedClaimsAndClientCapabilities(string claims, IEnumerable<string> clientCapabilities)
		{
			if (clientCapabilities != null && clientCapabilities.Any())
			{
				JObject capabilitiesJson = CreateClientCapabilitiesRequestJson(clientCapabilities);
				return JsonHelper.JsonObjectToString(MergeClaimsIntoCapabilityJson(claims, capabilitiesJson));
			}
			return claims;
		}

		internal static JObject MergeClaimsIntoCapabilityJson(string claims, JObject capabilitiesJson)
		{
			if (!string.IsNullOrEmpty(claims))
			{
				JObject content;
				try
				{
					content = JsonHelper.ParseIntoJsonObject(claims);
				}
				catch (JsonException innerException)
				{
					throw new MsalClientException("invalid_json_claims_format", MsalErrorMessage.InvalidJsonClaimsFormat(claims), innerException);
				}
				capabilitiesJson.Merge(content, new JsonMergeSettings
				{
					MergeArrayHandling = MergeArrayHandling.Union
				});
			}
			return capabilitiesJson;
		}

		private static JObject CreateClientCapabilitiesRequestJson(IEnumerable<string> clientCapabilities)
		{
			return new JObject { ["access_token"] = new JObject { ["xms_cc"] = new JObject { ["values"] = new JArray(clientCapabilities) } } };
		}
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class ClientInfo
	{
		[JsonProperty("uid")]
		public string UniqueObjectIdentifier { get; set; }

		[JsonProperty("utid")]
		public string UniqueTenantIdentifier { get; set; }

		public static ClientInfo CreateFromJson(string clientInfo)
		{
			if (string.IsNullOrEmpty(clientInfo))
			{
				throw new MsalClientException("json_parse_failed", "client info is null");
			}
			try
			{
				return JsonHelper.DeserializeFromJson<ClientInfo>(Base64UrlHelpers.DecodeBytes(clientInfo));
			}
			catch (Exception innerException)
			{
				throw new MsalClientException("json_parse_failed", "Failed to parse the returned client info.", innerException);
			}
		}

		public string ToAccountIdentifier()
		{
			return UniqueObjectIdentifier + "." + UniqueTenantIdentifier;
		}
	}
	internal static class ClientInfoClaim
	{
		public const string UniqueIdentifier = "uid";

		public const string UniqueTenantIdentifier = "utid";
	}
	internal static class Constants
	{
		public const string MsAppScheme = "ms-app";

		public const int ExpirationMarginInMinutes = 5;

		public const int CodeVerifierLength = 128;

		public const int CodeVerifierByteSize = 96;

		public const string DefaultRedirectUri = "urn:ietf:wg:oauth:2.0:oob";

		public const string NativeClientRedirectUri = "https://login.microsoftonline.com/common/oauth2/nativeclient";

		public const string LocalHostRedirectUri = "http://localhost";

		public const string DefaultConfidentialClientRedirectUri = "https://replyUrlNotSet";

		public const string DefaultRealm = "http://schemas.microsoft.com/rel/trusted-realm";

		public const string MsaTenantId = "9188040d-6c67-4c5b-b112-36a304b66dad";

		public const string ConsumerTenant = "consumers";

		public const string OrganizationsTenant = "organizations";

		public const string CommonTenant = "common";

		public const string UserRealmMsaDomainName = "live.com";

		public const string CcsRoutingHintHeader = "x-anchormailbox";

		public const string AadThrottledErrorCode = "AADSTS50196";

		public const int DefaultJitterRangeInSeconds = 300;

		public static readonly TimeSpan AccessTokenExpirationBuffer = TimeSpan.FromMinutes(5.0);

		public const string EnableSpaAuthCode = "1";

		public const string PoPTokenType = "pop";

		public const string PoPAuthHeaderPrefix = "PoP";

		public const string RequestConfirmation = "req_cnf";

		public const string BearerAuthHeaderPrefix = "Bearer";

		public const string ManagedIdentityClientId = "client_id";

		public const string ManagedIdentityObjectId = "object_id";

		public const string ManagedIdentityResourceId = "mi_res_id";

		public const string ManagedIdentityDefaultClientId = "system_assigned_managed_identity";

		public const string ManagedIdentityDefaultTenant = "managed_identity";

		public const string CiamAuthorityHostSuffix = ".ciamlogin.com";

		public const string WellKnownOpenIdConfigurationPath = ".well-known/openid-configuration";

		public const string OpenIdConfigurationEndpoint = "v2.0/.well-known/openid-configuration";

		public const string Tenant = "{tenant}";

		public const string TenantId = "{tenantid}";

		public static string FormatEnterpriseRegistrationOnPremiseUri(string domain)
		{
			return "https://enterpriseregistration." + domain + "/enrollmentserver/contract";
		}

		public static string FormatEnterpriseRegistrationInternetUri(string domain)
		{
			return "https://enterpriseregistration.windows.net/" + domain + "/enrollmentserver/contract";
		}

		public static string FormatAdfsWebFingerUrl(string host, string resource)
		{
			return "https://" + host + "/.well-known/webfinger?rel=http://schemas.microsoft.com/rel/trusted-realm&resource=" + resource;
		}
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class DeviceCodeResponse : OAuth2ResponseBase
	{
		[JsonProperty("user_code")]
		public string UserCode { get; set; }

		[JsonProperty("device_code")]
		public string DeviceCode { get; set; }

		[JsonProperty("verification_url")]
		public string VerificationUrl { get; set; }

		[JsonProperty("verification_uri")]
		public string VerificationUri { get; set; }

		[JsonProperty("expires_in")]
		public long ExpiresIn { get; set; }

		[JsonProperty("interval")]
		public long Interval { get; set; }

		[JsonProperty("message")]
		public string Message { get; set; }

		public DeviceCodeResult GetResult(string clientId, ISet<string> scopes)
		{
			string verificationUrl = (string.IsNullOrWhiteSpace(VerificationUri) ? VerificationUrl : VerificationUri);
			return new DeviceCodeResult(UserCode, DeviceCode, verificationUrl, DateTime.UtcNow.AddSeconds(ExpiresIn), Interval, Message, clientId, scopes);
		}
	}
	internal static class IdTokenClaim
	{
		public const string Issuer = "iss";

		public const string ObjectId = "oid";

		public const string Subject = "sub";

		public const string TenantId = "tid";

		public const string Version = "ver";

		public const string PreferredUsername = "preferred_username";

		public const string Name = "name";

		public const string Email = "email";

		public const string HomeObjectId = "home_oid";

		public const string GivenName = "given_name";

		public const string FamilyName = "family_name";

		public const string Upn = "upn";
	}
	internal static class JsonClaimValueTypes
	{
		public const string Json = "JSON";

		public const string JsonArray = "JSON_ARRAY";

		public const string JsonNull = "JSON_NULL";
	}
	internal class IdToken
	{
		private const string DefaultIssuser = "LOCAL AUTHORITY";

		public string ObjectId { get; private set; }

		public string Subject { get; private set; }

		public string TenantId { get; private set; }

		public string PreferredUsername { get; private set; }

		public string Name { get; private set; }

		public string Email { get; private set; }

		public string Upn { get; private set; }

		public string GivenName { get; private set; }

		public string FamilyName { get; private set; }

		public ClaimsPrincipal ClaimsPrincipal { get; private set; }

		public string GetUniqueId()
		{
			return ObjectId ?? Subject;
		}

		private static IdToken ClaimsToToken(List<Claim> claims)
		{
			ClaimsPrincipal claimsPrincipal = new ClaimsPrincipal(new ClaimsIdentity(claims));
			return new IdToken
			{
				ClaimsPrincipal = claimsPrincipal,
				ObjectId = FindClaim(claims, "oid"),
				Subject = FindClaim(claims, "sub"),
				TenantId = FindClaim(claims, "tid"),
				PreferredUsername = FindClaim(claims, "preferred_username"),
				Name = FindClaim(claims, "name"),
				Email = FindClaim(claims, "email"),
				Upn = FindClaim(claims, "upn"),
				GivenName = FindClaim(claims, "given_name"),
				FamilyName = FindClaim(claims, "family_name")
			};
			static string FindClaim(List<Claim> source, string type)
			{
				return source.SingleOrDefault((Claim _) => string.Equals(_.Type, type, StringComparison.OrdinalIgnoreCase))?.Value;
			}
		}

		public static IdToken Parse(string idToken)
		{
			if (string.IsNullOrEmpty(idToken))
			{
				return null;
			}
			string[] array = idToken.Split(new char[1] { '.' });
			if (array.Length < 2)
			{
				throw new MsalClientException("invalid_jwt", "ID Token must have a valid JWT format. ");
			}
			try
			{
				return ClaimsToToken(GetClaimsFromRawToken(JsonConvert.DeserializeObject<Dictionary<string, object>>(Base64UrlHelpers.Decode(array[1]))));
			}
			catch (JsonException innerException)
			{
				throw new MsalClientException("json_parse_failed", "Failed to parse the returned id token. ", innerException);
			}
		}

		private static List<Claim> GetClaimsFromRawToken(Dictionary<string, object> idTokenClaims)
		{
			List<Claim> list = new List<Claim>();
			string text = null;
			if (idTokenClaims.TryGetValue("iss", out var value))
			{
				text = value as string;
			}
			if (text == null)
			{
				text = "LOCAL AUTHORITY";
			}
			foreach (KeyValuePair<string, object> idTokenClaim in idTokenClaims)
			{
				if (idTokenClaim.Value == null)
				{
					list.Add(new Claim(idTokenClaim.Key, string.Empty, "JSON_NULL", text, text));
				}
				else if (idTokenClaim.Value is string value2)
				{
					list.Add(new Claim(idTokenClaim.Key, value2, "http://www.w3.org/2001/XMLSchema#string", text, text));
				}
				else if (idTokenClaim.Value is JToken jtoken)
				{
					AddClaimsFromJToken(list, idTokenClaim.Key, jtoken, text);
				}
				else if (idTokenClaim.Value is IEnumerable<object> enumerable)
				{
					foreach (object item in enumerable)
					{
						if (item is string value3)
						{
							list.Add(new Claim(idTokenClaim.Key, value3, "http://www.w3.org/2001/XMLSchema#string", text, text));
						}
						else if (item is JToken jtoken2)
						{
							AddDefaultClaimFromJToken(list, idTokenClaim.Key, jtoken2, text);
						}
						else if (item is DateTime dateTime)
						{
							list.Add(new Claim(idTokenClaim.Key, dateTime.ToUniversalTime().ToString("o", CultureInfo.InvariantCulture), "http://www.w3.org/2001/XMLSchema#dateTime", text, text));
						}
						else
						{
							list.Add(new Claim(idTokenClaim.Key, JsonConvert.SerializeObject(item), GetClaimValueType(item), text, text));
						}
					}
				}
				else if (idTokenClaim.Value is IDictionary<string, object> dictionary)
				{
					foreach (KeyValuePair<string, object> item2 in dictionary)
					{
						list.Add(new Claim(idTokenClaim.Key, "{" + item2.Key + ":" + JsonConvert.SerializeObject(item2.Value) + "}", GetClaimValueType(item2.Value), text, text));
					}
				}
				else if (idTokenClaim.Value is DateTime dateTime2)
				{
					list.Add(new Claim(idTokenClaim.Key, dateTime2.ToUniversalTime().ToString("o", CultureInfo.InvariantCulture), "http://www.w3.org/2001/XMLSchema#dateTime", text, text));
				}
				else
				{
					list.Add(new Claim(idTokenClaim.Key, JsonConvert.SerializeObject(idTokenClaim.Value), GetClaimValueType(idTokenClaim.Value), text, text));
				}
			}
			return list;
		}

		private static void AddClaimsFromJToken(List<Claim> claims, string claimType, JToken jtoken, string issuer)
		{
			if (jtoken.Type == JTokenType.Object)
			{
				claims.Add(new Claim(claimType, jtoken.ToString(Microsoft.Identity.Json.Formatting.None), "JSON"));
				return;
			}
			if (jtoken.Type == JTokenType.Array)
			{
				foreach (JToken item in jtoken as JArray)
				{
					switch (item.Type)
					{
					case JTokenType.Object:
						claims.Add(new Claim(claimType, item.ToString(Microsoft.Identity.Json.Formatting.None), "JSON", issuer, issuer));
						break;
					case JTokenType.Array:
						claims.Add(new Claim(claimType, item.ToString(Microsoft.Identity.Json.Formatting.None), "JSON_ARRAY", issuer, issuer));
						break;
					default:
						AddDefaultClaimFromJToken(claims, claimType, item, issuer);
						break;
					}
				}
				return;
			}
			AddDefaultClaimFromJToken(claims, claimType, jtoken, issuer);
		}

		private static void AddDefaultClaimFromJToken(List<Claim> claims, string claimType, JToken jtoken, string issuer)
		{
			if (jtoken is JValue jValue)
			{
				if (jValue.Type == JTokenType.String)
				{
					claims.Add(new Claim(claimType, jValue.Value.ToString(), "http://www.w3.org/2001/XMLSchema#string", issuer, issuer));
				}
				else if (jValue.Value is DateTime dateTime)
				{
					claims.Add(new Claim(claimType, dateTime.ToUniversalTime().ToString("o", CultureInfo.InvariantCulture), "http://www.w3.org/2001/XMLSchema#dateTime", issuer, issuer));
				}
				else
				{
					claims.Add(new Claim(claimType, jtoken.ToString(Microsoft.Identity.Json.Formatting.None), GetClaimValueType(jValue.Value), issuer, issuer));
				}
			}
			else
			{
				claims.Add(new Claim(claimType, jtoken.ToString(Microsoft.Identity.Json.Formatting.None), GetClaimValueType(jtoken), issuer, issuer));
			}
		}

		private static string GetClaimValueType(object obj)
		{
			if (obj == null)
			{
				return "JSON_NULL";
			}
			Type type = obj.GetType();
			if (type == typeof(string))
			{
				return "http://www.w3.org/2001/XMLSchema#string";
			}
			if (type == typeof(int))
			{
				return "http://www.w3.org/2001/XMLSchema#integer";
			}
			if (type == typeof(bool))
			{
				return "http://www.w3.org/2001/XMLSchema#boolean";
			}
			if (type == typeof(double))
			{
				return "http://www.w3.org/2001/XMLSchema#double";
			}
			if (type == typeof(long))
			{
				long num = (long)obj;
				if (num >= int.MinValue && num <= int.MaxValue)
				{
					return "http://www.w3.org/2001/XMLSchema#integer";
				}
				return "http://www.w3.org/2001/XMLSchema#integer64";
			}
			if (type == typeof(DateTime))
			{
				return "http://www.w3.org/2001/XMLSchema#dateTime";
			}
			if (type == typeof(JObject))
			{
				return "JSON";
			}
			if (type == typeof(JArray))
			{
				return "JSON_ARRAY";
			}
			return type.ToString();
		}
	}
	internal interface IServiceBundle
	{
		ApplicationConfiguration Config { get; }

		ILoggerAdapter ApplicationLogger { get; }

		IHttpManager HttpManager { get; }

		IInstanceDiscoveryManager InstanceDiscoveryManager { get; }

		IPlatformProxy PlatformProxy { get; }

		IWsTrustWebRequestManager WsTrustWebRequestManager { get; }

		IDeviceAuthManager DeviceAuthManager { get; }

		IThrottlingProvider ThrottlingManager { get; }

		IHttpTelemetryManager HttpTelemetryManager { get; }

		void SetPlatformProxyForTest(IPlatformProxy platformProxy);
	}
	internal class JsonWebToken
	{
		private const int MaxTokenLength = 65536;

		public const long JwtToAadLifetimeInSeconds = 600L;

		private readonly IDictionary<string, string> _claimsToSign;

		private readonly ICryptographyManager _cryptographyManager;

		private readonly string _clientId;

		private readonly string _audience;

		private readonly bool _appendDefaultClaims;

		public JsonWebToken(ICryptographyManager cryptographyManager, string clientId, string audience)
		{
			_cryptographyManager = cryptographyManager;
			_clientId = clientId;
			_audience = audience;
		}

		public JsonWebToken(ICryptographyManager cryptographyManager, string clientId, string audience, IDictionary<string, string> claimsToSign, bool appendDefaultClaims = false)
			: this(cryptographyManager, clientId, audience)
		{
			_claimsToSign = claimsToSign;
			_appendDefaultClaims = appendDefaultClaims;
		}

		private string CreateJsonPayload()
		{
			long num = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
			long num2 = num + 600;
			if (_claimsToSign == null || _claimsToSign.Count == 0)
			{
				return $"{{\"aud\":\"{_audience}\",\"iss\":\"{_clientId}\",\"sub\":\"{_clientId}\",\"nbf\":\"{num}\",\"exp\":\"{num2}\",\"jti\":\"{Guid.NewGuid()}\"}}";
			}
			StringBuilder stringBuilder = new StringBuilder();
			if (_appendDefaultClaims)
			{
				string value = $"{{\"aud\":\"{_audience}\",\"iss\":\"{_clientId}\",\"sub\":\"{_clientId}\",\"nbf\":\"{num}\",\"exp\":\"{num2}\",\"jti\":\"{Guid.NewGuid()}\",";
				stringBuilder.Append(value);
			}
			else
			{
				stringBuilder.Append('{');
			}
			int num3 = 0;
			foreach (KeyValuePair<string, string> item in _claimsToSign)
			{
				stringBuilder.Append("\"" + item.Key + "\":\"" + item.Value + "\"");
				if (num3 != _claimsToSign.Count - 1)
				{
					num3++;
					stringBuilder.Append(',');
				}
			}
			stringBuilder.Append('}');
			return stringBuilder.ToString();
		}

		public string Sign(X509Certificate2 certificate, bool sendX5C, bool useSha2AndPss)
		{
			string text = CreateJwtHeaderAndBody(certificate, sendX5C, useSha2AndPss);
			if (65536 < text.Length)
			{
				throw new MsalClientException("encoded_token_too_long");
			}
			byte[] inArray = _cryptographyManager.SignWithCertificate(text, certificate, useSha2AndPss ? RSASignaturePadding.Pss : RSASignaturePadding.Pkcs1);
			return text + "." + Base64UrlHelpers.Encode(inArray);
		}

		private static string CreateJsonHeader(X509Certificate2 certificate, bool sendX5C, bool useSha2AndPss)
		{
			string text = ComputeCertThumbprint(certificate, useSha2AndPss);
			string text2 = (useSha2AndPss ? "PS256" : "RS256");
			string text3 = (useSha2AndPss ? "x5t#S256" : "x5t");
			if (sendX5C)
			{
				string text4 = Convert.ToBase64String(certificate.RawData);
				return "{\"alg\":\"" + text2 + "\",\"typ\":\"JWT\",\"" + text3 + "\":\"" + text + "\",\"x5c\":\"" + text4 + "\"}";
			}
			return "{\"alg\":\"" + text2 + "\",\"typ\":\"JWT\",\"" + text3 + "\":\"" + text + "\"}";
		}

		private static string ComputeCertThumbprint(X509Certificate2 certificate, bool useSha2)
		{
			string result = null;
			try
			{
				if (useSha2)
				{
					using SHA256 sHA = SHA256.Create();
					result = Base64UrlHelpers.Encode(sHA.ComputeHash(certificate.RawData));
				}
				else
				{
					result = Base64UrlHelpers.Encode(certificate.GetCertHash());
				}
			}
			catch (CryptographicException innerException)
			{
				throw new MsalClientException("cryptographic_error", "A cryptographic exception occurred. Possible cause: the certificate has been disposed. See inner exception for full details.", innerException);
			}
			return result;
		}

		private string CreateJwtHeaderAndBody(X509Certificate2 certificate, bool addX5C, bool useSha2AndPss)
		{
			string text = Base64UrlHelpers.EncodeString(CreateJsonHeader(certificate, addX5C, useSha2AndPss));
			string text2 = Base64UrlHelpers.EncodeString(CreateJsonPayload());
			return text + "." + text2;
		}
	}
	internal class JsonWebTokenConstants
	{
		public const string Algorithm = "alg";

		public const string Type = "typ";

		public const string KeyId = "kid";

		public const string X509CertificateThumbprint = "x5t";

		public const string X509CertificatePublicCertValue = "x5c";
	}
	internal static class MsalIdParameter
	{
		public const string Product = "x-client-SKU";

		public const string Version = "x-client-Ver";

		public const string OS = "x-client-OS";

		public const string DeviceModel = "x-client-DM";
	}
	internal static class MsalIdHelper
	{
		private static readonly Lazy<string> s_msalVersion = new Lazy<string>(delegate
		{
			string fullName = typeof(MsalIdHelper).Assembly.FullName;
			Match match = new Regex("Version=[\\d]+.[\\d+]+.[\\d]+.[\\d]+").Match(fullName);
			return (!match.Success) ? null : match.Groups[0].Value.Split(new char[1] { '=' }, StringSplitOptions.None)[1];
		});

		public static IDictionary<string, string> GetMsalIdParameters(ILoggerAdapter logger)
		{
			IPlatformProxy platformProxy = PlatformProxyFactory.CreatePlatformProxy(logger);
			if (platformProxy == null)
			{
				throw new MsalClientException("platform_not_supported", "Platform Not Supported");
			}
			Dictionary<string, string> dictionary = new Dictionary<string, string>
			{
				["x-client-SKU"] = platformProxy.GetProductName(),
				["x-client-Ver"] = GetMsalVersion()
			};
			string operatingSystem = platformProxy.GetOperatingSystem();
			if (operatingSystem != null)
			{
				dictionary["x-client-OS"] = operatingSystem;
			}
			string deviceModel = platformProxy.GetDeviceModel();
			if (deviceModel != null)
			{
				dictionary["x-client-DM"] = deviceModel;
			}
			return dictionary;
		}

		public static string GetMsalVersion()
		{
			return s_msalVersion.Value;
		}
	}
	internal class RequestContext
	{
		public Guid CorrelationId { get; }

		public ILoggerAdapter Logger { get; }

		public IServiceBundle ServiceBundle { get; }

		public ApiEvent ApiEvent { get; set; }

		public CancellationToken UserCancellationToken { get; }

		public RequestContext(IServiceBundle serviceBundle, Guid correlationId, CancellationToken cancellationToken = default(CancellationToken))
		{
			ServiceBundle = serviceBundle ?? throw new ArgumentNullException("serviceBundle");
			Logger = LoggerHelper.CreateLogger(correlationId, ServiceBundle.Config);
			CorrelationId = correlationId;
			UserCancellationToken = cancellationToken;
		}

		public TelemetryHelper CreateTelemetryHelper(ApiEvent eventToStart)
		{
			return new TelemetryHelper(ServiceBundle.HttpTelemetryManager, eventToStart);
		}
	}
	internal class AuthCodeRequestComponent : IAuthCodeRequestComponent
	{
		private readonly AuthenticationRequestParameters _requestParams;

		private readonly AcquireTokenInteractiveParameters _interactiveParameters;

		private readonly IServiceBundle _serviceBundle;

		public AuthCodeRequestComponent(AuthenticationRequestParameters requestParams, AcquireTokenInteractiveParameters interactiveParameters)
		{
			_requestParams = requestParams ?? throw new ArgumentNullException("requestParams");
			_interactiveParameters = interactiveParameters ?? throw new ArgumentNullException("requestParams");
			_serviceBundle = _requestParams.RequestContext.ServiceBundle;
		}

		public async Task<Tuple<AuthorizationResult, string>> FetchAuthCodeAndPkceVerifierAsync(CancellationToken cancellationToken)
		{
			IWebUI webUi = CreateWebAuthenticationDialog();
			return await FetchAuthCodeAndPkceInternalAsync(webUi, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<Uri> GetAuthorizationUriWithoutPkceAsync(CancellationToken cancellationToken)
		{
			return CreateAuthorizationUri(await _requestParams.Authority.GetAuthorizationEndpointAsync(_requestParams.RequestContext).ConfigureAwait(continueOnCapturedContext: false)).Item1;
		}

		public async Task<Uri> GetAuthorizationUriWithPkceAsync(string codeVerifier, CancellationToken cancellationToken)
		{
			return CreateAuthorizationUriWithCodeChallenge(await _requestParams.Authority.GetAuthorizationEndpointAsync(_requestParams.RequestContext).ConfigureAwait(continueOnCapturedContext: false), codeVerifier).Item1;
		}

		private async Task<Tuple<AuthorizationResult, string>> FetchAuthCodeAndPkceInternalAsync(IWebUI webUi, CancellationToken cancellationToken)
		{
			RedirectUriHelper.Validate(_requestParams.RedirectUri);
			_requestParams.RedirectUri = webUi.UpdateRedirectUri(_requestParams.RedirectUri);
			Tuple<Uri, string, string> tuple = CreateAuthorizationUri(await _requestParams.Authority.GetAuthorizationEndpointAsync(_requestParams.RequestContext).ConfigureAwait(continueOnCapturedContext: false), addPkceAndState: true);
			Uri item = tuple.Item1;
			string state = tuple.Item2;
			string codeVerifier = tuple.Item3;
			AuthorizationResult authorizationResult = await webUi.AcquireAuthorizationAsync(item, _requestParams.RedirectUri, _requestParams.RequestContext, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			VerifyAuthorizationResult(authorizationResult, state);
			return new Tuple<AuthorizationResult, string>(authorizationResult, codeVerifier);
		}

		private Tuple<Uri, string> CreateAuthorizationUriWithCodeChallenge(string authEndpoint, string codeVerifier)
		{
			IDictionary<string, string> dictionary = CreateAuthorizationRequestParameters();
			string value = _serviceBundle.PlatformProxy.CryptographyManager.CreateBase64UrlEncodedSha256Hash(codeVerifier);
			dictionary["code_challenge"] = value;
			dictionary["code_challenge_method"] = "S256";
			return new Tuple<Uri, string>(CreateInteractiveRequestParameters(authEndpoint, dictionary).Uri, codeVerifier);
		}

		private Tuple<Uri, string, string> CreateAuthorizationUri(string authEndpoint, bool addPkceAndState = false)
		{
			IDictionary<string, string> dictionary = CreateAuthorizationRequestParameters();
			string text = null;
			string item = null;
			if (addPkceAndState)
			{
				text = _serviceBundle.PlatformProxy.CryptographyManager.GenerateCodeVerifier();
				string value = _serviceBundle.PlatformProxy.CryptographyManager.CreateBase64UrlEncodedSha256Hash(text);
				dictionary["code_challenge"] = value;
				dictionary["code_challenge_method"] = "S256";
				item = (dictionary["state"] = Guid.NewGuid().ToString() + Guid.NewGuid().ToString());
			}
			dictionary["client_info"] = "1";
			return new Tuple<Uri, string, string>(CreateInteractiveRequestParameters(authEndpoint, dictionary).Uri, item, text);
		}

		private UriBuilder CreateInteractiveRequestParameters(string authEndpoint, IDictionary<string, string> requestParameters)
		{
			if (_interactiveParameters.Account != null)
			{
				if (!string.IsNullOrEmpty(_interactiveParameters.Account.Username))
				{
					requestParameters["login_hint"] = _interactiveParameters.Account.Username;
				}
				if (_interactiveParameters.Account.HomeAccountId?.ObjectId != null)
				{
					requestParameters["login_req"] = _interactiveParameters.Account.HomeAccountId.ObjectId;
				}
				if (!string.IsNullOrEmpty(_interactiveParameters.Account.HomeAccountId?.TenantId))
				{
					requestParameters["domain_req"] = _interactiveParameters.Account.HomeAccountId.TenantId;
				}
			}
			CheckForDuplicateQueryParameters(_requestParams.ExtraQueryParameters, requestParameters);
			string queryParams = requestParameters.ToQueryParameter();
			UriBuilder uriBuilder = new UriBuilder(authEndpoint);
			uriBuilder.AppendQueryParameters(queryParams);
			return uriBuilder;
		}

		private Dictionary<string, string> CreateAuthorizationRequestParameters(Uri redirectUriOverride = null)
		{
			HashSet<string> hashSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			if (!_interactiveParameters.ExtraScopesToConsent.IsNullOrEmpty())
			{
				hashSet = ScopeHelper.CreateScopeSet(_interactiveParameters.ExtraScopesToConsent);
			}
			if (hashSet.Contains(_requestParams.AppConfig.ClientId))
			{
				throw new ArgumentException("API does not accept client id as a user-provided scope");
			}
			HashSet<string> msalScopes = ScopeHelper.GetMsalScopes(new HashSet<string>(_requestParams.Scope.Concat(hashSet)));
			Dictionary<string, string> dictionary = new Dictionary<string, string>
			{
				["scope"] = msalScopes.AsSingleString(),
				["response_type"] = "code",
				["client_id"] = _requestParams.AppConfig.ClientId,
				["redirect_uri"] = redirectUriOverride?.OriginalString ?? _requestParams.RedirectUri.OriginalString
			};
			if (!string.IsNullOrWhiteSpace(_requestParams.ClaimsAndClientCapabilities))
			{
				dictionary["claims"] = _requestParams.ClaimsAndClientCapabilities;
			}
			if (!string.IsNullOrWhiteSpace(_interactiveParameters.LoginHint) || _requestParams.CcsRoutingHint.HasValue)
			{
				string value;
				if (!_requestParams.CcsRoutingHint.HasValue)
				{
					dictionary["login_hint"] = _interactiveParameters.LoginHint;
					value = CoreHelpers.GetCcsUpnHint(_interactiveParameters.LoginHint);
				}
				else
				{
					dictionary["login_hint"] = _interactiveParameters.LoginHint;
					value = CoreHelpers.GetCcsClientInfoHint(_requestParams.CcsRoutingHint.Value.Key, _requestParams.CcsRoutingHint.Value.Value);
				}
				dictionary["x-anchormailbox"] = value;
			}
			if (_requestParams.RequestContext.CorrelationId != Guid.Empty)
			{
				dictionary["client-request-id"] = _requestParams.RequestContext.CorrelationId.ToString();
			}
			foreach (KeyValuePair<string, string> msalIdParameter in MsalIdHelper.GetMsalIdParameters(_requestParams.RequestContext.Logger))
			{
				dictionary[msalIdParameter.Key] = msalIdParameter.Value;
			}
			if (_interactiveParameters.Prompt == Prompt.NotSpecified)
			{
				dictionary["prompt"] = Prompt.SelectAccount.PromptValue;
			}
			else if (_interactiveParameters.Prompt.PromptValue != Prompt.NoPrompt.PromptValue)
			{
				dictionary["prompt"] = _interactiveParameters.Prompt.PromptValue;
			}
			return dictionary;
		}

		private static void CheckForDuplicateQueryParameters(IDictionary<string, string> queryParamsDictionary, IDictionary<string, string> requestParameters)
		{
			foreach (KeyValuePair<string, string> item in queryParamsDictionary)
			{
				if (requestParameters.ContainsKey(item.Key))
				{
					throw new MsalClientException("duplicate_query_parameter", string.Format(CultureInfo.InvariantCulture, "Duplicate query parameter '{0}' in extraQueryParameters. ", item.Key));
				}
				requestParameters[item.Key] = item.Value;
			}
		}

		private void VerifyAuthorizationResult(AuthorizationResult authorizationResult, string originalState)
		{
			if (authorizationResult.Status == AuthorizationStatus.Success && originalState != null && !originalState.Equals(authorizationResult.State, StringComparison.OrdinalIgnoreCase))
			{
				throw new MsalClientException("state_mismatch", string.Format(CultureInfo.InvariantCulture, "Returned state({0}) from authorize endpoint is not the same as the one sent({1}). See https://aka.ms/msal-statemismatcherror for more details. ", authorizationResult.State, originalState));
			}
			if (authorizationResult.Error == "login_required")
			{
				throw new MsalUiRequiredException("no_prompt_failed", "One of two conditions was encountered: 1. The Prompt.Never flag was passed, but the constraint could not be honored, because user interaction was required. 2. An error occurred during a silent web authentication that prevented the HTTP authentication flow from completing in a short enough time frame. ", null, UiRequiredExceptionClassification.PromptNeverFailed);
			}
			if (authorizationResult.Status == AuthorizationStatus.UserCancel)
			{
				_requestParams.RequestContext.Logger.Info("Authorization result status returned user cancelled authentication. ");
				throw new MsalClientException(authorizationResult.Error, authorizationResult.ErrorDescription ?? "User canceled authentication.");
			}
			if (authorizationResult.Status != AuthorizationStatus.Success)
			{
				_requestParams.RequestContext.Logger.ErrorPii("Authorization result was not successful. See error message for more details. " + authorizationResult.ErrorDescription, "Authorization result was not successful. See error message for more details. ");
				throw new MsalServiceException(authorizationResult.Error, (!string.IsNullOrEmpty(authorizationResult.ErrorDescription)) ? authorizationResult.ErrorDescription : "Unknown error");
			}
		}

		private IWebUI CreateWebAuthenticationDialog()
		{
			if (_interactiveParameters.CustomWebUi != null)
			{
				return new CustomWebUiHandler(_interactiveParameters.CustomWebUi);
			}
			CoreUIParent uiParent = _interactiveParameters.UiParent;
			return _serviceBundle.PlatformProxy.GetWebUiFactory(_requestParams.AppConfig).CreateAuthenticationDialog(uiParent, _interactiveParameters.UseEmbeddedWebView, _requestParams.RequestContext);
		}
	}
	internal interface IAuthCodeRequestComponent
	{
		Task<Tuple<AuthorizationResult, string>> FetchAuthCodeAndPkceVerifierAsync(CancellationToken cancellationToken);

		Task<Uri> GetAuthorizationUriWithoutPkceAsync(CancellationToken cancellationToken);
	}
	internal static class SilentRequestHelper
	{
		internal const string MamEnrollmentIdKey = "microsoft_enrollment_id";

		internal const string ProactiveRefreshServiceError = "Proactive token refresh failed with MsalServiceException.";

		internal const string ProactiveRefreshGeneralError = "Proactive token refresh failed with exception.";

		internal const string ProactiveRefreshCancellationError = "Proactive token refresh was canceled.";

		private static Random s_random = new Random();

		internal static async Task<MsalTokenResponse> RefreshAccessTokenAsync(MsalRefreshTokenCacheItem msalRefreshTokenItem, RequestBase request, AuthenticationRequestParameters authenticationRequestParameters, CancellationToken cancellationToken)
		{
			authenticationRequestParameters.RequestContext.Logger.Verbose(() => "Refreshing access token...");
			await authenticationRequestParameters.AuthorityManager.RunInstanceDiscoveryAndValidationAsync().ConfigureAwait(continueOnCapturedContext: false);
			Dictionary<string, string> bodyParameters = GetBodyParameters(msalRefreshTokenItem.Secret);
			MsalTokenResponse msalTokenResponse = await request.SendTokenRequestAsync(bodyParameters, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (msalTokenResponse.RefreshToken == null)
			{
				msalTokenResponse.RefreshToken = msalRefreshTokenItem.Secret;
				authenticationRequestParameters.RequestContext.Logger.Warning("Refresh token was missing from the token refresh response, so the refresh token in the request is returned instead. ");
			}
			return msalTokenResponse;
		}

		private static Dictionary<string, string> GetBodyParameters(string refreshTokenSecret)
		{
			return new Dictionary<string, string>
			{
				["client_info"] = "1",
				["grant_type"] = "refresh_token",
				["refresh_token"] = refreshTokenSecret
			};
		}

		internal static bool NeedsRefresh(MsalAccessTokenCacheItem oldAccessToken)
		{
			DateTimeOffset? refreshOnWithJitter;
			return NeedsRefresh(oldAccessToken, out refreshOnWithJitter);
		}

		internal static bool NeedsRefresh(MsalAccessTokenCacheItem oldAccessToken, out DateTimeOffset? refreshOnWithJitter)
		{
			refreshOnWithJitter = GetRefreshOnWithJitter(oldAccessToken);
			if (refreshOnWithJitter.HasValue && refreshOnWithJitter.Value < DateTimeOffset.UtcNow)
			{
				return true;
			}
			return false;
		}

		internal static void ProcessFetchInBackground(MsalAccessTokenCacheItem oldAccessToken, Func<Task<AuthenticationResult>> fetchAction, ILoggerAdapter logger, IServiceBundle serviceBundle, ApiEvent.ApiIds apiId)
		{
			Task.Run(async delegate
			{
				try
				{
					await fetchAction().ConfigureAwait(continueOnCapturedContext: false);
					serviceBundle.PlatformProxy.OtelInstrumentation.IncrementSuccessCounter(serviceBundle.PlatformProxy.GetProductName(), apiId, TokenSource.IdentityProvider, CacheRefreshReason.ProactivelyRefreshed, CacheLevel.None, logger);
				}
				catch (MsalServiceException ex)
				{
					string prefix = string.Format("{0} Is exception retryable? {1}", "Proactive token refresh failed with MsalServiceException.", ex.IsRetryable);
					if (ex.StatusCode == 400)
					{
						logger.ErrorPiiWithPrefix(ex, prefix);
					}
					else
					{
						logger.ErrorPiiWithPrefix(ex, prefix);
					}
					serviceBundle.PlatformProxy.OtelInstrumentation.LogFailureMetrics(serviceBundle.PlatformProxy.GetProductName(), ex.ErrorCode, apiId, CacheRefreshReason.ProactivelyRefreshed);
				}
				catch (OperationCanceledException ex2)
				{
					logger.WarningPiiWithPrefix(ex2, "Proactive token refresh was canceled.");
					serviceBundle.PlatformProxy.OtelInstrumentation.LogFailureMetrics(serviceBundle.PlatformProxy.GetProductName(), ex2.GetType().Name, apiId, CacheRefreshReason.ProactivelyRefreshed);
				}
				catch (Exception ex3)
				{
					logger.ErrorPiiWithPrefix(ex3, "Proactive token refresh failed with exception.");
					serviceBundle.PlatformProxy.OtelInstrumentation.LogFailureMetrics(serviceBundle.PlatformProxy.GetProductName(), ex3.GetType().Name, apiId, CacheRefreshReason.ProactivelyRefreshed);
				}
			});
		}

		private static DateTimeOffset? GetRefreshOnWithJitter(MsalAccessTokenCacheItem msalAccessTokenCacheItem)
		{
			if (msalAccessTokenCacheItem.RefreshOn.HasValue)
			{
				int num = s_random.Next(-300, 300);
				return msalAccessTokenCacheItem.RefreshOn.Value + TimeSpan.FromSeconds(num);
			}
			return null;
		}
	}
	internal class ServiceBundle : IServiceBundle
	{
		public ILoggerAdapter ApplicationLogger { get; }

		public IHttpManager HttpManager { get; }

		public IInstanceDiscoveryManager InstanceDiscoveryManager { get; }

		public IWsTrustWebRequestManager WsTrustWebRequestManager { get; }

		public IPlatformProxy PlatformProxy { get; private set; }

		public ApplicationConfiguration Config { get; }

		public IDeviceAuthManager DeviceAuthManager { get; }

		public IHttpTelemetryManager HttpTelemetryManager { get; }

		public IThrottlingProvider ThrottlingManager { get; }

		internal ServiceBundle(ApplicationConfiguration config, bool shouldClearCaches = false)
		{
			Config = config;
			ApplicationLogger = LoggerHelper.CreateLogger(Guid.Empty, config);
			PlatformProxy = config.PlatformProxy ?? PlatformProxyFactory.CreatePlatformProxy(ApplicationLogger);
			HttpManager = config.HttpManager ?? HttpManagerFactory.GetHttpManager(config.HttpClientFactory ?? PlatformProxy.CreateDefaultHttpClientFactory(), config.RetryOnServerErrors, config.IsManagedIdentity);
			HttpTelemetryManager = new HttpTelemetryManager();
			InstanceDiscoveryManager = new InstanceDiscoveryManager(HttpManager, shouldClearCaches, config.CustomInstanceDiscoveryMetadata, config.CustomInstanceDiscoveryMetadataUri);
			WsTrustWebRequestManager = new WsTrustWebRequestManager(HttpManager);
			ThrottlingManager = SingletonThrottlingManager.GetInstance();
			DeviceAuthManager = config.DeviceAuthManagerForTest ?? PlatformProxy.CreateDeviceAuthManager();
			if (shouldClearCaches)
			{
				AuthorityManager.ClearValidationCache();
				PoPProviderFactory.Reset();
			}
		}

		public static ServiceBundle Create(ApplicationConfiguration config)
		{
			return new ServiceBundle(config);
		}

		public void SetPlatformProxyForTest(IPlatformProxy platformProxy)
		{
			PlatformProxy = platformProxy;
		}
	}
	internal static class XmlNamespace
	{
		public static readonly XNamespace Wsdl = "http://schemas.xmlsoap.org/wsdl/";

		public static readonly XNamespace Wsp = "http://schemas.xmlsoap.org/ws/2004/09/policy";

		public static readonly XNamespace Http = "http://schemas.microsoft.com/ws/06/2004/policy/http";

		public static readonly XNamespace Sp = "http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702";

		public static readonly XNamespace Sp2005 = "http://schemas.xmlsoap.org/ws/2005/07/securitypolicy";

		public static readonly XNamespace Wsu = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd";

		public static readonly XNamespace Soap12 = "http://schemas.xmlsoap.org/wsdl/soap12/";

		public static readonly XNamespace Wsa10 = "http://www.w3.org/2005/08/addressing";

		public static readonly XNamespace Trust = "http://docs.oasis-open.org/ws-sx/ws-trust/200512";

		public static readonly XNamespace Trust2005 = "http://schemas.xmlsoap.org/ws/2005/02/trust";

		public static readonly XNamespace Issue = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue";

		public static readonly XNamespace Issue2005 = "http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue";

		public static readonly XNamespace SoapEnvelope = "http://www.w3.org/2003/05/soap-envelope";
	}
}
namespace Microsoft.Identity.Client.Internal.Requests
{
	internal class AuthenticationRequestParameters
	{
		private readonly IServiceBundle _serviceBundle;

		private readonly AcquireTokenCommonParameters _commonParameters;

		private string _loginHint;

		public ApplicationConfiguration AppConfig => _serviceBundle.Config;

		public ApiEvent.ApiIds ApiId => _commonParameters.ApiId;

		public RequestContext RequestContext { get; }

		public AuthorityManager AuthorityManager { get; set; }

		public Authority Authority => AuthorityManager.Authority;

		public AuthorityInfo AuthorityInfo => AuthorityManager.Authority.AuthorityInfo;

		public AuthorityInfo AuthorityOverride => _commonParameters.AuthorityOverride;

		public ICacheSessionManager CacheSessionManager { get; }

		public HashSet<string> Scope { get; }

		public Uri RedirectUri { get; set; }

		public IDictionary<string, string> ExtraQueryParameters { get; }

		public string ClaimsAndClientCapabilities { get; private set; }

		public Guid CorrelationId => _commonParameters.CorrelationId;

		public string Claims => _commonParameters.Claims;

		public IAuthenticationScheme AuthenticationScheme => _commonParameters.AuthenticationScheme;

		public bool SendX5C { get; set; }

		public string LoginHint
		{
			get
			{
				if (string.IsNullOrEmpty(_loginHint) && Account != null)
				{
					return Account.Username;
				}
				return _loginHint;
			}
			set
			{
				_loginHint = value;
			}
		}

		public IAccount Account { get; set; }

		public string HomeAccountId { get; }

		public Func<OnBeforeTokenRequestData, Task> OnBeforeTokenRequestHandler => _commonParameters.OnBeforeTokenRequestHandler;

		public IDictionary<string, string> ExtraHttpHeaders => _commonParameters.ExtraHttpHeaders;

		public bool IsClientCredentialRequest => ApiId == ApiEvent.ApiIds.AcquireTokenForClient;

		public PoPAuthenticationConfiguration PopAuthenticationConfiguration => _commonParameters.PopAuthenticationConfiguration;

		public UserAssertion UserAssertion { get; set; }

		public string LongRunningOboCacheKey { get; set; }

		public KeyValuePair<string, string>? CcsRoutingHint { get; set; }

		public AuthenticationRequestParameters(IServiceBundle serviceBundle, ITokenCacheInternal tokenCache, AcquireTokenCommonParameters commonParameters, RequestContext requestContext, Authority initialAuthority, string homeAccountId = null)
		{
			_serviceBundle = serviceBundle;
			_commonParameters = commonParameters;
			RequestContext = requestContext;
			CacheSessionManager = new CacheSessionManager(tokenCache, this);
			Scope = ScopeHelper.CreateScopeSet(commonParameters.Scopes);
			RedirectUri = new Uri(serviceBundle.Config.RedirectUri);
			AuthorityManager = new AuthorityManager(RequestContext, initialAuthority);
			ExtraQueryParameters = serviceBundle.Config.ExtraQueryParameters ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			if (commonParameters.ExtraQueryParameters != null)
			{
				foreach (KeyValuePair<string, string> extraQueryParameter in commonParameters.ExtraQueryParameters)
				{
					ExtraQueryParameters[extraQueryParameter.Key] = extraQueryParameter.Value;
				}
			}
			ClaimsAndClientCapabilities = ClaimsHelper.GetMergedClaimsAndClientCapabilities(_commonParameters.Claims, _serviceBundle.Config.ClientCapabilities);
			HomeAccountId = homeAccountId;
		}

		public void LogParameters()
		{
			ILoggerAdapter logger = RequestContext.Logger;
			if (logger.IsLoggingEnabled(LogLevel.Info))
			{
				StringBuilder stringBuilder = new StringBuilder(Environment.NewLine + "=== Request Data ===" + Environment.NewLine + "Authority Provided? - " + (Authority != null) + Environment.NewLine);
				stringBuilder.AppendLine("Client Id - " + AppConfig.ClientId);
				stringBuilder.AppendLine("Scopes - " + Scope?.AsSingleString());
				stringBuilder.AppendLine("Redirect Uri - " + RedirectUri?.OriginalString);
				stringBuilder.AppendLine("Extra Query Params Keys (space separated) - " + ExtraQueryParameters.Keys.AsSingleString());
				stringBuilder.AppendLine("ClaimsAndClientCapabilities - " + ClaimsAndClientCapabilities);
				stringBuilder.AppendLine("Authority - " + AuthorityInfo?.CanonicalAuthority);
				stringBuilder.AppendLine("ApiId - " + ApiId);
				stringBuilder.AppendLine("IsConfidentialClient - " + AppConfig.IsConfidentialClient);
				stringBuilder.AppendLine("SendX5C - " + SendX5C);
				stringBuilder.AppendLine("LoginHint - " + LoginHint);
				stringBuilder.AppendLine("IsBrokerConfigured - " + AppConfig.IsBrokerEnabled);
				stringBuilder.AppendLine("HomeAccountId - " + HomeAccountId);
				stringBuilder.AppendLine("CorrelationId - " + CorrelationId.ToString());
				stringBuilder.AppendLine("UserAssertion set: " + (UserAssertion != null));
				stringBuilder.AppendLine("LongRunningOboCacheKey set: " + !string.IsNullOrWhiteSpace(LongRunningOboCacheKey));
				stringBuilder.AppendLine("Region configured: " + AppConfig.AzureRegion);
				string messageWithPii = stringBuilder.ToString();
				stringBuilder = new StringBuilder(Environment.NewLine + "=== Request Data ===" + Environment.NewLine + "Authority Provided? - " + (Authority != null) + Environment.NewLine);
				stringBuilder.AppendLine("Scopes - " + Scope?.AsSingleString());
				stringBuilder.AppendLine("Extra Query Params Keys (space separated) - " + ExtraQueryParameters.Keys.AsSingleString());
				stringBuilder.AppendLine("ApiId - " + ApiId);
				stringBuilder.AppendLine("IsConfidentialClient - " + AppConfig.IsConfidentialClient);
				stringBuilder.AppendLine("SendX5C - " + SendX5C);
				stringBuilder.AppendLine("LoginHint ? " + !string.IsNullOrEmpty(LoginHint));
				stringBuilder.AppendLine("IsBrokerConfigured - " + AppConfig.IsBrokerEnabled);
				stringBuilder.AppendLine("HomeAccountId - " + !string.IsNullOrEmpty(HomeAccountId));
				stringBuilder.AppendLine("CorrelationId - " + CorrelationId.ToString());
				stringBuilder.AppendLine("UserAssertion set: " + (UserAssertion != null));
				stringBuilder.AppendLine("LongRunningOboCacheKey set: " + !string.IsNullOrWhiteSpace(LongRunningOboCacheKey));
				stringBuilder.AppendLine("Region configured: " + AppConfig.AzureRegion);
				logger.InfoPii(messageWithPii, stringBuilder.ToString());
			}
		}
	}
	internal class ByRefreshTokenRequest : RequestBase
	{
		private readonly AcquireTokenByRefreshTokenParameters _refreshTokenParameters;

		public ByRefreshTokenRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByRefreshTokenParameters refreshTokenParameters)
			: base(serviceBundle, authenticationRequestParameters, refreshTokenParameters)
		{
			_refreshTokenParameters = refreshTokenParameters;
		}

		protected override async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			base.AuthenticationRequestParameters.RequestContext.Logger.Verbose(() => "Begin acquire token by refresh token...");
			await ResolveAuthorityAsync().ConfigureAwait(continueOnCapturedContext: false);
			MsalTokenResponse msalTokenResponse = await SendTokenRequestAsync(GetBodyParameters(_refreshTokenParameters.RefreshToken), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (msalTokenResponse.RefreshToken == null)
			{
				base.AuthenticationRequestParameters.RequestContext.Logger.Error("Acquire by refresh token request completed, but no refresh token was found. ");
				throw new MsalServiceException(msalTokenResponse.Error, msalTokenResponse.ErrorDescription, null);
			}
			return await CacheTokenResponseAndCreateAuthenticationResultAsync(msalTokenResponse).ConfigureAwait(continueOnCapturedContext: false);
		}

		private static Dictionary<string, string> GetBodyParameters(string refreshTokenSecret)
		{
			return new Dictionary<string, string>
			{
				["grant_type"] = "refresh_token",
				["refresh_token"] = refreshTokenSecret,
				["client_info"] = "1"
			};
		}
	}
	internal class ClientCredentialRequest : RequestBase
	{
		private readonly AcquireTokenForClientParameters _clientParameters;

		private static readonly SemaphoreSlim s_semaphoreSlim = new SemaphoreSlim(1, 1);

		public ClientCredentialRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenForClientParameters clientParameters)
			: base(serviceBundle, authenticationRequestParameters, clientParameters)
		{
			_clientParameters = clientParameters;
		}

		protected override async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			if (base.AuthenticationRequestParameters.Scope == null || base.AuthenticationRequestParameters.Scope.Count == 0)
			{
				throw new MsalClientException("scopes_required_client_credentials", "At least one scope needs to be requested for this authentication flow. ");
			}
			ILoggerAdapter logger = base.AuthenticationRequestParameters.RequestContext.Logger;
			if (base.AuthenticationRequestParameters.Authority is AadAuthority aadAuthority && aadAuthority.IsCommonOrOrganizationsTenant())
			{
				logger.Error("The current authority is targeting the /common or /organizations endpoint which is not recommended. See https://aka.ms/msal-net-client-credentials for more details.");
			}
			if (_clientParameters.ForceRefresh || !string.IsNullOrEmpty(base.AuthenticationRequestParameters.Claims))
			{
				base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo = CacheRefreshReason.ForceRefreshOrClaims;
				logger.Info("[ClientCredentialRequest] Skipped looking for a cached access token because ForceRefresh or Claims were set.");
				return await GetAccessTokenAsync(cancellationToken, logger).ConfigureAwait(continueOnCapturedContext: false);
			}
			MsalAccessTokenCacheItem msalAccessTokenCacheItem = await GetCachedAccessTokenAsync().ConfigureAwait(continueOnCapturedContext: false);
			AuthenticationResult result;
			if (msalAccessTokenCacheItem != null)
			{
				result = CreateAuthenticationResultFromCache(msalAccessTokenCacheItem);
				try
				{
					if (SilentRequestHelper.NeedsRefresh(msalAccessTokenCacheItem))
					{
						base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo = CacheRefreshReason.ProactivelyRefreshed;
						SilentRequestHelper.ProcessFetchInBackground(msalAccessTokenCacheItem, delegate
						{
							using CancellationTokenSource cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
							return GetAccessTokenAsync(cancellationTokenSource.Token, logger);
						}, logger, base.ServiceBundle, base.AuthenticationRequestParameters.RequestContext.ApiEvent.ApiId);
					}
				}
				catch (MsalServiceException e)
				{
					return await HandleTokenRefreshErrorAsync(e, msalAccessTokenCacheItem).ConfigureAwait(continueOnCapturedContext: false);
				}
			}
			else
			{
				if (base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo != CacheRefreshReason.Expired)
				{
					base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo = CacheRefreshReason.NoCachedAccessToken;
				}
				result = await GetAccessTokenAsync(cancellationToken, logger).ConfigureAwait(continueOnCapturedContext: false);
			}
			return result;
		}

		private async Task<AuthenticationResult> GetAccessTokenAsync(CancellationToken cancellationToken, ILoggerAdapter logger)
		{
			await ResolveAuthorityAsync().ConfigureAwait(continueOnCapturedContext: false);
			if (base.ServiceBundle.Config.AppTokenProvider == null)
			{
				return await CacheTokenResponseAndCreateAuthenticationResultAsync(await SendTokenRequestAsync(GetBodyParameters(), cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).ConfigureAwait(continueOnCapturedContext: false);
			}
			logger.Verbose(() => "[ClientCredentialRequest] Entering client credential request semaphore.");
			await s_semaphoreSlim.WaitAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			logger.Verbose(() => "[ClientCredentialRequest] Entered client credential request semaphore.");
			try
			{
				AuthenticationResult result;
				if (_clientParameters.ForceRefresh || base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo == CacheRefreshReason.ProactivelyRefreshed || !string.IsNullOrEmpty(base.AuthenticationRequestParameters.Claims))
				{
					result = await SendTokenRequestToAppTokenProviderAsync(logger, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				else
				{
					MsalAccessTokenCacheItem msalAccessTokenCacheItem = await GetCachedAccessTokenAsync().ConfigureAwait(continueOnCapturedContext: false);
					if (msalAccessTokenCacheItem == null)
					{
						result = await SendTokenRequestToAppTokenProviderAsync(logger, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						logger.Verbose(() => "[ClientCredentialRequest] Checking for a cached access token.");
						result = CreateAuthenticationResultFromCache(msalAccessTokenCacheItem);
					}
				}
				return result;
			}
			finally
			{
				s_semaphoreSlim.Release();
				logger.Verbose(() => "[ClientCredentialRequest] Released client credential request semaphore.");
			}
		}

		private async Task<AuthenticationResult> SendTokenRequestToAppTokenProviderAsync(ILoggerAdapter logger, CancellationToken cancellationToken)
		{
			logger.Info("[ClientCredentialRequest] Acquiring a token from the token provider.");
			AppTokenProviderParameters appTokenProviderParameters = new AppTokenProviderParameters
			{
				Scopes = GetOverriddenScopes(base.AuthenticationRequestParameters.Scope),
				CorrelationId = base.AuthenticationRequestParameters.RequestContext.CorrelationId.ToString(),
				Claims = base.AuthenticationRequestParameters.Claims,
				TenantId = base.AuthenticationRequestParameters.Authority.TenantId,
				CancellationToken = cancellationToken
			};
			MsalTokenResponse msalTokenResponse = MsalTokenResponse.CreateFromAppProviderResponse(await base.ServiceBundle.Config.AppTokenProvider(appTokenProviderParameters).ConfigureAwait(continueOnCapturedContext: false));
			msalTokenResponse.Scope = appTokenProviderParameters.Scopes.AsSingleString();
			msalTokenResponse.CorrelationId = appTokenProviderParameters.CorrelationId;
			return await CacheTokenResponseAndCreateAuthenticationResultAsync(msalTokenResponse).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<MsalAccessTokenCacheItem> GetCachedAccessTokenAsync()
		{
			MsalAccessTokenCacheItem msalAccessTokenCacheItem = await base.CacheManager.FindAccessTokenAsync().ConfigureAwait(continueOnCapturedContext: false);
			if (msalAccessTokenCacheItem != null && !_clientParameters.ForceRefresh)
			{
				base.AuthenticationRequestParameters.RequestContext.ApiEvent.IsAccessTokenCacheHit = true;
				Metrics.IncrementTotalAccessTokensFromCache();
				return msalAccessTokenCacheItem;
			}
			return null;
		}

		private AuthenticationResult CreateAuthenticationResultFromCache(MsalAccessTokenCacheItem cachedAccessTokenItem)
		{
			return new AuthenticationResult(cachedAccessTokenItem, null, base.AuthenticationRequestParameters.AuthenticationScheme, base.AuthenticationRequestParameters.RequestContext.CorrelationId, TokenSource.Cache, base.AuthenticationRequestParameters.RequestContext.ApiEvent, null, null, null);
		}

		protected override SortedSet<string> GetOverriddenScopes(ISet<string> inputScopes)
		{
			return new SortedSet<string>(inputScopes);
		}

		private Dictionary<string, string> GetBodyParameters()
		{
			return new Dictionary<string, string>
			{
				["grant_type"] = "client_credentials",
				["scope"] = base.AuthenticationRequestParameters.Scope.AsSingleString()
			};
		}

		protected override KeyValuePair<string, string>? GetCcsHeader(IDictionary<string, string> additionalBodyParameters)
		{
			return null;
		}
	}
	internal class ConfidentialAuthCodeRequest : RequestBase
	{
		private readonly AcquireTokenByAuthorizationCodeParameters _authorizationCodeParameters;

		public ConfidentialAuthCodeRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByAuthorizationCodeParameters authorizationCodeParameters)
			: base(serviceBundle, authenticationRequestParameters, authorizationCodeParameters)
		{
			_authorizationCodeParameters = authorizationCodeParameters;
			RedirectUriHelper.Validate(authenticationRequestParameters.RedirectUri);
		}

		protected override async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			await ResolveAuthorityAsync().ConfigureAwait(continueOnCapturedContext: false);
			return await CacheTokenResponseAndCreateAuthenticationResultAsync(await SendTokenRequestAsync(GetBodyParameters(), cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).ConfigureAwait(continueOnCapturedContext: false);
		}

		private Dictionary<string, string> GetBodyParameters()
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>
			{
				["client_info"] = "1",
				["grant_type"] = "authorization_code",
				["code"] = _authorizationCodeParameters.AuthorizationCode,
				["redirect_uri"] = base.AuthenticationRequestParameters.RedirectUri.OriginalString
			};
			if (!string.IsNullOrEmpty(_authorizationCodeParameters.PkceCodeVerifier))
			{
				dictionary["code_verifier"] = _authorizationCodeParameters.PkceCodeVerifier;
			}
			if (_authorizationCodeParameters.SpaCode)
			{
				dictionary["return_spa_code"] = "1";
			}
			return dictionary;
		}
	}
	internal class DeviceCodeRequest : RequestBase
	{
		private readonly AcquireTokenWithDeviceCodeParameters _deviceCodeParameters;

		public DeviceCodeRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenWithDeviceCodeParameters deviceCodeParameters)
			: base(serviceBundle, authenticationRequestParameters, deviceCodeParameters)
		{
			_deviceCodeParameters = deviceCodeParameters;
		}

		protected override async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			await ResolveAuthorityAsync().ConfigureAwait(continueOnCapturedContext: false);
			OAuth2Client client = new OAuth2Client(base.ServiceBundle.ApplicationLogger, base.ServiceBundle.HttpManager);
			HashSet<string> deviceCodeScopes = new HashSet<string>();
			deviceCodeScopes.UnionWith(base.AuthenticationRequestParameters.Scope);
			deviceCodeScopes.Add("offline_access");
			deviceCodeScopes.Add("profile");
			deviceCodeScopes.Add("openid");
			client.AddBodyParameter("client_id", base.AuthenticationRequestParameters.AppConfig.ClientId);
			client.AddBodyParameter("scope", deviceCodeScopes.AsSingleString());
			client.AddBodyParameter("claims", base.AuthenticationRequestParameters.ClaimsAndClientCapabilities);
			UriBuilder uriBuilder = new UriBuilder(await base.AuthenticationRequestParameters.Authority.GetDeviceCodeEndpointAsync(base.AuthenticationRequestParameters.RequestContext).ConfigureAwait(continueOnCapturedContext: false));
			uriBuilder.AppendQueryParameters(base.AuthenticationRequestParameters.ExtraQueryParameters);
			DeviceCodeResult deviceCodeResult = (await client.ExecuteRequestAsync<DeviceCodeResponse>(uriBuilder.Uri, HttpMethod.Post, base.AuthenticationRequestParameters.RequestContext, expectErrorsOn200OK: true).ConfigureAwait(continueOnCapturedContext: false)).GetResult(base.AuthenticationRequestParameters.AppConfig.ClientId, deviceCodeScopes);
			await _deviceCodeParameters.DeviceCodeResultCallback(deviceCodeResult).ConfigureAwait(continueOnCapturedContext: false);
			return await CacheTokenResponseAndCreateAuthenticationResultAsync(await WaitForTokenResponseAsync(deviceCodeResult, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<MsalTokenResponse> WaitForTokenResponseAsync(DeviceCodeResult deviceCodeResult, CancellationToken cancellationToken)
		{
			TimeSpan timeRemaining = deviceCodeResult.ExpiresOn - DateTimeOffset.UtcNow;
			while (timeRemaining.TotalSeconds > 0.0)
			{
				if (cancellationToken.IsCancellationRequested)
				{
					throw new OperationCanceledException();
				}
				try
				{
					MsalTokenResponse result = await SendTokenRequestAsync(await base.AuthenticationRequestParameters.Authority.GetTokenEndpointAsync(base.AuthenticationRequestParameters.RequestContext).ConfigureAwait(continueOnCapturedContext: false), GetBodyParameters(deviceCodeResult), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					Metrics.IncrementTotalAccessTokensFromIdP();
					return result;
				}
				catch (MsalServiceException ex)
				{
					if (ex.ErrorCode.Equals("authorization_pending", StringComparison.OrdinalIgnoreCase))
					{
						await Task.Delay(TimeSpan.FromSeconds(deviceCodeResult.Interval), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						timeRemaining = deviceCodeResult.ExpiresOn - DateTimeOffset.UtcNow;
					}
					else
					{
						ExceptionDispatchInfo.Capture((ex as Exception) ?? throw ex).Throw();
					}
				}
			}
			throw new MsalClientException("code_expired", "Verification code expired before contacting the server");
		}

		private static Dictionary<string, string> GetBodyParameters(DeviceCodeResult deviceCodeResult)
		{
			return new Dictionary<string, string>
			{
				["client_info"] = "1",
				["grant_type"] = "device_code",
				["device_code"] = deviceCodeResult.DeviceCode
			};
		}

		protected override KeyValuePair<string, string>? GetCcsHeader(IDictionary<string, string> additionalBodyParameters)
		{
			return null;
		}
	}
	internal class IntegratedWindowsAuthRequest : RequestBase
	{
		private readonly CommonNonInteractiveHandler _commonNonInteractiveHandler;

		private readonly AcquireTokenByIntegratedWindowsAuthParameters _integratedWindowsAuthParameters;

		public IntegratedWindowsAuthRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByIntegratedWindowsAuthParameters integratedWindowsAuthParameters)
			: base(serviceBundle, authenticationRequestParameters, integratedWindowsAuthParameters)
		{
			_integratedWindowsAuthParameters = integratedWindowsAuthParameters;
			_commonNonInteractiveHandler = new CommonNonInteractiveHandler(authenticationRequestParameters.RequestContext, serviceBundle);
		}

		protected override async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			await ResolveAuthorityAsync().ConfigureAwait(continueOnCapturedContext: false);
			await UpdateUsernameAsync().ConfigureAwait(continueOnCapturedContext: false);
			return await CacheTokenResponseAndCreateAuthenticationResultAsync(await SendTokenRequestAsync(GetAdditionalBodyParameters(await FetchAssertionFromWsTrustAsync().ConfigureAwait(continueOnCapturedContext: false)), cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).ConfigureAwait(continueOnCapturedContext: false);
		}

		protected override KeyValuePair<string, string>? GetCcsHeader(IDictionary<string, string> additionalBodyParameters)
		{
			return GetCcsUpnHeader(_integratedWindowsAuthParameters.Username);
		}

		private async Task<UserAssertion> FetchAssertionFromWsTrustAsync()
		{
			if (!base.AuthenticationRequestParameters.AuthorityInfo.IsWsTrustFlowSupported)
			{
				throw new MsalClientException("integrated_windows_authentication_failed", "Integrated windows authenticaiton is not supported when using WithAdfsAuthority() to specify the authority in ADFS on premises environments See https://aka.ms/msal-net-iwa for more details.");
			}
			UserRealmDiscoveryResponse userRealmDiscoveryResponse = await _commonNonInteractiveHandler.QueryUserRealmDataAsync(base.AuthenticationRequestParameters.AuthorityInfo.UserRealmUriPrefix, _integratedWindowsAuthParameters.Username).ConfigureAwait(continueOnCapturedContext: false);
			if (userRealmDiscoveryResponse.IsFederated)
			{
				WsTrustResponse wsTrustResponse = await _commonNonInteractiveHandler.PerformWsTrustMexExchangeAsync(userRealmDiscoveryResponse.FederationMetadataUrl, userRealmDiscoveryResponse.CloudAudienceUrn, UserAuthType.IntegratedAuth, _integratedWindowsAuthParameters.Username, null, _integratedWindowsAuthParameters.FederationMetadata).ConfigureAwait(continueOnCapturedContext: false);
				return new UserAssertion(wsTrustResponse.Token, (wsTrustResponse.TokenType == "urn:oasis:names:tc:SAML:1.0:assertion") ? "urn:ietf:params:oauth:grant-type:saml1_1-bearer" : "urn:ietf:params:oauth:grant-type:saml2-bearer");
			}
			if (userRealmDiscoveryResponse.IsManaged)
			{
				throw new MsalClientException("integrated_windows_auth_not_supported_managed_user", "Integrated Windows Auth is not supported for managed users. See https://aka.ms/msal-net-iwa for details. ");
			}
			throw new MsalClientException("unknown_user_type", string.Format(CultureInfo.CurrentCulture, "Unsupported User Type '{0}'. Please see https://aka.ms/msal-net-up. ", userRealmDiscoveryResponse.AccountType));
		}

		private async Task UpdateUsernameAsync()
		{
			if (string.IsNullOrWhiteSpace(_integratedWindowsAuthParameters.Username))
			{
				string username = await _commonNonInteractiveHandler.GetPlatformUserAsync().ConfigureAwait(continueOnCapturedContext: false);
				_integratedWindowsAuthParameters.Username = username;
			}
		}

		private static Dictionary<string, string> GetAdditionalBodyParameters(UserAssertion userAssertion)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			if (userAssertion != null)
			{
				dictionary["client_info"] = "1";
				dictionary["grant_type"] = userAssertion.AssertionType;
				dictionary["assertion"] = Convert.ToBase64String(Encoding.UTF8.GetBytes(userAssertion.Assertion));
			}
			return dictionary;
		}
	}
	internal class AuthCodeExchangeComponent : ITokenRequestComponent
	{
		private readonly AuthenticationRequestParameters _requestParams;

		private readonly AcquireTokenInteractiveParameters _interactiveParameters;

		private readonly string _authorizationCode;

		private readonly string _pkceCodeVerifier;

		private readonly TokenClient _tokenClient;

		private readonly string _clientInfo;

		public AuthCodeExchangeComponent(AuthenticationRequestParameters requestParams, AcquireTokenInteractiveParameters interactiveParameters, string authorizationCode, string pkceCodeVerifier, string clientInfo)
		{
			_requestParams = requestParams ?? throw new ArgumentNullException("requestParams");
			_interactiveParameters = interactiveParameters ?? throw new ArgumentNullException("interactiveParameters");
			_authorizationCode = authorizationCode ?? throw new ArgumentNullException("authorizationCode");
			_pkceCodeVerifier = pkceCodeVerifier ?? throw new ArgumentNullException("pkceCodeVerifier");
			_clientInfo = clientInfo;
			_tokenClient = new TokenClient(requestParams);
			_interactiveParameters.LogParameters(requestParams.RequestContext.Logger);
		}

		public Task<MsalTokenResponse> FetchTokensAsync(CancellationToken cancellationToken)
		{
			AddCcsHeadersToTokenClient();
			return _tokenClient.SendTokenRequestAsync(GetBodyParameters(), null, null, cancellationToken);
		}

		private Dictionary<string, string> GetBodyParameters()
		{
			return new Dictionary<string, string>
			{
				["client_info"] = "1",
				["grant_type"] = "authorization_code",
				["code"] = _authorizationCode,
				["redirect_uri"] = _requestParams.RedirectUri.OriginalString,
				["code_verifier"] = _pkceCodeVerifier
			};
		}

		private void AddCcsHeadersToTokenClient()
		{
			if (!string.IsNullOrEmpty(_clientInfo))
			{
				ClientInfo clientInfo = ClientInfo.CreateFromJson(_clientInfo);
				_tokenClient.AddHeaderToClient("x-anchormailbox", CoreHelpers.GetCcsClientInfoHint(clientInfo.UniqueObjectIdentifier, clientInfo.UniqueTenantIdentifier));
			}
			else if (!string.IsNullOrEmpty(_interactiveParameters.LoginHint))
			{
				_tokenClient.AddHeaderToClient("x-anchormailbox", CoreHelpers.GetCcsUpnHint(_interactiveParameters.LoginHint));
			}
		}
	}
	internal class InteractiveRequest : RequestBase
	{
		private readonly AuthenticationRequestParameters _requestParams;

		private readonly AcquireTokenInteractiveParameters _interactiveParameters;

		private readonly IServiceBundle _serviceBundle;

		private readonly ILoggerAdapter _logger;

		private const string InstanceAwareParam = "instance_aware";

		private readonly IAuthCodeRequestComponent _authCodeRequestComponentOverride;

		private readonly ITokenRequestComponent _authCodeExchangeComponentOverride;

		private readonly ITokenRequestComponent _brokerInteractiveComponent;

		public InteractiveRequest(AuthenticationRequestParameters requestParams, AcquireTokenInteractiveParameters interactiveParameters, IAuthCodeRequestComponent authCodeRequestComponentOverride = null, ITokenRequestComponent authCodeExchangeComponentOverride = null, ITokenRequestComponent brokerExchangeComponentOverride = null)
			: base(requestParams?.RequestContext?.ServiceBundle, requestParams, interactiveParameters)
		{
			_requestParams = requestParams ?? throw new ArgumentNullException("requestParams");
			_interactiveParameters = interactiveParameters ?? throw new ArgumentNullException("interactiveParameters");
			_authCodeRequestComponentOverride = authCodeRequestComponentOverride;
			_authCodeExchangeComponentOverride = authCodeExchangeComponentOverride;
			_brokerInteractiveComponent = brokerExchangeComponentOverride;
			_serviceBundle = requestParams.RequestContext.ServiceBundle;
			_logger = requestParams.RequestContext.Logger;
		}

		protected override async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			await ResolveAuthorityAsync().ConfigureAwait(continueOnCapturedContext: false);
			cancellationToken.ThrowIfCancellationRequested();
			return await CacheTokenResponseAndCreateAuthenticationResultAsync(await GetTokenResponseAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<MsalTokenResponse> FetchTokensFromBrokerAsync(string brokerInstallUrl, CancellationToken cancellationToken)
		{
			IBroker broker = _serviceBundle.PlatformProxy.CreateBroker(_serviceBundle.Config, _interactiveParameters.UiParent);
			return await (_brokerInteractiveComponent ?? new BrokerInteractiveRequestComponent(_requestParams, _interactiveParameters, broker, brokerInstallUrl)).FetchTokensAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<MsalTokenResponse> GetTokenResponseAsync(CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (_requestParams.AppConfig.IsBrokerEnabled)
			{
				_logger.Info("Broker is configured. Starting broker flow without knowing the broker installation app link. ");
				MsalTokenResponse msalTokenResponse = await FetchTokensFromBrokerAsync(null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (msalTokenResponse != null)
				{
					_logger.Info("Broker attempt completed successfully. ");
					Metrics.IncrementTotalAccessTokensFromBroker();
					return msalTokenResponse;
				}
				if (string.Equals(_requestParams.AuthenticationScheme.AccessTokenType, "pop"))
				{
					_logger.Error("A broker application is required for Proof-of-Possesion, but one could not be found or communicated with. See https://aka.ms/msal-net-pop");
					throw new MsalClientException("broker_application_required", "MSAL cannot invoke the broker and it is required for Proof-of-Possession. WAM (Broker) may not be installed on the user's device or there was an error invoking the broker. Use IPublicClientApplication.IsProofOfPossessionSupportedByClient to ensure Proof-of-Possession can be performed before using WithProofOfPossession.Check logs for more details and see https://aka.ms/msal-net-pop. ");
				}
				_logger.Info("Broker attempt did not complete, most likely because the broker is not installed. Attempting to use a browser / web UI. ");
				cancellationToken.ThrowIfCancellationRequested();
			}
			if (_requestParams.AppConfig.MultiCloudSupportEnabled)
			{
				_logger.Info("Instance Aware was configured.");
				_requestParams.AppConfig.ExtraQueryParameters["instance_aware"] = "true";
			}
			Tuple<AuthorizationResult, string> tuple = await (_authCodeRequestComponentOverride ?? new AuthCodeRequestComponent(_requestParams, _interactiveParameters)).FetchAuthCodeAndPkceVerifierAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			_logger.Info("An authorization code was retrieved from the /authorize endpoint. ");
			AuthorizationResult authResult = tuple.Item1;
			string authCode = authResult.Code;
			string pkceCodeVerifier = tuple.Item2;
			if (BrokerInteractiveRequestComponent.IsBrokerRequiredAuthCode(authCode, out var installationUri))
			{
				return await RunBrokerWithInstallUriAsync(installationUri, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			if (_requestParams.AppConfig.MultiCloudSupportEnabled && !string.IsNullOrEmpty(authResult.CloudInstanceHost))
			{
				_logger.Info("Updating the authority to the cloud specific authority.");
				_requestParams.AuthorityManager = new AuthorityManager(_requestParams.RequestContext, Authority.CreateAuthorityWithEnvironment(_requestParams.Authority.AuthorityInfo, authResult.CloudInstanceHost));
				await ResolveAuthorityAsync().ConfigureAwait(continueOnCapturedContext: false);
			}
			_logger.Info("Exchanging the auth code for tokens. ");
			MsalTokenResponse result = await (_authCodeExchangeComponentOverride ?? new AuthCodeExchangeComponent(_requestParams, _interactiveParameters, authCode, pkceCodeVerifier, authResult.ClientInfo)).FetchTokensAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			Metrics.IncrementTotalAccessTokensFromIdP();
			return result;
		}

		private async Task<MsalTokenResponse> RunBrokerWithInstallUriAsync(string brokerInstallUri, CancellationToken cancellationToken)
		{
			_logger.Info(() => "Based on the auth code, the broker flow is required. Starting broker flow knowing the broker installation app link. ");
			cancellationToken.ThrowIfCancellationRequested();
			MsalTokenResponse tokenResponse = await FetchTokensFromBrokerAsync(brokerInstallUri, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			_logger.Info(() => "Broker attempt completed successfully " + (tokenResponse != null));
			Metrics.IncrementTotalAccessTokensFromBroker();
			return tokenResponse;
		}
	}
	internal class ManagedIdentityAuthRequest : RequestBase
	{
		private readonly AcquireTokenForManagedIdentityParameters _managedIdentityParameters;

		private static readonly SemaphoreSlim s_semaphoreSlim = new SemaphoreSlim(1, 1);

		public ManagedIdentityAuthRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenForManagedIdentityParameters managedIdentityParameters)
			: base(serviceBundle, authenticationRequestParameters, managedIdentityParameters)
		{
			_managedIdentityParameters = managedIdentityParameters;
		}

		protected override async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			ILoggerAdapter logger = base.AuthenticationRequestParameters.RequestContext.Logger;
			if (_managedIdentityParameters.ForceRefresh)
			{
				base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo = CacheRefreshReason.ForceRefreshOrClaims;
				logger.Info("[ManagedIdentityRequest] Skipped looking for a cached access token because ForceRefresh was set.");
				return await GetAccessTokenAsync(cancellationToken, logger).ConfigureAwait(continueOnCapturedContext: false);
			}
			MsalAccessTokenCacheItem msalAccessTokenCacheItem = await GetCachedAccessTokenAsync().ConfigureAwait(continueOnCapturedContext: false);
			AuthenticationResult result;
			if (msalAccessTokenCacheItem != null)
			{
				result = CreateAuthenticationResultFromCache(msalAccessTokenCacheItem);
				logger.Info("[ManagedIdentityRequest] Access token retrieved from cache.");
				try
				{
					if (SilentRequestHelper.NeedsRefresh(msalAccessTokenCacheItem))
					{
						logger.Info("[ManagedIdentityRequest] Initiating a proactive refresh.");
						base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo = CacheRefreshReason.ProactivelyRefreshed;
						SilentRequestHelper.ProcessFetchInBackground(msalAccessTokenCacheItem, delegate
						{
							using CancellationTokenSource cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
							return GetAccessTokenAsync(cancellationTokenSource.Token, logger);
						}, logger, base.ServiceBundle, base.AuthenticationRequestParameters.RequestContext.ApiEvent.ApiId);
					}
				}
				catch (MsalServiceException e)
				{
					return await HandleTokenRefreshErrorAsync(e, msalAccessTokenCacheItem).ConfigureAwait(continueOnCapturedContext: false);
				}
			}
			else
			{
				if (base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo != CacheRefreshReason.Expired)
				{
					base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo = CacheRefreshReason.NoCachedAccessToken;
				}
				logger.Info("[ManagedIdentityRequest] No cached access token. Getting a token from the managed identity endpoint.");
				result = await GetAccessTokenAsync(cancellationToken, logger).ConfigureAwait(continueOnCapturedContext: false);
			}
			return result;
		}

		private async Task<AuthenticationResult> GetAccessTokenAsync(CancellationToken cancellationToken, ILoggerAdapter logger)
		{
			logger.Verbose(() => "[ManagedIdentityRequest] Entering managed identity request semaphore.");
			await s_semaphoreSlim.WaitAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			logger.Verbose(() => "[ManagedIdentityRequest] Entered managed identity request semaphore.");
			try
			{
				AuthenticationResult result;
				if (_managedIdentityParameters.ForceRefresh || base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo == CacheRefreshReason.ProactivelyRefreshed)
				{
					result = await SendTokenRequestForManagedIdentityAsync(logger, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				else
				{
					logger.Info("[ManagedIdentityRequest] Checking for a cached access token.");
					MsalAccessTokenCacheItem msalAccessTokenCacheItem = await GetCachedAccessTokenAsync().ConfigureAwait(continueOnCapturedContext: false);
					result = ((msalAccessTokenCacheItem == null) ? (await SendTokenRequestForManagedIdentityAsync(logger, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)) : CreateAuthenticationResultFromCache(msalAccessTokenCacheItem));
				}
				return result;
			}
			finally
			{
				s_semaphoreSlim.Release();
				logger.Verbose(() => "[ManagedIdentityRequest] Released managed identity request semaphore.");
			}
		}

		private async Task<AuthenticationResult> SendTokenRequestForManagedIdentityAsync(ILoggerAdapter logger, CancellationToken cancellationToken)
		{
			logger.Info("[ManagedIdentityRequest] Acquiring a token from the managed identity endpoint.");
			await ResolveAuthorityAsync().ConfigureAwait(continueOnCapturedContext: false);
			MsalTokenResponse msalTokenResponse = MsalTokenResponse.CreateFromManagedIdentityResponse(await new ManagedIdentityClient(base.AuthenticationRequestParameters.RequestContext).SendTokenRequestForManagedIdentityAsync(_managedIdentityParameters, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
			msalTokenResponse.Scope = base.AuthenticationRequestParameters.Scope.AsSingleString();
			return await CacheTokenResponseAndCreateAuthenticationResultAsync(msalTokenResponse).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<MsalAccessTokenCacheItem> GetCachedAccessTokenAsync()
		{
			MsalAccessTokenCacheItem msalAccessTokenCacheItem = await base.CacheManager.FindAccessTokenAsync().ConfigureAwait(continueOnCapturedContext: false);
			if (msalAccessTokenCacheItem != null)
			{
				base.AuthenticationRequestParameters.RequestContext.ApiEvent.IsAccessTokenCacheHit = true;
				Metrics.IncrementTotalAccessTokensFromCache();
				return msalAccessTokenCacheItem;
			}
			return null;
		}

		private AuthenticationResult CreateAuthenticationResultFromCache(MsalAccessTokenCacheItem cachedAccessTokenItem)
		{
			return new AuthenticationResult(cachedAccessTokenItem, null, base.AuthenticationRequestParameters.AuthenticationScheme, base.AuthenticationRequestParameters.RequestContext.CorrelationId, TokenSource.Cache, base.AuthenticationRequestParameters.RequestContext.ApiEvent, null, null, null);
		}

		protected override KeyValuePair<string, string>? GetCcsHeader(IDictionary<string, string> additionalBodyParameters)
		{
			return null;
		}
	}
	internal class OnBehalfOfRequest : RequestBase
	{
		private readonly AcquireTokenOnBehalfOfParameters _onBehalfOfParameters;

		private string _ccsRoutingHint;

		public OnBehalfOfRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenOnBehalfOfParameters onBehalfOfParameters)
			: base(serviceBundle, authenticationRequestParameters, onBehalfOfParameters)
		{
			_onBehalfOfParameters = onBehalfOfParameters;
		}

		protected override async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			if (base.AuthenticationRequestParameters.Scope == null || base.AuthenticationRequestParameters.Scope.Count == 0)
			{
				throw new MsalClientException("scopes_required_client_credentials", "At least one scope needs to be requested for this authentication flow. ");
			}
			await ResolveAuthorityAsync().ConfigureAwait(continueOnCapturedContext: false);
			MsalAccessTokenCacheItem cachedAccessToken = null;
			ILoggerAdapter logger = base.AuthenticationRequestParameters.RequestContext.Logger;
			AuthenticationResult authResult = null;
			if (base.AuthenticationRequestParameters.Authority is AadAuthority aadAuthority && aadAuthority.IsCommonOrOrganizationsTenant())
			{
				logger.Error("The current authority is targeting the /common or /organizations endpoint. Instead, it should target the same tenant as the client, which can be found in the 'tid' claim of the incoming client token. See https://aka.ms/msal-net-on-behalf-of for more details.");
			}
			CacheRefreshReason cacheInfoTelemetry = CacheRefreshReason.NotApplicable;
			if (base.AuthenticationRequestParameters.ApiId == ApiEvent.ApiIds.InitiateLongRunningObo && !_onBehalfOfParameters.SearchInCacheForLongRunningObo)
			{
				logger.Info("[OBO Request] Initiating long running process. Fetching OBO token from ESTS.");
				return await FetchNewAccessTokenAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			if (!_onBehalfOfParameters.ForceRefresh && string.IsNullOrEmpty(base.AuthenticationRequestParameters.Claims))
			{
				using (logger.LogBlockDuration("[OBO Request] Looking in the cache for an access token"))
				{
					cachedAccessToken = await base.CacheManager.FindAccessTokenAsync().ConfigureAwait(continueOnCapturedContext: false);
				}
				if (cachedAccessToken != null)
				{
					MsalIdTokenCacheItem cachedIdToken = await base.CacheManager.GetIdTokenCacheItemAsync(cachedAccessToken).ConfigureAwait(continueOnCapturedContext: false);
					Account account = await base.CacheManager.GetAccountAssociatedWithAccessTokenAsync(cachedAccessToken).ConfigureAwait(continueOnCapturedContext: false);
					logger.Info(() => "[OBO Request] Found a valid access token in the cache. ID token also found? " + (cachedIdToken != null));
					base.AuthenticationRequestParameters.RequestContext.ApiEvent.IsAccessTokenCacheHit = true;
					Metrics.IncrementTotalAccessTokensFromCache();
					authResult = new AuthenticationResult(cachedAccessToken, cachedIdToken, base.AuthenticationRequestParameters.AuthenticationScheme, base.AuthenticationRequestParameters.RequestContext.CorrelationId, TokenSource.Cache, base.AuthenticationRequestParameters.RequestContext.ApiEvent, account, null, null);
				}
				else if (base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo != CacheRefreshReason.Expired)
				{
					cacheInfoTelemetry = CacheRefreshReason.NoCachedAccessToken;
				}
			}
			else
			{
				logger.Info("[OBO Request] Skipped looking for an Access Token in the cache because ForceRefresh or Claims were set. ");
				cacheInfoTelemetry = CacheRefreshReason.ForceRefreshOrClaims;
			}
			if (base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo == CacheRefreshReason.NotApplicable)
			{
				base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo = cacheInfoTelemetry;
			}
			try
			{
				if (cachedAccessToken == null)
				{
					authResult = await RefreshRtOrFetchNewAccessTokenAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				else if (SilentRequestHelper.NeedsRefresh(cachedAccessToken))
				{
					base.AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo = CacheRefreshReason.ProactivelyRefreshed;
					SilentRequestHelper.ProcessFetchInBackground(cachedAccessToken, delegate
					{
						using CancellationTokenSource cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
						return RefreshRtOrFetchNewAccessTokenAsync(cancellationTokenSource.Token);
					}, logger, base.ServiceBundle, base.AuthenticationRequestParameters.RequestContext.ApiEvent.ApiId);
				}
				return authResult;
			}
			catch (MsalServiceException e)
			{
				return await HandleTokenRefreshErrorAsync(e, cachedAccessToken).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		private async Task<AuthenticationResult> RefreshRtOrFetchNewAccessTokenAsync(CancellationToken cancellationToken)
		{
			ILoggerAdapter logger = base.AuthenticationRequestParameters.RequestContext.Logger;
			if (ApiEvent.IsLongRunningObo(base.AuthenticationRequestParameters.ApiId))
			{
				base.AuthenticationRequestParameters.RequestContext.Logger.Info("[OBO request] Long-running OBO flow, trying to refresh using a refresh token flow.");
				MsalRefreshTokenCacheItem msalRefreshTokenCacheItem = await base.CacheManager.FindRefreshTokenAsync().ConfigureAwait(continueOnCapturedContext: false);
				if (msalRefreshTokenCacheItem != null)
				{
					logger.Info("[OBO request] Found a refresh token");
					if (!string.IsNullOrEmpty(msalRefreshTokenCacheItem.RawClientInfo))
					{
						ClientInfo clientInfo = ClientInfo.CreateFromJson(msalRefreshTokenCacheItem.RawClientInfo);
						_ccsRoutingHint = CoreHelpers.GetCcsClientInfoHint(clientInfo.UniqueObjectIdentifier, clientInfo.UniqueTenantIdentifier);
					}
					else
					{
						logger.Info("[OBO request] No client info associated with RT. This is OBO for a Service Principal.");
					}
					return await CacheTokenResponseAndCreateAuthenticationResultAsync(await SilentRequestHelper.RefreshAccessTokenAsync(msalRefreshTokenCacheItem, this, base.AuthenticationRequestParameters, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).ConfigureAwait(continueOnCapturedContext: false);
				}
				if (base.AuthenticationRequestParameters.ApiId == ApiEvent.ApiIds.AcquireTokenInLongRunningObo)
				{
					base.AuthenticationRequestParameters.RequestContext.Logger.Error("[OBO request] AcquireTokenInLongRunningProcess was called and no access or refresh tokens were found in the cache.");
					throw new MsalClientException("obo_cache_key_not_in_cache_error", "The token cache does not contain a token with an OBO cache key that matches the longRunningProcessSessionKey passed into ILongRunningWebApi.AcquireTokenInLongRunningProcess method. Call ILongRunningWebApi.InitiateLongRunningProcessInWebApi method with this longRunningProcessSessionKey first or call ILongRunningWebApi.AcquireTokenInLongRunningProcess method with an already used longRunningProcessSessionKey. See https://aka.ms/msal-net-long-running-obo .");
				}
				base.AuthenticationRequestParameters.RequestContext.Logger.Info("[OBO request] No refresh token was found in the cache. Fetching OBO tokens from ESTS.");
			}
			else
			{
				logger.Info("[OBO request] Fetching tokens via normal OBO flow.");
			}
			return await FetchNewAccessTokenAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<AuthenticationResult> FetchNewAccessTokenAsync(CancellationToken cancellationToken)
		{
			MsalTokenResponse msalTokenResponse = await SendTokenRequestAsync(GetBodyParameters(), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (!ApiEvent.IsLongRunningObo(base.AuthenticationRequestParameters.ApiId))
			{
				msalTokenResponse.RefreshToken = null;
			}
			if (msalTokenResponse.ClientInfo == null && base.AuthenticationRequestParameters.AuthorityInfo.IsClientInfoSupported)
			{
				base.AuthenticationRequestParameters.RequestContext.Logger.Info("[OBO request] This is an on behalf of request for a service principal as no client info returned in the token response.");
			}
			return await CacheTokenResponseAndCreateAuthenticationResultAsync(msalTokenResponse).ConfigureAwait(continueOnCapturedContext: false);
		}

		private Dictionary<string, string> GetBodyParameters()
		{
			return new Dictionary<string, string>
			{
				["client_info"] = "1",
				["grant_type"] = _onBehalfOfParameters.UserAssertion.AssertionType,
				["assertion"] = _onBehalfOfParameters.UserAssertion.Assertion,
				["requested_token_use"] = "on_behalf_of"
			};
		}

		protected override KeyValuePair<string, string>? GetCcsHeader(IDictionary<string, string> additionalBodyParameters)
		{
			if (string.IsNullOrEmpty(_ccsRoutingHint))
			{
				return null;
			}
			return new KeyValuePair<string, string>("x-anchormailbox", _ccsRoutingHint);
		}
	}
	internal abstract class RequestBase
	{
		internal AuthenticationRequestParameters AuthenticationRequestParameters { get; }

		internal ICacheSessionManager CacheManager => AuthenticationRequestParameters.CacheSessionManager;

		internal IServiceBundle ServiceBundle { get; }

		protected RequestBase(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, IAcquireTokenParameters acquireTokenParameters)
		{
			ServiceBundle = serviceBundle ?? throw new ArgumentNullException("serviceBundle");
			AuthenticationRequestParameters = authenticationRequestParameters ?? throw new ArgumentNullException("authenticationRequestParameters");
			if (acquireTokenParameters == null)
			{
				throw new ArgumentNullException("acquireTokenParameters");
			}
			acquireTokenParameters.LogParameters(AuthenticationRequestParameters.RequestContext.Logger);
		}

		protected virtual SortedSet<string> GetOverriddenScopes(ISet<string> inputScopes)
		{
			return null;
		}

		protected abstract Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);

		public async Task<AuthenticationResult> RunAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			ApiEvent apiEvent = null;
			MsalTelemetryEventDetails telemetryEventDetails = null;
			ITelemetryClient[] telemetryClients = null;
			MeasureDurationResult measureTelemetryDurationResult = StopwatchService.MeasureCodeBlock(delegate
			{
				apiEvent = InitializeApiEvent(AuthenticationRequestParameters.Account?.HomeAccountId?.Identifier);
				AuthenticationRequestParameters.RequestContext.ApiEvent = apiEvent;
				telemetryEventDetails = new MsalTelemetryEventDetails("acquire_token");
				telemetryClients = AuthenticationRequestParameters.RequestContext.ServiceBundle.Config.TelemetryClients;
			});
			using (AuthenticationRequestParameters.RequestContext.CreateTelemetryHelper(apiEvent))
			{
				try
				{
					AuthenticationResult authenticationResult = null;
					MeasureDurationResult measureDurationResult = await StopwatchService.MeasureCodeBlockAsync(async delegate
					{
						AuthenticationRequestParameters.LogParameters();
						LogRequestStarted(AuthenticationRequestParameters);
						authenticationResult = await ExecuteAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						LogReturnedToken(authenticationResult);
					}).ConfigureAwait(continueOnCapturedContext: false);
					UpdateTelemetry(measureDurationResult.Milliseconds + measureTelemetryDurationResult.Milliseconds, apiEvent, authenticationResult);
					LogMetricsFromAuthResult(authenticationResult, AuthenticationRequestParameters.RequestContext.Logger);
					LogSuccessfulTelemetryToClient(authenticationResult, telemetryEventDetails, telemetryClients);
					LogSuccessTelemetryToOtel(authenticationResult, apiEvent.ApiId, measureDurationResult.Microseconds);
					return authenticationResult;
				}
				catch (MsalException ex)
				{
					apiEvent.ApiErrorCode = ex.ErrorCode;
					if (string.IsNullOrWhiteSpace(ex.CorrelationId))
					{
						ex.CorrelationId = AuthenticationRequestParameters.CorrelationId.ToString();
					}
					AuthenticationRequestParameters.RequestContext.Logger.ErrorPii(ex);
					LogMsalErrorTelemetryToClient(ex, telemetryEventDetails, telemetryClients);
					LogFailureTelemetryToOtel(ex.ErrorCode, apiEvent.ApiId, apiEvent.CacheInfo);
					throw;
				}
				catch (Exception ex2)
				{
					apiEvent.ApiErrorCode = ex2.GetType().Name;
					AuthenticationRequestParameters.RequestContext.Logger.ErrorPii(ex2);
					LogMsalErrorTelemetryToClient(ex2, telemetryEventDetails, telemetryClients);
					LogFailureTelemetryToOtel(ex2.GetType().Name, apiEvent.ApiId, apiEvent.CacheInfo);
					throw;
				}
				finally
				{
					telemetryClients.TrackEvent(telemetryEventDetails);
				}
			}
		}

		private void LogSuccessTelemetryToOtel(AuthenticationResult authenticationResult, ApiEvent.ApiIds apiId, long durationInUs)
		{
			ServiceBundle.PlatformProxy.OtelInstrumentation.LogSuccessMetrics(ServiceBundle.PlatformProxy.GetProductName(), apiId, GetCacheLevel(authenticationResult), durationInUs, authenticationResult.AuthenticationResultMetadata, AuthenticationRequestParameters.RequestContext.Logger);
		}

		private void LogFailureTelemetryToOtel(string errorCodeToLog, ApiEvent.ApiIds apiId, CacheRefreshReason cacheRefreshReason)
		{
			ServiceBundle.PlatformProxy.OtelInstrumentation.LogFailureMetrics(ServiceBundle.PlatformProxy.GetProductName(), errorCodeToLog, apiId, cacheRefreshReason);
		}

		private static void LogMsalErrorTelemetryToClient(Exception ex, MsalTelemetryEventDetails telemetryEventDetails, ITelemetryClient[] telemetryClients)
		{
			if (telemetryClients.HasEnabledClients("acquire_token"))
			{
				telemetryEventDetails.SetProperty("Succeeded", value: false);
				telemetryEventDetails.SetProperty("ErrorMessage", ex.Message);
				if (ex is MsalClientException ex2)
				{
					telemetryEventDetails.SetProperty("ErrorCode", ex2.ErrorCode);
				}
				else if (ex is MsalServiceException ex3)
				{
					telemetryEventDetails.SetProperty("ErrorCode", ex3.ErrorCode);
					telemetryEventDetails.SetProperty("StsErrorCode", ex3.ErrorCodes?.FirstOrDefault());
				}
				else
				{
					telemetryEventDetails.SetProperty("ErrorCode", ex.GetType().ToString());
				}
			}
		}

		private void LogSuccessfulTelemetryToClient(AuthenticationResult authenticationResult, MsalTelemetryEventDetails telemetryEventDetails, ITelemetryClient[] telemetryClients)
		{
			if (telemetryClients.HasEnabledClients("acquire_token"))
			{
				telemetryEventDetails.SetProperty("CacheInfoTelemetry", Convert.ToInt64(authenticationResult.AuthenticationResultMetadata.CacheRefreshReason));
				telemetryEventDetails.SetProperty("TokenSource", Convert.ToInt64(authenticationResult.AuthenticationResultMetadata.TokenSource));
				telemetryEventDetails.SetProperty("Duration", authenticationResult.AuthenticationResultMetadata.DurationTotalInMs);
				telemetryEventDetails.SetProperty("DurationInCache", authenticationResult.AuthenticationResultMetadata.DurationInCacheInMs);
				telemetryEventDetails.SetProperty("DurationInHttp", authenticationResult.AuthenticationResultMetadata.DurationInHttpInMs);
				telemetryEventDetails.SetProperty("Succeeded", value: true);
				telemetryEventDetails.SetProperty("TokenType", (long)AuthenticationRequestParameters.RequestContext.ApiEvent.TokenType.Value);
				telemetryEventDetails.SetProperty("RemainingLifetime", (authenticationResult.ExpiresOn - DateTime.Now).TotalMilliseconds);
				telemetryEventDetails.SetProperty("ActivityId", authenticationResult.CorrelationId);
				if (authenticationResult.AuthenticationResultMetadata.RefreshOn.HasValue)
				{
					telemetryEventDetails.SetProperty("RefreshOn", authenticationResult.AuthenticationResultMetadata.RefreshOn.Value.ToUnixTimeMilliseconds());
				}
				telemetryEventDetails.SetProperty("AssertionType", (long)AuthenticationRequestParameters.RequestContext.ApiEvent.AssertionType);
				telemetryEventDetails.SetProperty("Endpoint", AuthenticationRequestParameters.Authority.AuthorityInfo.CanonicalAuthority.ToString());
				telemetryEventDetails.SetProperty("CacheLevel", (long)authenticationResult.AuthenticationResultMetadata.CacheLevel);
				Tuple<string, string> tuple = ParseScopesForTelemetry();
				if (tuple.Item1 != null)
				{
					telemetryEventDetails.SetProperty("Resource", tuple.Item1);
				}
				if (tuple.Item2 != null)
				{
					telemetryEventDetails.SetProperty("Scopes", tuple.Item2);
				}
			}
		}

		private Tuple<string, string> ParseScopesForTelemetry()
		{
			string item = null;
			string item2 = null;
			if (AuthenticationRequestParameters.Scope.Count > 0)
			{
				string uriString = AuthenticationRequestParameters.Scope.First();
				if (Uri.IsWellFormedUriString(uriString, UriKind.Absolute))
				{
					Uri uri = new Uri(uriString);
					item = uri.Scheme + "://" + uri.Host;
					StringBuilder stringBuilder = new StringBuilder();
					foreach (string item3 in AuthenticationRequestParameters.Scope)
					{
						string[] array = item3.Split(new string[1] { uri.Host }, StringSplitOptions.None);
						string value = ((array.Length > 1) ? (array[1].TrimStart(new char[1] { '/' }) + " ") : array.FirstOrDefault());
						stringBuilder.Append(value);
					}
					item2 = stringBuilder.ToString().TrimEnd(new char[1] { ' ' });
				}
				else
				{
					item2 = AuthenticationRequestParameters.Scope.AsSingleString();
				}
			}
			return new Tuple<string, string>(item, item2);
		}

		private CacheLevel GetCacheLevel(AuthenticationResult authenticationResult)
		{
			if (authenticationResult.AuthenticationResultMetadata.TokenSource == TokenSource.Cache)
			{
				if (AuthenticationRequestParameters.RequestContext.ApiEvent.CacheLevel > CacheLevel.Unknown)
				{
					return AuthenticationRequestParameters.RequestContext.ApiEvent.CacheLevel;
				}
				return CacheLevel.Unknown;
			}
			return CacheLevel.None;
		}

		private static void LogMetricsFromAuthResult(AuthenticationResult authenticationResult, ILoggerAdapter logger)
		{
			if (logger.IsLoggingEnabled(LogLevel.Always))
			{
				AuthenticationResultMetadata authenticationResultMetadata = authenticationResult.AuthenticationResultMetadata;
				logger.Always($"\r\n[LogMetricsFromAuthResult] Cache Refresh Reason: {authenticationResultMetadata.CacheRefreshReason}\r\n[LogMetricsFromAuthResult] DurationInCacheInMs: {authenticationResultMetadata.DurationInCacheInMs}\r\n[LogMetricsFromAuthResult] DurationTotalInMs: {authenticationResultMetadata.DurationTotalInMs}\r\n[LogMetricsFromAuthResult] DurationInHttpInMs: {authenticationResultMetadata.DurationInHttpInMs}");
				logger.AlwaysPii("[LogMetricsFromAuthResult] TokenEndpoint: " + authenticationResultMetadata.TokenEndpoint, "TokenEndpoint: ****");
			}
		}

		private void UpdateTelemetry(long elapsedMilliseconds, ApiEvent apiEvent, AuthenticationResult authenticationResult)
		{
			authenticationResult.AuthenticationResultMetadata.DurationTotalInMs = elapsedMilliseconds;
			authenticationResult.AuthenticationResultMetadata.DurationInHttpInMs = apiEvent.DurationInHttpInMs;
			authenticationResult.AuthenticationResultMetadata.DurationInCacheInMs = apiEvent.DurationInCacheInMs;
			authenticationResult.AuthenticationResultMetadata.TokenEndpoint = apiEvent.TokenEndpoint;
			authenticationResult.AuthenticationResultMetadata.CacheRefreshReason = apiEvent.CacheInfo;
			authenticationResult.AuthenticationResultMetadata.CacheLevel = GetCacheLevel(authenticationResult);
			authenticationResult.AuthenticationResultMetadata.Telemetry = apiEvent.MsalRuntimeTelemetry;
			authenticationResult.AuthenticationResultMetadata.RegionDetails = CreateRegionDetails(apiEvent);
			Metrics.IncrementTotalDurationInMs(authenticationResult.AuthenticationResultMetadata.DurationTotalInMs);
		}

		protected virtual void EnrichTelemetryApiEvent(ApiEvent apiEvent)
		{
		}

		private ApiEvent InitializeApiEvent(string accountId)
		{
			ApiEvent apiEvent = new ApiEvent(AuthenticationRequestParameters.RequestContext.CorrelationId)
			{
				ApiId = AuthenticationRequestParameters.ApiId
			};
			apiEvent.IsTokenCacheSerialized = AuthenticationRequestParameters.CacheSessionManager.TokenCacheInternal.IsAppSubscribedToSerializationEvents();
			apiEvent.IsLegacyCacheEnabled = AuthenticationRequestParameters.RequestContext.ServiceBundle.Config.LegacyCacheCompatibilityEnabled;
			apiEvent.CacheInfo = CacheRefreshReason.NotApplicable;
			apiEvent.TokenType = AuthenticationRequestParameters.AuthenticationScheme.TelemetryTokenType;
			apiEvent.AssertionType = GetAssertionType();
			EnrichTelemetryApiEvent(apiEvent);
			return apiEvent;
		}

		private AssertionType GetAssertionType()
		{
			if (ServiceBundle.Config.IsManagedIdentity || ServiceBundle.Config.AppTokenProvider != null)
			{
				return AssertionType.ManagedIdentity;
			}
			if (ServiceBundle.Config.ClientCredential != null)
			{
				if (ServiceBundle.Config.ClientCredential.AssertionType == AssertionType.CertificateWithoutSni)
				{
					if (ServiceBundle.Config.SendX5C)
					{
						return AssertionType.CertificateWithSni;
					}
					return AssertionType.CertificateWithoutSni;
				}
				return ServiceBundle.Config.ClientCredential.AssertionType;
			}
			return AssertionType.None;
		}

		protected async Task<AuthenticationResult> CacheTokenResponseAndCreateAuthenticationResultAsync(MsalTokenResponse msalTokenResponse)
		{
			AuthenticationRequestParameters.RequestContext.Logger.Info("Checking client info returned from the server..");
			ClientInfo fromServer = null;
			if (!AuthenticationRequestParameters.IsClientCredentialRequest && AuthenticationRequestParameters.ApiId != ApiEvent.ApiIds.AcquireTokenForSystemAssignedManagedIdentity && AuthenticationRequestParameters.ApiId != ApiEvent.ApiIds.AcquireTokenForUserAssignedManagedIdentity && AuthenticationRequestParameters.ApiId != ApiEvent.ApiIds.AcquireTokenByRefreshToken && AuthenticationRequestParameters.AuthorityInfo.AuthorityType != AuthorityType.Adfs && msalTokenResponse.ClientInfo != null)
			{
				fromServer = ClientInfo.CreateFromJson(msalTokenResponse.ClientInfo);
			}
			ValidateAccountIdentifiers(fromServer);
			AuthenticationRequestParameters.RequestContext.Logger.Info("Saving token response to cache..");
			Tuple<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account> obj = await CacheManager.SaveTokenResponseAsync(msalTokenResponse).ConfigureAwait(continueOnCapturedContext: false);
			MsalAccessTokenCacheItem item = obj.Item1;
			MsalIdTokenCacheItem item2 = obj.Item2;
			Account item3 = obj.Item3;
			return new AuthenticationResult(item, item2, AuthenticationRequestParameters.AuthenticationScheme, AuthenticationRequestParameters.RequestContext.CorrelationId, msalTokenResponse.TokenSource, AuthenticationRequestParameters.RequestContext.ApiEvent, item3, msalTokenResponse.SpaAuthCode, msalTokenResponse.CreateExtensionDataStringMap());
		}

		protected virtual void ValidateAccountIdentifiers(ClientInfo fromServer)
		{
		}

		protected Task ResolveAuthorityAsync()
		{
			return AuthenticationRequestParameters.AuthorityManager.RunInstanceDiscoveryAndValidationAsync();
		}

		internal async Task<MsalTokenResponse> SendTokenRequestAsync(IDictionary<string, string> additionalBodyParameters, CancellationToken cancellationToken)
		{
			MsalTokenResponse result = await SendTokenRequestAsync(await AuthenticationRequestParameters.Authority.GetTokenEndpointAsync(AuthenticationRequestParameters.RequestContext).ConfigureAwait(continueOnCapturedContext: false), additionalBodyParameters, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			Metrics.IncrementTotalAccessTokensFromIdP();
			return result;
		}

		protected Task<MsalTokenResponse> SendTokenRequestAsync(string tokenEndpoint, IDictionary<string, string> additionalBodyParameters, CancellationToken cancellationToken)
		{
			string scopeOverride = GetOverriddenScopes(AuthenticationRequestParameters.Scope).AsSingleString();
			TokenClient tokenClient = new TokenClient(AuthenticationRequestParameters);
			KeyValuePair<string, string>? ccsHeader = GetCcsHeader(additionalBodyParameters);
			if (ccsHeader.HasValue && !string.IsNullOrEmpty(ccsHeader.Value.Key))
			{
				tokenClient.AddHeaderToClient(ccsHeader.Value.Key, ccsHeader.Value.Value);
			}
			InjectPcaSsoPolicyHeader(tokenClient);
			return tokenClient.SendTokenRequestAsync(additionalBodyParameters, scopeOverride, tokenEndpoint, cancellationToken);
		}

		private void InjectPcaSsoPolicyHeader(TokenClient tokenClient)
		{
			if (!ServiceBundle.Config.IsPublicClient || !ServiceBundle.Config.IsWebviewSsoPolicyEnabled)
			{
				return;
			}
			foreach (KeyValuePair<string, string> ssoPolicyHeader in ServiceBundle.Config.BrokerCreatorFunc(null, ServiceBundle.Config, AuthenticationRequestParameters.RequestContext.Logger).GetSsoPolicyHeaders())
			{
				tokenClient.AddHeaderToClient(ssoPolicyHeader.Key, ssoPolicyHeader.Value);
			}
		}

		protected virtual KeyValuePair<string, string>? GetCcsHeader(IDictionary<string, string> additionalBodyParameters)
		{
			if (AuthenticationRequestParameters?.Account?.HomeAccountId != null)
			{
				if (!string.IsNullOrEmpty(AuthenticationRequestParameters.Account.HomeAccountId.Identifier))
				{
					string objectId = AuthenticationRequestParameters.Account.HomeAccountId.ObjectId;
					string tenantId = AuthenticationRequestParameters.Account.HomeAccountId.TenantId;
					string ccsClientInfoHint = CoreHelpers.GetCcsClientInfoHint(objectId, tenantId);
					return new KeyValuePair<string, string>("x-anchormailbox", ccsClientInfoHint);
				}
				if (!string.IsNullOrEmpty(AuthenticationRequestParameters.Account.Username))
				{
					return GetCcsUpnHeader(AuthenticationRequestParameters.Account.Username);
				}
			}
			if (additionalBodyParameters.TryGetValue("username", out var value))
			{
				return GetCcsUpnHeader(value);
			}
			if (!string.IsNullOrEmpty(AuthenticationRequestParameters.LoginHint))
			{
				return GetCcsUpnHeader(AuthenticationRequestParameters.LoginHint);
			}
			return null;
		}

		protected KeyValuePair<string, string>? GetCcsUpnHeader(string upnHeader)
		{
			if (AuthenticationRequestParameters.Authority.AuthorityInfo.AuthorityType == AuthorityType.B2C)
			{
				return null;
			}
			string ccsUpnHint = CoreHelpers.GetCcsUpnHint(upnHeader);
			return new KeyValuePair<string, string>("x-anchormailbox", ccsUpnHint);
		}

		private void LogRequestStarted(AuthenticationRequestParameters authenticationRequestParameters)
		{
			if (authenticationRequestParameters.RequestContext.Logger.IsLoggingEnabled(LogLevel.Info))
			{
				string text = authenticationRequestParameters.Scope.AsSingleString();
				string name = GetType().Name;
				string messageWithPii = $"=== Token Acquisition ({name}) started:\n\tAuthority: {authenticationRequestParameters.AuthorityInfo?.CanonicalAuthority}\n\tScope: {text}\n\tClientId: {authenticationRequestParameters.AppConfig.ClientId}\n\t";
				string text2 = "=== Token Acquisition (" + name + ") started:\n\t Scopes: " + text;
				if (authenticationRequestParameters.AuthorityInfo != null && KnownMetadataProvider.IsKnownEnvironment(authenticationRequestParameters.AuthorityInfo?.Host))
				{
					text2 = text2 + "\n\tAuthority Host: " + authenticationRequestParameters.AuthorityInfo?.Host;
				}
				authenticationRequestParameters.RequestContext.Logger.InfoPii(messageWithPii, text2);
			}
			if (authenticationRequestParameters.AppConfig.IsConfidentialClient && !authenticationRequestParameters.IsClientCredentialRequest && !CacheManager.TokenCacheInternal.IsAppSubscribedToSerializationEvents())
			{
				authenticationRequestParameters.RequestContext.Logger.Warning("Only in-memory caching is used. The cache is not persisted and will be lost if the machine is restarted. It also does not scale for a web app or web API, where the number of users can grow large. In production, web apps and web APIs should use distributed caching like Redis. See https://aka.ms/msal-net-cca-token-cache-serialization");
			}
		}

		private void LogReturnedToken(AuthenticationResult result)
		{
			if (result.AccessToken == null || !AuthenticationRequestParameters.RequestContext.Logger.IsLoggingEnabled(LogLevel.Info))
			{
				return;
			}
			string scopes = string.Join(" ", result.Scopes);
			AuthenticationRequestParameters.RequestContext.Logger.Info("\n\t=== Token Acquisition finished successfully:");
			AuthenticationRequestParameters.RequestContext.Logger.InfoPii(() => $" AT expiration time: {result.ExpiresOn}, scopes: {scopes}. " + $"source: {result.AuthenticationResultMetadata.TokenSource}", () => $" AT expiration time: {result.ExpiresOn}, scopes: {scopes}. " + $"source: {result.AuthenticationResultMetadata.TokenSource}");
			if (result.AuthenticationResultMetadata.TokenSource != TokenSource.Cache)
			{
				Uri canonicalAuthority = AuthenticationRequestParameters.AuthorityInfo.CanonicalAuthority;
				AuthenticationRequestParameters.RequestContext.Logger.InfoPii(() => $"Fetched access token from host {canonicalAuthority.Host}. Endpoint: {canonicalAuthority}. ", () => "Fetched access token from host " + canonicalAuthority.Host + ". ");
			}
		}

		internal async Task<AuthenticationResult> HandleTokenRefreshErrorAsync(MsalServiceException e, MsalAccessTokenCacheItem cachedAccessTokenItem)
		{
			ILoggerAdapter logger = AuthenticationRequestParameters.RequestContext.Logger;
			logger.Warning($"Fetching a new AT failed. Is exception retry-able? {e.IsRetryable}. Is there an AT in the cache that is usable? {cachedAccessTokenItem != null}");
			if (cachedAccessTokenItem != null && e.IsRetryable)
			{
				logger.Info("Returning existing access token. It is not expired, but should be refreshed. ");
				MsalIdTokenCacheItem idToken = await CacheManager.GetIdTokenCacheItemAsync(cachedAccessTokenItem).ConfigureAwait(continueOnCapturedContext: false);
				Account account = await CacheManager.GetAccountAssociatedWithAccessTokenAsync(cachedAccessTokenItem).ConfigureAwait(continueOnCapturedContext: false);
				return new AuthenticationResult(cachedAccessTokenItem, idToken, AuthenticationRequestParameters.AuthenticationScheme, AuthenticationRequestParameters.RequestContext.CorrelationId, TokenSource.Cache, AuthenticationRequestParameters.RequestContext.ApiEvent, account, null, null);
			}
			logger.Warning("Either the exception does not indicate a problem with AAD or the token cache does not have an AT that is usable. ");
			throw e;
		}

		private static RegionDetails CreateRegionDetails(ApiEvent apiEvent)
		{
			return new RegionDetails(apiEvent.RegionOutcome, apiEvent.RegionUsed, apiEvent.RegionDiscoveryFailureReason);
		}
	}
	internal class BrokerSilentStrategy : ISilentAuthRequestStrategy
	{
		internal AuthenticationRequestParameters _authenticationRequestParameters;

		protected IServiceBundle _serviceBundle;

		private readonly AcquireTokenSilentParameters _silentParameters;

		private readonly SilentRequest _silentRequest;

		private readonly ILoggerAdapter _logger;

		internal IBroker Broker { get; }

		public BrokerSilentStrategy(SilentRequest request, IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters silentParameters, IBroker broker)
		{
			_authenticationRequestParameters = authenticationRequestParameters;
			_silentParameters = silentParameters;
			_serviceBundle = serviceBundle;
			_silentRequest = request;
			Broker = broker ?? throw new ArgumentNullException("broker");
			_logger = authenticationRequestParameters.RequestContext.Logger;
		}

		public async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			if (!Broker.IsBrokerInstalledAndInvokable(_authenticationRequestParameters.AuthorityInfo.AuthorityType))
			{
				if (_authenticationRequestParameters.PopAuthenticationConfiguration != null)
				{
					throw new MsalClientException("broker_application_required", "MSAL cannot invoke the broker and it is required for Proof-of-Possession. WAM (Broker) may not be installed on the user's device or there was an error invoking the broker. Use IPublicClientApplication.IsProofOfPossessionSupportedByClient to ensure Proof-of-Possession can be performed before using WithProofOfPossession.Check logs for more details and see https://aka.ms/msal-net-pop. ");
				}
				_logger.Warning("Broker is not installed or authority type is incorrect. Cannot respond to silent request.");
				return null;
			}
			MsalTokenResponse msalTokenResponse = await SendTokenRequestToBrokerAsync().ConfigureAwait(continueOnCapturedContext: false);
			if (msalTokenResponse != null)
			{
				ValidateResponseFromBroker(msalTokenResponse);
				Metrics.IncrementTotalAccessTokensFromBroker();
				return await _silentRequest.CacheTokenResponseAndCreateAuthenticationResultAsync(msalTokenResponse).ConfigureAwait(continueOnCapturedContext: false);
			}
			return null;
		}

		private async Task<MsalTokenResponse> SendTokenRequestToBrokerAsync()
		{
			_authenticationRequestParameters.RequestContext.Logger.Info("Can invoke broker. Will attempt to acquire token with broker. ");
			return PublicClientApplication.IsOperatingSystemAccount(_authenticationRequestParameters.Account) ? (await Broker.AcquireTokenSilentDefaultUserAsync(_authenticationRequestParameters, _silentParameters).ConfigureAwait(continueOnCapturedContext: false)) : (await Broker.AcquireTokenSilentAsync(_authenticationRequestParameters, _silentParameters).ConfigureAwait(continueOnCapturedContext: false));
		}

		internal void ValidateResponseFromBroker(MsalTokenResponse msalTokenResponse)
		{
			_logger.Info("Checking MsalTokenResponse returned from broker. ");
			if (msalTokenResponse.AccessToken != null)
			{
				_logger.Info("Success. Response contains an access token. ");
				return;
			}
			if (msalTokenResponse.Error != null)
			{
				_logger.Info(() => LogMessages.ErrorReturnedInBrokerResponse(msalTokenResponse.Error));
				if (msalTokenResponse.Error == "no_tokens_found" || msalTokenResponse.Error == "no_account_found" || msalTokenResponse.Error == "Broker refresh token is invalid")
				{
					throw new MsalUiRequiredException(msalTokenResponse.Error, msalTokenResponse.ErrorDescription);
				}
				throw MsalServiceExceptionFactory.FromBrokerResponse(msalTokenResponse, "Broker response returned error: " + msalTokenResponse.ErrorDescription);
			}
			_logger.Info("Unknown error returned in broker response. ");
			throw new MsalServiceException("broker_response_returned_error", "Broker response returned an error which does not contain an error or error description. See https://aka.ms/msal-brokers for details. ", null);
		}
	}
	internal class UsernamePasswordRequest : RequestBase
	{
		private readonly CommonNonInteractiveHandler _commonNonInteractiveHandler;

		private readonly AcquireTokenByUsernamePasswordParameters _usernamePasswordParameters;

		private readonly AuthenticationRequestParameters _requestParameters;

		private readonly ILoggerAdapter _logger;

		public UsernamePasswordRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByUsernamePasswordParameters usernamePasswordParameters)
			: base(serviceBundle, authenticationRequestParameters, usernamePasswordParameters)
		{
			_usernamePasswordParameters = usernamePasswordParameters;
			_requestParameters = authenticationRequestParameters;
			_commonNonInteractiveHandler = new CommonNonInteractiveHandler(authenticationRequestParameters.RequestContext, serviceBundle);
			_logger = _requestParameters.RequestContext.Logger;
		}

		protected override async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			await ResolveAuthorityAsync().ConfigureAwait(continueOnCapturedContext: false);
			await UpdateUsernameAsync().ConfigureAwait(continueOnCapturedContext: false);
			MsalTokenResponse msalTokenResponse;
			try
			{
				msalTokenResponse = await GetTokenResponseAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (JsonException innerException)
			{
				throw new MsalServiceException("json_parse_failed", "There was an error parsing the response from the token endpoint, see inner exception for details. Verify that your app is configured correctly. If this is a B2C app, one possible cause is acquiring a token for Microsoft Graph, which is not supported. See https://aka.ms/msal-net-up", innerException);
			}
			return await CacheTokenResponseAndCreateAuthenticationResultAsync(msalTokenResponse).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<MsalTokenResponse> GetTokenResponseAsync(CancellationToken cancellationToken)
		{
			if (_requestParameters.AppConfig.IsBrokerEnabled)
			{
				_logger.Info("Broker is configured. Starting broker flow. ");
				IBroker broker = _requestParameters.RequestContext.ServiceBundle.PlatformProxy.CreateBroker(_requestParameters.RequestContext.ServiceBundle.Config, null);
				if (broker.IsBrokerInstalledAndInvokable(_requestParameters.AuthorityInfo.AuthorityType))
				{
					_logger.Info("Can invoke broker. Will attempt to acquire token with broker. ");
					MsalTokenResponse msalTokenResponse = await broker.AcquireTokenByUsernamePasswordAsync(_requestParameters, _usernamePasswordParameters).ConfigureAwait(continueOnCapturedContext: false);
					if (msalTokenResponse != null)
					{
						_logger.Info("Broker attempt completed successfully. ");
						Metrics.IncrementTotalAccessTokensFromBroker();
						return msalTokenResponse;
					}
					if (string.Equals(_requestParameters.AuthenticationScheme.AccessTokenType, "pop"))
					{
						_logger.Error("A broker application is required for Proof-of-Possesion, but one could not be found or communicated with. See https://aka.ms/msal-net-pop");
						throw new MsalClientException("broker_application_required", "MSAL cannot invoke the broker and it is required for Proof-of-Possession. WAM (Broker) may not be installed on the user's device or there was an error invoking the broker. Use IPublicClientApplication.IsProofOfPossessionSupportedByClient to ensure Proof-of-Possession can be performed before using WithProofOfPossession.Check logs for more details and see https://aka.ms/msal-net-pop. ");
					}
				}
				_logger.Info("Broker request not attempted because the broker is not available.");
				cancellationToken.ThrowIfCancellationRequested();
			}
			return await SendTokenRequestAsync(GetAdditionalBodyParameters(await FetchAssertionFromWsTrustAsync().ConfigureAwait(continueOnCapturedContext: false)), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<UserAssertion> FetchAssertionFromWsTrustAsync()
		{
			if (!base.AuthenticationRequestParameters.AuthorityInfo.IsWsTrustFlowSupported)
			{
				return null;
			}
			UserRealmDiscoveryResponse userRealmDiscoveryResponse = await _commonNonInteractiveHandler.QueryUserRealmDataAsync(base.AuthenticationRequestParameters.AuthorityInfo.UserRealmUriPrefix, _usernamePasswordParameters.Username).ConfigureAwait(continueOnCapturedContext: false);
			if (userRealmDiscoveryResponse.IsFederated)
			{
				WsTrustResponse wsTrustResponse = await _commonNonInteractiveHandler.PerformWsTrustMexExchangeAsync(userRealmDiscoveryResponse.FederationMetadataUrl, userRealmDiscoveryResponse.CloudAudienceUrn, UserAuthType.UsernamePassword, _usernamePasswordParameters.Username, _usernamePasswordParameters.Password, _usernamePasswordParameters.FederationMetadata).ConfigureAwait(continueOnCapturedContext: false);
				return new UserAssertion(wsTrustResponse.Token, (wsTrustResponse.TokenType == "urn:oasis:names:tc:SAML:1.0:assertion") ? "urn:ietf:params:oauth:grant-type:saml1_1-bearer" : "urn:ietf:params:oauth:grant-type:saml2-bearer");
			}
			if (userRealmDiscoveryResponse.IsManaged)
			{
				if (_usernamePasswordParameters.Password == null)
				{
					throw new MsalClientException("password_required_for_managed_user");
				}
				return null;
			}
			throw new MsalClientException("unknown_user_type", string.Format(CultureInfo.CurrentCulture, "Unsupported User Type '{0}'. Please see https://aka.ms/msal-net-up. ", userRealmDiscoveryResponse.AccountType));
		}

		private async Task UpdateUsernameAsync()
		{
			if (string.IsNullOrWhiteSpace(_usernamePasswordParameters.Username))
			{
				string username = await _commonNonInteractiveHandler.GetPlatformUserAsync().ConfigureAwait(continueOnCapturedContext: false);
				_usernamePasswordParameters.Username = username;
			}
		}

		private Dictionary<string, string> GetAdditionalBodyParameters(UserAssertion userAssertion)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			if (userAssertion != null)
			{
				dictionary["grant_type"] = userAssertion.AssertionType;
				dictionary["assertion"] = Convert.ToBase64String(Encoding.UTF8.GetBytes(userAssertion.Assertion));
			}
			else
			{
				dictionary["grant_type"] = "password";
				dictionary["username"] = _usernamePasswordParameters.Username;
				dictionary["password"] = _usernamePasswordParameters.Password;
			}
			ISet<string> set = new HashSet<string> { "openid", "offline_access", "profile" };
			set.UnionWith(base.AuthenticationRequestParameters.Scope);
			dictionary["scope"] = set.AsSingleString();
			dictionary["client_info"] = "1";
			return dictionary;
		}

		protected override KeyValuePair<string, string>? GetCcsHeader(IDictionary<string, string> additionalBodyParameters)
		{
			return GetCcsUpnHeader(_usernamePasswordParameters.Username);
		}
	}
}
namespace Microsoft.Identity.Client.Internal.Requests.Silent
{
	internal class CacheSilentStrategy : ISilentAuthRequestStrategy
	{
		private readonly AcquireTokenSilentParameters _silentParameters;

		private const string TheOnlyFamilyId = "1";

		private readonly SilentRequest _silentRequest;

		private AuthenticationRequestParameters AuthenticationRequestParameters { get; }

		private ICacheSessionManager CacheManager => AuthenticationRequestParameters.CacheSessionManager;

		protected IServiceBundle ServiceBundle { get; }

		public CacheSilentStrategy(SilentRequest request, IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters silentParameters)
		{
			AuthenticationRequestParameters = authenticationRequestParameters;
			_silentParameters = silentParameters;
			ServiceBundle = serviceBundle;
			_silentRequest = request;
		}

		public async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			ILoggerAdapter logger = AuthenticationRequestParameters.RequestContext.Logger;
			MsalAccessTokenCacheItem cachedAccessTokenItem = null;
			CacheRefreshReason cacheInfoTelemetry = CacheRefreshReason.NotApplicable;
			ThrowIfCurrentBrokerAccount();
			AuthenticationResult authResult = null;
			if (!_silentParameters.ForceRefresh && string.IsNullOrEmpty(AuthenticationRequestParameters.Claims))
			{
				cachedAccessTokenItem = await CacheManager.FindAccessTokenAsync().ConfigureAwait(continueOnCapturedContext: false);
				if (cachedAccessTokenItem != null)
				{
					logger.Info("Returning access token found in cache. RefreshOn exists ? " + cachedAccessTokenItem.RefreshOn.HasValue);
					AuthenticationRequestParameters.RequestContext.ApiEvent.IsAccessTokenCacheHit = true;
					Metrics.IncrementTotalAccessTokensFromCache();
					authResult = await CreateAuthenticationResultAsync(cachedAccessTokenItem).ConfigureAwait(continueOnCapturedContext: false);
				}
				else if (AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo != CacheRefreshReason.Expired)
				{
					cacheInfoTelemetry = CacheRefreshReason.NoCachedAccessToken;
				}
			}
			else
			{
				cacheInfoTelemetry = CacheRefreshReason.ForceRefreshOrClaims;
				logger.Info("Skipped looking for an Access Token because ForceRefresh or Claims were set. ");
			}
			if (AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo == CacheRefreshReason.NotApplicable)
			{
				AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo = cacheInfoTelemetry;
			}
			AuthenticationResult result = default(AuthenticationResult);
			try
			{
				if (cachedAccessTokenItem == null)
				{
					authResult = await RefreshRtOrFailAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				else if (SilentRequestHelper.NeedsRefresh(cachedAccessTokenItem))
				{
					AuthenticationRequestParameters.RequestContext.ApiEvent.CacheInfo = CacheRefreshReason.ProactivelyRefreshed;
					SilentRequestHelper.ProcessFetchInBackground(cachedAccessTokenItem, delegate
					{
						using CancellationTokenSource cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
						return RefreshRtOrFailAsync(cancellationTokenSource.Token);
					}, logger, ServiceBundle, AuthenticationRequestParameters.RequestContext.ApiEvent.ApiId);
				}
				result = authResult;
				return result;
			}
			catch (MsalServiceException ex)
			{
				MsalServiceException ex2 = ex;
				logger.Warning($"Refreshing the RT failed. Is the exception retryable? {ex2.IsRetryable}. Is there an AT in the cache that is usable? {cachedAccessTokenItem != null} ");
				if (cachedAccessTokenItem != null && ex2.IsRetryable)
				{
					logger.Info("Returning existing access token. It is not expired, but should be refreshed. ");
					return await CreateAuthenticationResultAsync(cachedAccessTokenItem).ConfigureAwait(continueOnCapturedContext: false);
				}
				logger.Warning("Failed to refresh the RT and cannot use existing AT (expired or missing). ");
				ExceptionDispatchInfo.Capture((ex as Exception) ?? throw ex).Throw();
			}
			return result;
		}

		private void ThrowIfCurrentBrokerAccount()
		{
			if (PublicClientApplication.IsOperatingSystemAccount(AuthenticationRequestParameters.Account))
			{
				AuthenticationRequestParameters.RequestContext.Logger.Verbose(() => "OperatingSystemAccount is only supported by some brokers");
				throw new MsalUiRequiredException("current_broker_account", "Only some brokers (WAM) can log in the current OS account. ", null, UiRequiredExceptionClassification.AcquireTokenSilentFailed);
			}
		}

		private async Task<AuthenticationResult> RefreshRtOrFailAsync(CancellationToken cancellationToken)
		{
			MsalTokenResponse msalTokenResponse = await TryGetTokenUsingFociAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (msalTokenResponse == null)
			{
				msalTokenResponse = await SilentRequestHelper.RefreshAccessTokenAsync(await FindRefreshTokenOrFailAsync().ConfigureAwait(continueOnCapturedContext: false), _silentRequest, AuthenticationRequestParameters, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return await _silentRequest.CacheTokenResponseAndCreateAuthenticationResultAsync(msalTokenResponse).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<AuthenticationResult> CreateAuthenticationResultAsync(MsalAccessTokenCacheItem cachedAccessTokenItem)
		{
			MsalIdTokenCacheItem msalIdTokenItem = await CacheManager.GetIdTokenCacheItemAsync(cachedAccessTokenItem).ConfigureAwait(continueOnCapturedContext: false);
			Account account = await CacheManager.GetAccountAssociatedWithAccessTokenAsync(cachedAccessTokenItem).ConfigureAwait(continueOnCapturedContext: false);
			return new AuthenticationResult(cachedAccessTokenItem, msalIdTokenItem, AuthenticationRequestParameters.AuthenticationScheme, AuthenticationRequestParameters.RequestContext.CorrelationId, TokenSource.Cache, AuthenticationRequestParameters.RequestContext.ApiEvent, account, null, null);
		}

		private async Task<MsalTokenResponse> TryGetTokenUsingFociAsync(CancellationToken cancellationToken)
		{
			if (!ServiceBundle.PlatformProxy.GetFeatureFlags().IsFociEnabled)
			{
				return null;
			}
			ILoggerAdapter logger = AuthenticationRequestParameters.RequestContext.Logger;
			bool? flag = await CacheManager.IsAppFociMemberAsync("1").ConfigureAwait(continueOnCapturedContext: false);
			if (flag.HasValue && !flag.Value)
			{
				AuthenticationRequestParameters.RequestContext.Logger.Verbose(() => "[FOCI] App is not part of the family, skipping FOCI. ");
				return null;
			}
			logger.Verbose(() => "[FOCI] App is part of the family or unknown, looking for FRT. ");
			MsalRefreshTokenCacheItem familyRefreshToken = await CacheManager.FindFamilyRefreshTokenAsync("1").ConfigureAwait(continueOnCapturedContext: false);
			logger.Verbose(() => "[FOCI] FRT found? " + (familyRefreshToken != null));
			if (familyRefreshToken != null)
			{
				try
				{
					MsalTokenResponse result = await SilentRequestHelper.RefreshAccessTokenAsync(familyRefreshToken, _silentRequest, AuthenticationRequestParameters, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					logger.Verbose(() => "[FOCI] FRT refresh succeeded. ");
					return result;
				}
				catch (MsalServiceException ex)
				{
					ex?.GetType();
					return null;
				}
			}
			return null;
		}

		private async Task<MsalRefreshTokenCacheItem> FindRefreshTokenOrFailAsync()
		{
			MsalRefreshTokenCacheItem obj = await CacheManager.FindRefreshTokenAsync().ConfigureAwait(continueOnCapturedContext: false);
			if (obj == null)
			{
				AuthenticationRequestParameters.RequestContext.Logger.Verbose(() => "No Refresh Token was found in the cache. ");
				throw new MsalUiRequiredException("no_tokens_found", "No Refresh Token found in the cache. ", null, UiRequiredExceptionClassification.AcquireTokenSilentFailed);
			}
			return obj;
		}
	}
	internal interface ISilentAuthRequestStrategy
	{
		Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
	}
	internal class SilentRequest : RequestBase
	{
		private readonly AcquireTokenSilentParameters _silentParameters;

		private readonly ISilentAuthRequestStrategy _clientStrategy;

		private readonly Lazy<ISilentAuthRequestStrategy> _brokerStrategyLazy;

		private readonly ILoggerAdapter _logger;

		public SilentRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters silentParameters, ISilentAuthRequestStrategy clientStrategyOverride = null, ISilentAuthRequestStrategy brokerStrategyOverride = null)
			: base(serviceBundle, authenticationRequestParameters, silentParameters)
		{
			SilentRequest request = this;
			_silentParameters = silentParameters;
			_brokerStrategyLazy = new Lazy<ISilentAuthRequestStrategy>(() => brokerStrategyOverride ?? new BrokerSilentStrategy(request, serviceBundle, authenticationRequestParameters, silentParameters, serviceBundle.PlatformProxy.CreateBroker(serviceBundle.Config, null)));
			_clientStrategy = clientStrategyOverride ?? new CacheSilentStrategy(this, serviceBundle, authenticationRequestParameters, silentParameters);
			_logger = authenticationRequestParameters.RequestContext.Logger;
		}

		protected override async Task<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken)
		{
			await UpdateRequestWithAccountAsync().ConfigureAwait(continueOnCapturedContext: false);
			bool isBrokerConfigured = base.AuthenticationRequestParameters.AppConfig.IsBrokerEnabled && base.ServiceBundle.PlatformProxy.CanBrokerSupportSilentAuth();
			try
			{
				if (base.AuthenticationRequestParameters.Account == null)
				{
					_logger.Verbose(() => "No account passed to AcquireTokenSilent. ");
					throw new MsalUiRequiredException("user_null", "No account or login hint was passed to the AcquireTokenSilent call. ", null, UiRequiredExceptionClassification.AcquireTokenSilentFailed);
				}
				if (isBrokerConfigured)
				{
					_logger.Info("Broker is configured and enabled, attempting to use broker instead.");
					AuthenticationResult authenticationResult = await _brokerStrategyLazy.Value.ExecuteAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					if (authenticationResult != null)
					{
						_logger.Verbose(() => "Broker responded to silent request.");
						return authenticationResult;
					}
				}
				_logger.Verbose(() => "Attempting to acquire token using local cache.");
				return await _clientStrategy.ExecuteAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (MsalException ex)
			{
				_logger.Verbose(() => (!isBrokerConfigured) ? "Token cache could not satisfy silent request." : "Broker could not satisfy silent request.");
				throw ex;
			}
		}

		internal new Task<AuthenticationResult> CacheTokenResponseAndCreateAuthenticationResultAsync(MsalTokenResponse response)
		{
			return base.CacheTokenResponseAndCreateAuthenticationResultAsync(response);
		}

		internal Task<AuthenticationResult> ExecuteTestAsync(CancellationToken cancellationToken)
		{
			return ExecuteAsync(cancellationToken);
		}

		private async Task UpdateRequestWithAccountAsync()
		{
			IAccount account = await GetAccountFromParamsOrLoginHintAsync(_silentParameters.Account, _silentParameters.LoginHint).ConfigureAwait(continueOnCapturedContext: false);
			base.AuthenticationRequestParameters.Account = account;
			Authority initialAuthority = await Authority.CreateAuthorityForRequestAsync(base.AuthenticationRequestParameters.RequestContext, base.AuthenticationRequestParameters.AuthorityOverride, account).ConfigureAwait(continueOnCapturedContext: false);
			base.AuthenticationRequestParameters.AuthorityManager = new AuthorityManager(base.AuthenticationRequestParameters.RequestContext, initialAuthority);
		}

		private async Task<IAccount> GetSingleAccountForLoginHintAsync(string loginHint)
		{
			if (!string.IsNullOrEmpty(loginHint))
			{
				List<IAccount> list = (await base.CacheManager.GetAccountsAsync().ConfigureAwait(continueOnCapturedContext: false)).Where((IAccount a) => !string.IsNullOrWhiteSpace(a.Username) && a.Username.Equals(loginHint, StringComparison.OrdinalIgnoreCase)).ToList();
				if (((IReadOnlyCollection<IAccount>)list).Count == 0)
				{
					throw new MsalUiRequiredException("no_account_for_login_hint", "You are trying to acquire a token silently using a login hint. No account was found in the token cache having this login hint. ", null, UiRequiredExceptionClassification.AcquireTokenSilentFailed);
				}
				if (((IReadOnlyCollection<IAccount>)list).Count > 1)
				{
					throw new MsalUiRequiredException("multiple_accounts_for_login_hint", "You are trying to acquire a token silently using a login hint. Multiple accounts were found in the token cache having this login hint. Please choose an account manually an pass it in to AcquireTokenSilently. ", null, UiRequiredExceptionClassification.AcquireTokenSilentFailed);
				}
				return ((IReadOnlyList<IAccount>)list)[0];
			}
			return null;
		}

		private async Task<IAccount> GetAccountFromParamsOrLoginHintAsync(IAccount account, string loginHint)
		{
			if (account != null)
			{
				return account;
			}
			return await GetSingleAccountForLoginHintAsync(loginHint).ConfigureAwait(continueOnCapturedContext: false);
		}

		protected override void ValidateAccountIdentifiers(ClientInfo fromServer)
		{
			if (fromServer == null || base.AuthenticationRequestParameters?.Account?.HomeAccountId == null || PublicClientApplication.IsOperatingSystemAccount(base.AuthenticationRequestParameters?.Account) || (base.AuthenticationRequestParameters.AuthorityInfo.AuthorityType == AuthorityType.B2C && fromServer.UniqueTenantIdentifier.Equals(base.AuthenticationRequestParameters.Account.HomeAccountId.TenantId, StringComparison.OrdinalIgnoreCase)) || (fromServer.UniqueObjectIdentifier.Equals(base.AuthenticationRequestParameters.Account.HomeAccountId.ObjectId, StringComparison.OrdinalIgnoreCase) && fromServer.UniqueTenantIdentifier.Equals(base.AuthenticationRequestParameters.Account.HomeAccountId.TenantId, StringComparison.OrdinalIgnoreCase)))
			{
				return;
			}
			base.AuthenticationRequestParameters.RequestContext.Logger.Error("Returned user identifiers do not match the sent user identifier");
			base.AuthenticationRequestParameters.RequestContext.Logger.ErrorPii("User identifier returned by AAD (uid:" + fromServer.UniqueObjectIdentifier + " utid:" + fromServer.UniqueTenantIdentifier + ") does not match the user identifier sent. (uid:" + base.AuthenticationRequestParameters.Account.HomeAccountId.ObjectId + " utid:" + base.AuthenticationRequestParameters.Account.HomeAccountId.TenantId + ")", string.Empty);
			throw new MsalClientException("user_mismatch", "Returned user identifier does not match the sent user identifier when saving the token to the cache. ");
		}
	}
}
namespace Microsoft.Identity.Client.Internal.Logger
{
	internal class CallbackIdentityLogger : IIdentityLogger
	{
		private LogCallback _logCallback;

		private readonly string _correlationId;

		private readonly string _clientInformation;

		private readonly bool _piiLoggingEnabled;

		private readonly LogLevel _minLogLevel;

		public CallbackIdentityLogger(LogCallback logCallback, string correlationId, string clientName, string clientVersion, bool enablePiiLogging, LogLevel minLogLevel)
		{
			_correlationId = correlationId;
			_clientInformation = LoggerHelper.GetClientInfo(clientName, clientVersion);
			_piiLoggingEnabled = enablePiiLogging;
			_logCallback = logCallback;
			_minLogLevel = minLogLevel;
		}

		public bool IsEnabled(EventLogLevel eventLevel)
		{
			if (_logCallback != null)
			{
				return GetLogLevel(eventLevel) <= _minLogLevel;
			}
			return false;
		}

		public void Log(LogEntry entry)
		{
			string message = LoggerHelper.FormatLogMessage(entry.Message, _piiLoggingEnabled, string.IsNullOrEmpty(entry.CorrelationId) ? entry.CorrelationId : _correlationId, _clientInformation);
			_logCallback(GetLogLevel(entry.EventLogLevel), message, _piiLoggingEnabled);
		}

		private static LogLevel GetLogLevel(EventLogLevel eventLogLevel)
		{
			if (eventLogLevel == EventLogLevel.LogAlways)
			{
				return LogLevel.Always;
			}
			return (LogLevel)(eventLogLevel - 2);
		}
	}
	internal class CallbackIdentityLoggerAdapter : ILoggerAdapter
	{
		private string _correlationId;

		public bool PiiLoggingEnabled { get; }

		public bool IsDefaultPlatformLoggingEnabled { get; }

		public string ClientName { get; }

		public string ClientVersion { get; }

		public IIdentityLogger IdentityLogger { get; }

		public bool IsLoggingEnabled(LogLevel logLevel)
		{
			return IdentityLogger.IsEnabled(LoggerHelper.GetEventLogLevel(logLevel));
		}

		internal CallbackIdentityLoggerAdapter(Guid correlationId, string clientName, string clientVersion, LogLevel logLevel, bool enablePiiLogging, bool isDefaultPlatformLoggingEnabled, LogCallback loggingCallback)
		{
			ClientName = clientName;
			ClientVersion = clientVersion;
			string correlationId2;
			if (!correlationId.Equals(Guid.Empty))
			{
				Guid guid = correlationId;
				correlationId2 = " - " + guid.ToString();
			}
			else
			{
				correlationId2 = string.Empty;
			}
			_correlationId = correlationId2;
			PiiLoggingEnabled = enablePiiLogging;
			IsDefaultPlatformLoggingEnabled = isDefaultPlatformLoggingEnabled;
			IdentityLogger = new CallbackIdentityLogger(loggingCallback, _correlationId, clientName, clientVersion, enablePiiLogging, logLevel);
		}

		public void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed)
		{
			if (IsLoggingEnabled(logLevel))
			{
				string messageToLog = LoggerHelper.GetMessageToLog(messageWithPii, messageScrubbed, PiiLoggingEnabled);
				LogEntry logEntry = new LogEntry();
				logEntry.EventLogLevel = LoggerHelper.GetEventLogLevel(logLevel);
				logEntry.CorrelationId = _correlationId;
				logEntry.Message = messageToLog;
				IdentityLogger.Log(logEntry);
			}
		}

		public static ILoggerAdapter Create(Guid correlationId, ApplicationConfiguration config, bool isDefaultPlatformLoggingEnabled = false)
		{
			return new CallbackIdentityLoggerAdapter(correlationId, config?.ClientName ?? string.Empty, config?.ClientVersion ?? string.Empty, config?.LogLevel ?? LogLevel.Verbose, config?.EnablePiiLogging ?? false, config?.IsDefaultPlatformLoggingEnabled ?? isDefaultPlatformLoggingEnabled, config?.LoggingCallback);
		}

		public DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel = LogLevel.Verbose)
		{
			return new DurationLogHelper(this, measuredBlockName, logLevel);
		}

		public DurationLogHelper LogMethodDuration(LogLevel logLevel = LogLevel.Verbose, [CallerMemberName] string methodName = null, [CallerFilePath] string filePath = null)
		{
			return LoggerHelper.LogMethodDuration(this, logLevel, methodName, filePath);
		}
	}
	internal sealed class DurationLogHelper : IDisposable
	{
		private readonly ILoggerAdapter _logger;

		private readonly string _measuredBlockName;

		private readonly LogLevel _logLevel;

		private readonly long _startMilliseconds;

		public DurationLogHelper(ILoggerAdapter logger, string measuredBlockName, LogLevel logLevel = LogLevel.Verbose)
		{
			_logger = logger;
			_measuredBlockName = measuredBlockName;
			_logLevel = logLevel;
			_startMilliseconds = StopwatchService.CurrentElapsedMilliseconds;
			_logger.Log(LogLevel.Verbose, string.Empty, "Starting " + measuredBlockName);
		}

		public void Dispose()
		{
			_logger.Log(LogLevel.Verbose, string.Empty, $"Finished {_measuredBlockName} in {StopwatchService.CurrentElapsedMilliseconds - _startMilliseconds} ms");
		}
	}
	internal class IdentityLogger : IIdentityLogger
	{
		private readonly IIdentityLogger _identityLogger;

		private readonly string _correlationId;

		private readonly string _clientInformation;

		private readonly bool _piiLoggingEnabled;

		internal IdentityLogger(IIdentityLogger identityLogger, Guid correlationId, string clientName, string clientVersion, bool enablePiiLogging)
		{
			_identityLogger = identityLogger;
			string correlationId2;
			if (!correlationId.Equals(Guid.Empty))
			{
				Guid guid = correlationId;
				correlationId2 = " - " + guid.ToString();
			}
			else
			{
				correlationId2 = string.Empty;
			}
			_correlationId = correlationId2;
			_clientInformation = LoggerHelper.GetClientInfo(clientName, clientVersion);
			_piiLoggingEnabled = enablePiiLogging;
		}

		public bool IsEnabled(EventLogLevel eventLevel)
		{
			return _identityLogger.IsEnabled(eventLevel);
		}

		public void Log(LogEntry entry)
		{
			entry.Message = LoggerHelper.FormatLogMessage(entry.Message, _piiLoggingEnabled, (!string.IsNullOrEmpty(entry.CorrelationId)) ? entry.CorrelationId : _correlationId, _clientInformation);
			_identityLogger.Log(entry);
		}
	}
	internal class IdentityLoggerAdapter : ILoggerAdapter
	{
		private string _correlationId;

		public bool PiiLoggingEnabled { get; }

		public bool IsDefaultPlatformLoggingEnabled { get; }

		public string ClientName { get; }

		public string ClientVersion { get; }

		public IIdentityLogger IdentityLogger { get; }

		internal IdentityLoggerAdapter(IIdentityLogger identityLogger, Guid correlationId, string clientName, string clientVersion, bool enablePiiLogging)
		{
			ClientName = clientName;
			ClientVersion = clientVersion;
			IdentityLogger = new IdentityLogger(identityLogger, correlationId, clientName, clientVersion, enablePiiLogging);
			string correlationId2;
			if (!correlationId.Equals(Guid.Empty))
			{
				Guid guid = correlationId;
				correlationId2 = " - " + guid.ToString();
			}
			else
			{
				correlationId2 = string.Empty;
			}
			_correlationId = correlationId2;
			PiiLoggingEnabled = enablePiiLogging;
		}

		public static ILoggerAdapter Create(Guid correlationId, ApplicationConfiguration config)
		{
			return new IdentityLoggerAdapter(config?.IdentityLogger, correlationId, config?.ClientName ?? string.Empty, config?.ClientVersion ?? string.Empty, config?.EnablePiiLogging ?? false);
		}

		public void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed)
		{
			if (IsLoggingEnabled(logLevel))
			{
				string messageToLog = LoggerHelper.GetMessageToLog(messageWithPii, messageScrubbed, PiiLoggingEnabled);
				LogEntry logEntry = new LogEntry();
				logEntry.EventLogLevel = LoggerHelper.GetEventLogLevel(logLevel);
				logEntry.CorrelationId = _correlationId;
				logEntry.Message = messageToLog;
				IdentityLogger.Log(logEntry);
			}
		}

		public bool IsLoggingEnabled(LogLevel logLevel)
		{
			return IdentityLogger.IsEnabled(LoggerHelper.GetEventLogLevel(logLevel));
		}

		public DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel = LogLevel.Verbose)
		{
			return new DurationLogHelper(this, measuredBlockName, logLevel);
		}

		public DurationLogHelper LogMethodDuration(LogLevel logLevel = LogLevel.Verbose, [CallerMemberName] string methodName = null, [CallerFilePath] string filePath = null)
		{
			return LoggerHelper.LogMethodDuration(this, logLevel, methodName, filePath);
		}
	}
	internal class LoggerHelper
	{
		private static Lazy<string> s_msalVersionLazy = new Lazy<string>(MsalIdHelper.GetMsalVersion);

		private static Lazy<string> s_runtimeVersionLazy = new Lazy<string>(() => PlatformProxyFactory.CreatePlatformProxy(null).GetRuntimeVersion());

		private static readonly Lazy<ILoggerAdapter> s_nullLogger = new Lazy<ILoggerAdapter>(() => new NullLogger());

		private static Lazy<string> s_osLazy = new Lazy<string>(() => MsalIdHelper.GetMsalIdParameters(null).TryGetValue("x-client-OS", out var value) ? value : "Unknown OS");

		private static Lazy<string> s_skuLazy = new Lazy<string>(() => MsalIdHelper.GetMsalIdParameters(null).TryGetValue("x-client-SKU", out value) ? value : "Unknown SKU");

		public static ILoggerAdapter NullLogger => s_nullLogger.Value;

		public static string GetClientInfo(string clientName, string clientVersion)
		{
			if (!string.IsNullOrEmpty(clientName) && !"UnknownClient".Equals(clientName))
			{
				if (string.IsNullOrEmpty(clientVersion))
				{
					return " (" + clientName + ")";
				}
				return " (" + clientName + ": " + clientVersion + ")";
			}
			return string.Empty;
		}

		public static ILoggerAdapter CreateLogger(Guid correlationId, ApplicationConfiguration config)
		{
			if (config.IdentityLogger == null)
			{
				if (config.LoggingCallback == null)
				{
					return s_nullLogger.Value;
				}
				return CallbackIdentityLoggerAdapter.Create(correlationId, config);
			}
			return IdentityLoggerAdapter.Create(correlationId, config);
		}

		public static string FormatLogMessage(string message, bool piiEnabled, string correlationId, string clientInformation)
		{
			return string.Format(CultureInfo.InvariantCulture, "{0} MSAL {1} {2} {3} {4} [{5}{6}]{7} {8}", piiEnabled, s_msalVersionLazy.Value, s_skuLazy.Value, s_runtimeVersionLazy.Value, s_osLazy.Value, DateTime.UtcNow.ToString("u"), correlationId, clientInformation, message);
		}

		internal static string GetPiiScrubbedExceptionDetails(Exception ex)
		{
			if (ex == null)
			{
				return string.Empty;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine(string.Format(CultureInfo.InvariantCulture, "Exception type: {0}", ex.GetType()));
			if (ex is MsalException ex2)
			{
				stringBuilder.AppendLine(", ErrorCode: " + ex2.ErrorCode);
			}
			if (ex is MsalServiceException ex3)
			{
				stringBuilder.AppendLine(string.Format(CultureInfo.InvariantCulture, "HTTP StatusCode {0}", ex3.StatusCode));
				stringBuilder.AppendLine("CorrelationId " + ex3.CorrelationId);
				string[] errorCodes = ex3.ErrorCodes;
				if (errorCodes != null && errorCodes.Length > 0)
				{
					stringBuilder.AppendLine("Microsoft Entra ID Error Code AADSTS" + string.Join(" ", ex3.ErrorCodes));
				}
			}
			if (ex.InnerException != null)
			{
				stringBuilder.AppendLine("---> Inner Exception Details");
				stringBuilder.AppendLine(GetPiiScrubbedExceptionDetails(ex.InnerException));
				stringBuilder.AppendLine("=== End of inner exception stack trace ===");
			}
			if (ex is MsalClaimsChallengeException)
			{
				stringBuilder.AppendLine("The returned error contains a claims challenge. For additional info on how to handle claims related to multifactor authentication, Conditional Access, and incremental consent, see https://aka.ms/msal-conditional-access-claims. If you are using the On-Behalf-Of flow, see https://aka.ms/msal-conditional-access-claims-obo for details.");
			}
			stringBuilder.AppendLine("To see full exception details, enable PII Logging. See https://aka.ms/msal-net-logging");
			if (ex.StackTrace != null)
			{
				stringBuilder.AppendLine(ex.StackTrace);
			}
			return stringBuilder.ToString();
		}

		public static DurationLogHelper LogBlockDuration(ILoggerAdapter logger, string measuredBlockName, LogLevel logLevel = LogLevel.Verbose)
		{
			return new DurationLogHelper(logger, measuredBlockName, logLevel);
		}

		public static DurationLogHelper LogMethodDuration(ILoggerAdapter logger, LogLevel logLevel = LogLevel.Verbose, [CallerMemberName] string methodName = null, [CallerFilePath] string filePath = null)
		{
			string text = ((!string.IsNullOrEmpty(filePath)) ? Path.GetFileNameWithoutExtension(filePath) : "");
			return new DurationLogHelper(logger, text + ":" + methodName, logLevel);
		}

		public static EventLogLevel GetEventLogLevel(LogLevel logLevel)
		{
			if (logLevel == LogLevel.Always)
			{
				return EventLogLevel.LogAlways;
			}
			return (EventLogLevel)(logLevel + 2);
		}

		public static string GetMessageToLog(string messageWithPii, string messageScrubbed, bool piiLoggingEnabled)
		{
			if (!(!string.IsNullOrWhiteSpace(messageWithPii) && piiLoggingEnabled))
			{
				return messageScrubbed;
			}
			return messageWithPii;
		}
	}
	internal class NullLogger : ILoggerAdapter
	{
		public string ClientName { get; } = string.Empty;

		public string ClientVersion { get; } = string.Empty;

		public Guid CorrelationId { get; } = Guid.Empty;

		public bool PiiLoggingEnabled { get; }

		public string ClientInformation { get; } = string.Empty;

		public bool IsDefaultPlatformLoggingEnabled { get; }

		public IIdentityLogger IdentityLogger { get; } = NullIdentityModelLogger.Instance;

		public bool IsLoggingEnabled(LogLevel logLevel)
		{
			return false;
		}

		public void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed)
		{
		}

		public DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel = LogLevel.Verbose)
		{
			return null;
		}

		public DurationLogHelper LogMethodDuration(LogLevel logLevel = LogLevel.Verbose, [CallerMemberName] string methodName = null, [CallerFilePath] string filePath = null)
		{
			return null;
		}
	}
}
namespace Microsoft.Identity.Client.Internal.ClientCredential
{
	internal class CertificateAndClaimsClientCredential : IClientCredential
	{
		private readonly IDictionary<string, string> _claimsToSign;

		private readonly bool _appendDefaultClaims;

		public X509Certificate2 Certificate { get; }

		public AssertionType AssertionType => AssertionType.CertificateWithoutSni;

		public CertificateAndClaimsClientCredential(X509Certificate2 certificate, IDictionary<string, string> claimsToSign, bool appendDefaultClaims)
		{
			Certificate = certificate;
			_claimsToSign = claimsToSign;
			_appendDefaultClaims = appendDefaultClaims;
		}

		public Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, bool useSha2AndPss, CancellationToken cancellationToken)
		{
			string value = new JsonWebToken(cryptographyManager, clientId, tokenEndpoint, _claimsToSign, _appendDefaultClaims).Sign(Certificate, sendX5C, useSha2AndPss);
			oAuth2Client.AddBodyParameter("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer");
			oAuth2Client.AddBodyParameter("client_assertion", value);
			return Task.CompletedTask;
		}
	}
	internal class CertificateClientCredential : CertificateAndClaimsClientCredential
	{
		public CertificateClientCredential(X509Certificate2 certificate)
			: base(certificate, null, appendDefaultClaims: true)
		{
		}
	}
	internal interface IClientCredential
	{
		AssertionType AssertionType { get; }

		Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, bool useSha2, CancellationToken cancellationToken);
	}
	internal class SecretStringClientCredential : IClientCredential
	{
		internal string Secret { get; }

		public AssertionType AssertionType => AssertionType.Secret;

		public SecretStringClientCredential(string secret)
		{
			Secret = secret;
		}

		public Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, bool useSha2, CancellationToken cancellationToken)
		{
			oAuth2Client.AddBodyParameter("client_secret", Secret);
			return Task.CompletedTask;
		}
	}
	internal class SignedAssertionClientCredential : IClientCredential
	{
		private readonly string _signedAssertion;

		public AssertionType AssertionType => AssertionType.ClientAssertion;

		public SignedAssertionClientCredential(string signedAssertion)
		{
			_signedAssertion = signedAssertion;
		}

		public Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, bool useSha2, CancellationToken cancellationToken)
		{
			oAuth2Client.AddBodyParameter("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer");
			oAuth2Client.AddBodyParameter("client_assertion", _signedAssertion);
			return Task.CompletedTask;
		}
	}
	internal class SignedAssertionDelegateClientCredential : IClientCredential
	{
		internal Func<CancellationToken, Task<string>> _signedAssertionDelegate { get; }

		internal Func<AssertionRequestOptions, Task<string>> _signedAssertionWithInfoDelegate { get; }

		public AssertionType AssertionType => AssertionType.ClientAssertion;

		[EditorBrowsable(EditorBrowsableState.Never)]
		public SignedAssertionDelegateClientCredential(Func<CancellationToken, Task<string>> signedAssertionDelegate)
		{
			_signedAssertionDelegate = signedAssertionDelegate;
		}

		public SignedAssertionDelegateClientCredential(Func<AssertionRequestOptions, Task<string>> signedAssertionDelegate)
		{
			_signedAssertionWithInfoDelegate = signedAssertionDelegate;
		}

		public async Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, bool useSha2, CancellationToken cancellationToken)
		{
			string value = await ((_signedAssertionDelegate != null) ? _signedAssertionDelegate(cancellationToken).ConfigureAwait(continueOnCapturedContext: false) : _signedAssertionWithInfoDelegate(new AssertionRequestOptions
			{
				CancellationToken = cancellationToken,
				ClientID = clientId,
				TokenEndpoint = tokenEndpoint
			}).ConfigureAwait(continueOnCapturedContext: false));
			oAuth2Client.AddBodyParameter("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer");
			oAuth2Client.AddBodyParameter("client_assertion", value);
		}
	}
}
namespace Microsoft.Identity.Client.Internal.Broker
{
	internal class BrokerInteractiveRequestComponent : ITokenRequestComponent
	{
		private readonly AcquireTokenInteractiveParameters _interactiveParameters;

		private readonly string _optionalBrokerInstallUrl;

		private readonly AuthenticationRequestParameters _authenticationRequestParameters;

		private readonly IServiceBundle _serviceBundle;

		private readonly ILoggerAdapter _logger;

		internal IBroker Broker { get; }

		public BrokerInteractiveRequestComponent(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenInteractiveParameters acquireTokenInteractiveParameters, IBroker broker, string optionalBrokerInstallUrl)
		{
			_authenticationRequestParameters = authenticationRequestParameters;
			_interactiveParameters = acquireTokenInteractiveParameters;
			_serviceBundle = authenticationRequestParameters.RequestContext.ServiceBundle;
			Broker = broker;
			_optionalBrokerInstallUrl = optionalBrokerInstallUrl;
			_logger = _authenticationRequestParameters.RequestContext.Logger;
		}

		public async Task<MsalTokenResponse> FetchTokensAsync(CancellationToken cancellationToken)
		{
			if (Broker.IsBrokerInstalledAndInvokable(_authenticationRequestParameters.AuthorityInfo.AuthorityType))
			{
				_logger.Info("Can invoke broker. Will attempt to acquire token with broker. ");
			}
			else
			{
				if (string.IsNullOrEmpty(_optionalBrokerInstallUrl))
				{
					_logger.Info("Broker is required but is not installed or not available on the current platform. An app URI has not been provided. MSAL will fallback to use a browser.");
					return null;
				}
				_logger.Info("Broker is required for authentication and broker is not installed on the device. Adding BrokerInstallUrl to broker payload. ");
				Broker.HandleInstallUrl(_optionalBrokerInstallUrl);
			}
			MsalTokenResponse msalTokenResponse = await Broker.AcquireTokenInteractiveAsync(_authenticationRequestParameters, _interactiveParameters).ConfigureAwait(continueOnCapturedContext: false);
			ValidateResponseFromBroker(msalTokenResponse);
			return msalTokenResponse;
		}

		internal void ValidateResponseFromBroker(MsalTokenResponse msalTokenResponse)
		{
			_logger.Info("Checking MsalTokenResponse returned from broker. ");
			if (!string.IsNullOrEmpty(msalTokenResponse.AccessToken))
			{
				_logger.Info("Success. Broker response contains an access token. ");
				return;
			}
			if (msalTokenResponse.Error != null)
			{
				_logger.Error(LogMessages.ErrorReturnedInBrokerResponse(msalTokenResponse.Error));
				throw MsalServiceExceptionFactory.FromBrokerResponse(msalTokenResponse, "Broker response returned error: " + msalTokenResponse.ErrorDescription);
			}
			_logger.Error("Unknown error returned in broker response. ");
			throw new MsalServiceException("broker_response_returned_error", "Broker response returned an error which does not contain an error or error description. See https://aka.ms/msal-brokers for details. ", null);
		}

		public static bool IsBrokerRequiredAuthCode(string authCode, out string installationUri)
		{
			if (authCode.StartsWith("msauth://", StringComparison.OrdinalIgnoreCase))
			{
				installationUri = ExtractAppLink(authCode);
				return installationUri != null;
			}
			installationUri = null;
			return false;
		}

		private static string ExtractAppLink(string authCode)
		{
			string text = new Uri(authCode).Query;
			if (text.StartsWith("?", StringComparison.OrdinalIgnoreCase))
			{
				text = text.Substring(1);
			}
			Dictionary<string, string> dictionary = CoreHelpers.ParseKeyValueList(text, '&', urlDecode: true, lowercaseKeys: true, null);
			if (!dictionary.ContainsKey("app_link"))
			{
				return null;
			}
			return dictionary["app_link"];
		}
	}
	internal class BrokerParameter
	{
		public const string Authority = "authority";

		public const string ClientId = "client_id";

		public const string Scope = "scope";

		public const string ExtraOidcScopes = "extra_oidc_scopes";

		public const string OidcScopesValue = "openid offline_access profile";

		public const string RedirectUri = "redirect_uri";

		public const string BrokerKey = "broker_key";

		public const string ClientVersion = "client_version";

		public const string MsgProtocolVersion = "msg_protocol_ver";

		public const string MsgProtocolVersion3 = "3";

		public const string SkipCache = "YES";

		public const string AppLink = "app_link";

		public const string IsSilentBrokerRequest = "is_silent_broker_request";

		public const string CorrelationId = "correlation_id";

		public const string ExtraQp = "extra_query_param";

		public const string HomeAccountId = "home_account_id";

		public const string LocalAccountId = "local_account_id";

		public const string Username = "username";

		public const string IntuneEnrollmentIds = "intune_enrollment_ids";

		public const string IntuneMamResource = "intune_mam_resource";

		public const string ClientCapabilities = "client_capabilities";

		public const string ClientAppName = "client_app_name";

		public const string ClientAppVersion = "client_app_version";

		public const string Claims = "claims";

		public const string ExtraConsentScopes = "extra_consent_scopes";

		public const string Prompt = "prompt";

		public const string BrokerAccountName = "broker_account_name";

		public const string ForceRefresh = "force_refresh";

		public const string Force = "force";

		public const string BrokerInstallUrl = "broker_install_url";

		public const string UriSchemeBrokerV2 = "msauthv2://";

		public const string UriSchemeBrokerV3 = "msauthv3://";

		public const string AuthCodePrefixForEmbeddedWebviewBrokerInstallRequired = "msauth://";
	}
	internal static class BrokerResponseConst
	{
		public const string ErrorMetadata = "error_metadata";

		public const string BrokerErrorDomain = "broker_error_domain";

		public const string BrokerErrorCode = "broker_error_code";

		public const string BrokerErrorDescription = "error_description";

		public const string BrokerSubError = "oauth_sub_error";

		public const string BrokerHttpHeaders = "http_response_headers";

		public const string BrokerHttpBody = "http_response_body";

		public const string BrokerHttpStatusCode = "http_response_code";

		public const string BrokerErrorMessage = "broker_error_message";

		public const string Authority = "authority";

		public const string AccessToken = "access_token";

		public const string ClientId = "client_id";

		public const string RefreshToken = "refresh_token";

		public const string IdToken = "id_token";

		public const string Bearer = "Bearer";

		public const string CorrelationId = "correlation_id";

		public const string Scope = "scope";

		public const string AndroidScopes = "scopes";

		public const string ExpiresOn = "expires_on";

		public const string ExtendedExpiresOn = "ext_expires_on";

		public const string ClientInfo = "client_info";

		public const string Account = "mAccount";

		public const string HomeAccountId = "home_account_id";

		public const string LocalAccountId = "local_account_id";

		public const string TenantId = "tenant_id";

		public const string UserName = "username";

		public const string iOSBrokerNonce = "broker_nonce";

		public const string iOSBrokerTenantId = "utid";

		public const string Environment = "environment";

		public const string iOSBrokerUserCancellationErrorCode = "-50005";

		public const string iOSBrokerProtectionPoliciesRequiredErrorCode = "-50004";

		public const string TokenType = "token_type";

		public const string AndroidNoTokenFound = "no_tokens_found";

		public const string AndroidNoAccountFound = "no_account_found";

		public const string AndroidUnauthorizedClient = "unauthorized_client";

		public const string AndroidInvalidRefreshToken = "Broker refresh token is invalid";

		public const string AndroidProtectionPolicyRequired = "protection_policy_required";
	}
	internal interface IBroker
	{
		bool IsPopSupported { get; }

		bool IsBrokerInstalledAndInvokable(AuthorityType authorityType);

		Task<MsalTokenResponse> AcquireTokenInteractiveAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenInteractiveParameters acquireTokenInteractiveParameters);

		Task<MsalTokenResponse> AcquireTokenSilentAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);

		Task<MsalTokenResponse> AcquireTokenSilentDefaultUserAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);

		Task<MsalTokenResponse> AcquireTokenByUsernamePasswordAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByUsernamePasswordParameters acquireTokenByUsernamePasswordParameters);

		IReadOnlyDictionary<string, string> GetSsoPolicyHeaders();

		void HandleInstallUrl(string appLink);

		Task<IReadOnlyList<IAccount>> GetAccountsAsync(string clientId, string redirectUri, AuthorityInfo authorityInfo, ICacheSessionManager cacheSessionManager, IInstanceDiscoveryManager instanceDiscoveryManager);

		Task RemoveAccountAsync(ApplicationConfiguration appConfig, IAccount account);
	}
	internal class NullBroker : IBroker
	{
		private readonly ILoggerAdapter _logger;

		public bool IsPopSupported => false;

		public NullBroker(ILoggerAdapter logger)
		{
			_logger = logger ?? new NullLogger();
		}

		public virtual bool IsBrokerInstalledAndInvokable(AuthorityType authorityType)
		{
			_logger.Info("NullBroker - acting as not installed.");
			return false;
		}

		public Task<MsalTokenResponse> AcquireTokenInteractiveAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenInteractiveParameters acquireTokenInteractiveParameters)
		{
			throw new PlatformNotSupportedException();
		}

		public Task<MsalTokenResponse> AcquireTokenSilentAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters)
		{
			_logger.Info("NullBroker - returning null on silent request.");
			return Task.FromResult<MsalTokenResponse>(null);
		}

		public void HandleInstallUrl(string appLink)
		{
			throw new PlatformNotSupportedException();
		}

		public Task RemoveAccountAsync(ApplicationConfiguration appConfig, IAccount account)
		{
			_logger.Info("NullBroker::RemoveAccountAsync - NOP.");
			return Task.Delay(0);
		}

		public Task<MsalTokenResponse> AcquireTokenSilentDefaultUserAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters)
		{
			_logger.Info("NullBroker - returning null on silent request.");
			return Task.FromResult<MsalTokenResponse>(null);
		}

		public Task<IReadOnlyList<IAccount>> GetAccountsAsync(string clientID, string redirectUri, AuthorityInfo authorityInfo, ICacheSessionManager cacheSessionManager, IInstanceDiscoveryManager instanceDiscoveryManager)
		{
			_logger.Info("NullBroker - returning empty list on GetAccounts request.");
			return Task.FromResult(CollectionHelpers.GetEmptyReadOnlyList<IAccount>());
		}

		public Task<MsalTokenResponse> AcquireTokenByUsernamePasswordAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByUsernamePasswordParameters acquireTokenByUsernamePasswordParameters)
		{
			_logger.Info("NullBroker - returning null on ROPC request.");
			return Task.FromResult<MsalTokenResponse>(null);
		}

		public IReadOnlyDictionary<string, string> GetSsoPolicyHeaders()
		{
			return CollectionHelpers.GetEmptyDictionary<string, string>();
		}
	}
	internal interface ITokenRequestComponent
	{
		Task<MsalTokenResponse> FetchTokensAsync(CancellationToken cancellationToken);
	}
}
namespace Microsoft.Identity.Client.Region
{
	internal interface IRegionDiscoveryProvider
	{
		Task<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext);
	}
	internal class RegionDiscoveryProvider : IRegionDiscoveryProvider
	{
		private readonly IRegionManager _regionManager;

		public const string PublicEnvForRegional = "login.microsoft.com";

		public RegionDiscoveryProvider(IHttpManager httpManager, bool clearCache)
		{
			_regionManager = new RegionManager(httpManager, 2000, clearCache);
		}

		public async Task<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext)
		{
			string text = null;
			ApiEvent apiEvent = requestContext.ApiEvent;
			if (apiEvent != null && apiEvent.ApiId == ApiEvent.ApiIds.AcquireTokenForClient)
			{
				text = await _regionManager.GetAzureRegionAsync(requestContext).ConfigureAwait(continueOnCapturedContext: false);
			}
			if (string.IsNullOrEmpty(text))
			{
				requestContext.Logger.Info("[Region discovery] Not using a regional authority. ");
				return null;
			}
			if (authority.Host.StartsWith(text + "."))
			{
				return CreateEntry(requestContext.ServiceBundle.Config.Authority.AuthorityInfo.Host, authority.Host);
			}
			string regionalizedEnvironment = GetRegionalizedEnvironment(authority, text, requestContext);
			return CreateEntry(authority.Host, regionalizedEnvironment);
		}

		private static InstanceDiscoveryMetadataEntry CreateEntry(string originalEnv, string regionalEnv)
		{
			InstanceDiscoveryMetadataEntry instanceDiscoveryMetadataEntry = new InstanceDiscoveryMetadataEntry();
			instanceDiscoveryMetadataEntry.Aliases = new string[2] { regionalEnv, originalEnv };
			instanceDiscoveryMetadataEntry.PreferredCache = originalEnv;
			instanceDiscoveryMetadataEntry.PreferredNetwork = regionalEnv;
			return instanceDiscoveryMetadataEntry;
		}

		private static string GetRegionalizedEnvironment(Uri authority, string region, RequestContext requestContext)
		{
			string host = authority.Host;
			if (KnownMetadataProvider.IsPublicEnvironment(host))
			{
				requestContext.Logger.Info(() => "[Region discovery] Regionalized Environment is : " + region + ".login.microsoft.com. ");
				return region + ".login.microsoft.com";
			}
			if (KnownMetadataProvider.TryGetKnownEnviromentPreferredNetwork(host, out var preferredNetworkEnvironment))
			{
				host = preferredNetworkEnvironment;
			}
			requestContext.Logger.Info(() => "[Region discovery] Regionalized Environment is : " + region + "." + host + ". ");
			return region + "." + host;
		}
	}
	internal interface IRegionManager
	{
		Task<string> GetAzureRegionAsync(RequestContext requestContext);
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal sealed class LocalImdsErrorResponse
	{
		[JsonProperty("error")]
		public string Error { get; set; }

		[JsonProperty("newest-versions")]
		public List<string> NewestVersions { get; set; }
	}
	internal enum RegionAutodetectionSource
	{
		None,
		FailedAutoDiscovery,
		Cache,
		EnvVariable,
		Imds
	}
	internal sealed class RegionManager : IRegionManager
	{
		private class RegionInfo
		{
			public readonly string RegionDetails;

			public string Region { get; }

			public RegionAutodetectionSource RegionSource { get; }

			public RegionInfo(string region, RegionAutodetectionSource regionSource, string regionDetails)
			{
				Region = region;
				RegionSource = regionSource;
				RegionDetails = regionDetails;
			}
		}

		private const string ImdsEndpoint = "http://169.254.169.254/metadata/instance/compute/location";

		private const string DefaultApiVersion = "2020-06-01";

		private readonly IHttpManager _httpManager;

		private readonly int _imdsCallTimeoutMs;

		private static readonly SemaphoreSlim _lockDiscover = new SemaphoreSlim(1);

		private static string s_autoDiscoveredRegion;

		private static bool s_failedAutoDiscovery = false;

		private static string s_regionDiscoveryDetails;

		public RegionManager(IHttpManager httpManager, int imdsCallTimeout = 2000, bool shouldClearStaticCache = false)
		{
			_httpManager = httpManager;
			_imdsCallTimeoutMs = imdsCallTimeout;
			if (shouldClearStaticCache)
			{
				s_failedAutoDiscovery = false;
				s_autoDiscoveredRegion = null;
				s_regionDiscoveryDetails = null;
			}
		}

		public async Task<string> GetAzureRegionAsync(RequestContext requestContext)
		{
			string azureRegionConfig = requestContext.ServiceBundle.Config.AzureRegion;
			ILoggerAdapter logger = requestContext.Logger;
			if (string.IsNullOrEmpty(azureRegionConfig))
			{
				logger.Verbose(() => "[Region discovery] WithAzureRegion not configured. ");
				return null;
			}
			RegionInfo discoveredRegion = await DiscoverAndCacheAsync(logger, requestContext.UserCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			RecordTelemetry(requestContext.ApiEvent, azureRegionConfig, discoveredRegion);
			if (IsAutoDiscoveryRequested(azureRegionConfig))
			{
				if (discoveredRegion.RegionSource != RegionAutodetectionSource.FailedAutoDiscovery)
				{
					logger.Verbose(() => "[Region discovery] Discovered Region " + discoveredRegion.Region);
					requestContext.ApiEvent.RegionUsed = discoveredRegion.Region;
					requestContext.ApiEvent.AutoDetectedRegion = discoveredRegion.Region;
					return discoveredRegion.Region;
				}
				logger.Verbose(() => "[Region discovery] " + s_regionDiscoveryDetails);
				requestContext.ApiEvent.RegionDiscoveryFailureReason = s_regionDiscoveryDetails;
				return null;
			}
			logger.Info(() => "[Region discovery] Returning user provided region: " + azureRegionConfig + ".");
			return azureRegionConfig;
		}

		private static bool IsAutoDiscoveryRequested(string azureRegionConfig)
		{
			return string.Equals(azureRegionConfig, "TryAutoDetect");
		}

		private static void RecordTelemetry(ApiEvent apiEvent, string azureRegionConfig, RegionInfo discoveredRegion)
		{
			if (IsTelemetryRecorded(apiEvent))
			{
				return;
			}
			bool num = IsAutoDiscoveryRequested(azureRegionConfig);
			apiEvent.RegionAutodetectionSource = discoveredRegion.RegionSource;
			if (num)
			{
				apiEvent.RegionUsed = discoveredRegion.Region;
				apiEvent.RegionOutcome = ((discoveredRegion.RegionSource == RegionAutodetectionSource.FailedAutoDiscovery) ? RegionOutcome.FallbackToGlobal : RegionOutcome.AutodetectSuccess);
				return;
			}
			apiEvent.RegionUsed = azureRegionConfig;
			apiEvent.RegionDiscoveryFailureReason = discoveredRegion.RegionDetails;
			if (discoveredRegion.RegionSource == RegionAutodetectionSource.FailedAutoDiscovery)
			{
				apiEvent.RegionOutcome = RegionOutcome.UserProvidedAutodetectionFailed;
			}
			if (!string.IsNullOrEmpty(discoveredRegion.Region))
			{
				apiEvent.RegionOutcome = (string.Equals(discoveredRegion.Region, azureRegionConfig, StringComparison.OrdinalIgnoreCase) ? RegionOutcome.UserProvidedValid : RegionOutcome.UserProvidedInvalid);
			}
		}

		private static bool IsTelemetryRecorded(ApiEvent apiEvent)
		{
			if (string.IsNullOrEmpty(apiEvent.RegionUsed) && apiEvent.RegionAutodetectionSource == RegionAutodetectionSource.None)
			{
				return apiEvent.RegionOutcome != RegionOutcome.None;
			}
			return true;
		}

		private async Task<RegionInfo> DiscoverAndCacheAsync(ILoggerAdapter logger, CancellationToken requestCancellationToken)
		{
			RegionInfo cachedRegion = GetCachedRegion(logger);
			if (cachedRegion != null)
			{
				return cachedRegion;
			}
			return await DiscoverAsync(logger, requestCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<RegionInfo> DiscoverAsync(ILoggerAdapter logger, CancellationToken requestCancellationToken)
		{
			RegionInfo result = null;
			await _lockDiscover.WaitAsync(requestCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			try
			{
				RegionInfo cachedRegion = GetCachedRegion(logger);
				if (cachedRegion != null)
				{
					result = cachedRegion;
				}
				else
				{
					try
					{
						string region = Environment.GetEnvironmentVariable("REGION_NAME")?.Replace(" ", string.Empty).ToLowerInvariant();
						if (ValidateRegion(region, "REGION_NAME env variable", logger))
						{
							logger.Info(() => "[Region discovery] Region found in environment variable: " + region + ".");
							result = new RegionInfo(region, RegionAutodetectionSource.EnvVariable, null);
						}
						else
						{
							Dictionary<string, string> headers = new Dictionary<string, string> { { "Metadata", "true" } };
							Uri imdsUri = BuildImdsUri("2020-06-01");
							HttpResponse httpResponse = await _httpManager.SendGetAsync(imdsUri, headers, logger, retry: false, GetCancellationToken(requestCancellationToken)).ConfigureAwait(continueOnCapturedContext: false);
							if (httpResponse.StatusCode == HttpStatusCode.BadRequest)
							{
								string apiVersion = await GetImdsUriApiVersionAsync(logger, headers, requestCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
								imdsUri = BuildImdsUri(apiVersion);
								httpResponse = await _httpManager.SendGetAsync(BuildImdsUri(apiVersion), headers, logger, retry: false, GetCancellationToken(requestCancellationToken)).ConfigureAwait(continueOnCapturedContext: false);
							}
							if (httpResponse.StatusCode == HttpStatusCode.OK && !httpResponse.Body.IsNullOrEmpty())
							{
								region = httpResponse.Body;
								if (ValidateRegion(region, "IMDS call to " + imdsUri.AbsoluteUri, logger))
								{
									logger.Info(() => $"[Region discovery] Call to local IMDS succeeded. Region: {region}. {DateTime.UtcNow}");
									result = new RegionInfo(region, RegionAutodetectionSource.Imds, null);
								}
							}
							else
							{
								s_regionDiscoveryDetails = $"Call to local IMDS failed with status code {httpResponse.StatusCode} or an empty response. {DateTime.UtcNow}";
								logger.Error("[Region discovery] " + s_regionDiscoveryDetails);
							}
						}
					}
					catch (Exception ex)
					{
						if (ex is MsalServiceException ex2 && "request_timeout".Equals(ex2?.ErrorCode))
						{
							s_regionDiscoveryDetails = $"Call to local IMDS timed out after {_imdsCallTimeoutMs}.";
							logger.Error("[Region discovery] " + s_regionDiscoveryDetails + ".");
						}
						else
						{
							s_regionDiscoveryDetails = $"IMDS call failed with exception {ex}. {DateTime.UtcNow}";
							logger.Error("[Region discovery] " + s_regionDiscoveryDetails);
						}
					}
				}
				if (result == null)
				{
					result = new RegionInfo(null, RegionAutodetectionSource.FailedAutoDiscovery, s_regionDiscoveryDetails);
				}
			}
			finally
			{
				s_failedAutoDiscovery = result.RegionSource == RegionAutodetectionSource.FailedAutoDiscovery;
				s_autoDiscoveredRegion = result.Region;
				s_regionDiscoveryDetails = result.RegionDetails;
				_lockDiscover.Release();
			}
			return result;
		}

		private static RegionInfo GetCachedRegion(ILoggerAdapter logger)
		{
			if (s_failedAutoDiscovery)
			{
				string autoDiscoveryError = $"[Region discovery] Auto-discovery failed in the past. Not trying again. {s_regionDiscoveryDetails}. {DateTime.UtcNow}";
				logger.Verbose(() => autoDiscoveryError);
				return new RegionInfo(null, RegionAutodetectionSource.FailedAutoDiscovery, autoDiscoveryError);
			}
			if (!s_failedAutoDiscovery && !string.IsNullOrEmpty(s_autoDiscoveredRegion))
			{
				logger.Info(() => "[Region discovery] Auto-discovery already ran and found " + s_autoDiscoveredRegion + ".");
				return new RegionInfo(s_autoDiscoveredRegion, RegionAutodetectionSource.Cache, null);
			}
			logger.Verbose(() => "[Region discovery] Auto-discovery did not run yet.");
			return null;
		}

		private static bool ValidateRegion(string region, string source, ILoggerAdapter logger)
		{
			if (string.IsNullOrEmpty(region))
			{
				logger.Verbose(() => $"[Region discovery] Region from {source} not detected. {DateTime.UtcNow}");
				return false;
			}
			if (!Uri.IsWellFormedUriString("https://" + region + ".login.microsoft.com", UriKind.Absolute))
			{
				logger.Error($"[Region discovery] Region from {source} was found but it's invalid: {region}. {DateTime.UtcNow}");
				return false;
			}
			return true;
		}

		private async Task<string> GetImdsUriApiVersionAsync(ILoggerAdapter logger, Dictionary<string, string> headers, CancellationToken userCancellationToken)
		{
			Uri endpoint = new Uri("http://169.254.169.254/metadata/instance/compute/location");
			HttpResponse response = await _httpManager.SendGetAsync(endpoint, headers, logger, retry: false, GetCancellationToken(userCancellationToken)).ConfigureAwait(continueOnCapturedContext: false);
			if (response.StatusCode == HttpStatusCode.BadRequest)
			{
				LocalImdsErrorResponse errorResponse = JsonHelper.DeserializeFromJson<LocalImdsErrorResponse>(response.Body);
				if (errorResponse != null && !errorResponse.NewestVersions.IsNullOrEmpty())
				{
					logger.Info(() => "[Region discovery] Updated the version for IMDS endpoint to: " + errorResponse.NewestVersions[0] + ".");
					return errorResponse.NewestVersions[0];
				}
				logger.Info(() => $"[Region discovery] The response is empty or does not contain the newest versions. {DateTime.UtcNow}");
			}
			logger.Info(() => $"[Region discovery] Failed to get the updated version for IMDS endpoint. HttpStatusCode: {response.StatusCode}. {DateTime.UtcNow}");
			throw MsalServiceExceptionFactory.FromImdsResponse("region_discovery_failed", "Region discovery for the instance failed. Region discovery can only be made if the service resides in Azure function or Azure VM. See https://aka.ms/msal-net-region-discovery for more details. ", response);
		}

		private static Uri BuildImdsUri(string apiVersion)
		{
			UriBuilder uriBuilder = new UriBuilder("http://169.254.169.254/metadata/instance/compute/location");
			uriBuilder.AppendQueryParameters("api-version=" + apiVersion);
			uriBuilder.AppendQueryParameters("format=text");
			return uriBuilder.Uri;
		}

		private CancellationToken GetCancellationToken(CancellationToken userCancellationToken)
		{
			CancellationTokenSource cancellationTokenSource = new CancellationTokenSource(_imdsCallTimeoutMs);
			return CancellationTokenSource.CreateLinkedTokenSource(userCancellationToken, cancellationTokenSource.Token).Token;
		}
	}
	public enum RegionOutcome
	{
		None,
		UserProvidedValid,
		UserProvidedAutodetectionFailed,
		UserProvidedInvalid,
		AutodetectSuccess,
		FallbackToGlobal
	}
}
namespace Microsoft.Identity.Client.Instance
{
	internal class AadAuthority : Authority
	{
		public const string DefaultTrustedHost = "login.microsoftonline.com";

		public const string AADCanonicalAuthorityTemplate = "https://{0}/{1}/";

		private const string TokenEndpointTemplate = "{0}oauth2/v2.0/token";

		private const string DeviceCodeEndpointTemplate = "{0}oauth2/v2.0/devicecode";

		private const string AuthorizationEndpointTemplate = "{0}oauth2/v2.0/authorize";

		private static readonly ISet<string> s_tenantlessTenantNames = new HashSet<string>(new string[3] { "common", "organizations", "consumers" }, StringComparer.OrdinalIgnoreCase);

		internal override string TenantId { get; }

		internal AadAuthority(AuthorityInfo authorityInfo)
			: base(authorityInfo)
		{
			TenantId = AuthorityInfo.GetFirstPathSegment(base.AuthorityInfo.CanonicalAuthority);
		}

		internal bool IsWorkAndSchoolOnly()
		{
			if (!TenantId.Equals("common", StringComparison.OrdinalIgnoreCase))
			{
				return !IsConsumers(TenantId);
			}
			return false;
		}

		internal bool IsConsumers()
		{
			return IsConsumers(TenantId);
		}

		internal static bool IsConsumers(string tenantId)
		{
			if (!tenantId.Equals("consumers", StringComparison.OrdinalIgnoreCase))
			{
				return tenantId.Equals("9188040d-6c67-4c5b-b112-36a304b66dad", StringComparison.OrdinalIgnoreCase);
			}
			return true;
		}

		internal bool IsCommonOrganizationsOrConsumersTenant()
		{
			return IsCommonOrganizationsOrConsumersTenant(TenantId);
		}

		internal static bool IsCommonOrganizationsOrConsumersTenant(string tenantId)
		{
			if (!string.IsNullOrEmpty(tenantId))
			{
				if (!IsCommonOrOrganizationsTenant(tenantId))
				{
					return IsConsumers(tenantId);
				}
				return true;
			}
			return false;
		}

		internal bool IsOrganizationsTenantWithMsaPassthroughEnabled(bool isMsaPassthrough, string accountTenantId)
		{
			if (accountTenantId != null && isMsaPassthrough && TenantId.Equals("organizations", StringComparison.OrdinalIgnoreCase))
			{
				return IsConsumers(accountTenantId);
			}
			return false;
		}

		internal bool IsCommonOrOrganizationsTenant()
		{
			return IsCommonOrOrganizationsTenant(TenantId);
		}

		internal static bool IsCommonOrOrganizationsTenant(string tenantId)
		{
			if (!string.IsNullOrEmpty(tenantId))
			{
				return s_tenantlessTenantNames.Contains(tenantId);
			}
			return false;
		}

		internal override string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant = false)
		{
			if (!string.IsNullOrEmpty(tenantId) && (forceSpecifiedTenant || IsCommonOrganizationsOrConsumersTenant()))
			{
				Uri canonicalAuthority = base.AuthorityInfo.CanonicalAuthority;
				return string.Format(CultureInfo.InvariantCulture, "https://{0}/{1}/", canonicalAuthority.Authority, tenantId);
			}
			return base.AuthorityInfo.CanonicalAuthority.AbsoluteUri;
		}

		internal override Task<string> GetTokenEndpointAsync(RequestContext requestContext)
		{
			return Task.FromResult(string.Format(CultureInfo.InvariantCulture, "{0}oauth2/v2.0/token", base.AuthorityInfo.CanonicalAuthority));
		}

		internal override Task<string> GetAuthorizationEndpointAsync(RequestContext requestContext)
		{
			return Task.FromResult(string.Format(CultureInfo.InvariantCulture, "{0}oauth2/v2.0/authorize", base.AuthorityInfo.CanonicalAuthority));
		}

		internal override Task<string> GetDeviceCodeEndpointAsync(RequestContext requestContext)
		{
			return Task.FromResult(string.Format(CultureInfo.InvariantCulture, "{0}oauth2/v2.0/devicecode", base.AuthorityInfo.CanonicalAuthority));
		}
	}
	internal class AdfsAuthority : Authority
	{
		private const string TokenEndpointTemplate = "{0}oauth2/token";

		private const string AuthorizationEndpointTemplate = "{0}oauth2/authorize";

		private const string DeviceCodeEndpointTemplate = "{0}oauth2/devicecode";

		internal override string TenantId => null;

		public AdfsAuthority(AuthorityInfo authorityInfo)
			: base(authorityInfo)
		{
		}

		internal override Task<string> GetTokenEndpointAsync(RequestContext requestContext)
		{
			return Task.FromResult(string.Format(CultureInfo.InvariantCulture, "{0}oauth2/token", base.AuthorityInfo.CanonicalAuthority));
		}

		internal override Task<string> GetAuthorizationEndpointAsync(RequestContext requestContext)
		{
			return Task.FromResult(string.Format(CultureInfo.InvariantCulture, "{0}oauth2/authorize", base.AuthorityInfo.CanonicalAuthority));
		}

		internal override Task<string> GetDeviceCodeEndpointAsync(RequestContext requestContext)
		{
			return Task.FromResult(string.Format(CultureInfo.InvariantCulture, "{0}oauth2/devicecode", base.AuthorityInfo.CanonicalAuthority));
		}

		internal override string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant)
		{
			return base.AuthorityInfo.CanonicalAuthority.ToString();
		}
	}
	[DebuggerDisplay("{AuthorityInfo.CanonicalAuthority}")]
	internal abstract class Authority
	{
		public AuthorityInfo AuthorityInfo { get; }

		internal abstract string TenantId { get; }

		protected Authority(AuthorityInfo authorityInfo)
		{
			if (authorityInfo == null)
			{
				throw new ArgumentNullException("authorityInfo");
			}
			AuthorityInfo = new AuthorityInfo(authorityInfo);
		}

		public static Task<Authority> CreateAuthorityForRequestAsync(RequestContext requestContext, AuthorityInfo requestAuthorityInfo, IAccount account = null)
		{
			return AuthorityInfo.AuthorityInfoHelper.CreateAuthorityForRequestAsync(requestContext, requestAuthorityInfo, account);
		}

		public static Authority CreateAuthority(string authority, bool validateAuthority = false)
		{
			return AuthorityInfo.FromAuthorityUri(authority, validateAuthority).CreateAuthority();
		}

		public static Authority CreateAuthority(AuthorityInfo authorityInfo)
		{
			return authorityInfo.CreateAuthority();
		}

		internal static Authority CreateAuthorityWithTenant(AuthorityInfo authorityInfo, string tenantId)
		{
			Authority authority = CreateAuthority(authorityInfo);
			if (string.IsNullOrEmpty(tenantId))
			{
				return authority;
			}
			string tenantedAuthority = authority.GetTenantedAuthority(tenantId, forceSpecifiedTenant: false);
			return CreateAuthority(new AuthorityInfo(authority.AuthorityInfo.AuthorityType, tenantedAuthority, authority.AuthorityInfo.ValidateAuthority));
		}

		internal static Authority CreateAuthorityWithEnvironment(AuthorityInfo authorityInfo, string environment)
		{
			if (!authorityInfo.IsInstanceDiscoverySupported)
			{
				return CreateAuthority(authorityInfo);
			}
			return CreateAuthority(new UriBuilder(authorityInfo.CanonicalAuthority)
			{
				Host = environment
			}.Uri.AbsoluteUri, authorityInfo.ValidateAuthority);
		}

		internal abstract string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant);

		internal abstract Task<string> GetTokenEndpointAsync(RequestContext requestContext);

		internal abstract Task<string> GetAuthorizationEndpointAsync(RequestContext requestContext);

		internal abstract Task<string> GetDeviceCodeEndpointAsync(RequestContext requestContext);

		internal static string GetEnvironment(string authority)
		{
			return new Uri(authority).Host;
		}
	}
	internal class AuthorityManager
	{
		private static readonly ConcurrentHashSet<string> s_validatedEnvironments = new ConcurrentHashSet<string>();

		private readonly RequestContext _requestContext;

		private readonly Authority _initialAuthority;

		private Authority _currentAuthority;

		private bool _instanceDiscoveryAndValidationExecuted;

		private InstanceDiscoveryMetadataEntry _metadata;

		public Authority OriginalAuthority => _initialAuthority;

		public Authority Authority => _currentAuthority;

		public AuthorityManager(RequestContext requestContext, Authority initialAuthority)
		{
			_requestContext = requestContext;
			_initialAuthority = initialAuthority;
			_currentAuthority = initialAuthority;
		}

		public async Task<InstanceDiscoveryMetadataEntry> GetInstanceDiscoveryEntryAsync()
		{
			await RunInstanceDiscoveryAndValidationAsync().ConfigureAwait(continueOnCapturedContext: false);
			return _metadata;
		}

		public async Task RunInstanceDiscoveryAndValidationAsync()
		{
			if (!_instanceDiscoveryAndValidationExecuted)
			{
				_metadata = await _requestContext.ServiceBundle.InstanceDiscoveryManager.GetMetadataEntryAsync(_initialAuthority.AuthorityInfo, _requestContext).ConfigureAwait(continueOnCapturedContext: false);
				_currentAuthority = Authority.CreateAuthorityWithEnvironment(_initialAuthority.AuthorityInfo, _metadata.PreferredNetwork);
				if (_initialAuthority.AuthorityInfo.ValidateAuthority && _requestContext.ServiceBundle.Config.IsInstanceDiscoveryEnabled)
				{
					await ValidateAuthorityAsync(_initialAuthority).ConfigureAwait(continueOnCapturedContext: false);
				}
				_instanceDiscoveryAndValidationExecuted = true;
			}
		}

		public static void ClearValidationCache()
		{
			s_validatedEnvironments.Clear();
		}

		private async Task ValidateAuthorityAsync(Authority authority)
		{
			if (!s_validatedEnvironments.Contains(authority.AuthorityInfo.Host))
			{
				await AuthorityInfo.AuthorityInfoHelper.CreateAuthorityValidator(authority.AuthorityInfo, _requestContext).ValidateAuthorityAsync(authority.AuthorityInfo).ConfigureAwait(continueOnCapturedContext: false);
				s_validatedEnvironments.Add(authority.AuthorityInfo.Host);
			}
		}
	}
	internal class B2CAuthority : AadAuthority
	{
		public const string Prefix = "tfp";

		public const string B2CCanonicalAuthorityTemplate = "https://{0}/{1}/{2}/{3}/";

		internal override string TenantId { get; }

		internal B2CAuthority(AuthorityInfo authorityInfo)
			: base(authorityInfo)
		{
			TenantId = base.AuthorityInfo.CanonicalAuthority.Segments[2].TrimEnd(new char[1] { '/' });
		}

		internal override string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant = false)
		{
			return base.AuthorityInfo.CanonicalAuthority.ToString();
		}
	}
	internal class CiamAuthority : AadAuthority
	{
		internal CiamAuthority(AuthorityInfo authorityInfo)
			: base(authorityInfo)
		{
		}

		internal override string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant = false)
		{
			if (!string.IsNullOrEmpty(tenantId) && (forceSpecifiedTenant || IsCommonOrganizationsOrConsumersTenant()))
			{
				Uri canonicalAuthority = base.AuthorityInfo.CanonicalAuthority;
				return string.Format(CultureInfo.InvariantCulture, "https://{0}/{1}/", canonicalAuthority.Authority, tenantId);
			}
			return base.AuthorityInfo.CanonicalAuthority.AbsoluteUri;
		}

		internal static Uri TransformAuthority(Uri ciamAuthority)
		{
			string text = ciamAuthority.Host + ciamAuthority.AbsolutePath;
			if (string.Equals(ciamAuthority.AbsolutePath, "/"))
			{
				string text2 = text.Substring(0, text.IndexOf(".ciamlogin.com", StringComparison.OrdinalIgnoreCase));
				string text3 = "https://" + text2 + ".ciamlogin.com/";
				string text4 = text2 + ".onmicrosoft.com";
				return new Uri(text3 + text4);
			}
			return ciamAuthority;
		}
	}
	internal class DstsAuthority : Authority
	{
		public const string DstsCanonicalAuthorityTemplate = "https://{0}/dstsv2/{1}/";

		private const string TokenEndpointTemplate = "{0}oauth2/v2.0/token";

		private const string AuthorizationEndpointTemplate = "{0}oauth2/v2.0/authorize";

		private const string DeviceCodeEndpointTemplate = "{0}oauth2/v2.0/devicecode";

		internal override string TenantId { get; }

		public DstsAuthority(AuthorityInfo authorityInfo)
			: base(authorityInfo)
		{
			TenantId = AuthorityInfo.GetSecondPathSegment(base.AuthorityInfo.CanonicalAuthority);
		}

		internal override string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant = false)
		{
			if (!string.IsNullOrEmpty(tenantId) && (forceSpecifiedTenant || AadAuthority.IsCommonOrganizationsOrConsumersTenant(TenantId)))
			{
				Uri canonicalAuthority = base.AuthorityInfo.CanonicalAuthority;
				return string.Format(CultureInfo.InvariantCulture, "https://{0}/dstsv2/{1}/", canonicalAuthority.Authority, tenantId);
			}
			return base.AuthorityInfo.CanonicalAuthority.ToString();
		}

		internal override Task<string> GetTokenEndpointAsync(RequestContext requestContext)
		{
			return Task.FromResult(string.Format(CultureInfo.InvariantCulture, "{0}oauth2/v2.0/token", base.AuthorityInfo.CanonicalAuthority));
		}

		internal override Task<string> GetAuthorizationEndpointAsync(RequestContext requestContext)
		{
			return Task.FromResult(string.Format(CultureInfo.InvariantCulture, "{0}oauth2/v2.0/authorize", base.AuthorityInfo.CanonicalAuthority));
		}

		internal override Task<string> GetDeviceCodeEndpointAsync(RequestContext requestContext)
		{
			return Task.FromResult(string.Format(CultureInfo.InvariantCulture, "{0}oauth2/v2.0/devicecode", base.AuthorityInfo.CanonicalAuthority));
		}
	}
	internal class GenericAuthority : Authority
	{
		internal override string TenantId => null;

		internal GenericAuthority(AuthorityInfo authorityInfo)
			: base(authorityInfo)
		{
		}

		internal override async Task<string> GetTokenEndpointAsync(RequestContext requestContext)
		{
			return (await OidcRetrieverWithCache.GetOidcAsync(base.AuthorityInfo.CanonicalAuthority.AbsoluteUri, requestContext).ConfigureAwait(continueOnCapturedContext: false)).TokenEndpoint;
		}

		internal override async Task<string> GetAuthorizationEndpointAsync(RequestContext requestContext)
		{
			return (await OidcRetrieverWithCache.GetOidcAsync(base.AuthorityInfo.CanonicalAuthority.AbsoluteUri, requestContext).ConfigureAwait(continueOnCapturedContext: false)).AuthorizationEndpoint;
		}

		internal override Task<string> GetDeviceCodeEndpointAsync(RequestContext requestContext)
		{
			throw new NotImplementedException();
		}

		internal override string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant)
		{
			return base.AuthorityInfo.CanonicalAuthority.ToString();
		}
	}
}
namespace Microsoft.Identity.Client.Instance.Validation
{
	internal class AadAuthorityValidator : IAuthorityValidator
	{
		private readonly RequestContext _requestContext;

		public AadAuthorityValidator(RequestContext requestContext)
		{
			_requestContext = requestContext;
		}

		public async Task ValidateAuthorityAsync(AuthorityInfo authorityInfo)
		{
			Uri canonicalAuthority = authorityInfo.CanonicalAuthority;
			bool isKnownEnv = KnownMetadataProvider.IsKnownEnvironment(canonicalAuthority.Host);
			_requestContext.Logger.Info(() => $"Authority validation enabled? {authorityInfo.ValidateAuthority}. ");
			_requestContext.Logger.Info(() => $"Authority validation - is known env? {isKnownEnv}. ");
			if (!isKnownEnv)
			{
				_requestContext.Logger.Info("Authority validation is being performed. ");
				await _requestContext.ServiceBundle.InstanceDiscoveryManager.GetMetadataEntryAsync(authorityInfo, _requestContext, forceValidation: true).ConfigureAwait(continueOnCapturedContext: false);
			}
		}
	}
	internal class AdfsAuthorityValidator : IAuthorityValidator
	{
		private readonly RequestContext _requestContext;

		public AdfsAuthorityValidator(RequestContext requestContext)
		{
			_requestContext = requestContext;
		}

		public async Task ValidateAuthorityAsync(AuthorityInfo authorityInfo)
		{
			if (authorityInfo.ValidateAuthority)
			{
				string resource = "https://" + authorityInfo.Host;
				string uriString = Constants.FormatAdfsWebFingerUrl(authorityInfo.Host, resource);
				HttpResponse httpResponse = await _requestContext.ServiceBundle.HttpManager.SendGetAsync(new Uri(uriString), null, _requestContext.Logger, retry: true, _requestContext.UserCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (httpResponse.StatusCode != HttpStatusCode.OK)
				{
					_requestContext.Logger.Error($"Authority validation failed because the configured authority is invalid. Authority: {authorityInfo.CanonicalAuthority}");
					throw MsalServiceExceptionFactory.FromHttpResponse("invalid_authority", "Authority validation failed. ", httpResponse);
				}
				if (OAuth2Client.CreateResponse<AdfsWebFingerResponse>(httpResponse, _requestContext).Links.FirstOrDefault((LinksList a) => a.Rel.Equals("http://schemas.microsoft.com/rel/trusted-realm", StringComparison.OrdinalIgnoreCase) && a.Href.Equals(resource)) == null)
				{
					_requestContext.Logger.Error($"Authority validation failed because the configured authority is invalid. Authority: {authorityInfo.CanonicalAuthority}");
					throw new MsalClientException("invalid_authority", "invalid authority while getting the open id config endpoint. ");
				}
			}
		}
	}
	internal class AdfsWebFingerResponseClaim : OAuth2ResponseBaseClaim
	{
		public const string Subject = "subject";

		public const string Links = "links";

		public const string Rel = "rel";

		public const string Href = "href";
	}
	[JsonObject(Title = "links")]
	[Preserve(AllMembers = true)]
	internal class LinksList
	{
		[JsonProperty("rel")]
		public string Rel { get; set; }

		[JsonProperty("href")]
		public string Href { get; set; }
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class AdfsWebFingerResponse : OAuth2ResponseBase
	{
		[JsonProperty("subject")]
		public string Subject { get; set; }

		[JsonProperty("links")]
		public List<LinksList> Links { get; set; }
	}
	internal interface IAuthorityValidator
	{
		Task ValidateAuthorityAsync(AuthorityInfo authorityInfo);
	}
	internal class NullAuthorityValidator : IAuthorityValidator
	{
		public Task ValidateAuthorityAsync(AuthorityInfo authorityInfo)
		{
			return Task.FromResult(0);
		}
	}
}
namespace Microsoft.Identity.Client.Instance.Oidc
{
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class OidcMetadata
	{
		[JsonProperty("token_endpoint")]
		public string TokenEndpoint { get; set; }

		[JsonProperty("authorization_endpoint")]
		public string AuthorizationEndpoint { get; set; }
	}
	internal static class OidcRetrieverWithCache
	{
		private static readonly ConcurrentDictionary<string, OidcMetadata> s_cache = new ConcurrentDictionary<string, OidcMetadata>();

		private static readonly SemaphoreSlim s_lockOidcRetrieval = new SemaphoreSlim(1);

		public static async Task<OidcMetadata> GetOidcAsync(string authority, RequestContext requestContext)
		{
			if (s_cache.TryGetValue(authority, out var value))
			{
				requestContext.Logger.Verbose(() => "[OIDC Discovery] OIDC discovery found a cached entry for " + authority);
				return value;
			}
			await s_lockOidcRetrieval.WaitAsync().ConfigureAwait(continueOnCapturedContext: false);
			Uri oidcMetadataEndpoint = null;
			try
			{
				if (s_cache.TryGetValue(authority, out value))
				{
					requestContext.Logger.Verbose(() => "[OIDC Discovery] OIDC discovery found a cached entry for " + authority);
					return value;
				}
				UriBuilder uriBuilder = new UriBuilder(authority);
				string path = uriBuilder.Path;
				uriBuilder.Path = path.TrimEnd(new char[1] { '/' }) + "/.well-known/openid-configuration";
				oidcMetadataEndpoint = uriBuilder.Uri;
				value = await new OAuth2Client(requestContext.Logger, requestContext.ServiceBundle.HttpManager).DiscoverOidcMetadataAsync(oidcMetadataEndpoint, requestContext).ConfigureAwait(continueOnCapturedContext: false);
				s_cache[authority] = value;
				requestContext.Logger.Verbose(() => "[OIDC Discovery] OIDC discovery retrieved metadata from the network for " + authority);
				return value;
			}
			catch (Exception ex)
			{
				requestContext.Logger.Error(string.Format("[OIDC Discovery] Failed to retrieve OpenID configuration from the OpenID endpoint {0} due to {1}", authority + ".well-known/openid-configuration", ex));
				if (ex is MsalServiceException)
				{
					throw;
				}
				throw new MsalServiceException("oidc_failure", $"Failed to retrieve OIDC configuration from {oidcMetadataEndpoint}. See inner exception. ", ex);
			}
			finally
			{
				s_lockOidcRetrieval.Release();
			}
		}

		public static void ResetCacheForTest()
		{
			s_cache.Clear();
		}
	}
}
namespace Microsoft.Identity.Client.Instance.Discovery
{
	internal interface IInstanceDiscoveryManager
	{
		Task<InstanceDiscoveryMetadataEntry> GetMetadataEntryTryAvoidNetworkAsync(AuthorityInfo authorityinfo, IEnumerable<string> existingEnvironmentsInCache, RequestContext requestContext);

		Task<InstanceDiscoveryMetadataEntry> GetMetadataEntryAsync(AuthorityInfo authorityinfo, RequestContext requestContext, bool forceValidation = false);
	}
	internal interface IKnownMetadataProvider
	{
		InstanceDiscoveryMetadataEntry GetMetadata(string environment, IEnumerable<string> existingEnvironmentsInCache, ILoggerAdapter logger);
	}
	internal interface INetworkCacheMetadataProvider
	{
		void AddMetadata(string environment, InstanceDiscoveryMetadataEntry entry);

		InstanceDiscoveryMetadataEntry GetMetadata(string environment, ILoggerAdapter logger);

		void Clear();
	}
	internal interface INetworkMetadataProvider
	{
		Task<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext);
	}
	internal class InstanceDiscoveryManager : IInstanceDiscoveryManager
	{
		private readonly IHttpManager _httpManager;

		private readonly IUserMetadataProvider _userMetadataProvider;

		private readonly IKnownMetadataProvider _knownMetadataProvider;

		private readonly INetworkCacheMetadataProvider _networkCacheMetadataProvider;

		private readonly INetworkMetadataProvider _networkMetadataProvider;

		private readonly IRegionDiscoveryProvider _regionDiscoveryProvider;

		public InstanceDiscoveryManager(IHttpManager httpManager, bool shouldClearCaches, InstanceDiscoveryResponse userProvidedInstanceDiscoveryResponse = null, Uri userProvidedInstanceDiscoveryUri = null)
			: this(httpManager, shouldClearCaches, (userProvidedInstanceDiscoveryResponse != null) ? new UserMetadataProvider(userProvidedInstanceDiscoveryResponse) : null, userProvidedInstanceDiscoveryUri)
		{
		}

		public InstanceDiscoveryManager(IHttpManager httpManager, bool shouldClearCaches, IUserMetadataProvider userMetadataProvider = null, Uri userProvidedInstanceDiscoveryUri = null, IKnownMetadataProvider knownMetadataProvider = null, INetworkCacheMetadataProvider networkCacheMetadataProvider = null, INetworkMetadataProvider networkMetadataProvider = null, IRegionDiscoveryProvider regionDiscoveryProvider = null)
		{
			_httpManager = httpManager ?? throw new ArgumentNullException("httpManager");
			_userMetadataProvider = userMetadataProvider;
			_knownMetadataProvider = knownMetadataProvider ?? new KnownMetadataProvider();
			_networkCacheMetadataProvider = networkCacheMetadataProvider ?? new NetworkCacheMetadataProvider();
			_networkMetadataProvider = networkMetadataProvider ?? new NetworkMetadataProvider(_httpManager, _networkCacheMetadataProvider, userProvidedInstanceDiscoveryUri);
			_regionDiscoveryProvider = regionDiscoveryProvider ?? new RegionDiscoveryProvider(_httpManager, shouldClearCaches);
			if (shouldClearCaches)
			{
				_networkCacheMetadataProvider.Clear();
			}
		}

		public async Task<InstanceDiscoveryMetadataEntry> GetMetadataEntryTryAvoidNetworkAsync(AuthorityInfo authorityInfo, IEnumerable<string> existingEnvironmentsInCache, RequestContext requestContext)
		{
			string environment = authorityInfo.Host;
			if (authorityInfo.IsInstanceDiscoverySupported)
			{
				InstanceDiscoveryMetadataEntry instanceDiscoveryMetadataEntry = _userMetadataProvider?.GetMetadataOrThrow(environment, requestContext.Logger);
				if (instanceDiscoveryMetadataEntry == null)
				{
					instanceDiscoveryMetadataEntry = await _regionDiscoveryProvider.GetMetadataAsync(authorityInfo.CanonicalAuthority, requestContext).ConfigureAwait(continueOnCapturedContext: false);
				}
				InstanceDiscoveryMetadataEntry instanceDiscoveryMetadataEntry2 = instanceDiscoveryMetadataEntry;
				if (instanceDiscoveryMetadataEntry2 == null && requestContext.ServiceBundle.Config.IsInstanceDiscoveryEnabled)
				{
					instanceDiscoveryMetadataEntry = _networkCacheMetadataProvider.GetMetadata(environment, requestContext.Logger);
					if (instanceDiscoveryMetadataEntry == null)
					{
						InstanceDiscoveryMetadataEntry instanceDiscoveryMetadataEntry3 = _knownMetadataProvider.GetMetadata(environment, existingEnvironmentsInCache, requestContext.Logger);
						if (instanceDiscoveryMetadataEntry3 == null)
						{
							instanceDiscoveryMetadataEntry3 = await GetMetadataEntryAsync(authorityInfo, requestContext).ConfigureAwait(continueOnCapturedContext: false);
						}
						instanceDiscoveryMetadataEntry = instanceDiscoveryMetadataEntry3;
					}
					instanceDiscoveryMetadataEntry2 = instanceDiscoveryMetadataEntry;
				}
				if (instanceDiscoveryMetadataEntry2 == null)
				{
					requestContext.Logger.Info(() => $"Skipping Instance discovery for {authorityInfo.AuthorityType} authority because it is not enabled.");
					instanceDiscoveryMetadataEntry2 = CreateEntryForSingleAuthority(authorityInfo.CanonicalAuthority);
				}
				return instanceDiscoveryMetadataEntry2;
			}
			requestContext.Logger.Info(() => $"Skipping Instance discovery for {authorityInfo.AuthorityType} authority because it is not supported.");
			return await GetMetadataEntryAsync(authorityInfo, requestContext).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<InstanceDiscoveryMetadataEntry> GetMetadataEntryAsync(AuthorityInfo authorityInfo, RequestContext requestContext, bool forceValidation = false)
		{
			Uri authorityUri = authorityInfo.CanonicalAuthority;
			string environment = authorityInfo.Host;
			if (authorityInfo.IsInstanceDiscoverySupported)
			{
				InstanceDiscoveryMetadataEntry entry = _userMetadataProvider?.GetMetadataOrThrow(environment, requestContext.Logger);
				if (entry == null && !requestContext.ServiceBundle.Config.IsInstanceDiscoveryEnabled)
				{
					entry = await _regionDiscoveryProvider.GetMetadataAsync(authorityUri, requestContext).ConfigureAwait(continueOnCapturedContext: false);
					if (entry == null)
					{
						requestContext.Logger.Info("[Instance Discovery] Skipping Instance discovery because it is disabled. ");
						return CreateEntryForSingleAuthority(authorityUri);
					}
				}
				if (entry == null && forceValidation)
				{
					await FetchNetworkMetadataOrFallbackAsync(requestContext, authorityUri).ConfigureAwait(continueOnCapturedContext: false);
				}
				requestContext.Logger.Info("[Instance Discovery] Instance discovery is enabled and will be performed");
				if (entry == null)
				{
					InstanceDiscoveryMetadataEntry instanceDiscoveryMetadataEntry = await _regionDiscoveryProvider.GetMetadataAsync(authorityUri, requestContext).ConfigureAwait(continueOnCapturedContext: false);
					if (instanceDiscoveryMetadataEntry == null)
					{
						instanceDiscoveryMetadataEntry = await FetchNetworkMetadataOrFallbackAsync(requestContext, authorityUri).ConfigureAwait(continueOnCapturedContext: false);
					}
					entry = instanceDiscoveryMetadataEntry;
				}
				if (entry == null)
				{
					string text = "[Instance Discovery] Instance metadata for this authority could neither be fetched nor found. MSAL will continue regardless. SSO might be broken if authority aliases exist. ";
					requestContext.Logger.WarningPii(text + "Authority: " + authorityInfo.CanonicalAuthority, text);
					entry = CreateEntryForSingleAuthority(authorityUri);
					_networkCacheMetadataProvider.AddMetadata(environment, entry);
				}
				return entry;
			}
			requestContext.Logger.Info("[Instance Discovery] Skipping Instance discovery for non-AAD authority. ");
			return CreateEntryForSingleAuthority(authorityUri);
		}

		private async Task<InstanceDiscoveryMetadataEntry> FetchNetworkMetadataOrFallbackAsync(RequestContext requestContext, Uri authorityUri)
		{
			try
			{
				return await _networkMetadataProvider.GetMetadataAsync(authorityUri, requestContext).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (MsalServiceException ex)
			{
				if (!requestContext.ServiceBundle.Config.Authority.AuthorityInfo.ValidateAuthority)
				{
					requestContext.Logger.Info("[Instance Discovery] Skipping Instance discovery as validate authority is set to false. ");
					return CreateEntryForSingleAuthority(authorityUri);
				}
				if (ex.ErrorCode == "invalid_instance")
				{
					requestContext.Logger.Error("[Instance Discovery] Instance discovery failed - invalid instance!");
					throw;
				}
				string text = "[Instance Discovery] Instance Discovery failed. Potential cause: no network connection or discovery endpoint is busy. See exception below. MSAL will continue without network instance metadata. ";
				requestContext.Logger.WarningPii(text + " Authority: " + authorityUri, text);
				requestContext.Logger.WarningPii(ex);
				return _knownMetadataProvider.GetMetadata(authorityUri.Host, Enumerable.Empty<string>(), requestContext.Logger);
			}
		}

		internal void AddTestValueToStaticProvider(string environment, InstanceDiscoveryMetadataEntry entry)
		{
			_networkCacheMetadataProvider.AddMetadata(environment, entry);
		}

		private static InstanceDiscoveryMetadataEntry CreateEntryForSingleAuthority(Uri authority)
		{
			InstanceDiscoveryMetadataEntry instanceDiscoveryMetadataEntry = new InstanceDiscoveryMetadataEntry();
			instanceDiscoveryMetadataEntry.Aliases = new string[1] { authority.Host };
			instanceDiscoveryMetadataEntry.PreferredCache = authority.Host;
			instanceDiscoveryMetadataEntry.PreferredNetwork = authority.Host;
			return instanceDiscoveryMetadataEntry;
		}
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal sealed class InstanceDiscoveryMetadataEntry
	{
		[JsonProperty("preferred_network")]
		public string PreferredNetwork { get; set; }

		[JsonProperty("preferred_cache")]
		public string PreferredCache { get; set; }

		[JsonProperty("aliases")]
		public string[] Aliases { get; set; }
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal sealed class InstanceDiscoveryResponse : OAuth2ResponseBase
	{
		[JsonProperty("tenant_discovery_endpoint")]
		public string TenantDiscoveryEndpoint { get; set; }

		[JsonProperty("metadata")]
		public InstanceDiscoveryMetadataEntry[] Metadata { get; set; }
	}
	internal interface IUserMetadataProvider
	{
		InstanceDiscoveryMetadataEntry GetMetadataOrThrow(string environment, ILoggerAdapter logger);
	}
	internal class KnownMetadataProvider : IKnownMetadataProvider
	{
		private static readonly IDictionary<string, InstanceDiscoveryMetadataEntry> s_knownEntries;

		private static readonly ISet<string> s_knownEnvironments;

		private static readonly ISet<string> s_knownPublicEnvironments;

		static KnownMetadataProvider()
		{
			s_knownEntries = new Dictionary<string, InstanceDiscoveryMetadataEntry>();
			s_knownEnvironments = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			s_knownPublicEnvironments = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			InstanceDiscoveryMetadataEntry entry = new InstanceDiscoveryMetadataEntry
			{
				Aliases = new string[4] { "login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net" },
				PreferredNetwork = "login.microsoftonline.com",
				PreferredCache = "login.windows.net"
			};
			InstanceDiscoveryMetadataEntry entry2 = new InstanceDiscoveryMetadataEntry
			{
				Aliases = new string[2] { "login.partner.microsoftonline.cn", "login.chinacloudapi.cn" },
				PreferredNetwork = "login.partner.microsoftonline.cn",
				PreferredCache = "login.partner.microsoftonline.cn"
			};
			InstanceDiscoveryMetadataEntry entry3 = new InstanceDiscoveryMetadataEntry
			{
				Aliases = new string[1] { "login.microsoftonline.de" },
				PreferredNetwork = "login.microsoftonline.de",
				PreferredCache = "login.microsoftonline.de"
			};
			InstanceDiscoveryMetadataEntry entry4 = new InstanceDiscoveryMetadataEntry
			{
				Aliases = new string[2] { "login.microsoftonline.us", "login.usgovcloudapi.net" },
				PreferredNetwork = "login.microsoftonline.us",
				PreferredCache = "login.microsoftonline.us"
			};
			InstanceDiscoveryMetadataEntry entry5 = new InstanceDiscoveryMetadataEntry
			{
				Aliases = new string[1] { "login-us.microsoftonline.com" },
				PreferredNetwork = "login-us.microsoftonline.com",
				PreferredCache = "login-us.microsoftonline.com"
			};
			InstanceDiscoveryMetadataEntry entry6 = new InstanceDiscoveryMetadataEntry
			{
				Aliases = new string[3] { "login.windows-ppe.net", "sts.windows-ppe.net", "login.microsoft-ppe.com" },
				PreferredNetwork = "login.windows-ppe.net",
				PreferredCache = "login.windows-ppe.net"
			};
			AddToKnownCache(entry);
			AddToKnownCache(entry2);
			AddToKnownCache(entry3);
			AddToKnownCache(entry4);
			AddToKnownCache(entry5);
			AddToKnownCache(entry6);
			AddToPublicEnvironment(entry);
			static void AddToKnownCache(InstanceDiscoveryMetadataEntry instanceDiscoveryMetadataEntry)
			{
				string[] aliases = instanceDiscoveryMetadataEntry.Aliases;
				foreach (string text in aliases)
				{
					s_knownEntries[text] = instanceDiscoveryMetadataEntry;
					s_knownEnvironments.Add(text);
				}
			}
			static void AddToPublicEnvironment(InstanceDiscoveryMetadataEntry instanceDiscoveryMetadataEntry)
			{
				string[] aliases = instanceDiscoveryMetadataEntry.Aliases;
				foreach (string item in aliases)
				{
					s_knownPublicEnvironments.Add(item);
				}
			}
		}

		public static bool IsPublicEnvironment(string environment)
		{
			return s_knownPublicEnvironments.Contains(environment);
		}

		public InstanceDiscoveryMetadataEntry GetMetadata(string environment, IEnumerable<string> existingEnvironmentsInCache, ILoggerAdapter logger)
		{
			if (existingEnvironmentsInCache == null)
			{
				existingEnvironmentsInCache = Enumerable.Empty<string>();
			}
			if (existingEnvironmentsInCache.All((string e) => s_knownEnvironments.ContainsOrdinalIgnoreCase(e)))
			{
				s_knownEntries.TryGetValue(environment, out var entry);
				logger.Verbose(() => $"[Instance Discovery] Tried to use known metadata provider for {environment}. Success? {entry != null}. ");
				return entry;
			}
			logger.VerbosePii(() => "[Instance Discovery] Could not use known metadata provider because at least one environment in the cache is not known. Environments in cache: " + string.Join(" ", existingEnvironmentsInCache) + " ", () => "[Instance Discovery] Could not use known metadata provider because at least one environment in the cache is not known. ");
			return null;
		}

		public static bool IsKnownEnvironment(string environment)
		{
			return s_knownEnvironments.Contains(environment);
		}

		public static bool TryGetKnownEnviromentPreferredNetwork(string environment, out string preferredNetworkEnvironment)
		{
			if (s_knownEntries.TryGetValue(environment, out var value))
			{
				preferredNetworkEnvironment = value.PreferredNetwork;
				return true;
			}
			preferredNetworkEnvironment = null;
			return false;
		}

		public static IDictionary<string, InstanceDiscoveryMetadataEntry> GetAllEntriesForTest()
		{
			return s_knownEntries;
		}
	}
	internal class NetworkCacheMetadataProvider : INetworkCacheMetadataProvider
	{
		private static readonly ConcurrentDictionary<string, InstanceDiscoveryMetadataEntry> s_cache = new ConcurrentDictionary<string, InstanceDiscoveryMetadataEntry>();

		public InstanceDiscoveryMetadataEntry GetMetadata(string environment, ILoggerAdapter logger)
		{
			s_cache.TryGetValue(environment, out var entry);
			logger.Verbose(() => $"[Instance Discovery] Tried to use network cache provider for {environment}. Success? {entry != null}. ");
			return entry;
		}

		public void AddMetadata(string environment, InstanceDiscoveryMetadataEntry entry)
		{
			s_cache.AddOrUpdate(environment, entry, (string _, InstanceDiscoveryMetadataEntry _) => entry);
		}

		public void Clear()
		{
			s_cache.Clear();
		}
	}
	internal class NetworkMetadataProvider : INetworkMetadataProvider
	{
		private readonly IHttpManager _httpManager;

		private readonly INetworkCacheMetadataProvider _networkCacheMetadataProvider;

		private readonly Uri _userProvidedInstanceDiscoveryUri;

		public NetworkMetadataProvider(IHttpManager httpManager, INetworkCacheMetadataProvider networkCacheMetadataProvider, Uri userProvidedInstanceDiscoveryUri = null)
		{
			_httpManager = httpManager ?? throw new ArgumentNullException("httpManager");
			_networkCacheMetadataProvider = networkCacheMetadataProvider ?? throw new ArgumentNullException("networkCacheMetadataProvider");
			_userProvidedInstanceDiscoveryUri = userProvidedInstanceDiscoveryUri;
		}

		public async Task<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext)
		{
			ILoggerAdapter logger = requestContext.Logger;
			string environment = authority.Host;
			InstanceDiscoveryMetadataEntry cachedEntry = _networkCacheMetadataProvider.GetMetadata(environment, logger);
			if (cachedEntry != null)
			{
				logger.Verbose(() => "[Instance Discovery] The network provider found an entry for " + environment + ". ");
				return cachedEntry;
			}
			CacheInstanceDiscoveryMetadata(await FetchAllDiscoveryMetadataAsync(authority, requestContext).ConfigureAwait(continueOnCapturedContext: false));
			cachedEntry = _networkCacheMetadataProvider.GetMetadata(environment, logger);
			logger.Verbose(() => $"[Instance Discovery] After hitting the discovery endpoint, the network provider found an entry for {environment} ? {cachedEntry != null}. ");
			return cachedEntry;
		}

		private void CacheInstanceDiscoveryMetadata(InstanceDiscoveryResponse instanceDiscoveryResponse)
		{
			IEnumerable<InstanceDiscoveryMetadataEntry> metadata = instanceDiscoveryResponse.Metadata;
			foreach (InstanceDiscoveryMetadataEntry item in metadata ?? Enumerable.Empty<InstanceDiscoveryMetadataEntry>())
			{
				IEnumerable<string> aliases = item.Aliases;
				foreach (string item2 in aliases ?? Enumerable.Empty<string>())
				{
					_networkCacheMetadataProvider.AddMetadata(item2, item);
				}
			}
		}

		private async Task<InstanceDiscoveryResponse> FetchAllDiscoveryMetadataAsync(Uri authority, RequestContext requestContext)
		{
			return await SendInstanceDiscoveryRequestAsync(authority, requestContext).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<InstanceDiscoveryResponse> SendInstanceDiscoveryRequestAsync(Uri authority, RequestContext requestContext)
		{
			OAuth2Client oAuth2Client = new OAuth2Client(requestContext.Logger, _httpManager);
			oAuth2Client.AddQueryParameter("api-version", "1.1");
			oAuth2Client.AddQueryParameter("authorization_endpoint", BuildAuthorizeEndpoint(authority));
			Uri endpoint = ComputeHttpEndpoint(authority, requestContext);
			return await oAuth2Client.DiscoverAadInstanceAsync(endpoint, requestContext).ConfigureAwait(continueOnCapturedContext: false);
		}

		private Uri ComputeHttpEndpoint(Uri authority, RequestContext requestContext)
		{
			if (_userProvidedInstanceDiscoveryUri != null)
			{
				return _userProvidedInstanceDiscoveryUri;
			}
			string discoveryHost = (KnownMetadataProvider.IsKnownEnvironment(authority.Host) ? authority.Host : "login.microsoftonline.com");
			string instanceDiscoveryEndpoint = UriBuilderExtensions.GetHttpsUriWithOptionalPort("https://" + discoveryHost + "/common/discovery/instance", authority.Port);
			requestContext.Logger.InfoPii(() => "Fetching instance discovery from the network from host " + discoveryHost + ". Endpoint " + instanceDiscoveryEndpoint + ". ", () => "Fetching instance discovery from the network from host " + discoveryHost + ". ");
			return new Uri(instanceDiscoveryEndpoint);
		}

		private static string BuildAuthorizeEndpoint(Uri authority)
		{
			return UriBuilderExtensions.GetHttpsUriWithOptionalPort(authority.Host, GetTenant(authority), "oauth2/v2.0/authorize", authority.Port);
		}

		private static string GetTenant(Uri uri)
		{
			return uri.AbsolutePath.Split(new char[1] { '/' })[1];
		}
	}
	internal class UserMetadataProvider : IUserMetadataProvider
	{
		private readonly IDictionary<string, InstanceDiscoveryMetadataEntry> _entries = new Dictionary<string, InstanceDiscoveryMetadataEntry>();

		public UserMetadataProvider(InstanceDiscoveryResponse instanceDiscoveryResponse)
		{
			foreach (InstanceDiscoveryMetadataEntry item in instanceDiscoveryResponse?.Metadata ?? Enumerable.Empty<InstanceDiscoveryMetadataEntry>())
			{
				IEnumerable<string> aliases = item.Aliases;
				foreach (string item2 in aliases ?? Enumerable.Empty<string>())
				{
					_entries.Add(item2, item);
				}
			}
		}

		public InstanceDiscoveryMetadataEntry GetMetadataOrThrow(string environment, ILoggerAdapter logger)
		{
			_entries.TryGetValue(environment ?? "", out var entry);
			logger.Verbose(() => $"[Instance Discovery] Tried to use user metadata provider for {environment}. Success? {entry != null}. ");
			if (entry == null)
			{
				throw new MsalClientException("invalid-custom-instance-metadata", MsalErrorMessage.NoUserInstanceMetadataEntry(environment));
			}
			return entry;
		}
	}
}
namespace Microsoft.Identity.Client.Http
{
	internal static class HttpClientConfig
	{
		public const long MaxResponseContentBufferSizeInBytes = 1048576L;

		public const int MaxConnections = 50;

		public static readonly TimeSpan ConnectionLifeTime = TimeSpan.FromMinutes(1.0);

		public static void ConfigureRequestHeadersAndSize(HttpClient httpClient)
		{
			httpClient.MaxResponseContentBufferSize = 1048576L;
			httpClient.DefaultRequestHeaders.Accept.Clear();
			httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
		}
	}
	internal class HttpManager : IHttpManager
	{
		protected readonly IMsalHttpClientFactory _httpClientFactory;

		public long LastRequestDurationInMs { get; private set; }

		public HttpManager(IMsalHttpClientFactory httpClientFactory)
		{
			_httpClientFactory = httpClientFactory ?? throw new ArgumentNullException("httpClientFactory");
		}

		protected virtual HttpClient GetHttpClient()
		{
			return _httpClientFactory.GetHttpClient();
		}

		public async Task<HttpResponse> SendPostAsync(Uri endpoint, IDictionary<string, string> headers, IDictionary<string, string> bodyParameters, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken))
		{
			HttpContent body = ((bodyParameters == null) ? null : new FormUrlEncodedContent(bodyParameters));
			return await SendPostAsync(endpoint, headers, body, logger, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Task<HttpResponse> SendPostAsync(Uri endpoint, IDictionary<string, string> headers, HttpContent body, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SendRequestAsync(endpoint, headers, body, HttpMethod.Post, logger, doNotThrow: false, retry: false, cancellationToken);
		}

		public virtual Task<HttpResponse> SendGetAsync(Uri endpoint, IDictionary<string, string> headers, ILoggerAdapter logger, bool retry = true, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SendRequestAsync(endpoint, headers, null, HttpMethod.Get, logger, doNotThrow: false, retry: false, cancellationToken);
		}

		public virtual Task<HttpResponse> SendGetForceResponseAsync(Uri endpoint, IDictionary<string, string> headers, ILoggerAdapter logger, bool retry = true, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SendRequestAsync(endpoint, headers, null, HttpMethod.Get, logger, doNotThrow: true, retry: false, cancellationToken);
		}

		public virtual Task<HttpResponse> SendPostForceResponseAsync(Uri uri, IDictionary<string, string> headers, IDictionary<string, string> bodyParameters, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken))
		{
			HttpContent body = ((bodyParameters == null) ? null : new FormUrlEncodedContent(bodyParameters));
			return SendRequestAsync(uri, headers, body, HttpMethod.Post, logger, doNotThrow: true, retry: false, cancellationToken);
		}

		public virtual Task<HttpResponse> SendPostForceResponseAsync(Uri uri, IDictionary<string, string> headers, StringContent body, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SendRequestAsync(uri, headers, body, HttpMethod.Post, logger, doNotThrow: true, retry: false, cancellationToken);
		}

		private static HttpRequestMessage CreateRequestMessage(Uri endpoint, IDictionary<string, string> headers)
		{
			HttpRequestMessage httpRequestMessage = new HttpRequestMessage
			{
				RequestUri = endpoint
			};
			httpRequestMessage.Headers.Accept.Clear();
			if (headers != null)
			{
				foreach (KeyValuePair<string, string> header in headers)
				{
					httpRequestMessage.Headers.Add(header.Key, header.Value);
				}
			}
			return httpRequestMessage;
		}

		protected virtual async Task<HttpResponse> SendRequestAsync(Uri endpoint, IDictionary<string, string> headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, bool doNotThrow = false, bool retry = false, CancellationToken cancellationToken = default(CancellationToken))
		{
			HttpResponse response = null;
			try
			{
				HttpContent body2 = body;
				if (body != null)
				{
					body2 = await CloneHttpContentAsync(body).ConfigureAwait(continueOnCapturedContext: false);
				}
				using (logger.LogBlockDuration("[HttpManager] ExecuteAsync"))
				{
					response = await ExecuteAsync(endpoint, headers, body2, method, logger, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				if (response.StatusCode == HttpStatusCode.OK)
				{
					return response;
				}
				logger.Info(() => string.Format(CultureInfo.InvariantCulture, "Response status code does not indicate success: {0} ({1}). ", (int)response.StatusCode, response.StatusCode));
			}
			catch (TaskCanceledException ex)
			{
				if (cancellationToken.IsCancellationRequested)
				{
					logger.Info("The HTTP request was cancelled. ");
					throw;
				}
				logger.Error("The HTTP request failed. " + ex.Message);
				throw new MsalServiceException("request_timeout", "Request to the endpoint timed out.", ex);
			}
			if (doNotThrow)
			{
				return response;
			}
			if (IsRetryableStatusCode((int)response.StatusCode))
			{
				throw MsalServiceExceptionFactory.FromHttpResponse("service_not_available", "Service is unavailable to process the request", response);
			}
			return response;
		}

		protected async Task<HttpResponse> ExecuteAsync(Uri endpoint, IDictionary<string, string> headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken))
		{
			HttpRequestMessage requestMessage = CreateRequestMessage(endpoint, headers);
			try
			{
				requestMessage.Method = method;
				requestMessage.Content = body;
				logger.VerbosePii(() => string.Format("[HttpManager] Sending request. Method: {0}. URI: {1}. ", method, (endpoint == null) ? "NULL" : (endpoint.Scheme + "://" + endpoint.Authority + endpoint.AbsolutePath)), () => string.Format("[HttpManager] Sending request. Method: {0}. Host: {1}. ", method, (endpoint == null) ? "NULL" : (endpoint.Scheme + "://" + endpoint.Authority)));
				MeasureDurationResult<HttpResponseMessage> measureDurationResult = await StopwatchService.MeasureCodeBlockAsync(async () => await GetHttpClient().SendAsync(requestMessage, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).ConfigureAwait(continueOnCapturedContext: false);
				HttpResponseMessage responseMessage = measureDurationResult.Result;
				try
				{
					LastRequestDurationInMs = measureDurationResult.Milliseconds;
					logger.Verbose(() => $"[HttpManager] Received response. Status code: {responseMessage.StatusCode}. ");
					HttpResponse obj = await CreateResponseAsync(responseMessage).ConfigureAwait(continueOnCapturedContext: false);
					obj.UserAgent = requestMessage.Headers.UserAgent.ToString();
					return obj;
				}
				finally
				{
					if (responseMessage != null)
					{
						((IDisposable)responseMessage).Dispose();
					}
				}
			}
			finally
			{
				if (requestMessage != null)
				{
					((IDisposable)requestMessage).Dispose();
				}
			}
		}

		internal static async Task<HttpResponse> CreateResponseAsync(HttpResponseMessage response)
		{
			string text = ((response.Content != null) ? (await response.Content.ReadAsStringAsync().ConfigureAwait(continueOnCapturedContext: false)) : null);
			string body = text;
			return new HttpResponse
			{
				Headers = response.Headers,
				Body = body,
				StatusCode = response.StatusCode
			};
		}

		protected static async Task<HttpContent> CloneHttpContentAsync(HttpContent httpContent)
		{
			MemoryStream temp = new MemoryStream();
			await httpContent.CopyToAsync(temp).ConfigureAwait(continueOnCapturedContext: false);
			temp.Position = 0L;
			StreamContent streamContent = new StreamContent(temp);
			if (httpContent.Headers != null)
			{
				foreach (KeyValuePair<string, IEnumerable<string>> header in httpContent.Headers)
				{
					streamContent.Headers.Add(header.Key, header.Value);
				}
			}
			return streamContent;
		}

		protected virtual bool IsRetryableStatusCode(int statusCode)
		{
			if (statusCode >= 500)
			{
				return statusCode < 600;
			}
			return false;
		}
	}
	internal sealed class HttpManagerFactory
	{
		public static IHttpManager GetHttpManager(IMsalHttpClientFactory httpClientFactory, bool withRetry, bool isManagedIdentity)
		{
			if (!withRetry)
			{
				return new HttpManager(httpClientFactory);
			}
			if (!isManagedIdentity)
			{
				return new HttpManagerWithRetry(httpClientFactory);
			}
			return new HttpManagerManagedIdentity(httpClientFactory);
		}
	}
	internal class HttpManagerManagedIdentity : HttpManagerWithRetry
	{
		public HttpManagerManagedIdentity(IMsalHttpClientFactory httpClientFactory)
			: base(httpClientFactory)
		{
		}

		protected override bool IsRetryableStatusCode(int statusCode)
		{
			switch (statusCode)
			{
			case 404:
			case 408:
			case 429:
			case 500:
			case 503:
			case 504:
				return true;
			default:
				return false;
			}
		}
	}
	internal class HttpManagerWithRetry : HttpManager
	{
		public HttpManagerWithRetry(IMsalHttpClientFactory httpClientFactory)
			: base(httpClientFactory)
		{
		}

		public override Task<HttpResponse> SendPostAsync(Uri endpoint, IDictionary<string, string> headers, HttpContent body, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SendRequestAsync(endpoint, headers, body, HttpMethod.Post, logger, doNotThrow: false, retry: true, cancellationToken);
		}

		public override Task<HttpResponse> SendGetAsync(Uri endpoint, IDictionary<string, string> headers, ILoggerAdapter logger, bool retry = true, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SendRequestAsync(endpoint, headers, null, HttpMethod.Get, logger, doNotThrow: false, retry: true, cancellationToken);
		}

		public override Task<HttpResponse> SendGetForceResponseAsync(Uri endpoint, IDictionary<string, string> headers, ILoggerAdapter logger, bool retry = true, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SendRequestAsync(endpoint, headers, null, HttpMethod.Get, logger, doNotThrow: true, retry: true, cancellationToken);
		}

		public override Task<HttpResponse> SendPostForceResponseAsync(Uri uri, IDictionary<string, string> headers, IDictionary<string, string> bodyParameters, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken))
		{
			HttpContent body = ((bodyParameters == null) ? null : new FormUrlEncodedContent(bodyParameters));
			return SendRequestAsync(uri, headers, body, HttpMethod.Post, logger, doNotThrow: true, retry: true, cancellationToken);
		}

		public override Task<HttpResponse> SendPostForceResponseAsync(Uri uri, IDictionary<string, string> headers, StringContent body, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SendRequestAsync(uri, headers, body, HttpMethod.Post, logger, doNotThrow: true, retry: true, cancellationToken);
		}

		protected override HttpClient GetHttpClient()
		{
			return _httpClientFactory.GetHttpClient();
		}

		protected override async Task<HttpResponse> SendRequestAsync(Uri endpoint, IDictionary<string, string> headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, bool doNotThrow = false, bool retry = true, CancellationToken cancellationToken = default(CancellationToken))
		{
			Exception timeoutException = null;
			bool isRetriableStatusCode = false;
			HttpResponse response = null;
			bool flag;
			try
			{
				HttpContent body2 = body;
				if (body != null)
				{
					body2 = await HttpManager.CloneHttpContentAsync(body).ConfigureAwait(continueOnCapturedContext: false);
				}
				using (logger.LogBlockDuration("[HttpManager] ExecuteAsync"))
				{
					response = await ExecuteAsync(endpoint, headers, body2, method, logger, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				if (response.StatusCode == HttpStatusCode.OK)
				{
					return response;
				}
				logger.Info(() => string.Format(CultureInfo.InvariantCulture, "Response status code does not indicate success: {0} ({1}). ", (int)response.StatusCode, response.StatusCode));
				isRetriableStatusCode = IsRetryableStatusCode((int)response.StatusCode);
				flag = isRetriableStatusCode && !HasRetryAfterHeader(response);
			}
			catch (TaskCanceledException ex)
			{
				if (cancellationToken.IsCancellationRequested)
				{
					logger.Info("The HTTP request was cancelled. ");
					throw;
				}
				logger.Error("The HTTP request failed. " + ex.Message);
				flag = true;
				timeoutException = ex;
			}
			if (flag && retry)
			{
				logger.Info("Retrying one more time..");
				await Task.Delay(TimeSpan.FromSeconds(1.0), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				return await SendRequestAsync(endpoint, headers, body, method, logger, doNotThrow, retry: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			logger.Warning("Request retry failed.");
			if (timeoutException != null)
			{
				throw new MsalServiceException("request_timeout", "Request to the endpoint timed out.", timeoutException);
			}
			if (doNotThrow)
			{
				return response;
			}
			if (isRetriableStatusCode)
			{
				throw MsalServiceExceptionFactory.FromHttpResponse("service_not_available", "Service is unavailable to process the request", response);
			}
			return response;
		}

		private static bool HasRetryAfterHeader(HttpResponse response)
		{
			RetryConditionHeaderValue retryConditionHeaderValue = response?.Headers?.RetryAfter;
			if (retryConditionHeaderValue != null)
			{
				if (!retryConditionHeaderValue.Delta.HasValue)
				{
					return retryConditionHeaderValue.Date.HasValue;
				}
				return true;
			}
			return false;
		}
	}
	internal class HttpResponse
	{
		public HttpResponseHeaders Headers { get; set; }

		public IDictionary<string, string> HeadersAsDictionary
		{
			get
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>();
				if (Headers != null)
				{
					foreach (KeyValuePair<string, IEnumerable<string>> header in Headers)
					{
						dictionary[header.Key] = header.Value.First();
					}
				}
				return dictionary;
			}
		}

		public HttpStatusCode StatusCode { get; set; }

		public string UserAgent { get; set; }

		public string Body { get; set; }
	}
	internal interface IHttpManager
	{
		long LastRequestDurationInMs { get; }

		Task<HttpResponse> SendPostAsync(Uri endpoint, IDictionary<string, string> headers, IDictionary<string, string> bodyParameters, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken));

		Task<HttpResponse> SendPostAsync(Uri endpoint, IDictionary<string, string> headers, HttpContent body, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken));

		Task<HttpResponse> SendGetAsync(Uri endpoint, IDictionary<string, string> headers, ILoggerAdapter logger, bool retry = true, CancellationToken cancellationToken = default(CancellationToken));

		Task<HttpResponse> SendPostForceResponseAsync(Uri uri, IDictionary<string, string> headers, StringContent body, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken));

		Task<HttpResponse> SendPostForceResponseAsync(Uri uri, IDictionary<string, string> headers, IDictionary<string, string> bodyParameters, ILoggerAdapter logger, CancellationToken cancellationToken = default(CancellationToken));

		Task<HttpResponse> SendGetForceResponseAsync(Uri endpoint, IDictionary<string, string> headers, ILoggerAdapter logger, bool retry = true, CancellationToken cancellationToken = default(CancellationToken));
	}
	internal class RedirectUriHelper
	{
		public static void Validate(Uri redirectUri, bool usesSystemBrowser = false)
		{
			if (redirectUri == null)
			{
				throw new MsalClientException("no_redirect_uri", "No redirectUri was configured. MSAL does not provide any defaults. ");
			}
			if (!string.IsNullOrWhiteSpace(redirectUri.Fragment))
			{
				throw new ArgumentException("'redirectUri' must NOT include a fragment component. ", "redirectUri");
			}
			if (usesSystemBrowser && "urn:ietf:wg:oauth:2.0:oob".Equals(redirectUri.AbsoluteUri, StringComparison.OrdinalIgnoreCase))
			{
				throw new MsalClientException("redirect_uri_validation_failed", string.Format(CultureInfo.InvariantCulture, "The OAuth2 redirect URI {0} should not be used with the system browser, because the operating system cannot go back to the app. Consider using the default redirect URI for this platform. See https://aka.ms/msal-client-apps for more details. ", "urn:ietf:wg:oauth:2.0:oob"));
			}
		}

		public static void ValidateIosBrokerRedirectUri(Uri redirectUri, string bundleId, ILoggerAdapter logger)
		{
			string text = "msauth." + bundleId + "://auth";
			string originalString = redirectUri.OriginalString;
			if (string.Equals(text, originalString.TrimEnd(new char[1] { '/' }), StringComparison.Ordinal))
			{
				logger.Verbose(() => "Valid MSAL style redirect Uri detected. ");
				return;
			}
			if (redirectUri.Authority.Equals(bundleId, StringComparison.OrdinalIgnoreCase))
			{
				logger.Verbose(() => "Valid ADAL style redirect Uri detected. ");
				return;
			}
			throw new MsalClientException("cannot_invoke_broker", "The broker redirect URI is incorrect, it should be " + text + " or app_scheme ://" + bundleId + " - please visit https://aka.ms/msal-net-xamarin for details about redirect URIs. ");
		}
	}
}
namespace Microsoft.Identity.Client.SSHCertificates
{
	public static class SSHExtensions
	{
		public static AcquireTokenInteractiveParameterBuilder WithSSHCertificateAuthenticationScheme(this AcquireTokenInteractiveParameterBuilder builder, string publicKeyJwk, string keyId)
		{
			builder.CommonParameters.AuthenticationScheme = new SSHCertAuthenticationScheme(keyId, publicKeyJwk);
			return builder;
		}

		public static AcquireTokenSilentParameterBuilder WithSSHCertificateAuthenticationScheme(this AcquireTokenSilentParameterBuilder builder, string publicKeyJwk, string keyId)
		{
			builder.CommonParameters.AuthenticationScheme = new SSHCertAuthenticationScheme(keyId, publicKeyJwk);
			return builder;
		}
	}
}
namespace Microsoft.Identity.Client.Advanced
{
	public static class AcquireTokenParameterBuilderExtensions
	{
		public static T WithExtraHttpHeaders<T>(this AbstractAcquireTokenParameterBuilder<T> builder, IDictionary<string, string> extraHttpHeaders) where T : AbstractAcquireTokenParameterBuilder<T>
		{
			builder.CommonParameters.ExtraHttpHeaders = extraHttpHeaders;
			return (T)builder;
		}
	}
}
namespace Microsoft.Identity.Client.Extensibility
{
	public static class AbstractConfidentialClientAcquireTokenParameterBuilderExtension
	{
		public static AbstractAcquireTokenParameterBuilder<T> OnBeforeTokenRequest<T>(this AbstractAcquireTokenParameterBuilder<T> builder, Func<OnBeforeTokenRequestData, Task> onBeforeTokenRequestHandler) where T : AbstractAcquireTokenParameterBuilder<T>
		{
			builder.CommonParameters.OnBeforeTokenRequestHandler = onBeforeTokenRequestHandler;
			return builder;
		}

		public static AbstractAcquireTokenParameterBuilder<T> WithProofOfPosessionKeyId<T>(this AbstractAcquireTokenParameterBuilder<T> builder, string keyId, string expectedTokenTypeFromAad = "Bearer") where T : AbstractAcquireTokenParameterBuilder<T>
		{
			if (string.IsNullOrEmpty(keyId))
			{
				throw new ArgumentNullException("keyId");
			}
			builder.ValidateUseOfExperimentalFeature("WithProofOfPosessionKeyId");
			builder.CommonParameters.AuthenticationScheme = new ExternalBoundTokenScheme(keyId, expectedTokenTypeFromAad);
			return builder;
		}
	}
	public static class AcquireTokenForClientBuilderExtensions
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static AcquireTokenForClientParameterBuilder WithProofOfPosessionKeyId(this AcquireTokenForClientParameterBuilder builder, string keyId, string expectedTokenTypeFromAad = "Bearer")
		{
			if (string.IsNullOrEmpty(keyId))
			{
				throw new ArgumentNullException("keyId");
			}
			builder.ValidateUseOfExperimentalFeature("WithProofOfPosessionKeyId");
			builder.CommonParameters.AuthenticationScheme = new ExternalBoundTokenScheme(keyId, expectedTokenTypeFromAad);
			return builder;
		}
	}
	public static class AcquireTokenInteractiveParameterBuilderExtensions
	{
		public static AcquireTokenInteractiveParameterBuilder WithCustomWebUi(this AcquireTokenInteractiveParameterBuilder builder, ICustomWebUi customWebUi)
		{
			builder.SetCustomWebUi(customWebUi);
			return builder;
		}
	}
	public static class AcquireTokenOnBehalfOfParameterBuilderExtensions
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static AcquireTokenOnBehalfOfParameterBuilder WithSearchInCacheForLongRunningProcess(this AcquireTokenOnBehalfOfParameterBuilder builder, bool searchInCache = true)
		{
			builder.Parameters.SearchInCacheForLongRunningObo = searchInCache;
			return builder;
		}
	}
	public class AppTokenProviderParameters
	{
		public IEnumerable<string> Scopes { get; internal set; }

		public string CorrelationId { get; internal set; }

		public string Claims { get; internal set; }

		public string TenantId { get; internal set; }

		public CancellationToken CancellationToken { get; internal set; }
	}
	public class AppTokenProviderResult
	{
		public string AccessToken { get; set; }

		public long ExpiresInSeconds { get; set; }

		public long? RefreshInSeconds { get; set; }
	}
	public static class ConfidentialClientApplicationBuilderExtensions
	{
		public static ConfidentialClientApplicationBuilder WithAppTokenProvider(this ConfidentialClientApplicationBuilder builder, Func<AppTokenProviderParameters, Task<AppTokenProviderResult>> appTokenProvider)
		{
			builder.Config.AppTokenProvider = appTokenProvider ?? throw new ArgumentNullException("appTokenProvider");
			return builder;
		}
	}
	public static class ConfidentialClientApplicationExtensions
	{
		public static async Task<bool> StopLongRunningProcessInWebApiAsync(this ILongRunningWebApi clientApp, string longRunningProcessSessionKey, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await ((ConfidentialClientApplication)clientApp).StopLongRunningProcessInWebApiAsync(longRunningProcessSessionKey, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}
	internal class ExternalBoundTokenScheme : IAuthenticationScheme
	{
		private readonly string _keyId;

		private readonly string _tokenType;

		public TokenType TelemetryTokenType => TokenType.External;

		public string AuthorizationHeaderPrefix => _tokenType;

		public string KeyId => _keyId;

		public string AccessTokenType => _tokenType;

		public ExternalBoundTokenScheme(string keyId, string expectedTokenTypeFromEsts = "Bearer")
		{
			_keyId = keyId;
			_tokenType = expectedTokenTypeFromEsts;
		}

		public string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem)
		{
			return msalAccessTokenCacheItem.Secret;
		}

		public IReadOnlyDictionary<string, string> GetTokenRequestParams()
		{
			return CollectionHelpers.GetEmptyDictionary<string, string>();
		}
	}
	public interface ICustomWebUi
	{
		Task<Uri> AcquireAuthorizationCodeAsync(Uri authorizationUri, Uri redirectUri, CancellationToken cancellationToken);
	}
	public sealed class OnBeforeTokenRequestData
	{
		public IDictionary<string, string> BodyParameters { get; }

		public IDictionary<string, string> Headers { get; }

		public Uri RequestUri { get; set; }

		public CancellationToken CancellationToken { get; }

		public OnBeforeTokenRequestData(IDictionary<string, string> bodyParameters, IDictionary<string, string> headers, Uri requestUri, CancellationToken cancellationToken)
		{
			BodyParameters = bodyParameters;
			Headers = headers;
			RequestUri = requestUri;
			CancellationToken = cancellationToken;
		}
	}
}
namespace Microsoft.Identity.Client.Cache
{
	internal static class AdalCacheOperations
	{
		private const int SchemaVersion = 3;

		private const string Delimiter = ":::";

		public static byte[] Serialize(ILoggerAdapter logger, IDictionary<AdalTokenCacheKey, AdalResultWrapper> tokenCacheDictionary)
		{
			using Stream stream = new MemoryStream();
			BinaryWriter binaryWriter = new BinaryWriter(stream);
			binaryWriter.Write(3);
			logger.Info(() => $"[AdalCacheOperations] Serializing token cache with {tokenCacheDictionary.Count} items. ");
			binaryWriter.Write(tokenCacheDictionary.Count);
			foreach (KeyValuePair<AdalTokenCacheKey, AdalResultWrapper> item in tokenCacheDictionary)
			{
				AdalTokenCacheKey key = item.Key;
				binaryWriter.Write(string.Format("{0}{1}{2}{3}{4}{5}{6}", key.Authority, ":::", key.Resource, ":::", key.ClientId, ":::", (int)key.TokenSubjectType));
				binaryWriter.Write(item.Value.Serialize());
			}
			int count = (int)stream.Position;
			stream.Position = 0L;
			return new BinaryReader(stream).ReadBytes(count);
		}

		public static IDictionary<AdalTokenCacheKey, AdalResultWrapper> Deserialize(ILoggerAdapter logger, byte[] state)
		{
			IDictionary<AdalTokenCacheKey, AdalResultWrapper> dictionary = new Dictionary<AdalTokenCacheKey, AdalResultWrapper>();
			if (state == null || state.Length == 0)
			{
				return dictionary;
			}
			using (Stream stream = new MemoryStream())
			{
				BinaryWriter binaryWriter = new BinaryWriter(stream);
				binaryWriter.Write(state);
				binaryWriter.Flush();
				stream.Position = 0L;
				BinaryReader binaryReader = new BinaryReader(stream);
				if (binaryReader.ReadInt32() != 3)
				{
					logger.Warning("[AdalCacheOperations] The version of the persistent state of the cache does not match the current schema, so skipping deserialization. ");
					return dictionary;
				}
				int num = binaryReader.ReadInt32();
				for (int i = 0; i < num; i++)
				{
					string[] array = binaryReader.ReadString().Split(new string[1] { ":::" }, StringSplitOptions.None);
					AdalResultWrapper adalResultWrapper = AdalResultWrapper.Deserialize(binaryReader.ReadString());
					AdalTokenCacheKey key = new AdalTokenCacheKey(array[0], array[1], array[2], (TokenSubjectType)int.Parse(array[3], CultureInfo.CurrentCulture), adalResultWrapper.Result.UserInfo);
					dictionary[key] = adalResultWrapper;
				}
				logger.Info(() => $"[AdalCacheOperations] Deserialized {dictionary.Count} items to ADAL token cache. ");
			}
			return dictionary;
		}
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal sealed class AdalResult
	{
		[JsonProperty]
		public AdalUserInfo UserInfo { get; internal set; }
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal class AdalResultWrapper
	{
		[JsonProperty]
		public AdalResult Result { get; set; }

		[JsonProperty]
		public string RawClientInfo { get; set; }

		[JsonProperty]
		public string RefreshToken { get; set; }

		internal bool IsMultipleResourceRefreshToken
		{
			get
			{
				if (!string.IsNullOrWhiteSpace(RefreshToken))
				{
					return !string.IsNullOrWhiteSpace(ResourceInResponse);
				}
				return false;
			}
		}

		[JsonProperty]
		internal string ResourceInResponse { get; set; }

		[JsonProperty]
		public string UserAssertionHash { get; set; }

		public static AdalResultWrapper Deserialize(string serializedObject)
		{
			return JsonHelper.DeserializeFromJson<AdalResultWrapper>(serializedObject);
		}

		public string Serialize()
		{
			return JsonHelper.SerializeToJson(this);
		}

		internal AdalResultWrapper Clone()
		{
			return Deserialize(Serialize());
		}
	}
	internal enum TokenSubjectType
	{
		User,
		Client,
		UserPlusClient
	}
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	internal sealed class AdalTokenCacheKey : IEquatable<AdalTokenCacheKey>
	{
		public string Authority { get; }

		public string Resource { get; }

		public string ClientId { get; }

		public string UniqueId { get; }

		public string DisplayableId { get; }

		public TokenSubjectType TokenSubjectType { get; }

		private string DebuggerDisplay => "AdalTokenCacheKey: " + Authority + " " + Resource + " " + ClientId + " " + UniqueId + " " + DisplayableId;

		internal AdalTokenCacheKey(string authority, string resource, string clientId, TokenSubjectType tokenSubjectType, AdalUserInfo adalUserInfo)
			: this(authority, resource, clientId, tokenSubjectType, adalUserInfo?.UniqueId, adalUserInfo?.DisplayableId)
		{
		}

		internal AdalTokenCacheKey(string authority, string resource, string clientId, TokenSubjectType tokenSubjectType, string uniqueId, string displayableId)
		{
			Authority = authority;
			Resource = resource;
			ClientId = clientId;
			TokenSubjectType = tokenSubjectType;
			UniqueId = uniqueId;
			DisplayableId = displayableId;
		}

		public override bool Equals(object obj)
		{
			if (obj is AdalTokenCacheKey other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(AdalTokenCacheKey other)
		{
			if (this == other)
			{
				return true;
			}
			if (other != null && other.Authority == Authority && ClientIdEquals(other.ClientId) && other.UniqueId == UniqueId && DisplayableIdEquals(other.DisplayableId))
			{
				return other.TokenSubjectType == TokenSubjectType;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (Authority + ":::" + ClientId + ":::" + UniqueId + ":::" + DisplayableId + ":::" + (int)TokenSubjectType).GetHashCode();
		}

		private bool ClientIdEquals(string otherClientId)
		{
			return string.Equals(otherClientId, ClientId, StringComparison.OrdinalIgnoreCase);
		}

		private bool DisplayableIdEquals(string otherDisplayableId)
		{
			return string.Equals(otherDisplayableId, DisplayableId, StringComparison.OrdinalIgnoreCase);
		}
	}
	internal class AdalUserForMsalEntry
	{
		public string ClientId { get; }

		public string Authority { get; }

		public string ClientInfo { get; }

		public AdalUserInfo UserInfo { get; }

		public AdalUserForMsalEntry(string clientId, string authority, string clientInfo, AdalUserInfo userInfo)
		{
			ClientId = clientId ?? throw new ArgumentNullException("clientId");
			Authority = authority;
			ClientInfo = clientInfo;
			UserInfo = userInfo ?? throw new ArgumentNullException("userInfo");
		}
	}
	[JsonObject]
	[Preserve(AllMembers = true)]
	internal sealed class AdalUserInfo
	{
		[JsonProperty]
		public string UniqueId { get; internal set; }

		[JsonProperty]
		public string DisplayableId { get; internal set; }

		[JsonProperty]
		public string GivenName { get; internal set; }

		[JsonProperty]
		public string FamilyName { get; internal set; }

		[JsonProperty]
		public DateTimeOffset? PasswordExpiresOn { get; internal set; }

		[JsonProperty]
		public Uri PasswordChangeUrl { get; internal set; }

		[JsonProperty]
		public string IdentityProvider { get; internal set; }

		public AdalUserInfo()
		{
		}

		public AdalUserInfo(AdalUserInfo other)
		{
			if (other != null)
			{
				UniqueId = other.UniqueId;
				DisplayableId = other.DisplayableId;
				GivenName = other.GivenName;
				FamilyName = other.FamilyName;
				IdentityProvider = other.IdentityProvider;
				PasswordChangeUrl = other.PasswordChangeUrl;
				PasswordExpiresOn = other.PasswordExpiresOn;
			}
		}
	}
	internal class AdalUsersForMsal
	{
		private readonly IEnumerable<AdalUserForMsalEntry> _userEntries;

		public AdalUsersForMsal(IEnumerable<AdalUserForMsalEntry> userEntries)
		{
			_userEntries = userEntries ?? throw new ArgumentNullException("userEntries");
		}

		public IDictionary<string, AdalUserInfo> GetUsersWithClientInfo(IEnumerable<string> envAliases)
		{
			return _userEntries.Where((AdalUserForMsalEntry u) => !string.IsNullOrEmpty(u.Authority) && !string.IsNullOrEmpty(u.ClientInfo) && (envAliases?.ContainsOrdinalIgnoreCase(Authority.GetEnvironment(u.Authority)) ?? true)).ToLookup((AdalUserForMsalEntry u) => u.ClientInfo, (AdalUserForMsalEntry u) => u.UserInfo).ToDictionary((IGrouping<string, AdalUserInfo> group) => group.Key, (IGrouping<string, AdalUserInfo> group) => group.First());
		}

		public IEnumerable<AdalUserInfo> GetUsersWithoutClientInfo(IEnumerable<string> envAliases)
		{
			return from u in _userEntries
				where !string.IsNullOrEmpty(u.Authority) && string.IsNullOrEmpty(u.ClientInfo) && (envAliases?.ContainsOrdinalIgnoreCase(Authority.GetEnvironment(u.Authority)) ?? true)
				select u.UserInfo;
		}

		public ISet<string> GetAdalUserEnvironments()
		{
			return new HashSet<string>(from u in _userEntries
				where !string.IsNullOrEmpty(u.Authority)
				select Authority.GetEnvironment(u.Authority), StringComparer.OrdinalIgnoreCase);
		}
	}
	[Obsolete("This is expected to be removed in MSAL.NET v3 and ADAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public class CacheData
	{
		public byte[] AdalV3State { get; set; }

		public byte[] UnifiedState { get; set; }
	}
	internal static class CacheFallbackOperations
	{
		internal const string DifferentEnvError = "Not expecting the RT and IdT to have different env when adding to legacy cache";

		internal const string DifferentAuthorityError = "Not expecting authority to have a different env than the RT and IdT";

		public static void WriteAdalRefreshToken(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, MsalRefreshTokenCacheItem rtItem, MsalIdTokenCacheItem idItem, string authority, string uniqueId, string scope)
		{
			try
			{
				if (rtItem == null)
				{
					logger.Info("No refresh token available. Skipping writing to ADAL legacy cache. ");
					return;
				}
				if (!string.IsNullOrEmpty(rtItem.FamilyId))
				{
					logger.Info("Not writing FRT in ADAL legacy cache. ");
					return;
				}
				AdalTokenCacheKey key = new AdalTokenCacheKey(authority, scope, rtItem.ClientId, TokenSubjectType.User, uniqueId, idItem.IdToken.PreferredUsername);
				AdalResultWrapper value = new AdalResultWrapper
				{
					Result = new AdalResult
					{
						UserInfo = new AdalUserInfo
						{
							UniqueId = uniqueId,
							DisplayableId = idItem.IdToken.PreferredUsername
						}
					},
					RefreshToken = rtItem.Secret,
					RawClientInfo = rtItem.RawClientInfo,
					ResourceInResponse = scope
				};
				IDictionary<AdalTokenCacheKey, AdalResultWrapper> dictionary = AdalCacheOperations.Deserialize(logger, legacyCachePersistence.LoadCache());
				dictionary[key] = value;
				legacyCachePersistence.WriteCache(AdalCacheOperations.Serialize(logger, dictionary));
			}
			catch (Exception exWithPii)
			{
				if (!string.Equals(rtItem?.Environment, idItem?.Environment, StringComparison.OrdinalIgnoreCase))
				{
					logger.Error("Not expecting the RT and IdT to have different env when adding to legacy cache");
				}
				if (!string.Equals(rtItem?.Environment, new Uri(authority).Host, StringComparison.OrdinalIgnoreCase))
				{
					logger.Error("Not expecting authority to have a different env than the RT and IdT");
				}
				logger.WarningPiiWithPrefix(exWithPii, "An error occurred while writing MSAL refresh token to the cache in ADAL format. For details please see https://aka.ms/net-cache-persistence-errors. ");
			}
		}

		public static AdalUsersForMsal GetAllAdalUsersForMsal(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, string clientId)
		{
			List<AdalUserForMsalEntry> userEntries = new List<AdalUserForMsalEntry>();
			try
			{
				(from p in AdalCacheOperations.Deserialize(logger, legacyCachePersistence.LoadCache())
					where p.Key.ClientId.Equals(clientId, StringComparison.OrdinalIgnoreCase) && !string.IsNullOrEmpty(p.Key.Authority)
					select p).ToList().ForEach(delegate(KeyValuePair<AdalTokenCacheKey, AdalResultWrapper> kvp)
				{
					userEntries.Add(new AdalUserForMsalEntry(authority: kvp.Key.Authority, clientId: clientId, clientInfo: kvp.Value.RawClientInfo, userInfo: kvp.Value.Result.UserInfo));
				});
			}
			catch (Exception exWithPii)
			{
				logger.WarningPiiWithPrefix(exWithPii, "An error occurred while reading accounts in ADAL format from the cache for MSAL. For details please see https://aka.ms/net-cache-persistence-errors. ");
			}
			return new AdalUsersForMsal(userEntries);
		}

		public static void RemoveAdalUser(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, string clientId, string displayableId, string accountOrUserId)
		{
			try
			{
				IDictionary<AdalTokenCacheKey, AdalResultWrapper> dictionary = AdalCacheOperations.Deserialize(logger, legacyCachePersistence.LoadCache());
				if (!string.IsNullOrEmpty(accountOrUserId))
				{
					RemoveEntriesWithMatchingId(clientId, accountOrUserId, dictionary);
				}
				RemoveEntriesWithMatchingName(logger, clientId, displayableId, dictionary);
				legacyCachePersistence.WriteCache(AdalCacheOperations.Serialize(logger, dictionary));
			}
			catch (Exception exWithPii)
			{
				logger.WarningPiiWithPrefix(exWithPii, "An error occurred while deleting account in ADAL format from the cache. For details please see https://aka.ms/net-cache-persistence-errors. ");
			}
		}

		private static void RemoveEntriesWithMatchingName(ILoggerAdapter logger, string clientId, string displayableId, IDictionary<AdalTokenCacheKey, AdalResultWrapper> adalCache)
		{
			if (string.IsNullOrEmpty(displayableId))
			{
				logger.Error("Internal error - trying to remove an MSAL user with an empty username. Possible cache corruption. See https://aka.ms/adal_token_cache_serialization. ");
				return;
			}
			List<AdalTokenCacheKey> list = new List<AdalTokenCacheKey>();
			foreach (KeyValuePair<AdalTokenCacheKey, AdalResultWrapper> item in adalCache)
			{
				string displayableId2 = item.Key.DisplayableId;
				string clientId2 = item.Key.ClientId;
				if (string.Equals(displayableId, displayableId2, StringComparison.OrdinalIgnoreCase) && string.Equals(clientId, clientId2, StringComparison.OrdinalIgnoreCase))
				{
					list.Add(item.Key);
				}
			}
			foreach (AdalTokenCacheKey item2 in list)
			{
				adalCache.Remove(item2);
			}
		}

		private static void RemoveEntriesWithMatchingId(string clientId, string accountOrUserId, IDictionary<AdalTokenCacheKey, AdalResultWrapper> adalCache)
		{
			List<AdalTokenCacheKey> list = new List<AdalTokenCacheKey>();
			foreach (KeyValuePair<AdalTokenCacheKey, AdalResultWrapper> item in adalCache)
			{
				string rawClientInfo = item.Value.RawClientInfo;
				if (!string.IsNullOrEmpty(rawClientInfo))
				{
					string b = ClientInfo.CreateFromJson(rawClientInfo).ToAccountIdentifier();
					string clientId2 = item.Key.ClientId;
					if (string.Equals(accountOrUserId, b, StringComparison.OrdinalIgnoreCase) && string.Equals(clientId, clientId2, StringComparison.OrdinalIgnoreCase))
					{
						list.Add(item.Key);
					}
				}
			}
			foreach (AdalTokenCacheKey item2 in list)
			{
				adalCache.Remove(item2);
			}
		}

		public static MsalRefreshTokenCacheItem GetRefreshToken(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, IEnumerable<string> environmentAliases, string clientId, IAccount account)
		{
			try
			{
				IEnumerable<KeyValuePair<AdalTokenCacheKey, AdalResultWrapper>> source = from p in AdalCacheOperations.Deserialize(logger, legacyCachePersistence.LoadCache())
					where p.Key.ClientId.Equals(clientId, StringComparison.OrdinalIgnoreCase) && environmentAliases.Contains(new Uri(p.Key.Authority).Host)
					select p;
				bool flag = false;
				if (!string.IsNullOrEmpty(account?.Username))
				{
					source = source.Where((KeyValuePair<AdalTokenCacheKey, AdalResultWrapper> p) => account.Username.Equals(p.Key.DisplayableId, StringComparison.OrdinalIgnoreCase));
					flag = true;
				}
				if (!string.IsNullOrEmpty(account?.HomeAccountId?.ObjectId))
				{
					source = source.Where((KeyValuePair<AdalTokenCacheKey, AdalResultWrapper> p) => account.HomeAccountId.ObjectId.Equals(p.Key.UniqueId, StringComparison.OrdinalIgnoreCase)).ToList();
					flag = true;
				}
				if (!flag)
				{
					logger.Warning("Could not filter ADAL entries by either UPN or unique ID, skipping. ");
					return null;
				}
				return source.Select((KeyValuePair<AdalTokenCacheKey, AdalResultWrapper> adalEntry) => new MsalRefreshTokenCacheItem(new Uri(adalEntry.Key.Authority).Host, adalEntry.Key.ClientId, adalEntry.Value.RefreshToken, adalEntry.Value.RawClientInfo, null, GetHomeAccountId(adalEntry.Value))).FirstOrDefault();
			}
			catch (Exception exWithPii)
			{
				logger.WarningPiiWithPrefix(exWithPii, "An error occurred while searching for refresh tokens in ADAL format in the cache for MSAL. For details please see https://aka.ms/net-cache-persistence-errors. ");
				return null;
			}
		}

		private static string GetHomeAccountId(AdalResultWrapper adalResultWrapper)
		{
			if (!string.IsNullOrEmpty(adalResultWrapper.RawClientInfo))
			{
				return ClientInfo.CreateFromJson(adalResultWrapper.RawClientInfo).ToAccountIdentifier();
			}
			return null;
		}
	}
	internal enum CacheAuthorityType
	{
		AAD,
		MSA,
		MSSTS,
		OTHER
	}
	internal static class CacheKeyFactory
	{
		public static string GetKeyFromRequest(AuthenticationRequestParameters requestParameters)
		{
			if (GetOboOrAppKey(requestParameters, out var key))
			{
				return key;
			}
			if (requestParameters.ApiId == ApiEvent.ApiIds.AcquireTokenSilent || requestParameters.ApiId == ApiEvent.ApiIds.RemoveAccount)
			{
				return requestParameters.Account?.HomeAccountId?.Identifier;
			}
			if (requestParameters.ApiId == ApiEvent.ApiIds.GetAccountById)
			{
				return requestParameters.HomeAccountId;
			}
			return null;
		}

		public static string GetExternalCacheKeyFromResponse(AuthenticationRequestParameters requestParameters, string homeAccountIdFromResponse)
		{
			if (GetOboOrAppKey(requestParameters, out var key))
			{
				return key;
			}
			if (requestParameters.AppConfig.IsConfidentialClient || requestParameters.ApiId == ApiEvent.ApiIds.AcquireTokenSilent)
			{
				return homeAccountIdFromResponse;
			}
			return null;
		}

		public static string GetInternalPartitionKeyFromResponse(AuthenticationRequestParameters requestParameters, string homeAccountIdFromResponse)
		{
			return GetExternalCacheKeyFromResponse(requestParameters, homeAccountIdFromResponse) ?? homeAccountIdFromResponse;
		}

		private static bool GetOboOrAppKey(AuthenticationRequestParameters requestParameters, out string key)
		{
			if (ApiEvent.IsOnBehalfOfRequest(requestParameters.ApiId))
			{
				key = GetOboKey(requestParameters.LongRunningOboCacheKey, requestParameters.UserAssertion);
				return true;
			}
			if (requestParameters.ApiId == ApiEvent.ApiIds.AcquireTokenForClient || requestParameters.ApiId == ApiEvent.ApiIds.AcquireTokenForSystemAssignedManagedIdentity || requestParameters.ApiId == ApiEvent.ApiIds.AcquireTokenForUserAssignedManagedIdentity)
			{
				string tenantId = requestParameters.Authority.TenantId ?? "";
				key = GetClientCredentialKey(requestParameters.AppConfig.ClientId, tenantId, requestParameters.AuthenticationScheme?.KeyId);
				return true;
			}
			key = null;
			return false;
		}

		public static string GetClientCredentialKey(string clientId, string tenantId, string popKid)
		{
			return popKid + clientId + "_" + tenantId + "_AppTokenCache";
		}

		public static string GetOboKey(string oboCacheKey, UserAssertion userAssertion)
		{
			if (string.IsNullOrEmpty(oboCacheKey))
			{
				return userAssertion?.AssertionHash;
			}
			return oboCacheKey;
		}

		public static string GetOboKey(string oboCacheKey, string homeAccountId)
		{
			if (string.IsNullOrEmpty(oboCacheKey))
			{
				return homeAccountId;
			}
			return oboCacheKey;
		}

		public static string GetKeyFromCachedItem(MsalAccessTokenCacheItem accessTokenCacheItem)
		{
			return GetOboKey(accessTokenCacheItem.OboCacheKey, accessTokenCacheItem.HomeAccountId);
		}

		public static string GetKeyFromCachedItem(MsalRefreshTokenCacheItem refreshTokenCacheItem)
		{
			return GetOboKey(refreshTokenCacheItem.OboCacheKey, refreshTokenCacheItem.HomeAccountId);
		}

		public static string GetIdTokenKeyFromCachedItem(MsalAccessTokenCacheItem accessTokenCacheItem)
		{
			return accessTokenCacheItem.HomeAccountId;
		}

		public static string GetKeyFromAccount(MsalAccountCacheItem accountCacheItem)
		{
			return accountCacheItem.HomeAccountId;
		}

		public static string GetKeyFromCachedItem(MsalIdTokenCacheItem idTokenCacheItem)
		{
			return idTokenCacheItem.HomeAccountId;
		}

		public static string GetKeyFromCachedItem(MsalAccountCacheItem accountCacheItem)
		{
			return accountCacheItem.HomeAccountId;
		}
	}
	public enum CacheLevel
	{
		None,
		Unknown,
		L1Cache,
		L2Cache
	}
	internal class CacheSessionManager : ICacheSessionManager
	{
		private readonly AuthenticationRequestParameters _requestParams;

		private bool _cacheRefreshedForRead;

		public RequestContext RequestContext { get; }

		public ITokenCacheInternal TokenCacheInternal { get; }

		public CacheSessionManager(ITokenCacheInternal tokenCacheInternal, AuthenticationRequestParameters requestParams)
		{
			TokenCacheInternal = tokenCacheInternal ?? throw new ArgumentNullException("tokenCacheInternal");
			_requestParams = requestParams ?? throw new ArgumentNullException("requestParams");
			RequestContext = _requestParams.RequestContext;
		}

		public async Task<MsalAccessTokenCacheItem> FindAccessTokenAsync()
		{
			await RefreshCacheForReadOperationsAsync().ConfigureAwait(continueOnCapturedContext: false);
			return await TokenCacheInternal.FindAccessTokenAsync(_requestParams).ConfigureAwait(continueOnCapturedContext: false);
		}

		public Task<Tuple<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> SaveTokenResponseAsync(MsalTokenResponse tokenResponse)
		{
			return TokenCacheInternal.SaveTokenResponseAsync(_requestParams, tokenResponse);
		}

		public async Task<Account> GetAccountAssociatedWithAccessTokenAsync(MsalAccessTokenCacheItem msalAccessTokenCacheItem)
		{
			await RefreshCacheForReadOperationsAsync().ConfigureAwait(continueOnCapturedContext: false);
			return await TokenCacheInternal.GetAccountAssociatedWithAccessTokenAsync(_requestParams, msalAccessTokenCacheItem).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<MsalIdTokenCacheItem> GetIdTokenCacheItemAsync(MsalAccessTokenCacheItem accessTokenCacheItem)
		{
			await RefreshCacheForReadOperationsAsync().ConfigureAwait(continueOnCapturedContext: false);
			return TokenCacheInternal.GetIdTokenCacheItem(accessTokenCacheItem);
		}

		public async Task<MsalRefreshTokenCacheItem> FindFamilyRefreshTokenAsync(string familyId)
		{
			await RefreshCacheForReadOperationsAsync().ConfigureAwait(continueOnCapturedContext: false);
			if (string.IsNullOrEmpty(familyId))
			{
				throw new ArgumentNullException("familyId");
			}
			return await TokenCacheInternal.FindRefreshTokenAsync(_requestParams, familyId).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<MsalRefreshTokenCacheItem> FindRefreshTokenAsync()
		{
			await RefreshCacheForReadOperationsAsync().ConfigureAwait(continueOnCapturedContext: false);
			return await TokenCacheInternal.FindRefreshTokenAsync(_requestParams).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<bool?> IsAppFociMemberAsync(string familyId)
		{
			await RefreshCacheForReadOperationsAsync().ConfigureAwait(continueOnCapturedContext: false);
			return await TokenCacheInternal.IsFociMemberAsync(_requestParams, familyId).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<IEnumerable<IAccount>> GetAccountsAsync()
		{
			await RefreshCacheForReadOperationsAsync().ConfigureAwait(continueOnCapturedContext: false);
			return await TokenCacheInternal.GetAccountsAsync(_requestParams).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task RefreshCacheForReadOperationsAsync()
		{
			if (TokenCacheInternal.IsAppSubscribedToSerializationEvents())
			{
				if (_cacheRefreshedForRead)
				{
					return;
				}
				_requestParams.RequestContext.Logger.Verbose(() => "[Cache Session Manager] Entering the cache semaphore. " + TokenCacheInternal.Semaphore.GetCurrentCountLogMessage());
				await TokenCacheInternal.Semaphore.WaitAsync(_requestParams.RequestContext.UserCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				_requestParams.RequestContext.Logger.Verbose(() => "[Cache Session Manager] Entered cache semaphore");
				TelemetryData telemetryData = new TelemetryData();
				try
				{
					if (!_cacheRefreshedForRead)
					{
						string key = CacheKeyFactory.GetKeyFromRequest(_requestParams);
						object obj = null;
						try
						{
							ITokenCacheInternal tokenCacheInternal = TokenCacheInternal;
							string clientId = _requestParams.AppConfig.ClientId;
							IAccount account = _requestParams.Account;
							bool isApplicationCache = TokenCacheInternal.IsApplicationCache;
							string suggestedCacheKey = key;
							bool hasTokens = TokenCacheInternal.HasTokensNoLocks();
							CancellationToken userCancellationToken = _requestParams.RequestContext.UserCancellationToken;
							TokenCacheNotificationArgs args = new TokenCacheNotificationArgs(tokenCacheInternal, clientId, account, hasStateChanged: false, isApplicationCache, suggestedCacheKey, hasTokens, null, userCancellationToken, _requestParams.RequestContext.CorrelationId, _requestParams.Scope, _requestParams.AuthorityManager.OriginalAuthority.TenantId, _requestParams.RequestContext.Logger.IdentityLogger, _requestParams.RequestContext.Logger.PiiLoggingEnabled, telemetryData);
							MeasureDurationResult measureDurationResult = await TokenCacheInternal.OnBeforeAccessAsync(args).MeasureAsync().ConfigureAwait(continueOnCapturedContext: false);
							RequestContext.ApiEvent.DurationInCacheInMs += measureDurationResult.Milliseconds;
						}
						catch (object obj2)
						{
							obj = obj2;
						}
						MeasureDurationResult measureDurationResult2 = await StopwatchService.MeasureCodeBlockAsync(async delegate
						{
							ITokenCacheInternal tokenCacheInternal2 = TokenCacheInternal;
							string clientId2 = _requestParams.AppConfig.ClientId;
							IAccount account2 = _requestParams.Account;
							bool isApplicationCache2 = TokenCacheInternal.IsApplicationCache;
							string suggestedCacheKey2 = key;
							bool hasTokens2 = TokenCacheInternal.HasTokensNoLocks();
							CancellationToken userCancellationToken2 = _requestParams.RequestContext.UserCancellationToken;
							TokenCacheNotificationArgs args2 = new TokenCacheNotificationArgs(tokenCacheInternal2, clientId2, account2, hasStateChanged: false, isApplicationCache2, suggestedCacheKey2, hasTokens2, null, userCancellationToken2, _requestParams.RequestContext.CorrelationId, _requestParams.Scope, _requestParams.AuthorityManager.OriginalAuthority.TenantId, _requestParams.RequestContext.Logger.IdentityLogger, _requestParams.RequestContext.Logger.PiiLoggingEnabled, telemetryData);
							await TokenCacheInternal.OnAfterAccessAsync(args2).ConfigureAwait(continueOnCapturedContext: false);
						}).ConfigureAwait(continueOnCapturedContext: false);
						RequestContext.ApiEvent.DurationInCacheInMs += measureDurationResult2.Milliseconds;
						object obj3 = obj;
						if (obj3 != null)
						{
							ExceptionDispatchInfo.Capture((obj3 as Exception) ?? throw obj3).Throw();
						}
						_cacheRefreshedForRead = true;
					}
				}
				finally
				{
					TokenCacheInternal.Semaphore.Release();
					_requestParams.RequestContext.Logger.Verbose(() => "[Cache Session Manager] Released cache semaphore");
					RequestContext.ApiEvent.CacheLevel = telemetryData.CacheLevel;
				}
			}
			else
			{
				RequestContext.ApiEvent.CacheLevel = CacheLevel.L1Cache;
			}
		}
	}
	internal interface ICacheSessionManager
	{
		RequestContext RequestContext { get; }

		ITokenCacheInternal TokenCacheInternal { get; }

		Task<MsalAccessTokenCacheItem> FindAccessTokenAsync();

		Task<Tuple<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> SaveTokenResponseAsync(MsalTokenResponse tokenResponse);

		Task<MsalIdTokenCacheItem> GetIdTokenCacheItemAsync(MsalAccessTokenCacheItem accessTokenCacheItem);

		Task<MsalRefreshTokenCacheItem> FindRefreshTokenAsync();

		Task<MsalRefreshTokenCacheItem> FindFamilyRefreshTokenAsync(string familyId);

		Task<bool?> IsAppFociMemberAsync(string familyId);

		Task<IEnumerable<IAccount>> GetAccountsAsync();

		Task<Account> GetAccountAssociatedWithAccessTokenAsync(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
	}
	internal interface ILegacyCachePersistence
	{
		byte[] LoadCache();

		void WriteCache(byte[] serializedCache);
	}
	internal interface ITokenCacheAccessor
	{
		void SaveAccessToken(MsalAccessTokenCacheItem item);

		void SaveRefreshToken(MsalRefreshTokenCacheItem item);

		void SaveIdToken(MsalIdTokenCacheItem item);

		void SaveAccount(MsalAccountCacheItem item);

		void SaveAppMetadata(MsalAppMetadataCacheItem item);

		MsalIdTokenCacheItem GetIdToken(MsalAccessTokenCacheItem accessTokenCacheItem);

		MsalAccountCacheItem GetAccount(MsalAccountCacheItem accountCacheItem);

		MsalAppMetadataCacheItem GetAppMetadata(MsalAppMetadataCacheItem appMetadataItem);

		void DeleteAccessToken(MsalAccessTokenCacheItem item);

		void DeleteRefreshToken(MsalRefreshTokenCacheItem item);

		void DeleteIdToken(MsalIdTokenCacheItem item);

		void DeleteAccount(MsalAccountCacheItem item);

		List<MsalAccessTokenCacheItem> GetAllAccessTokens(string optionalPartitionKey = null, ILoggerAdapter requestlogger = null);

		List<MsalRefreshTokenCacheItem> GetAllRefreshTokens(string optionalPartitionKey = null, ILoggerAdapter requestlogger = null);

		List<MsalIdTokenCacheItem> GetAllIdTokens(string optionalPartitionKey = null, ILoggerAdapter requestlogger = null);

		List<MsalAccountCacheItem> GetAllAccounts(string optionalPartitionKey = null, ILoggerAdapter requestlogger = null);

		List<MsalAppMetadataCacheItem> GetAllAppMetadata();

		void Clear(ILoggerAdapter requestlogger = null);

		bool HasAccessOrRefreshTokens();
	}
	internal interface ITokenCacheSerializable
	{
		IDictionary<string, JToken> Deserialize(byte[] bytes, bool clearExistingCacheData);

		byte[] Serialize(IDictionary<string, JToken> additionalNodes);
	}
	internal static class StorageJsonKeys
	{
		public const string HomeAccountId = "home_account_id";

		public const string Environment = "environment";

		public const string Realm = "realm";

		public const string LocalAccountId = "local_account_id";

		public const string Username = "username";

		public const string AuthorityType = "authority_type";

		public const string AlternativeAccountId = "alternative_account_id";

		public const string GivenName = "given_name";

		public const string FamilyName = "family_name";

		public const string MiddleName = "middle_name";

		public const string Name = "name";

		public const string AvatarUrl = "avatar_url";

		public const string CredentialType = "credential_type";

		public const string ClientId = "client_id";

		public const string Secret = "secret";

		public const string Target = "target";

		public const string CachedAt = "cached_at";

		public const string ExpiresOn = "expires_on";

		public const string RefreshOn = "refresh_on";

		public const string ExtendedExpiresOn = "extended_expires_on";

		public const string ClientInfo = "client_info";

		public const string FamilyId = "family_id";

		public const string AppMetadata = "appmetadata";

		public const string KeyId = "kid";

		public const string TokenType = "token_type";

		public const string WamAccountIds = "wam_account_ids";

		public const string UserAssertionHash = "user_assertion_hash";

		public const string ExtendedExpiresOn_MsalCompat = "ext_expires_on";
	}
	internal static class StorageJsonValues
	{
		public const string AuthorityTypeAdfs = "ADFS";

		public const string AuthorityTypeMsa = "MSA";

		public const string AuthorityTypeMsSts = "MSSTS";

		public const string AuthorityTypeOther = "Other";

		public const string TokenTypeBearer = "Bearer";

		public const string CredentialTypeRefreshToken = "RefreshToken";

		public const string CredentialTypeAccessToken = "AccessToken";

		public const string CredentialTypeAccessTokenWithAuthScheme = "AccessToken_With_AuthScheme";

		public const string CredentialTypeIdToken = "IdToken";

		public const string AccountRootKey = "Account";

		public const string CredentialTypeOther = "Other";

		public const string AppMetadata = "AppMetadata";
	}
	internal class TokenCacheDictionarySerializer : ITokenCacheSerializable
	{
		private const string AccessTokenKey = "access_tokens";

		private const string RefreshTokenKey = "refresh_tokens";

		private const string IdTokenKey = "id_tokens";

		private const string AccountKey = "accounts";

		private readonly ITokenCacheAccessor _accessor;

		public TokenCacheDictionarySerializer(ITokenCacheAccessor accessor)
		{
			_accessor = accessor;
		}

		public byte[] Serialize(IDictionary<string, JToken> unknownNodes)
		{
			List<string> list = new List<string>();
			List<string> list2 = new List<string>();
			List<string> list3 = new List<string>();
			List<string> list4 = new List<string>();
			foreach (MsalAccessTokenCacheItem allAccessToken in _accessor.GetAllAccessTokens())
			{
				list.Add(allAccessToken.ToJsonString());
			}
			foreach (MsalRefreshTokenCacheItem allRefreshToken in _accessor.GetAllRefreshTokens())
			{
				list2.Add(allRefreshToken.ToJsonString());
			}
			foreach (MsalIdTokenCacheItem allIdToken in _accessor.GetAllIdTokens())
			{
				list3.Add(allIdToken.ToJsonString());
			}
			foreach (MsalAccountCacheItem allAccount in _accessor.GetAllAccounts())
			{
				list4.Add(allAccount.ToJsonString());
			}
			return JsonHelper.SerializeToJson(new Dictionary<string, IEnumerable<string>>
			{
				["access_tokens"] = list,
				["refresh_tokens"] = list2,
				["id_tokens"] = list3,
				["accounts"] = list4
			}.ToList()).ToByteArray();
		}

		public IDictionary<string, JToken> Deserialize(byte[] bytes, bool clearExistingCacheData)
		{
			List<KeyValuePair<string, IEnumerable<string>>> list;
			try
			{
				list = JsonHelper.DeserializeFromJson<List<KeyValuePair<string, IEnumerable<string>>>>(bytes);
			}
			catch (Exception innerException)
			{
				throw new MsalClientException("json_parse_failed", "MSAL V2 Deserialization failed to parse the cache contents. Is this possibly an earlier format needed for DeserializeMsalV3?  (See https://aka.ms/msal-net-3x-cache-breaking-change). ", innerException);
			}
			Dictionary<string, IEnumerable<string>> dictionary = list.ToDictionary((KeyValuePair<string, IEnumerable<string>> x) => x.Key, (KeyValuePair<string, IEnumerable<string>> x) => x.Value);
			if (clearExistingCacheData)
			{
				_accessor.Clear();
			}
			if (list == null || list.Count == 0)
			{
				return null;
			}
			if (dictionary.TryGetValue("access_tokens", out var value))
			{
				foreach (string item in value)
				{
					_accessor.SaveAccessToken(MsalAccessTokenCacheItem.FromJsonString(item));
				}
			}
			if (dictionary.TryGetValue("refresh_tokens", out var value2))
			{
				foreach (string item2 in value2)
				{
					_accessor.SaveRefreshToken(MsalRefreshTokenCacheItem.FromJsonString(item2));
				}
			}
			if (dictionary.TryGetValue("id_tokens", out var value3))
			{
				foreach (string item3 in value3)
				{
					_accessor.SaveIdToken(MsalIdTokenCacheItem.FromJsonString(item3));
				}
			}
			if (dictionary.TryGetValue("accounts", out var value4))
			{
				foreach (string item4 in value4)
				{
					_accessor.SaveAccount(MsalAccountCacheItem.FromJsonString(item4));
				}
			}
			return null;
		}
	}
	internal class TokenCacheJsonSerializer : ITokenCacheSerializable
	{
		private readonly ITokenCacheAccessor _accessor;

		public TokenCacheJsonSerializer(ITokenCacheAccessor accessor)
		{
			_accessor = accessor;
		}

		public byte[] Serialize(IDictionary<string, JToken> unknownNodes)
		{
			CacheSerializationContract cacheSerializationContract = new CacheSerializationContract(unknownNodes);
			foreach (MsalAccessTokenCacheItem allAccessToken in _accessor.GetAllAccessTokens())
			{
				cacheSerializationContract.AccessTokens[allAccessToken.CacheKey] = allAccessToken;
			}
			foreach (MsalRefreshTokenCacheItem allRefreshToken in _accessor.GetAllRefreshTokens())
			{
				cacheSerializationContract.RefreshTokens[allRefreshToken.CacheKey] = allRefreshToken;
			}
			foreach (MsalIdTokenCacheItem allIdToken in _accessor.GetAllIdTokens())
			{
				cacheSerializationContract.IdTokens[allIdToken.CacheKey] = allIdToken;
			}
			foreach (MsalAccountCacheItem allAccount in _accessor.GetAllAccounts())
			{
				cacheSerializationContract.Accounts[allAccount.CacheKey] = allAccount;
			}
			foreach (MsalAppMetadataCacheItem allAppMetadatum in _accessor.GetAllAppMetadata())
			{
				cacheSerializationContract.AppMetadata[allAppMetadatum.CacheKey] = allAppMetadatum;
			}
			return cacheSerializationContract.ToJsonString().ToByteArray();
		}

		public IDictionary<string, JToken> Deserialize(byte[] bytes, bool clearExistingCacheData)
		{
			string text = CoreHelpers.ByteArrayToString(bytes);
			CacheSerializationContract cacheSerializationContract;
			try
			{
				cacheSerializationContract = CacheSerializationContract.FromJsonString(text);
			}
			catch (Exception ex)
			{
				string arg = ((text.Length > 5) ? text.Substring(0, 5) : text);
				throw new MsalClientException("json_parse_failed", $"MSAL deserialization failed to parse the cache contents. First characters of the cache string: {arg} \r\nPossible cause: token cache encryption is used via Microsoft.Identity.Web.TokenCache and decryption fails, for example. \r\n Full details of inner exception: {ex} ", ex);
			}
			if (clearExistingCacheData)
			{
				_accessor.Clear();
			}
			if (cacheSerializationContract.AccessTokens != null)
			{
				foreach (MsalAccessTokenCacheItem value in cacheSerializationContract.AccessTokens.Values)
				{
					_accessor.SaveAccessToken(value);
				}
			}
			if (cacheSerializationContract.RefreshTokens != null)
			{
				foreach (MsalRefreshTokenCacheItem value2 in cacheSerializationContract.RefreshTokens.Values)
				{
					_accessor.SaveRefreshToken(value2);
				}
			}
			if (cacheSerializationContract.IdTokens != null)
			{
				foreach (MsalIdTokenCacheItem value3 in cacheSerializationContract.IdTokens.Values)
				{
					_accessor.SaveIdToken(value3);
				}
			}
			if (cacheSerializationContract.Accounts != null)
			{
				foreach (MsalAccountCacheItem value4 in cacheSerializationContract.Accounts.Values)
				{
					_accessor.SaveAccount(value4);
				}
			}
			if (cacheSerializationContract.AppMetadata != null)
			{
				foreach (MsalAppMetadataCacheItem value5 in cacheSerializationContract.AppMetadata.Values)
				{
					_accessor.SaveAppMetadata(value5);
				}
			}
			return cacheSerializationContract.UnknownNodes;
		}
	}
}
namespace Microsoft.Identity.Client.Cache.Keys
{
	internal interface IiOSKey
	{
		string iOSAccount { get; }

		string iOSGeneric { get; }

		string iOSService { get; }

		int iOSType { get; }
	}
	internal class MsalCacheKeys
	{
		internal enum iOSCredentialAttrType
		{
			AccessToken = 2001,
			RefreshToken = 2002,
			IdToken = 2003,
			Password = 2004,
			AppMetadata = 3001
		}

		public const char CacheKeyDelimiter = '-';

		internal static readonly Dictionary<string, int> iOSAuthorityTypeToAttrType = new Dictionary<string, int>
		{
			{
				CacheAuthorityType.AAD.ToString(),
				1001
			},
			{
				CacheAuthorityType.MSA.ToString(),
				1002
			},
			{
				CacheAuthorityType.MSSTS.ToString(),
				1003
			},
			{
				CacheAuthorityType.OTHER.ToString(),
				1004
			}
		};

		public static string GetCredentialKey(string homeAccountId, string environment, string keyDescriptor, string clientId, string tenantId, string scopes, params string[] additionalKeys)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(homeAccountId ?? "");
			stringBuilder.Append('-');
			stringBuilder.Append(environment);
			stringBuilder.Append('-');
			stringBuilder.Append(keyDescriptor);
			stringBuilder.Append('-');
			stringBuilder.Append(clientId);
			stringBuilder.Append('-');
			stringBuilder.Append(tenantId ?? "");
			stringBuilder.Append('-');
			stringBuilder.Append(scopes ?? "");
			foreach (string item in additionalKeys ?? Enumerable.Empty<string>())
			{
				stringBuilder.Append('-');
				stringBuilder.Append(item);
			}
			return stringBuilder.ToString().ToLowerInvariant();
		}

		public static string GetiOSAccountKey(string homeAccountId, string environment)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(homeAccountId ?? "");
			stringBuilder.Append('-');
			stringBuilder.Append(environment);
			return stringBuilder.ToString().ToLowerInvariant();
		}

		public static string GetiOSServiceKey(string keyDescriptor, string clientId, string tenantId, string scopes, params string[] extraKeyParts)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(keyDescriptor);
			stringBuilder.Append('-');
			stringBuilder.Append(clientId);
			stringBuilder.Append('-');
			stringBuilder.Append(tenantId ?? "");
			stringBuilder.Append('-');
			stringBuilder.Append(scopes ?? "");
			foreach (string item in extraKeyParts ?? Enumerable.Empty<string>())
			{
				stringBuilder.Append('-');
				stringBuilder.Append(item);
			}
			return stringBuilder.ToString().ToLowerInvariant();
		}

		public static string GetiOSGenericKey(string keyDescriptor, string clientId, string tenantId)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(keyDescriptor);
			stringBuilder.Append('-');
			stringBuilder.Append(clientId);
			stringBuilder.Append('-');
			stringBuilder.Append(tenantId ?? "");
			return stringBuilder.ToString().ToLowerInvariant();
		}
	}
	internal struct IosKey : IiOSKey
	{
		public string iOSAccount { get; }

		public string iOSGeneric { get; }

		public string iOSService { get; }

		public int iOSType { get; }

		internal IosKey(string iOSAccount, string iOSService, string iOSGeneric, int iOSType)
		{
			this.iOSAccount = iOSAccount;
			this.iOSGeneric = iOSGeneric;
			this.iOSService = iOSService;
			this.iOSType = iOSType;
		}
	}
}
namespace Microsoft.Identity.Client.Cache.Items
{
	internal class CacheSerializationContract
	{
		private static readonly IEnumerable<string> s_knownPropertyNames = new string[5] { "AccessToken", "RefreshToken", "IdToken", "Account", "AppMetadata" };

		public Dictionary<string, MsalAccessTokenCacheItem> AccessTokens { get; set; } = new Dictionary<string, MsalAccessTokenCacheItem>();

		public Dictionary<string, MsalRefreshTokenCacheItem> RefreshTokens { get; set; } = new Dictionary<string, MsalRefreshTokenCacheItem>();

		public Dictionary<string, MsalIdTokenCacheItem> IdTokens { get; set; } = new Dictionary<string, MsalIdTokenCacheItem>();

		public Dictionary<string, MsalAccountCacheItem> Accounts { get; set; } = new Dictionary<string, MsalAccountCacheItem>();

		public Dictionary<string, MsalAppMetadataCacheItem> AppMetadata { get; set; } = new Dictionary<string, MsalAppMetadataCacheItem>();

		public IDictionary<string, JToken> UnknownNodes { get; }

		public CacheSerializationContract(IDictionary<string, JToken> unknownNodes)
		{
			UnknownNodes = unknownNodes ?? new Dictionary<string, JToken>();
		}

		internal static CacheSerializationContract FromJsonString(string json)
		{
			JObject jObject = JObject.Parse(json);
			CacheSerializationContract cacheSerializationContract = new CacheSerializationContract(ExtractUnknownNodes(jObject));
			if (jObject.ContainsKey("AccessToken"))
			{
				foreach (JObject item in GetElement(jObject, "AccessToken"))
				{
					if (item != null)
					{
						MsalAccessTokenCacheItem msalAccessTokenCacheItem = MsalAccessTokenCacheItem.FromJObject(item);
						cacheSerializationContract.AccessTokens[msalAccessTokenCacheItem.CacheKey] = msalAccessTokenCacheItem;
					}
				}
			}
			if (jObject.ContainsKey("RefreshToken"))
			{
				foreach (JObject item2 in GetElement(jObject, "RefreshToken"))
				{
					if (item2 != null)
					{
						MsalRefreshTokenCacheItem msalRefreshTokenCacheItem = MsalRefreshTokenCacheItem.FromJObject(item2);
						cacheSerializationContract.RefreshTokens[msalRefreshTokenCacheItem.CacheKey] = msalRefreshTokenCacheItem;
					}
				}
			}
			if (jObject.ContainsKey("IdToken"))
			{
				foreach (JObject item3 in GetElement(jObject, "IdToken"))
				{
					if (item3 != null)
					{
						MsalIdTokenCacheItem msalIdTokenCacheItem = MsalIdTokenCacheItem.FromJObject(item3);
						cacheSerializationContract.IdTokens[msalIdTokenCacheItem.CacheKey] = msalIdTokenCacheItem;
					}
				}
			}
			if (jObject.ContainsKey("Account"))
			{
				foreach (JObject item4 in GetElement(jObject, "Account"))
				{
					if (item4 != null)
					{
						MsalAccountCacheItem msalAccountCacheItem = MsalAccountCacheItem.FromJObject(item4);
						cacheSerializationContract.Accounts[msalAccountCacheItem.CacheKey] = msalAccountCacheItem;
					}
				}
			}
			if (jObject.ContainsKey("AppMetadata"))
			{
				foreach (JObject item5 in GetElement(jObject, "AppMetadata"))
				{
					if (item5 != null)
					{
						MsalAppMetadataCacheItem msalAppMetadataCacheItem = MsalAppMetadataCacheItem.FromJObject(item5);
						cacheSerializationContract.AppMetadata[msalAppMetadataCacheItem.CacheKey] = msalAppMetadataCacheItem;
					}
				}
			}
			return cacheSerializationContract;
			static IEnumerable<JObject> GetElement(JObject root, string key)
			{
				foreach (JToken item6 in root[key].Values())
				{
					yield return item6 as JObject;
				}
			}
		}

		private static IDictionary<string, JToken> ExtractUnknownNodes(JObject root)
		{
			return root.Where((KeyValuePair<string, JToken> kvp) => !s_knownPropertyNames.Any((string p) => string.Equals(kvp.Key, p, StringComparison.OrdinalIgnoreCase))).ToDictionary((KeyValuePair<string, JToken> kvp) => kvp.Key, (KeyValuePair<string, JToken> kvp) => kvp.Value);
		}

		internal string ToJsonString()
		{
			JObject jObject = new JObject();
			JObject jObject2 = new JObject();
			foreach (KeyValuePair<string, MsalAccessTokenCacheItem> accessToken in AccessTokens)
			{
				jObject2[accessToken.Key] = accessToken.Value.ToJObject();
			}
			jObject["AccessToken"] = jObject2;
			JObject jObject3 = new JObject();
			foreach (KeyValuePair<string, MsalRefreshTokenCacheItem> refreshToken in RefreshTokens)
			{
				jObject3[refreshToken.Key] = refreshToken.Value.ToJObject();
			}
			jObject["RefreshToken"] = jObject3;
			JObject jObject4 = new JObject();
			foreach (KeyValuePair<string, MsalIdTokenCacheItem> idToken in IdTokens)
			{
				jObject4[idToken.Key] = idToken.Value.ToJObject();
			}
			jObject["IdToken"] = jObject4;
			JObject jObject5 = new JObject();
			foreach (KeyValuePair<string, MsalAccountCacheItem> account in Accounts)
			{
				jObject5[account.Key] = account.Value.ToJObject();
			}
			jObject["Account"] = jObject5;
			JObject jObject6 = new JObject();
			foreach (KeyValuePair<string, MsalAppMetadataCacheItem> appMetadatum in AppMetadata)
			{
				jObject6[appMetadatum.Key] = appMetadatum.Value.ToJObject();
			}
			jObject["AppMetadata"] = jObject6;
			foreach (KeyValuePair<string, JToken> unknownNode in UnknownNodes)
			{
				jObject[unknownNode.Key] = unknownNode.Value;
			}
			return JsonConvert.SerializeObject(jObject, Microsoft.Identity.Json.Formatting.None, new JsonSerializerSettings
			{
				NullValueHandling = NullValueHandling.Include
			});
		}
	}
	internal class MsalAccessTokenCacheItem : MsalCredentialCacheItemBase
	{
		private string[] _extraKeyParts;

		private string _credentialDescriptor;

		private Lazy<IiOSKey> iOSCacheKeyLazy;

		internal string TenantId { get; private set; }

		internal string OboCacheKey { get; set; }

		internal string KeyId { get; }

		internal string TokenType { get; }

		internal HashSet<string> ScopeSet { get; }

		internal string ScopeString { get; }

		internal DateTimeOffset ExpiresOn { get; private set; }

		internal DateTimeOffset ExtendedExpiresOn { get; private set; }

		internal DateTimeOffset? RefreshOn { get; private set; }

		internal DateTimeOffset CachedAt { get; private set; }

		public bool IsExtendedLifeTimeToken { get; set; }

		internal string CacheKey { get; private set; }

		public IiOSKey iOSCacheKey => iOSCacheKeyLazy.Value;

		internal MsalAccessTokenCacheItem(string preferredCacheEnv, string clientId, MsalTokenResponse response, string tenantId, string homeAccountId, string keyId = null, string oboCacheKey = null)
			: this(ScopeHelper.OrderScopesAlphabetically(response.Scope), DateTimeOffset.UtcNow, DateTimeHelpers.DateTimeOffsetFromDuration(response.ExpiresIn), DateTimeHelpers.DateTimeOffsetFromDuration(response.ExtendedExpiresIn), DateTimeHelpers.DateTimeOffsetFromDuration(response.RefreshIn), tenantId, keyId, response.TokenType)
		{
			base.Environment = preferredCacheEnv;
			base.ClientId = clientId;
			base.Secret = response.AccessToken;
			base.RawClientInfo = response.ClientInfo;
			base.HomeAccountId = homeAccountId;
			OboCacheKey = oboCacheKey;
			InitCacheKey();
		}

		internal MsalAccessTokenCacheItem(string preferredCacheEnv, string clientId, string scopes, string tenantId, string secret, DateTimeOffset cachedAt, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, string rawClientInfo, string homeAccountId, string keyId = null, DateTimeOffset? refreshOn = null, string tokenType = "Bearer", string oboCacheKey = null)
			: this(scopes, cachedAt, expiresOn, extendedExpiresOn, refreshOn, tenantId, keyId, tokenType)
		{
			base.Environment = preferredCacheEnv;
			base.ClientId = clientId;
			base.Secret = secret;
			base.RawClientInfo = rawClientInfo;
			base.HomeAccountId = homeAccountId;
			OboCacheKey = oboCacheKey;
			InitCacheKey();
		}

		private MsalAccessTokenCacheItem(string scopes, DateTimeOffset cachedAt, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, DateTimeOffset? refreshOn, string tenantId, string keyId, string tokenType)
		{
			base.CredentialType = "AccessToken";
			ScopeString = scopes;
			ScopeSet = ScopeHelper.ConvertStringToScopeSet(ScopeString);
			ExpiresOn = expiresOn;
			ExtendedExpiresOn = extendedExpiresOn;
			RefreshOn = refreshOn;
			TenantId = tenantId ?? "";
			KeyId = keyId;
			TokenType = tokenType;
			CachedAt = cachedAt;
		}

		internal MsalAccessTokenCacheItem WithExpiresOn(DateTimeOffset expiresOn)
		{
			return new MsalAccessTokenCacheItem(base.Environment, base.ClientId, ScopeString, TenantId, base.Secret, CachedAt, expiresOn, ExtendedExpiresOn, base.RawClientInfo, base.HomeAccountId, KeyId, RefreshOn, TokenType, OboCacheKey);
		}

		internal void InitCacheKey()
		{
			_extraKeyParts = null;
			_credentialDescriptor = "AccessToken";
			if (AuthSchemeHelper.StoreTokenTypeInCacheKey(TokenType))
			{
				_extraKeyParts = new string[1] { TokenType };
				_credentialDescriptor = "AccessToken_With_AuthScheme";
			}
			CacheKey = MsalCacheKeys.GetCredentialKey(base.HomeAccountId, base.Environment, _credentialDescriptor, base.ClientId, TenantId, ScopeString, _extraKeyParts);
			iOSCacheKeyLazy = new Lazy<IiOSKey>(InitiOSKey);
		}

		internal string ToLogString(bool piiEnabled = false)
		{
			return MsalCacheKeys.GetCredentialKey(piiEnabled ? base.HomeAccountId : base.HomeAccountId?.GetHashCode().ToString(), base.Environment, _credentialDescriptor, base.ClientId, TenantId, ScopeString, _extraKeyParts);
		}

		private IiOSKey InitiOSKey()
		{
			string iOSAccount = MsalCacheKeys.GetiOSAccountKey(base.HomeAccountId, base.Environment);
			string iOSService = MsalCacheKeys.GetiOSServiceKey(_credentialDescriptor, base.ClientId, TenantId, ScopeString, _extraKeyParts);
			string iOSGeneric = MsalCacheKeys.GetiOSGenericKey(_credentialDescriptor, base.ClientId, TenantId);
			int iOSType = 2001;
			return new IosKey(iOSAccount, iOSService, iOSGeneric, iOSType);
		}

		internal static MsalAccessTokenCacheItem FromJsonString(string json)
		{
			if (string.IsNullOrWhiteSpace(json))
			{
				return null;
			}
			return FromJObject(JsonHelper.ParseIntoJsonObject(json));
		}

		internal static MsalAccessTokenCacheItem FromJObject(JObject j)
		{
			long num = JsonHelper.ExtractParsedIntOrZero(j, "cached_at");
			long num2 = JsonHelper.ExtractParsedIntOrZero(j, "expires_on");
			long num3 = JsonHelper.ExtractParsedIntOrZero(j, "refresh_on");
			long num4 = JsonHelper.ExtractParsedIntOrZero(j, "ext_expires_on");
			long num5 = JsonHelper.ExtractParsedIntOrZero(j, "extended_expires_on");
			if (num5 == 0L && num4 > 0)
			{
				num5 = num4;
			}
			string tenantId = JsonHelper.ExtractExistingOrEmptyString(j, "realm");
			string oboCacheKey = JsonHelper.ExtractExistingOrDefault<string>(j, "user_assertion_hash");
			string keyId = JsonHelper.ExtractExistingOrDefault<string>(j, "kid");
			string tokenType = JsonHelper.ExtractExistingOrDefault<string>(j, "token_type") ?? "Bearer";
			MsalAccessTokenCacheItem obj = new MsalAccessTokenCacheItem(JsonHelper.ExtractExistingOrEmptyString(j, "target"), expiresOn: DateTimeHelpers.UnixTimestampToDateTime(num2), extendedExpiresOn: DateTimeHelpers.UnixTimestampToDateTime(num5), refreshOn: DateTimeHelpers.UnixTimestampToDateTimeOrNull(num3), cachedAt: DateTimeHelpers.UnixTimestampToDateTime(num), tenantId: tenantId, keyId: keyId, tokenType: tokenType);
			obj.OboCacheKey = oboCacheKey;
			obj.PopulateFieldsFromJObject(j);
			obj.InitCacheKey();
			return obj;
		}

		internal override JObject ToJObject()
		{
			JObject jObject = base.ToJObject();
			string text = DateTimeHelpers.DateTimeToUnixTimestamp(ExtendedExpiresOn);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "realm", TenantId);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "target", ScopeString);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "user_assertion_hash", OboCacheKey);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "cached_at", DateTimeHelpers.DateTimeToUnixTimestamp(CachedAt));
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "expires_on", DateTimeHelpers.DateTimeToUnixTimestamp(ExpiresOn));
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "extended_expires_on", text);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "kid", KeyId);
			MsalItemWithAdditionalFields.SetItemIfValueNotNullOrDefault(jObject, "token_type", TokenType, "Bearer");
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "refresh_on", RefreshOn.HasValue ? DateTimeHelpers.DateTimeToUnixTimestamp(RefreshOn.Value) : null);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "ext_expires_on", text);
			return jObject;
		}

		internal string ToJsonString()
		{
			return ToJObject().ToString();
		}

		internal MsalIdTokenCacheItem GetIdTokenItem()
		{
			return new MsalIdTokenCacheItem(base.Environment, base.ClientId, base.Secret, base.RawClientInfo, base.HomeAccountId, TenantId);
		}

		internal bool IsExpiredWithBuffer()
		{
			return ExpiresOn < DateTime.UtcNow + Constants.AccessTokenExpirationBuffer;
		}
	}
	[DebuggerDisplay("{PreferredUsername} {base.Environment}")]
	internal class MsalAccountCacheItem : MsalCacheItemBase
	{
		private Lazy<IiOSKey> iOSCacheKeyLazy;

		internal string TenantId { get; set; }

		internal string PreferredUsername { get; set; }

		internal string Name { get; set; }

		internal string GivenName { get; set; }

		internal string FamilyName { get; set; }

		internal string LocalAccountId { get; set; }

		internal string AuthorityType { get; set; }

		internal IDictionary<string, string> WamAccountIds { get; set; }

		public string CacheKey { get; private set; }

		public IiOSKey iOSCacheKey => iOSCacheKeyLazy.Value;

		internal MsalAccountCacheItem()
		{
			AuthorityType = CacheAuthorityType.MSSTS.ToString();
		}

		internal MsalAccountCacheItem(string preferredCacheEnv, string clientInfo, string homeAccountId, IdToken idToken, string preferredUsername, string tenantId, IDictionary<string, string> wamAccountIds)
			: this()
		{
			Init(preferredCacheEnv, idToken?.GetUniqueId(), clientInfo, homeAccountId, idToken?.Name, preferredUsername, tenantId, idToken?.GivenName, idToken?.FamilyName, wamAccountIds);
		}

		internal MsalAccountCacheItem(string environment, string localAccountId, string rawClientInfo, string homeAccountId, string name, string preferredUsername, string tenantId, string givenName, string familyName, IDictionary<string, string> wamAccountIds)
			: this()
		{
			Init(environment, localAccountId, rawClientInfo, homeAccountId, name, preferredUsername, tenantId, givenName, familyName, wamAccountIds);
		}

		internal MsalAccountCacheItem(string environment, string tenantId, string homeAccountId, string preferredUsername)
			: this()
		{
			base.Environment = environment;
			TenantId = tenantId;
			base.HomeAccountId = homeAccountId;
			PreferredUsername = preferredUsername;
			InitCacheKey();
		}

		private void Init(string environment, string localAccountId, string rawClientInfo, string homeAccountId, string name, string preferredUsername, string tenantId, string givenName, string familyName, IDictionary<string, string> wamAccountIds)
		{
			base.Environment = environment;
			PreferredUsername = preferredUsername;
			Name = name;
			TenantId = tenantId;
			LocalAccountId = localAccountId;
			base.RawClientInfo = rawClientInfo;
			GivenName = givenName;
			FamilyName = familyName;
			base.HomeAccountId = homeAccountId;
			WamAccountIds = wamAccountIds;
			InitCacheKey();
		}

		internal void InitCacheKey()
		{
			CacheKey = $"{base.HomeAccountId}{'-'}{base.Environment}{'-'}{TenantId}";
			iOSCacheKeyLazy = new Lazy<IiOSKey>(InitiOSKey);
		}

		private IiOSKey InitiOSKey()
		{
			string iOSAccount = MsalCacheKeys.GetiOSAccountKey(base.HomeAccountId, base.Environment);
			string iOSService = (TenantId ?? "").ToLowerInvariant();
			string iOSGeneric = PreferredUsername?.ToLowerInvariant();
			int iOSType = MsalCacheKeys.iOSAuthorityTypeToAttrType[CacheAuthorityType.MSSTS.ToString()];
			return new IosKey(iOSAccount, iOSService, iOSGeneric, iOSType);
		}

		internal static MsalAccountCacheItem FromJsonString(string json)
		{
			if (string.IsNullOrWhiteSpace(json))
			{
				return null;
			}
			return FromJObject(JsonHelper.ParseIntoJsonObject(json));
		}

		internal static MsalAccountCacheItem FromJObject(JObject j)
		{
			MsalAccountCacheItem msalAccountCacheItem = new MsalAccountCacheItem();
			msalAccountCacheItem.PreferredUsername = JsonHelper.ExtractExistingOrEmptyString(j, "username");
			msalAccountCacheItem.Name = JsonHelper.ExtractExistingOrEmptyString(j, "name");
			msalAccountCacheItem.GivenName = JsonHelper.ExtractExistingOrEmptyString(j, "given_name");
			msalAccountCacheItem.FamilyName = JsonHelper.ExtractExistingOrEmptyString(j, "family_name");
			msalAccountCacheItem.LocalAccountId = JsonHelper.ExtractExistingOrEmptyString(j, "local_account_id");
			msalAccountCacheItem.AuthorityType = JsonHelper.ExtractExistingOrEmptyString(j, "authority_type");
			msalAccountCacheItem.TenantId = JsonHelper.ExtractExistingOrEmptyString(j, "realm");
			msalAccountCacheItem.WamAccountIds = JsonHelper.ExtractInnerJsonAsDictionary(j, "wam_account_ids");
			msalAccountCacheItem.PopulateFieldsFromJObject(j);
			msalAccountCacheItem.InitCacheKey();
			return msalAccountCacheItem;
		}

		internal override JObject ToJObject()
		{
			JObject jObject = base.ToJObject();
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "username", PreferredUsername);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "name", Name);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "given_name", GivenName);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "family_name", FamilyName);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "local_account_id", LocalAccountId);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "authority_type", AuthorityType);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "realm", TenantId);
			if (WamAccountIds != null && WamAccountIds.Any())
			{
				jObject["wam_account_ids"] = JObject.FromObject(WamAccountIds);
			}
			return jObject;
		}

		internal string ToJsonString()
		{
			return ToJObject().ToString();
		}
	}
	internal class MsalAppMetadataCacheItem : MsalItemWithAdditionalFields, IEquatable<MsalAppMetadataCacheItem>
	{
		private Lazy<IiOSKey> iOSCacheKeyLazy;

		public string ClientId { get; }

		public string Environment { get; }

		public string FamilyId { get; }

		public string CacheKey { get; private set; }

		public IiOSKey iOSCacheKey => iOSCacheKeyLazy.Value;

		public MsalAppMetadataCacheItem(string clientId, string preferredCacheEnv, string familyId)
		{
			ClientId = clientId;
			Environment = preferredCacheEnv;
			FamilyId = familyId;
			InitCacheKey();
		}

		private void InitCacheKey()
		{
			CacheKey = (string.Format("{0}{1}", "appmetadata", '-') + $"{Environment}{'-'}{ClientId}").ToLowerInvariant();
			iOSCacheKeyLazy = new Lazy<IiOSKey>(InitiOSKey);
		}

		private IiOSKey InitiOSKey()
		{
			string iOSService = string.Format("{0}{1}{2}", "AppMetadata", '-', ClientId).ToLowerInvariant();
			string iOSGeneric = "1";
			string iOSAccount = (Environment ?? "").ToLowerInvariant();
			int iOSType = 3001;
			return new IosKey(iOSAccount, iOSService, iOSGeneric, iOSType);
		}

		internal static MsalAppMetadataCacheItem FromJsonString(string json)
		{
			if (string.IsNullOrWhiteSpace(json))
			{
				return null;
			}
			return FromJObject(JsonHelper.ParseIntoJsonObject(json));
		}

		internal static MsalAppMetadataCacheItem FromJObject(JObject j)
		{
			string clientId = JsonHelper.ExtractExistingOrEmptyString(j, "client_id");
			string preferredCacheEnv = JsonHelper.ExtractExistingOrEmptyString(j, "environment");
			string familyId = JsonHelper.ExtractExistingOrEmptyString(j, "family_id");
			MsalAppMetadataCacheItem msalAppMetadataCacheItem = new MsalAppMetadataCacheItem(clientId, preferredCacheEnv, familyId);
			msalAppMetadataCacheItem.PopulateFieldsFromJObject(j);
			msalAppMetadataCacheItem.InitCacheKey();
			return msalAppMetadataCacheItem;
		}

		internal string ToJsonString()
		{
			return ToJObject().ToString();
		}

		internal override JObject ToJObject()
		{
			JObject jObject = base.ToJObject();
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "environment", Environment);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "client_id", ClientId);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "family_id", FamilyId);
			return jObject;
		}

		public override int GetHashCode()
		{
			return (((-1793347351 * -1521134295 + EqualityComparer<string>.Default.GetHashCode(ClientId)) * -1521134295 + EqualityComparer<string>.Default.GetHashCode(Environment)) * -1521134295 + EqualityComparer<string>.Default.GetHashCode(FamilyId)) * -1521134295 + EqualityComparer<string>.Default.GetHashCode(base.AdditionalFieldsJson);
		}

		public bool Equals(MsalAppMetadataCacheItem other)
		{
			if (ClientId == other.ClientId && Environment == other.Environment && FamilyId == other.FamilyId)
			{
				return base.AdditionalFieldsJson == other.AdditionalFieldsJson;
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj is MsalAppMetadataCacheItem other)
			{
				return Equals(other);
			}
			return false;
		}
	}
	[DebuggerDisplay("env: {Environment} accountId: {HomeAccountId}")]
	internal abstract class MsalCacheItemBase : MsalItemWithAdditionalFields
	{
		internal string HomeAccountId { get; set; }

		internal string Environment { get; set; }

		internal string RawClientInfo { get; set; }

		internal override void PopulateFieldsFromJObject(JObject j)
		{
			HomeAccountId = JsonHelper.ExtractExistingOrEmptyString(j, "home_account_id");
			Environment = JsonHelper.ExtractExistingOrEmptyString(j, "environment");
			RawClientInfo = JsonHelper.ExtractExistingOrEmptyString(j, "client_info");
			base.PopulateFieldsFromJObject(j);
		}

		internal override JObject ToJObject()
		{
			JObject jObject = base.ToJObject();
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "home_account_id", HomeAccountId);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "environment", Environment);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "client_info", RawClientInfo);
			return jObject;
		}
	}
	internal class MsalCredentialCacheItemBase : MsalCacheItemBase
	{
		internal string CredentialType { get; set; }

		public string ClientId { get; set; }

		public string Secret { get; set; }

		internal override void PopulateFieldsFromJObject(JObject j)
		{
			CredentialType = JsonHelper.ExtractExistingOrEmptyString(j, "credential_type");
			ClientId = JsonHelper.ExtractExistingOrEmptyString(j, "client_id");
			Secret = JsonHelper.ExtractExistingOrEmptyString(j, "secret");
			base.PopulateFieldsFromJObject(j);
		}

		internal override JObject ToJObject()
		{
			JObject jObject = base.ToJObject();
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "client_id", ClientId);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "secret", Secret);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "credential_type", CredentialType);
			return jObject;
		}
	}
	internal class MsalIdTokenCacheItem : MsalCredentialCacheItemBase
	{
		private readonly Lazy<IdToken> idTokenLazy;

		private Lazy<IiOSKey> iOSCacheKeyLazy;

		internal string TenantId { get; set; }

		internal IdToken IdToken => idTokenLazy.Value;

		public string CacheKey { get; private set; }

		public IiOSKey iOSCacheKey => iOSCacheKeyLazy.Value;

		internal MsalIdTokenCacheItem()
		{
			base.CredentialType = "IdToken";
			idTokenLazy = new Lazy<IdToken>(() => IdToken.Parse(base.Secret));
		}

		internal MsalIdTokenCacheItem(string preferredCacheEnv, string clientId, MsalTokenResponse response, string tenantId, string homeAccountId)
			: this(preferredCacheEnv, clientId, response.IdToken, response.ClientInfo, homeAccountId, tenantId)
		{
		}

		internal MsalIdTokenCacheItem(string preferredCacheEnv, string clientId, string secret, string rawClientInfo, string homeAccountId, string tenantId)
			: this()
		{
			base.Environment = preferredCacheEnv;
			TenantId = tenantId;
			base.ClientId = clientId;
			base.Secret = secret;
			base.RawClientInfo = rawClientInfo;
			base.HomeAccountId = homeAccountId;
			InitCacheKey();
		}

		internal void InitCacheKey()
		{
			CacheKey = MsalCacheKeys.GetCredentialKey(base.HomeAccountId, base.Environment, "IdToken", base.ClientId, TenantId, null);
			iOSCacheKeyLazy = new Lazy<IiOSKey>(InitiOSKey);
		}

		private IiOSKey InitiOSKey()
		{
			string iOSAccount = MsalCacheKeys.GetiOSAccountKey(base.HomeAccountId, base.Environment);
			string iOSGeneric = MsalCacheKeys.GetiOSGenericKey("IdToken", base.ClientId, TenantId);
			string iOSService = MsalCacheKeys.GetiOSServiceKey("IdToken", base.ClientId, TenantId, null);
			int iOSType = 2003;
			return new IosKey(iOSAccount, iOSService, iOSGeneric, iOSType);
		}

		internal static MsalIdTokenCacheItem FromJsonString(string json)
		{
			if (string.IsNullOrWhiteSpace(json))
			{
				return null;
			}
			return FromJObject(JsonHelper.ParseIntoJsonObject(json));
		}

		internal static MsalIdTokenCacheItem FromJObject(JObject j)
		{
			MsalIdTokenCacheItem msalIdTokenCacheItem = new MsalIdTokenCacheItem();
			msalIdTokenCacheItem.TenantId = JsonHelper.ExtractExistingOrEmptyString(j, "realm");
			msalIdTokenCacheItem.PopulateFieldsFromJObject(j);
			msalIdTokenCacheItem.InitCacheKey();
			return msalIdTokenCacheItem;
		}

		internal override JObject ToJObject()
		{
			JObject jObject = base.ToJObject();
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "realm", TenantId);
			return jObject;
		}

		internal string ToJsonString()
		{
			return ToJObject().ToString();
		}

		internal string GetUsername()
		{
			object obj = IdToken?.PreferredUsername;
			if (obj == null)
			{
				IdToken idToken = IdToken;
				if (idToken == null)
				{
					return null;
				}
				obj = idToken.Upn;
			}
			return (string)obj;
		}
	}
	internal abstract class MsalItemWithAdditionalFields
	{
		internal string AdditionalFieldsJson { get; set; } = "{}";

		internal virtual void PopulateFieldsFromJObject(JObject j)
		{
			AdditionalFieldsJson = j.ToString();
		}

		internal virtual JObject ToJObject()
		{
			if (!string.IsNullOrWhiteSpace(AdditionalFieldsJson))
			{
				return JsonHelper.ParseIntoJsonObject(AdditionalFieldsJson);
			}
			return new JObject();
		}

		internal static void SetItemIfValueNotNull(JObject json, string key, JToken value)
		{
			SetValueIfFilterMatches(json, key, value, (string strVal) => !string.IsNullOrEmpty(strVal));
		}

		internal static void SetItemIfValueNotNullOrDefault(JObject json, string key, JToken value, string defaultValue)
		{
			SetValueIfFilterMatches(json, key, value, (string strVal) => !string.IsNullOrEmpty(strVal) && !strVal.Equals(defaultValue, StringComparison.OrdinalIgnoreCase));
		}

		private static void SetValueIfFilterMatches(JObject json, string key, JToken value, Func<string, bool> filter)
		{
			bool flag = true;
			object obj = value.ToObject<object>();
			if (obj == null)
			{
				flag = false;
			}
			else if (obj is string arg)
			{
				flag = filter(arg);
			}
			if (flag)
			{
				json[key] = value;
			}
		}
	}
	internal class MsalRefreshTokenCacheItem : MsalCredentialCacheItemBase
	{
		private Lazy<IiOSKey> iOSCacheKeyLazy;

		public string FamilyId { get; set; }

		internal string OboCacheKey { get; set; }

		public bool IsFRT => !string.IsNullOrEmpty(FamilyId);

		public string CacheKey { get; private set; }

		public IiOSKey iOSCacheKey => iOSCacheKeyLazy.Value;

		internal MsalRefreshTokenCacheItem()
		{
			base.CredentialType = "RefreshToken";
		}

		internal MsalRefreshTokenCacheItem(string preferredCacheEnv, string clientId, MsalTokenResponse response, string homeAccountId)
			: this(preferredCacheEnv, clientId, response.RefreshToken, response.ClientInfo, response.FamilyId, homeAccountId)
		{
		}

		internal MsalRefreshTokenCacheItem(string preferredCacheEnv, string clientId, string secret, string rawClientInfo, string familyId, string homeAccountId)
			: this()
		{
			base.ClientId = clientId;
			base.Environment = preferredCacheEnv;
			base.Secret = secret;
			base.RawClientInfo = rawClientInfo;
			FamilyId = familyId;
			base.HomeAccountId = homeAccountId;
			InitCacheKey();
		}

		internal void InitCacheKey()
		{
			string cacheKey;
			if (!string.IsNullOrWhiteSpace(FamilyId))
			{
				char c = '-';
				cacheKey = string.Format("{0}{1}{2}{3}{4}{5}{6}{7}{8}", base.HomeAccountId, c, base.Environment, c, "RefreshToken", c, FamilyId, c, c).ToLowerInvariant();
			}
			else
			{
				cacheKey = MsalCacheKeys.GetCredentialKey(base.HomeAccountId, base.Environment, "RefreshToken", base.ClientId, null, null);
			}
			CacheKey = cacheKey;
			iOSCacheKeyLazy = new Lazy<IiOSKey>(() => InitiOSKey());
		}

		internal string ToLogString(bool piiEnabled = false)
		{
			return MsalCacheKeys.GetCredentialKey(piiEnabled ? base.HomeAccountId : base.HomeAccountId?.GetHashCode().ToString(), base.Environment, "RefreshToken", base.ClientId, null, null);
		}

		private IiOSKey InitiOSKey()
		{
			string iOSService = GetiOSService();
			string iOSGeneric = GetiOSGeneric();
			string iOSAccount = MsalCacheKeys.GetiOSAccountKey(base.HomeAccountId, base.Environment);
			int iOSType = 2002;
			return new IosKey(iOSAccount, iOSService, iOSGeneric, iOSType);
		}

		private string GetiOSGeneric()
		{
			if (!string.IsNullOrWhiteSpace(FamilyId))
			{
				return string.Format("{0}{1}{2}{3}", "RefreshToken", '-', FamilyId, '-').ToLowerInvariant();
			}
			return MsalCacheKeys.GetiOSGenericKey("RefreshToken", base.ClientId, null);
		}

		public string GetiOSService()
		{
			if (!string.IsNullOrWhiteSpace(FamilyId))
			{
				return string.Format("{0}{1}{2}{3}{4}", "RefreshToken", '-', FamilyId, '-', '-').ToLowerInvariant();
			}
			return MsalCacheKeys.GetiOSServiceKey("RefreshToken", base.ClientId, null, null);
		}

		internal static MsalRefreshTokenCacheItem FromJsonString(string json)
		{
			if (string.IsNullOrWhiteSpace(json))
			{
				return null;
			}
			return FromJObject(JsonHelper.ParseIntoJsonObject(json));
		}

		internal static MsalRefreshTokenCacheItem FromJObject(JObject j)
		{
			MsalRefreshTokenCacheItem msalRefreshTokenCacheItem = new MsalRefreshTokenCacheItem();
			msalRefreshTokenCacheItem.FamilyId = JsonHelper.ExtractExistingOrEmptyString(j, "family_id");
			msalRefreshTokenCacheItem.OboCacheKey = JsonHelper.ExtractExistingOrEmptyString(j, "user_assertion_hash");
			msalRefreshTokenCacheItem.PopulateFieldsFromJObject(j);
			msalRefreshTokenCacheItem.InitCacheKey();
			return msalRefreshTokenCacheItem;
		}

		internal override JObject ToJObject()
		{
			JObject jObject = base.ToJObject();
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "family_id", FamilyId);
			MsalItemWithAdditionalFields.SetItemIfValueNotNull(jObject, "user_assertion_hash", OboCacheKey);
			return jObject;
		}

		internal string ToJsonString()
		{
			return ToJObject().ToString();
		}
	}
}
namespace Microsoft.Identity.Client.AuthScheme
{
	internal class AuthSchemeHelper
	{
		public static bool StoreTokenTypeInCacheKey(string tokenType)
		{
			if (string.Equals(tokenType, "bearer", StringComparison.OrdinalIgnoreCase))
			{
				return false;
			}
			if (string.Equals(tokenType, "ssh-cert", StringComparison.OrdinalIgnoreCase))
			{
				return false;
			}
			return true;
		}
	}
	internal interface IAuthenticationScheme
	{
		TokenType TelemetryTokenType { get; }

		string AuthorizationHeaderPrefix { get; }

		string KeyId { get; }

		string AccessTokenType { get; }

		IReadOnlyDictionary<string, string> GetTokenRequestParams();

		string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
	}
	internal enum TokenType
	{
		Bearer = 1,
		Pop,
		SshCert,
		External
	}
}
namespace Microsoft.Identity.Client.AuthScheme.SSHCertificates
{
	internal class SSHCertAuthenticationScheme : IAuthenticationScheme
	{
		internal const string SSHCertTokenType = "ssh-cert";

		private readonly string _jwk;

		public TokenType TelemetryTokenType => TokenType.SshCert;

		public string AuthorizationHeaderPrefix
		{
			get
			{
				throw new MsalClientException("ssh_cert_used_as_http_header", "MSAL was configured to request SSH certificates from AAD, and these cannot be used as an HTTP authentication header. Developers are responsible for transporting the SSH certificates to the target machines. ");
			}
		}

		public string AccessTokenType => "ssh-cert";

		public string KeyId { get; }

		public SSHCertAuthenticationScheme(string keyId, string jwk)
		{
			if (string.IsNullOrEmpty(keyId))
			{
				throw new ArgumentNullException("keyId");
			}
			if (string.IsNullOrEmpty(jwk))
			{
				throw new ArgumentNullException("jwk");
			}
			KeyId = keyId;
			_jwk = jwk;
		}

		public string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem)
		{
			return msalAccessTokenCacheItem.Secret;
		}

		public IReadOnlyDictionary<string, string> GetTokenRequestParams()
		{
			return new Dictionary<string, string>
			{
				{ "token_type", "ssh-cert" },
				{ "req_cnf", _jwk }
			};
		}
	}
}
namespace Microsoft.Identity.Client.AuthScheme.PoP
{
	internal class InMemoryCryptoProvider : IPoPCryptoProvider
	{
		internal const int RsaKeySize = 2048;

		private RSA _signingKey;

		public string CannonicalPublicKeyJwk { get; private set; }

		public string CryptographicAlgorithm => "RS256";

		public InMemoryCryptoProvider()
		{
			InitializeSigningKey();
		}

		private void InitializeSigningKey()
		{
			_signingKey = RSA.Create();
			_signingKey.KeySize = 2048;
			RSAParameters rsaPublicKey = _signingKey.ExportParameters(includePrivateParameters: false);
			CannonicalPublicKeyJwk = ComputeCanonicalJwk(rsaPublicKey);
		}

		public byte[] Sign(byte[] payload)
		{
			return _signingKey.SignData(payload, HashAlgorithmName.SHA256, RSASignaturePadding.Pss);
		}

		private static string ComputeCanonicalJwk(RSAParameters rsaPublicKey)
		{
			return "{\"e\":\"" + Base64UrlHelpers.Encode(rsaPublicKey.Exponent) + "\",\"kty\":\"RSA\",\"n\":\"" + Base64UrlHelpers.Encode(rsaPublicKey.Modulus) + "\"}";
		}
	}
	public interface IPoPCryptoProvider
	{
		string CannonicalPublicKeyJwk { get; }

		string CryptographicAlgorithm { get; }

		byte[] Sign(byte[] data);
	}
	internal static class JsonWebKeyParameterNames
	{
		public const string Alg = "alg";

		public const string Crv = "crv";

		public const string D = "d";

		public const string DP = "dp";

		public const string DQ = "dq";

		public const string E = "e";

		public const string K = "k";

		public const string KeyOps = "key_ops";

		public const string Keys = "keys";

		public const string Kid = "kid";

		public const string Kty = "kty";

		public const string N = "n";

		public const string Oth = "oth";

		public const string P = "p";

		public const string Q = "q";

		public const string R = "r";

		public const string T = "t";

		public const string QI = "qi";

		public const string Use = "use";

		public const string X5c = "x5c";

		public const string X5t = "x5t";

		public const string X5tS256 = "x5t#S256";

		public const string X5u = "x5u";

		public const string X = "x";

		public const string Y = "y";

		public const string EC = "EC";
	}
	internal static class JsonWebAlgorithmsKeyTypes
	{
		public const string EllipticCurve = "EC";

		public const string RSA = "RSA";

		public const string Octet = "oct";
	}
	internal class PopAuthenticationScheme : IAuthenticationScheme
	{
		private readonly PoPAuthenticationConfiguration _popAuthenticationConfiguration;

		private readonly IPoPCryptoProvider _popCryptoProvider;

		public TokenType TelemetryTokenType => TokenType.Pop;

		public string AuthorizationHeaderPrefix => "PoP";

		public string AccessTokenType => "pop";

		public string KeyId { get; }

		public PopAuthenticationScheme(PoPAuthenticationConfiguration popAuthenticationConfiguration, IServiceBundle serviceBundle)
		{
			if (serviceBundle == null)
			{
				throw new ArgumentNullException("serviceBundle");
			}
			_popAuthenticationConfiguration = popAuthenticationConfiguration ?? throw new ArgumentNullException("popAuthenticationConfiguration");
			_popCryptoProvider = _popAuthenticationConfiguration.PopCryptoProvider ?? serviceBundle.PlatformProxy.GetDefaultPoPCryptoProvider();
			byte[] inArray = ComputeThumbprint(_popCryptoProvider.CannonicalPublicKeyJwk);
			KeyId = Base64UrlHelpers.Encode(inArray);
		}

		public IReadOnlyDictionary<string, string> GetTokenRequestParams()
		{
			return new Dictionary<string, string>
			{
				{ "token_type", "pop" },
				{
					"req_cnf",
					ComputeReqCnf()
				}
			};
		}

		public string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem)
		{
			if (!_popAuthenticationConfiguration.SignHttpRequest)
			{
				return msalAccessTokenCacheItem.Secret;
			}
			JObject jObject = new JObject();
			jObject["alg"] = _popCryptoProvider.CryptographicAlgorithm;
			jObject["kid"] = KeyId;
			jObject["typ"] = "pop";
			JObject jsonObject = CreateBody(msalAccessTokenCacheItem);
			return CreateJWS(JsonHelper.JsonObjectToString(jsonObject), JsonHelper.JsonObjectToString(jObject));
		}

		private JObject CreateBody(MsalAccessTokenCacheItem msalAccessTokenCacheItem)
		{
			JToken value = JToken.Parse(_popCryptoProvider.CannonicalPublicKeyJwk);
			JObject jObject = new JObject
			{
				["cnf"] = new JObject { ["jwk"] = value },
				["ts"] = DateTimeHelpers.CurrDateTimeInUnixTimestamp(),
				["at"] = msalAccessTokenCacheItem.Secret,
				["nonce"] = _popAuthenticationConfiguration.Nonce ?? CreateSimpleNonce()
			};
			if (_popAuthenticationConfiguration.HttpMethod != null)
			{
				jObject["m"] = _popAuthenticationConfiguration.HttpMethod?.ToString();
			}
			if (!string.IsNullOrEmpty(_popAuthenticationConfiguration.HttpHost))
			{
				jObject["u"] = _popAuthenticationConfiguration.HttpHost;
			}
			if (!string.IsNullOrEmpty(_popAuthenticationConfiguration.HttpPath))
			{
				jObject["p"] = _popAuthenticationConfiguration.HttpPath;
			}
			return jObject;
		}

		private static string CreateSimpleNonce()
		{
			return Guid.NewGuid().ToString("N", CultureInfo.InvariantCulture);
		}

		private string ComputeReqCnf()
		{
			return Base64UrlHelpers.Encode("{\"kid\":\"" + KeyId + "\"}");
		}

		private static byte[] ComputeThumbprint(string canonicalJwk)
		{
			using SHA256 sHA = SHA256.Create();
			return sHA.ComputeHash(Encoding.UTF8.GetBytes(canonicalJwk));
		}

		private string CreateJWS(string payload, string header)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(Base64UrlHelpers.Encode(Encoding.UTF8.GetBytes(header)));
			stringBuilder.Append('.');
			stringBuilder.Append(Base64UrlHelpers.Encode(payload));
			string s = stringBuilder.ToString();
			stringBuilder.Append('.');
			stringBuilder.Append(Base64UrlHelpers.Encode(_popCryptoProvider.Sign(Encoding.UTF8.GetBytes(s))));
			return stringBuilder.ToString();
		}
	}
	internal class PopBrokerAuthenticationScheme : IAuthenticationScheme
	{
		public TokenType TelemetryTokenType => TokenType.Pop;

		public string AuthorizationHeaderPrefix => "PoP";

		public string KeyId => string.Empty;

		public string AccessTokenType => "pop";

		public string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem)
		{
			return msalAccessTokenCacheItem.Secret;
		}

		public IReadOnlyDictionary<string, string> GetTokenRequestParams()
		{
			return CollectionHelpers.GetEmptyDictionary<string, string>();
		}
	}
	internal static class PoPClaimTypes
	{
		public const string At = "at";

		public const string HttpMethod = "m";

		public const string Ts = "ts";

		public const string Host = "u";

		public const string Path = "p";

		public const string Query = "q";

		public const string Cnf = "cnf";

		public const string JWK = "jwk";

		public const string Nonce = "nonce";
	}
	internal static class PoPProviderFactory
	{
		private static InMemoryCryptoProvider s_currentProvider;

		private static DateTime s_providerExpiration;

		private static object s_lock = new object();

		public static TimeSpan KeyRotationInterval { get; } = TimeSpan.FromHours(8.0);

		internal static ITimeService TimeService { get; set; } = new TimeService();

		public static InMemoryCryptoProvider GetOrCreateProvider()
		{
			lock (s_lock)
			{
				DateTime utcNow = TimeService.GetUtcNow();
				if (s_currentProvider != null && s_providerExpiration > utcNow)
				{
					return s_currentProvider;
				}
				s_currentProvider = new InMemoryCryptoProvider();
				s_providerExpiration = TimeService.GetUtcNow() + KeyRotationInterval;
				return s_currentProvider;
			}
		}

		public static void Reset()
		{
			s_currentProvider = null;
			TimeService = new TimeService();
		}
	}
}
namespace Microsoft.Identity.Client.AuthScheme.Bearer
{
	internal class BearerAuthenticationScheme : IAuthenticationScheme
	{
		internal const string BearerTokenType = "bearer";

		public TokenType TelemetryTokenType => TokenType.Bearer;

		public string AuthorizationHeaderPrefix => "Bearer";

		public string AccessTokenType => "bearer";

		public string KeyId => null;

		public string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem)
		{
			return msalAccessTokenCacheItem.Secret;
		}

		public IReadOnlyDictionary<string, string> GetTokenRequestParams()
		{
			return CollectionHelpers.GetEmptyDictionary<string, string>();
		}
	}
}
namespace Microsoft.Identity.Client.AppConfig
{
	public class ManagedIdentityId
	{
		internal string UserAssignedId { get; private set; }

		internal ManagedIdentityIdType IdType { get; }

		internal bool IsUserAssigned { get; }

		public static ManagedIdentityId SystemAssigned { get; } = new ManagedIdentityId(ManagedIdentityIdType.SystemAssigned);

		private ManagedIdentityId(ManagedIdentityIdType idType)
		{
			IdType = idType;
			IsUserAssigned = idType != ManagedIdentityIdType.SystemAssigned;
		}

		public static ManagedIdentityId WithUserAssignedClientId(string clientId)
		{
			if (string.IsNullOrEmpty(clientId))
			{
				throw new ArgumentNullException(clientId);
			}
			return new ManagedIdentityId(ManagedIdentityIdType.ClientId)
			{
				UserAssignedId = clientId
			};
		}

		public static ManagedIdentityId WithUserAssignedResourceId(string resourceId)
		{
			if (string.IsNullOrEmpty(resourceId))
			{
				throw new ArgumentNullException(resourceId);
			}
			return new ManagedIdentityId(ManagedIdentityIdType.ResourceId)
			{
				UserAssignedId = resourceId
			};
		}

		public static ManagedIdentityId WithUserAssignedObjectId(string objectId)
		{
			if (string.IsNullOrEmpty(objectId))
			{
				throw new ArgumentNullException(objectId);
			}
			return new ManagedIdentityId(ManagedIdentityIdType.ObjectId)
			{
				UserAssignedId = objectId
			};
		}
	}
	internal enum ManagedIdentityIdType
	{
		SystemAssigned,
		ClientId,
		ResourceId,
		ObjectId
	}
	internal enum MsalClientType
	{
		ConfidentialClient,
		PublicClient,
		ManagedIdentityClient
	}
	public class PoPAuthenticationConfiguration
	{
		public HttpMethod HttpMethod { get; set; }

		public string HttpHost { get; set; }

		public string HttpPath { get; set; }

		public IPoPCryptoProvider PopCryptoProvider { get; set; }

		public string Nonce { get; set; }

		public bool SignHttpRequest { get; set; } = true;

		public PoPAuthenticationConfiguration()
		{
			ApplicationBase.GuardMobileFrameworks();
		}

		public PoPAuthenticationConfiguration(HttpRequestMessage httpRequestMessage)
		{
			if (httpRequestMessage == null)
			{
				throw new ArgumentNullException("httpRequestMessage");
			}
			HttpMethod = httpRequestMessage.Method;
			HttpHost = httpRequestMessage.RequestUri.Authority;
			HttpPath = httpRequestMessage.RequestUri.AbsolutePath;
		}

		public PoPAuthenticationConfiguration(Uri requestUri)
		{
			if (requestUri == null)
			{
				throw new ArgumentNullException("requestUri");
			}
			HttpHost = requestUri.Authority;
			HttpPath = requestUri.AbsolutePath;
		}
	}
}
namespace Microsoft.Identity.Client.ApiConfig.Parameters
{
	internal abstract class AbstractAcquireTokenByUsernameParameters
	{
		public string Username { get; set; }

		public string FederationMetadata { get; set; }
	}
	internal abstract class AbstractAcquireTokenConfidentialClientParameters
	{
		public bool? SendX5C { get; set; }

		public bool SpaCode { get; set; }
	}
	internal class AcquireTokenByAuthorizationCodeParameters : AbstractAcquireTokenConfidentialClientParameters, IAcquireTokenParameters
	{
		public string AuthorizationCode { get; set; }

		public string PkceCodeVerifier { get; set; }

		public void LogParameters(ILoggerAdapter logger)
		{
		}
	}
	internal class AcquireTokenByIntegratedWindowsAuthParameters : AbstractAcquireTokenByUsernameParameters, IAcquireTokenParameters
	{
		public void LogParameters(ILoggerAdapter logger)
		{
		}
	}
	internal class AcquireTokenByRefreshTokenParameters : AbstractAcquireTokenConfidentialClientParameters, IAcquireTokenParameters
	{
		public string RefreshToken { get; set; }

		public void LogParameters(ILoggerAdapter logger)
		{
		}
	}
	internal class AcquireTokenByUsernamePasswordParameters : AbstractAcquireTokenByUsernameParameters, IAcquireTokenParameters
	{
		public string Password { get; set; }

		public void LogParameters(ILoggerAdapter logger)
		{
		}
	}
	internal class AcquireTokenCommonParameters
	{
		public ApiEvent.ApiIds ApiId { get; set; }

		public Guid CorrelationId { get; set; }

		public Guid UserProvidedCorrelationId { get; set; }

		public bool UseCorrelationIdFromUser { get; set; }

		public IEnumerable<string> Scopes { get; set; }

		public IDictionary<string, string> ExtraQueryParameters { get; set; }

		public string Claims { get; set; }

		public AuthorityInfo AuthorityOverride { get; set; }

		public IAuthenticationScheme AuthenticationScheme { get; set; } = new BearerAuthenticationScheme();

		public IDictionary<string, string> ExtraHttpHeaders { get; set; }

		public PoPAuthenticationConfiguration PopAuthenticationConfiguration { get; set; }

		public Func<OnBeforeTokenRequestData, Task> OnBeforeTokenRequestHandler { get; internal set; }
	}
	internal class AcquireTokenForClientParameters : AbstractAcquireTokenConfidentialClientParameters, IAcquireTokenParameters
	{
		public bool ForceRefresh { get; set; }

		public void LogParameters(ILoggerAdapter logger)
		{
			if (logger.IsLoggingEnabled(LogLevel.Info))
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.AppendLine("=== AcquireTokenForClientParameters ===");
				stringBuilder.AppendLine("SendX5C: " + base.SendX5C);
				stringBuilder.AppendLine("ForceRefresh: " + ForceRefresh);
				logger.Info(stringBuilder.ToString());
			}
		}
	}
	internal class AcquireTokenForManagedIdentityParameters : IAcquireTokenParameters
	{
		public bool ForceRefresh { get; set; }

		public string Resource { get; set; }

		public void LogParameters(ILoggerAdapter logger)
		{
			if (logger.IsLoggingEnabled(LogLevel.Info))
			{
				logger.Info($"=== AcquireTokenForManagedIdentityParameters ===\r\nForceRefresh: {ForceRefresh}\r\nResource: {Resource}");
			}
		}
	}
	internal class AcquireTokenInteractiveParameters : IAcquireTokenParameters
	{
		public Prompt Prompt { get; set; } = Prompt.NotSpecified;

		public CoreUIParent UiParent { get; } = new CoreUIParent();

		public IEnumerable<string> ExtraScopesToConsent { get; set; } = CollectionHelpers.GetEmptyReadOnlyList<string>();

		public WebViewPreference UseEmbeddedWebView { get; set; }

		public string LoginHint { get; set; }

		public IAccount Account { get; set; }

		public ICustomWebUi CustomWebUi { get; set; }

		public string CodeVerifier { get; set; }

		public void LogParameters(ILoggerAdapter logger)
		{
			if (logger.IsLoggingEnabled(LogLevel.Info))
			{
				UiParent.SystemWebViewOptions?.LogParameters(logger);
				logger.Info(string.Format("=== InteractiveParameters Data ===\r\nLoginHint provided: {0}\r\nUser provided: {1}\r\nUseEmbeddedWebView: {2}\r\nExtraScopesToConsent: {3}\r\nPrompt: {4}\r\nHasCustomWebUi: {5}", !string.IsNullOrEmpty(LoginHint), Account != null, UseEmbeddedWebView, string.Join(";", ExtraScopesToConsent ?? CollectionHelpers.GetEmptyReadOnlyList<string>()), Prompt.PromptValue, CustomWebUi != null));
			}
		}
	}
	internal class AcquireTokenOnBehalfOfParameters : AbstractAcquireTokenConfidentialClientParameters, IAcquireTokenParameters
	{
		public UserAssertion UserAssertion { get; set; }

		public string LongRunningOboCacheKey { get; set; }

		public bool SearchInCacheForLongRunningObo { get; set; }

		public bool ForceRefresh { get; set; }

		public void LogParameters(ILoggerAdapter logger)
		{
			if (logger.IsLoggingEnabled(LogLevel.Info))
			{
				StringBuilder stringBuilder = new StringBuilder($"=== OnBehalfOfParameters ===\r\nSendX5C: {base.SendX5C}\r\nForceRefresh: {ForceRefresh}\r\nUserAssertion set: {UserAssertion != null}\r\nSearchInCacheForLongRunningObo: {SearchInCacheForLongRunningObo}\r\nLongRunningOboCacheKey set: {!string.IsNullOrWhiteSpace(LongRunningOboCacheKey)}");
				if (UserAssertion != null && !string.IsNullOrWhiteSpace(LongRunningOboCacheKey))
				{
					stringBuilder.AppendLine("InitiateLongRunningProcessInWebApi called: True");
				}
				else if (UserAssertion == null && !string.IsNullOrWhiteSpace(LongRunningOboCacheKey))
				{
					stringBuilder.AppendLine("AcquireTokenInLongRunningProcess called: True");
				}
				logger.Info(stringBuilder.ToString());
			}
		}
	}
	internal class AcquireTokenSilentParameters : IAcquireTokenParameters
	{
		public bool ForceRefresh { get; set; }

		public string LoginHint { get; set; }

		public IAccount Account { get; set; }

		public bool? SendX5C { get; set; }

		public void LogParameters(ILoggerAdapter logger)
		{
			if (logger.IsLoggingEnabled(LogLevel.Info))
			{
				logger.Info("=== AcquireTokenSilent Parameters ===");
				logger.Info("LoginHint provided: " + !string.IsNullOrEmpty(LoginHint));
				logger.InfoPii("Account provided: " + ((Account != null) ? Account.ToString() : "false"), "Account provided: " + (Account != null));
				logger.Info("ForceRefresh: " + ForceRefresh);
			}
		}
	}
	internal class AcquireTokenWithDeviceCodeParameters : IAcquireTokenParameters
	{
		public Func<DeviceCodeResult, Task> DeviceCodeResultCallback { get; set; }

		public void LogParameters(ILoggerAdapter logger)
		{
		}
	}
	internal class GetAuthorizationRequestUrlParameters : IAcquireTokenParameters
	{
		public string RedirectUri { get; set; }

		public IAccount Account { get; set; }

		public IEnumerable<string> ExtraScopesToConsent { get; set; }

		public string LoginHint { get; set; }

		public string CodeVerifier { get; set; }

		public KeyValuePair<string, string>? CcsRoutingHint { get; set; }

		public Prompt Prompt { get; set; } = Prompt.SelectAccount;

		public AcquireTokenInteractiveParameters ToInteractiveParameters()
		{
			return new AcquireTokenInteractiveParameters
			{
				Account = Account,
				ExtraScopesToConsent = ExtraScopesToConsent,
				LoginHint = LoginHint,
				Prompt = Prompt,
				UseEmbeddedWebView = WebViewPreference.NotSpecified,
				CodeVerifier = CodeVerifier
			};
		}

		public void LogParameters(ILoggerAdapter logger)
		{
		}
	}
	internal interface IAcquireTokenParameters
	{
		void LogParameters(ILoggerAdapter logger);
	}
	internal enum WebViewPreference
	{
		NotSpecified,
		Embedded,
		System
	}
}
namespace Microsoft.Identity.Client.ApiConfig.Executors
{
	internal abstract class AbstractExecutor
	{
		public IServiceBundle ServiceBundle { get; }

		protected AbstractExecutor(IServiceBundle serviceBundle)
		{
			ServiceBundle = serviceBundle;
		}

		protected RequestContext CreateRequestContextAndLogVersionInfo(Guid correlationId, CancellationToken userCancellationToken = default(CancellationToken))
		{
			RequestContext requestContext = new RequestContext(ServiceBundle, correlationId, userCancellationToken);
			requestContext.Logger.Info(() => string.Format(CultureInfo.InvariantCulture, "MSAL {0} with assembly version '{1}'. CorrelationId({2})", ServiceBundle.PlatformProxy.GetProductName(), MsalIdHelper.GetMsalVersion(), requestContext.CorrelationId));
			return requestContext;
		}
	}
	internal class ClientApplicationBaseExecutor : AbstractExecutor, IClientApplicationBaseExecutor
	{
		private readonly ClientApplicationBase _clientApplicationBase;

		public ClientApplicationBaseExecutor(IServiceBundle serviceBundle, ClientApplicationBase clientApplicationBase)
			: base(serviceBundle)
		{
			_clientApplicationBase = clientApplicationBase;
		}

		public async Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenSilentParameters silentParameters, CancellationToken cancellationToken)
		{
			RequestContext requestContext = CreateRequestContextAndLogVersionInfo(commonParameters.CorrelationId, cancellationToken);
			AuthenticationRequestParameters authenticationRequestParameters = await _clientApplicationBase.CreateRequestParametersAsync(commonParameters, requestContext, _clientApplicationBase.UserTokenCacheInternal).ConfigureAwait(continueOnCapturedContext: false);
			authenticationRequestParameters.SendX5C = silentParameters.SendX5C == true;
			return await new SilentRequest(base.ServiceBundle, authenticationRequestParameters, silentParameters).RunAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByRefreshTokenParameters refreshTokenParameters, CancellationToken cancellationToken)
		{
			RequestContext requestContext = CreateRequestContextAndLogVersionInfo(commonParameters.CorrelationId, cancellationToken);
			if (commonParameters.Scopes == null || !commonParameters.Scopes.Any())
			{
				commonParameters.Scopes = new SortedSet<string> { _clientApplicationBase.AppConfig.ClientId + "/.default" };
				requestContext.Logger.Info("No scopes provided for acquire token by refresh token request. Using default scope instead.");
			}
			AuthenticationRequestParameters authenticationRequestParameters = await _clientApplicationBase.CreateRequestParametersAsync(commonParameters, requestContext, _clientApplicationBase.UserTokenCacheInternal).ConfigureAwait(continueOnCapturedContext: false);
			requestContext.Logger.Info(() => LogMessages.UsingXScopesForRefreshTokenRequest(commonParameters.Scopes.Count()));
			authenticationRequestParameters.SendX5C = refreshTokenParameters.SendX5C == true;
			return await new ByRefreshTokenRequest(base.ServiceBundle, authenticationRequestParameters, refreshTokenParameters).RunAsync(CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
		}
	}
	internal static class ClientExecutorFactory
	{
		public static IPublicClientApplicationExecutor CreatePublicClientExecutor(PublicClientApplication publicClientApplication)
		{
			return new PublicClientExecutor(publicClientApplication.ServiceBundle, publicClientApplication);
		}

		public static IConfidentialClientApplicationExecutor CreateConfidentialClientExecutor(ConfidentialClientApplication confidentialClientApplication)
		{
			ApplicationBase.GuardMobileFrameworks();
			return new ConfidentialClientExecutor(confidentialClientApplication.ServiceBundle, confidentialClientApplication);
		}

		public static IManagedIdentityApplicationExecutor CreateManagedIdentityExecutor(ManagedIdentityApplication managedIdentityApplication)
		{
			ApplicationBase.GuardMobileFrameworks();
			return new ManagedIdentityExecutor(managedIdentityApplication.ServiceBundle, managedIdentityApplication);
		}

		public static IClientApplicationBaseExecutor CreateClientApplicationBaseExecutor(ClientApplicationBase clientApplicationBase)
		{
			return new ClientApplicationBaseExecutor(clientApplicationBase.ServiceBundle, clientApplicationBase);
		}
	}
	internal class ConfidentialClientExecutor : AbstractExecutor, IConfidentialClientApplicationExecutor
	{
		private readonly ConfidentialClientApplication _confidentialClientApplication;

		public ConfidentialClientExecutor(IServiceBundle serviceBundle, ConfidentialClientApplication confidentialClientApplication)
			: base(serviceBundle)
		{
			ApplicationBase.GuardMobileFrameworks();
			_confidentialClientApplication = confidentialClientApplication;
		}

		public async Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByAuthorizationCodeParameters authorizationCodeParameters, CancellationToken cancellationToken)
		{
			RequestContext requestContext = CreateRequestContextAndLogVersionInfo(commonParameters.CorrelationId, cancellationToken);
			AuthenticationRequestParameters authenticationRequestParameters = await _confidentialClientApplication.CreateRequestParametersAsync(commonParameters, requestContext, _confidentialClientApplication.UserTokenCacheInternal).ConfigureAwait(continueOnCapturedContext: false);
			authenticationRequestParameters.SendX5C = authorizationCodeParameters.SendX5C == true;
			return await new ConfidentialAuthCodeRequest(base.ServiceBundle, authenticationRequestParameters, authorizationCodeParameters).RunAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForClientParameters clientParameters, CancellationToken cancellationToken)
		{
			RequestContext requestContext = CreateRequestContextAndLogVersionInfo(commonParameters.CorrelationId, cancellationToken);
			AuthenticationRequestParameters authenticationRequestParameters = await _confidentialClientApplication.CreateRequestParametersAsync(commonParameters, requestContext, _confidentialClientApplication.AppTokenCacheInternal).ConfigureAwait(continueOnCapturedContext: false);
			authenticationRequestParameters.SendX5C = clientParameters.SendX5C == true;
			return await new ClientCredentialRequest(base.ServiceBundle, authenticationRequestParameters, clientParameters).RunAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenOnBehalfOfParameters onBehalfOfParameters, CancellationToken cancellationToken)
		{
			RequestContext requestContext = CreateRequestContextAndLogVersionInfo(commonParameters.CorrelationId, cancellationToken);
			AuthenticationRequestParameters authenticationRequestParameters = await _confidentialClientApplication.CreateRequestParametersAsync(commonParameters, requestContext, _confidentialClientApplication.UserTokenCacheInternal).ConfigureAwait(continueOnCapturedContext: false);
			authenticationRequestParameters.SendX5C = onBehalfOfParameters.SendX5C == true;
			authenticationRequestParameters.UserAssertion = onBehalfOfParameters.UserAssertion;
			authenticationRequestParameters.LongRunningOboCacheKey = onBehalfOfParameters.LongRunningOboCacheKey;
			return await new OnBehalfOfRequest(base.ServiceBundle, authenticationRequestParameters, onBehalfOfParameters).RunAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<Uri> ExecuteAsync(AcquireTokenCommonParameters commonParameters, GetAuthorizationRequestUrlParameters authorizationRequestUrlParameters, CancellationToken cancellationToken)
		{
			RequestContext requestContext = CreateRequestContextAndLogVersionInfo(commonParameters.CorrelationId, cancellationToken);
			AuthenticationRequestParameters requestParameters = await _confidentialClientApplication.CreateRequestParametersAsync(commonParameters, requestContext, _confidentialClientApplication.UserTokenCacheInternal).ConfigureAwait(continueOnCapturedContext: false);
			requestParameters.Account = authorizationRequestUrlParameters.Account;
			requestParameters.LoginHint = authorizationRequestUrlParameters.LoginHint;
			requestParameters.CcsRoutingHint = authorizationRequestUrlParameters.CcsRoutingHint;
			if (!string.IsNullOrWhiteSpace(authorizationRequestUrlParameters.RedirectUri))
			{
				requestParameters.RedirectUri = new Uri(authorizationRequestUrlParameters.RedirectUri);
			}
			await requestParameters.AuthorityManager.RunInstanceDiscoveryAndValidationAsync().ConfigureAwait(continueOnCapturedContext: false);
			AuthCodeRequestComponent authCodeRequestComponent = new AuthCodeRequestComponent(requestParameters, authorizationRequestUrlParameters.ToInteractiveParameters());
			if (authorizationRequestUrlParameters.CodeVerifier != null)
			{
				return await authCodeRequestComponent.GetAuthorizationUriWithPkceAsync(authorizationRequestUrlParameters.CodeVerifier, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return await authCodeRequestComponent.GetAuthorizationUriWithoutPkceAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}
	internal interface IClientApplicationBaseExecutor
	{
		IServiceBundle ServiceBundle { get; }

		Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenSilentParameters silentParameters, CancellationToken cancellationToken);

		Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByRefreshTokenParameters byRefreshTokenParameters, CancellationToken cancellationToken);
	}
	internal interface IConfidentialClientApplicationExecutor
	{
		IServiceBundle ServiceBundle { get; }

		Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByAuthorizationCodeParameters authorizationCodeParameters, CancellationToken cancellationToken);

		Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForClientParameters clientParameters, CancellationToken cancellationToken);

		Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenOnBehalfOfParameters onBehalfOfParameters, CancellationToken cancellationToken);

		Task<Uri> ExecuteAsync(AcquireTokenCommonParameters commonParameters, GetAuthorizationRequestUrlParameters authorizationRequestUrlParameters, CancellationToken cancellationToken);
	}
	internal interface IManagedIdentityApplicationExecutor
	{
		IServiceBundle ServiceBundle { get; }

		Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForManagedIdentityParameters managedIdentityParameters, CancellationToken cancellationToken);
	}
	internal interface IPublicClientApplicationExecutor
	{
		IServiceBundle ServiceBundle { get; }

		Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenInteractiveParameters interactiveParameters, CancellationToken cancellationToken);

		Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenWithDeviceCodeParameters withDeviceCodeParameters, CancellationToken cancellationToken);

		Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByIntegratedWindowsAuthParameters integratedWindowsAuthParameters, CancellationToken cancellationToken);

		Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByUsernamePasswordParameters usernamePasswordParameters, CancellationToken cancellationToken);
	}
	internal class ManagedIdentityExecutor : AbstractExecutor, IManagedIdentityApplicationExecutor
	{
		private readonly ManagedIdentityApplication _managedIdentityApplication;

		public ManagedIdentityExecutor(IServiceBundle serviceBundle, ManagedIdentityApplication managedIdentityApplication)
			: base(serviceBundle)
		{
			ApplicationBase.GuardMobileFrameworks();
			_managedIdentityApplication = managedIdentityApplication;
		}

		public async Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForManagedIdentityParameters managedIdentityParameters, CancellationToken cancellationToken)
		{
			RequestContext requestContext = CreateRequestContextAndLogVersionInfo(commonParameters.CorrelationId, cancellationToken);
			AuthenticationRequestParameters authenticationRequestParameters = await _managedIdentityApplication.CreateRequestParametersAsync(commonParameters, requestContext, _managedIdentityApplication.AppTokenCacheInternal).ConfigureAwait(continueOnCapturedContext: false);
			return await new ManagedIdentityAuthRequest(base.ServiceBundle, authenticationRequestParameters, managedIdentityParameters).RunAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}
	internal class PublicClientExecutor : AbstractExecutor, IPublicClientApplicationExecutor
	{
		private readonly PublicClientApplication _publicClientApplication;

		public PublicClientExecutor(IServiceBundle serviceBundle, PublicClientApplication publicClientApplication)
			: base(serviceBundle)
		{
			_publicClientApplication = publicClientApplication;
		}

		public async Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenInteractiveParameters interactiveParameters, CancellationToken cancellationToken)
		{
			RequestContext requestContext = CreateRequestContextAndLogVersionInfo(commonParameters.CorrelationId, cancellationToken);
			AuthenticationRequestParameters obj = await _publicClientApplication.CreateRequestParametersAsync(commonParameters, requestContext, _publicClientApplication.UserTokenCacheInternal).ConfigureAwait(continueOnCapturedContext: false);
			obj.LoginHint = interactiveParameters.LoginHint;
			obj.Account = interactiveParameters.Account;
			return await new InteractiveRequest(obj, interactiveParameters).RunAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenWithDeviceCodeParameters deviceCodeParameters, CancellationToken cancellationToken)
		{
			RequestContext requestContext = CreateRequestContextAndLogVersionInfo(commonParameters.CorrelationId, cancellationToken);
			AuthenticationRequestParameters authenticationRequestParameters = await _publicClientApplication.CreateRequestParametersAsync(commonParameters, requestContext, _publicClientApplication.UserTokenCacheInternal).ConfigureAwait(continueOnCapturedContext: false);
			return await new DeviceCodeRequest(base.ServiceBundle, authenticationRequestParameters, deviceCodeParameters).RunAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByIntegratedWindowsAuthParameters integratedWindowsAuthParameters, CancellationToken cancellationToken)
		{
			RequestContext requestContext = CreateRequestContextAndLogVersionInfo(commonParameters.CorrelationId, cancellationToken);
			AuthenticationRequestParameters authenticationRequestParameters = await _publicClientApplication.CreateRequestParametersAsync(commonParameters, requestContext, _publicClientApplication.UserTokenCacheInternal).ConfigureAwait(continueOnCapturedContext: false);
			return await new IntegratedWindowsAuthRequest(base.ServiceBundle, authenticationRequestParameters, integratedWindowsAuthParameters).RunAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByUsernamePasswordParameters usernamePasswordParameters, CancellationToken cancellationToken)
		{
			RequestContext requestContext = CreateRequestContextAndLogVersionInfo(commonParameters.CorrelationId, cancellationToken);
			AuthenticationRequestParameters authenticationRequestParameters = await _publicClientApplication.CreateRequestParametersAsync(commonParameters, requestContext, _publicClientApplication.UserTokenCacheInternal).ConfigureAwait(continueOnCapturedContext: false);
			return await new UsernamePasswordRequest(base.ServiceBundle, authenticationRequestParameters, usernamePasswordParameters).RunAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}
}
